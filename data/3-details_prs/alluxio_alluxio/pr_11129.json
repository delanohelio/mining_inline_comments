{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTUyOTQ0", "number": 11129, "title": "Improve multi-tier block management", "bodyText": "Changes in this PR:\n\nAllow writes to utilize any available space on the cache, starting from the highest tier.\nWhen the cache is full, remove the worst block in order to open up space for the write.\nMove blocks between tiers based on the access pattern.\n\nFixes #9796, Fixes #9804, Fixes #10150, Fixes #10318, Fixes #10688", "createdAt": "2020-03-05T23:33:51Z", "url": "https://github.com/Alluxio/alluxio/pull/11129", "merged": true, "mergeCommit": {"oid": "3762d75eb611f388895ad9bea0746b17afc7cdd1"}, "closed": true, "closedAt": "2020-05-01T23:03:43Z", "author": {"login": "ggezer"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcK1LAfgBqjMxMDM0Mjc3NDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdJ6eTAFqTQwNDQ0MDUyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e2aa8be527966c5f636f012578faaceb311d597", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2e2aa8be527966c5f636f012578faaceb311d597", "committedDate": "2020-03-05T23:31:44Z", "message": "Fix existing tests"}, "afterCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/34da8bc1ee5eb20657011aeb753484c799cdd923", "committedDate": "2020-03-06T00:42:11Z", "message": "Fix existing tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjY1MDk4", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-370665098", "createdAt": "2020-03-06T22:28:41Z", "commit": {"oid": "8600b40c2f3916d382b07fa2ef59efda0fed7e9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjoyODo0MlrOFzJWBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMjoyODo0MlrOFzJWBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NDc4OQ==", "bodyText": "Fix this comment as swap space is internally managed.", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389174789", "createdAt": "2020-03-06T22:28:42Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/test/java/alluxio/worker/block/management/TierSwapTaskTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.worker.block.AllocateOptions;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.TieredBlockStore;\n+import alluxio.worker.block.TieredBlockStoreTestUtils;\n+import alluxio.worker.block.io.BlockWriter;\n+import alluxio.worker.block.meta.StorageDir;\n+import alluxio.worker.block.annotator.BlockIterator;\n+import alluxio.worker.block.annotator.BlockOrder;\n+import alluxio.worker.block.annotator.LRUAnnotator;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.File;\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Random;\n+\n+public class TierSwapTaskTest {\n+  private static final String FIRST_TIER_ALIAS = TieredBlockStoreTestUtils.TIER_ALIAS[0];\n+  private static final String SECOND_TIER_ALIAS = TieredBlockStoreTestUtils.TIER_ALIAS[1];\n+  private static final long SIMULATE_LOAD_SESSION_ID = 1;\n+  private static final long SIMULATE_LOAD_BLOCK_ID = 1;\n+  private static final long BLOCK_SIZE = 100;\n+\n+  @Rule\n+  public TemporaryFolder mTestFolder = new TemporaryFolder();\n+\n+  private TieredBlockStore mBlockStore;\n+  private BlockMetadataManager mMetaManager;\n+  private BlockIterator mBlockIterator;\n+\n+  private StorageDir mTestDir1;\n+  private StorageDir mTestDir2;\n+  private StorageDir mTestDir3;\n+  private StorageDir mTestDir4;\n+\n+  private BlockWriter mSimulateWriter;\n+\n+  /**\n+   * Sets up all dependencies before a test runs.\n+   */\n+  @Before\n+  public void before() throws Exception {\n+    // Use LRU for stronger overlap guarantee.\n+    ServerConfiguration.set(PropertyKey.WORKER_BLOCK_ANNOTATOR_CLASS,\n+        LRUAnnotator.class.getName());\n+    ServerConfiguration.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, BLOCK_SIZE);\n+    // Reserve block size per directory.\n+    ServerConfiguration.set(PropertyKey.WORKER_MANAGEMENT_RESERVED_SPACE_BYTES, BLOCK_SIZE);\n+    // Set timeouts for faster task execution.\n+    ServerConfiguration.set(PropertyKey.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME, \"100ms\");\n+    ServerConfiguration.set(PropertyKey.WORKER_MANAGEMENT_IDLE_SLEEP_TIME, \"100ms\");\n+    // Disable move task to avoid interference.\n+    ServerConfiguration.set(PropertyKey.WORKER_MANAGEMENT_TIER_MOVE_ENABLED, false);\n+\n+    File tempFolder = mTestFolder.newFolder();\n+    TieredBlockStoreTestUtils.setupDefaultConf(tempFolder.getAbsolutePath());\n+    mBlockStore = new TieredBlockStore();\n+    Field field = mBlockStore.getClass().getDeclaredField(\"mMetaManager\");\n+    field.setAccessible(true);\n+    mMetaManager = (BlockMetadataManager) field.get(mBlockStore);\n+    mBlockIterator = mMetaManager.getBlockIterator();\n+\n+    mTestDir1 = mMetaManager.getTier(FIRST_TIER_ALIAS).getDir(0);\n+    mTestDir2 = mMetaManager.getTier(FIRST_TIER_ALIAS).getDir(1);\n+    mTestDir3 = mMetaManager.getTier(SECOND_TIER_ALIAS).getDir(1);\n+    mTestDir4 = mMetaManager.getTier(SECOND_TIER_ALIAS).getDir(2);\n+  }\n+\n+  private void startSimulateLoad() throws Exception {\n+    mBlockStore.createBlock(SIMULATE_LOAD_SESSION_ID, SIMULATE_LOAD_BLOCK_ID,\n+        AllocateOptions.forCreate(0, BlockStoreLocation.anyTier()));\n+    mSimulateWriter = mBlockStore.getBlockWriter(SIMULATE_LOAD_SESSION_ID, SIMULATE_LOAD_BLOCK_ID);\n+  }\n+\n+  private void stopSimulateLoad() throws Exception {\n+    mBlockStore.abortBlock(SIMULATE_LOAD_SESSION_ID, SIMULATE_LOAD_BLOCK_ID);\n+    mSimulateWriter.close();\n+  }\n+\n+  @Test\n+  public void testOverlapElimination() throws Exception {\n+    Random rnd = new Random();\n+    StorageDir[] dirArray = new StorageDir[] {mTestDir1, mTestDir2, mTestDir3, mTestDir4};\n+\n+    // Start simulating random load on worker.\n+    startSimulateLoad();\n+\n+    // Fill each directory, leaving free space on each as swap buffer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8600b40c2f3916d382b07fa2ef59efda0fed7e9b"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDIyNjk4", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-370022698", "createdAt": "2020-03-06T01:06:02Z", "commit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMTowNjowM1rOFyp8Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzoyODoxMlrOFzKZKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MDMxOQ==", "bodyText": "Unrelated to this PR - it would be nice to have a getOrElse method for alluxio conf", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r388660319", "createdAt": "2020-03-06T01:06:03Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/options/OutStreamOptions.java", "diffHunk": "@@ -144,6 +144,9 @@ private OutStreamOptions(ClientContext context, AlluxioConfiguration alluxioConf\n     mReplicationMax = alluxioConf.getInt(PropertyKey.USER_FILE_REPLICATION_MAX);\n     mReplicationMin = alluxioConf.getInt(PropertyKey.USER_FILE_REPLICATION_MIN);\n     mMediumType = \"\";\n+    if (alluxioConf.isSet(PropertyKey.USER_FILE_TARGET_MEDIA)) {\n+      mMediumType = alluxioConf.get(PropertyKey.USER_FILE_TARGET_MEDIA);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MTIzNQ==", "bodyText": "If these two have the same functionality, could we keep the same property name? evictor.class is not misleading?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r388661235", "createdAt": "2020-03-06T01:07:22Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2272,9 +2272,12 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  /**\n+   * @deprecated use block annotators instead\n+   */\n+  @Deprecated(message = \"Use WORKER_BLOCK_ANNOTATOR_CLASS instead.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzUyNw==", "bodyText": "is supposed to be visible for -> is only visible to", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r388667527", "createdAt": "2020-03-06T01:27:04Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -291,51 +309,180 @@ public void requestSpace(long sessionId, long blockId, long additionalBytes)\n       throws BlockDoesNotExistException, WorkerOutOfSpaceException, IOException {\n     LOG.debug(\"requestSpace: sessionId={}, blockId={}, additionalBytes={}\", sessionId, blockId,\n         additionalBytes);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {\n-      Pair<Boolean, BlockStoreLocation> requestResult =\n-          requestSpaceInternal(blockId, additionalBytes);\n-      if (requestResult.getFirst()) {\n-        return;\n+\n+    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MDE1MQ==", "bodyText": "Add TODO here to run multiple tasks in parallel?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389190151", "createdAt": "2020-03-06T23:20:28Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/ManagementTaskCoordinator.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.ThreadFactoryUtils;\n+import alluxio.worker.block.BlockMetadataEvictorView;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStore;\n+import alluxio.worker.block.BlockStoreLocation;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Coordinator for instantiating and running various block management tasks.\n+ */\n+public class ManagementTaskCoordinator implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(ManagementTaskCoordinator.class);\n+\n+  /** Duration to sleep when there is no pending task. */\n+  private final long mIdleSleepMs;\n+  /** Duration to sleep when load detected on worker. */\n+  private final long mLoadDetectionCoolDownMs;\n+\n+  /** Runner thread for launching management tasks. */\n+  private final Thread mRunnerThread;\n+  /** Executor that will running the management tasks. */\n+  private final ExecutorService mTaskExecutor;\n+\n+  private final BlockStore mBlockStore;\n+  private final BlockMetadataManager mMetadataManager;\n+  private final StoreLoadTracker mLoadTracker;\n+\n+  /** This coordinator requires to calculate eviction view per each task. */\n+  private final Supplier<BlockMetadataEvictorView> mEvictionViewSupplier;\n+\n+  /** List of management task providers. */\n+  private List<ManagementTaskProvider> mTaskProviders;\n+\n+  /**\n+   * Creates management coordinator.\n+   *\n+   * @param blockStore block store\n+   * @param metadataManager meta manager\n+   * @param loadTracker load tracker\n+   * @param evictionViewSupplier eviction view supplier\n+   */\n+  public ManagementTaskCoordinator(BlockStore blockStore, BlockMetadataManager metadataManager,\n+      StoreLoadTracker loadTracker, Supplier<BlockMetadataEvictorView> evictionViewSupplier) {\n+    mBlockStore = blockStore;\n+    mMetadataManager = metadataManager;\n+    mLoadTracker = loadTracker;\n+    mEvictionViewSupplier = evictionViewSupplier;\n+\n+    initializeTaskProviders();\n+\n+    // Read configs.\n+    mLoadDetectionCoolDownMs =\n+        ServerConfiguration.getMs(PropertyKey.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME);\n+    mIdleSleepMs = ServerConfiguration.getMs(PropertyKey.WORKER_MANAGEMENT_IDLE_SLEEP_TIME);\n+\n+    // Initialize management task executor.\n+    // Currently a single management task is active at a time.\n+    mTaskExecutor = Executors\n+        .newSingleThreadExecutor(ThreadFactoryUtils.build(\"block-management-thread-%d\", true));\n+\n+    // Initialize runner thread.\n+    mRunnerThread = new Thread(this::runManagement, \"block-management-runner\");\n+  }\n+\n+  /**\n+   * Starts the coordinator.\n+   */\n+  public void start() {\n+    // Start runner thread.\n+    mRunnerThread.start();\n+  }\n+\n+  /**\n+   * Register known task providers by priority order.\n+   *\n+   * TODO(ggezer): TV2 - Implement pin enforcer as {@link BlockManagementTask}.\n+   * TODO(ggezer): TV2 - Re-implement async-cache as {@link BlockManagementTask}.\n+   */\n+  private void initializeTaskProviders() {\n+    mTaskProviders = new ArrayList<>(1);\n+    if (ServerConfiguration.isSet(PropertyKey.WORKER_EVICTOR_CLASS)) {\n+      LOG.warn(\"Tier management tasks will be disabled under eviction emulation mode.\");\n+    } else {\n+      mTaskProviders.add(new TierManagementTaskProvider(mBlockStore, mMetadataManager,\n+          mEvictionViewSupplier, mLoadTracker));\n+    }\n+  }\n+\n+  /**\n+   * @return the next management task to run, {@code null} if none pending\n+   */\n+  private BlockManagementTask getNextTask() {\n+    /**\n+     * Order of providers in the registered list imposes an implicit priority of tasks.\n+     * As long as a provider gives a task, providers next to it won't be consulted.\n+     */\n+    for (ManagementTaskProvider taskProvider : mTaskProviders) {\n+      BlockManagementTask task = taskProvider.getTask();\n+      if (task != null) {\n+        return task;\n+      }\n+    }\n+    // No task provided.\n+    return null;\n+  }\n+\n+  /**\n+   * Main management loop.\n+   */\n+  private void runManagement() {\n+    while (true) {\n+      if (Thread.interrupted()) {\n+        // Coordinator closed.\n+        return;\n+      }\n+\n+      BlockManagementTask currentTask = null;\n+      try {\n+        // Back off if any load detected.\n+        // TODO(ggezer): TV2 - Trust management tasks' back-off handling.\n+        if (mLoadTracker.loadDetected(BlockStoreLocation.anyTier())) {\n+          LOG.info(\"Load detected.\");\n+          Thread.sleep(mLoadDetectionCoolDownMs);\n+          continue;\n+        }\n+\n+        final BlockManagementTask nextTask = getNextTask();\n+        if (nextTask == null) {\n+          LOG.info(\"No management task pending.\");\n+          Thread.sleep(mIdleSleepMs);\n+          continue;\n+        }\n+\n+        // Submit and wait for the task.\n+        currentTask = nextTask;\n+        mTaskExecutor.submit(() -> nextTask.run()).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MDg1MQ==", "bodyText": "Is it okay to have this thread running by itself, should we keep track of it?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389190851", "createdAt": "2020-03-06T23:23:19Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -126,21 +121,23 @@ public TieredBlockStore() {\n     mMetaManager = BlockMetadataManager.createBlockMetadataManager();\n     mLockManager = new BlockLockManager();\n \n+    mBlockIterator = mMetaManager.getBlockIterator();\n+    // Register listeners required by the block iterator.\n+    for (BlockStoreEventListener listener : mBlockIterator.getListeners()) {\n+      registerBlockStoreEventListener(listener);\n+    }\n+\n     BlockMetadataEvictorView initManagerView = new BlockMetadataEvictorView(mMetaManager,\n         Collections.<Long>emptySet(), Collections.<Long>emptySet());\n     mAllocator = Allocator.Factory.create(initManagerView);\n     if (mAllocator instanceof BlockStoreEventListener) {\n       registerBlockStoreEventListener((BlockStoreEventListener) mAllocator);\n     }\n \n-    initManagerView = new BlockMetadataEvictorView(mMetaManager, Collections.<Long>emptySet(),\n-        Collections.<Long>emptySet());\n-    mEvictor = Evictor.Factory.create(initManagerView, mAllocator);\n-    if (mEvictor instanceof BlockStoreEventListener) {\n-      registerBlockStoreEventListener((BlockStoreEventListener) mEvictor);\n-    }\n-\n-    mStorageTierAssoc = new WorkerStorageTierAssoc();\n+    // Initialize and start coordinator.\n+    mTaskCoordinator = new ManagementTaskCoordinator(this, mMetaManager,\n+        new DefaultStoreLoadTracker(), () -> getUpdatedView());\n+    mTaskCoordinator.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTQxNA==", "bodyText": "Should we log this, I don't think its unexpected? Maybe we can increment some metric to keep track of how many failed allocations we had.", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389191414", "createdAt": "2020-03-06T23:25:45Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -526,42 +697,92 @@ private void abortBlockInternal(long sessionId, long blockId) throws BlockDoesNo\n   private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n-    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+    // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n+    // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n+    // after moving actual block file to its committed path.\n+    BlockStoreLocation loc;\n+    String srcPath;\n+    String dstPath;\n+    TempBlockMeta tempBlockMeta;\n+    try (LockResource r = new LockResource(mMetadataReadLock)) {\n+      checkTempBlockOwnedBySession(sessionId, blockId);\n+      tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+      srcPath = tempBlockMeta.getPath();\n+      dstPath = tempBlockMeta.getCommitPath();\n+      loc = tempBlockMeta.getBlockLocation();\n+    }\n+\n+    // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n+    FileUtils.move(srcPath, dstPath);\n+\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      mMetaManager.commitTempBlockMeta(tempBlockMeta);\n+    } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n+        | WorkerOutOfSpaceException e) {\n+      throw Throwables.propagate(e); // we shall never reach here\n+    }\n+\n+    // Check if block is pinned on commit\n+    if (pinOnCreate) {\n+      addToPinnedInodes(BlockId.getFileId(blockId));\n+    }\n+\n+    return loc;\n+  }\n+\n+  private StorageDirView allocateSpace(long sessionId, AllocateOptions options) {\n+    StorageDirView dirView = null;\n+    BlockMetadataView allocatorView = new BlockMetadataAllocatorView(mMetaManager);\n     try {\n-      // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n-      // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n-      // after moving actual block file to its committed path.\n-      BlockStoreLocation loc;\n-      String srcPath;\n-      String dstPath;\n-      TempBlockMeta tempBlockMeta;\n-      try (LockResource r = new LockResource(mMetadataReadLock)) {\n-        checkTempBlockOwnedBySession(sessionId, blockId);\n-        tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-        srcPath = tempBlockMeta.getPath();\n-        dstPath = tempBlockMeta.getCommitPath();\n-        loc = tempBlockMeta.getBlockLocation();\n+      // Allocate from given location.\n+      dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+          options.getLocation(), allocatorView);\n+\n+      if (dirView != null) {\n+        return dirView;\n       }\n \n-      // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n-      FileUtils.move(srcPath, dstPath);\n+      if (options.isForceLocation()) {\n+        if (options.isEvictionAllowed()) {\n+          freeSpace(sessionId, options.getSize(), options.getSize(), options.getLocation());\n+          dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+              options.getLocation(), allocatorView.refreshView());\n \n-      try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-        mMetaManager.commitTempBlockMeta(tempBlockMeta);\n-      } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n-          | WorkerOutOfSpaceException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n+          if (dirView == null) {\n+            LOG.error(\"Target tier: {} has no evictable space to store {} bytes for session: {}\",\n+                options.getLocation(), options.getSize(), sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 581}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTc2Mw==", "bodyText": "Is this concept necessary, it seems a bit too much of a heuristic?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389191763", "createdAt": "2020-03-06T23:27:06Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -526,42 +697,92 @@ private void abortBlockInternal(long sessionId, long blockId) throws BlockDoesNo\n   private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n-    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+    // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n+    // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n+    // after moving actual block file to its committed path.\n+    BlockStoreLocation loc;\n+    String srcPath;\n+    String dstPath;\n+    TempBlockMeta tempBlockMeta;\n+    try (LockResource r = new LockResource(mMetadataReadLock)) {\n+      checkTempBlockOwnedBySession(sessionId, blockId);\n+      tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+      srcPath = tempBlockMeta.getPath();\n+      dstPath = tempBlockMeta.getCommitPath();\n+      loc = tempBlockMeta.getBlockLocation();\n+    }\n+\n+    // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n+    FileUtils.move(srcPath, dstPath);\n+\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      mMetaManager.commitTempBlockMeta(tempBlockMeta);\n+    } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n+        | WorkerOutOfSpaceException e) {\n+      throw Throwables.propagate(e); // we shall never reach here\n+    }\n+\n+    // Check if block is pinned on commit\n+    if (pinOnCreate) {\n+      addToPinnedInodes(BlockId.getFileId(blockId));\n+    }\n+\n+    return loc;\n+  }\n+\n+  private StorageDirView allocateSpace(long sessionId, AllocateOptions options) {\n+    StorageDirView dirView = null;\n+    BlockMetadataView allocatorView = new BlockMetadataAllocatorView(mMetaManager);\n     try {\n-      // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n-      // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n-      // after moving actual block file to its committed path.\n-      BlockStoreLocation loc;\n-      String srcPath;\n-      String dstPath;\n-      TempBlockMeta tempBlockMeta;\n-      try (LockResource r = new LockResource(mMetadataReadLock)) {\n-        checkTempBlockOwnedBySession(sessionId, blockId);\n-        tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-        srcPath = tempBlockMeta.getPath();\n-        dstPath = tempBlockMeta.getCommitPath();\n-        loc = tempBlockMeta.getBlockLocation();\n+      // Allocate from given location.\n+      dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+          options.getLocation(), allocatorView);\n+\n+      if (dirView != null) {\n+        return dirView;\n       }\n \n-      // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n-      FileUtils.move(srcPath, dstPath);\n+      if (options.isForceLocation()) {\n+        if (options.isEvictionAllowed()) {\n+          freeSpace(sessionId, options.getSize(), options.getSize(), options.getLocation());\n+          dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+              options.getLocation(), allocatorView.refreshView());\n \n-      try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-        mMetaManager.commitTempBlockMeta(tempBlockMeta);\n-      } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n-          | WorkerOutOfSpaceException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n+          if (dirView == null) {\n+            LOG.error(\"Target tier: {} has no evictable space to store {} bytes for session: {}\",\n+                options.getLocation(), options.getSize(), sessionId);\n+            return null;\n+          }\n+        } else {\n+          LOG.error(\"Target tier: {} has no available space to store {} bytes for session: {}\",\n+              options.getLocation(), options.getSize(), sessionId);\n+          return null;\n+        }\n+      } else {\n+        dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+            BlockStoreLocation.anyTier(), allocatorView);\n \n-      // Check if block is pinned on commit\n-      if (pinOnCreate) {\n-        addToPinnedInodes(BlockId.getFileId(blockId));\n-      }\n+        if (dirView != null) {\n+          return dirView;\n+        }\n \n-      return loc;\n-    } finally {\n-      mLockManager.unlockBlock(lockId);\n+        if (options.isEvictionAllowed()) {\n+          // There is no space left on worker.\n+          // Free more than requested by configured free-ahead size.\n+          long freeAheadBytes =\n+              ServerConfiguration.getBytes(PropertyKey.WORKER_TIERED_STORE_FREE_AHEAD_BYTES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 608}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTkxMQ==", "bodyText": "Should we do a check if dirView is null here and do our failure handling (ie. log message now but I suggest to increment some metric)?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389191911", "createdAt": "2020-03-06T23:27:55Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -526,42 +697,92 @@ private void abortBlockInternal(long sessionId, long blockId) throws BlockDoesNo\n   private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n-    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+    // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n+    // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n+    // after moving actual block file to its committed path.\n+    BlockStoreLocation loc;\n+    String srcPath;\n+    String dstPath;\n+    TempBlockMeta tempBlockMeta;\n+    try (LockResource r = new LockResource(mMetadataReadLock)) {\n+      checkTempBlockOwnedBySession(sessionId, blockId);\n+      tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+      srcPath = tempBlockMeta.getPath();\n+      dstPath = tempBlockMeta.getCommitPath();\n+      loc = tempBlockMeta.getBlockLocation();\n+    }\n+\n+    // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n+    FileUtils.move(srcPath, dstPath);\n+\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      mMetaManager.commitTempBlockMeta(tempBlockMeta);\n+    } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n+        | WorkerOutOfSpaceException e) {\n+      throw Throwables.propagate(e); // we shall never reach here\n+    }\n+\n+    // Check if block is pinned on commit\n+    if (pinOnCreate) {\n+      addToPinnedInodes(BlockId.getFileId(blockId));\n+    }\n+\n+    return loc;\n+  }\n+\n+  private StorageDirView allocateSpace(long sessionId, AllocateOptions options) {\n+    StorageDirView dirView = null;\n+    BlockMetadataView allocatorView = new BlockMetadataAllocatorView(mMetaManager);\n     try {\n-      // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n-      // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n-      // after moving actual block file to its committed path.\n-      BlockStoreLocation loc;\n-      String srcPath;\n-      String dstPath;\n-      TempBlockMeta tempBlockMeta;\n-      try (LockResource r = new LockResource(mMetadataReadLock)) {\n-        checkTempBlockOwnedBySession(sessionId, blockId);\n-        tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-        srcPath = tempBlockMeta.getPath();\n-        dstPath = tempBlockMeta.getCommitPath();\n-        loc = tempBlockMeta.getBlockLocation();\n+      // Allocate from given location.\n+      dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+          options.getLocation(), allocatorView);\n+\n+      if (dirView != null) {\n+        return dirView;\n       }\n \n-      // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n-      FileUtils.move(srcPath, dstPath);\n+      if (options.isForceLocation()) {\n+        if (options.isEvictionAllowed()) {\n+          freeSpace(sessionId, options.getSize(), options.getSize(), options.getLocation());\n+          dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+              options.getLocation(), allocatorView.refreshView());\n \n-      try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-        mMetaManager.commitTempBlockMeta(tempBlockMeta);\n-      } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n-          | WorkerOutOfSpaceException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n+          if (dirView == null) {\n+            LOG.error(\"Target tier: {} has no evictable space to store {} bytes for session: {}\",\n+                options.getLocation(), options.getSize(), sessionId);\n+            return null;\n+          }\n+        } else {\n+          LOG.error(\"Target tier: {} has no available space to store {} bytes for session: {}\",\n+              options.getLocation(), options.getSize(), sessionId);\n+          return null;\n+        }\n+      } else {\n+        dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+            BlockStoreLocation.anyTier(), allocatorView);\n \n-      // Check if block is pinned on commit\n-      if (pinOnCreate) {\n-        addToPinnedInodes(BlockId.getFileId(blockId));\n-      }\n+        if (dirView != null) {\n+          return dirView;\n+        }\n \n-      return loc;\n-    } finally {\n-      mLockManager.unlockBlock(lockId);\n+        if (options.isEvictionAllowed()) {\n+          // There is no space left on worker.\n+          // Free more than requested by configured free-ahead size.\n+          long freeAheadBytes =\n+              ServerConfiguration.getBytes(PropertyKey.WORKER_TIERED_STORE_FREE_AHEAD_BYTES);\n+          freeSpace(sessionId, options.getSize(), options.getSize() + freeAheadBytes,\n+              BlockStoreLocation.anyTier());\n+\n+          dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+              BlockStoreLocation.anyTier(), allocatorView.refreshView());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 613}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTk3OQ==", "bodyText": "return null here?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r389191979", "createdAt": "2020-03-06T23:28:12Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -526,42 +697,92 @@ private void abortBlockInternal(long sessionId, long blockId) throws BlockDoesNo\n   private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n-    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+    // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n+    // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n+    // after moving actual block file to its committed path.\n+    BlockStoreLocation loc;\n+    String srcPath;\n+    String dstPath;\n+    TempBlockMeta tempBlockMeta;\n+    try (LockResource r = new LockResource(mMetadataReadLock)) {\n+      checkTempBlockOwnedBySession(sessionId, blockId);\n+      tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+      srcPath = tempBlockMeta.getPath();\n+      dstPath = tempBlockMeta.getCommitPath();\n+      loc = tempBlockMeta.getBlockLocation();\n+    }\n+\n+    // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n+    FileUtils.move(srcPath, dstPath);\n+\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      mMetaManager.commitTempBlockMeta(tempBlockMeta);\n+    } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n+        | WorkerOutOfSpaceException e) {\n+      throw Throwables.propagate(e); // we shall never reach here\n+    }\n+\n+    // Check if block is pinned on commit\n+    if (pinOnCreate) {\n+      addToPinnedInodes(BlockId.getFileId(blockId));\n+    }\n+\n+    return loc;\n+  }\n+\n+  private StorageDirView allocateSpace(long sessionId, AllocateOptions options) {\n+    StorageDirView dirView = null;\n+    BlockMetadataView allocatorView = new BlockMetadataAllocatorView(mMetaManager);\n     try {\n-      // When committing TempBlockMeta, the final BlockMeta calculates the block size according to\n-      // the actual file size of this TempBlockMeta. Therefore, commitTempBlockMeta must happen\n-      // after moving actual block file to its committed path.\n-      BlockStoreLocation loc;\n-      String srcPath;\n-      String dstPath;\n-      TempBlockMeta tempBlockMeta;\n-      try (LockResource r = new LockResource(mMetadataReadLock)) {\n-        checkTempBlockOwnedBySession(sessionId, blockId);\n-        tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-        srcPath = tempBlockMeta.getPath();\n-        dstPath = tempBlockMeta.getCommitPath();\n-        loc = tempBlockMeta.getBlockLocation();\n+      // Allocate from given location.\n+      dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+          options.getLocation(), allocatorView);\n+\n+      if (dirView != null) {\n+        return dirView;\n       }\n \n-      // Heavy IO is guarded by block lock but not metadata lock. This may throw IOException.\n-      FileUtils.move(srcPath, dstPath);\n+      if (options.isForceLocation()) {\n+        if (options.isEvictionAllowed()) {\n+          freeSpace(sessionId, options.getSize(), options.getSize(), options.getLocation());\n+          dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+              options.getLocation(), allocatorView.refreshView());\n \n-      try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-        mMetaManager.commitTempBlockMeta(tempBlockMeta);\n-      } catch (BlockAlreadyExistsException | BlockDoesNotExistException\n-          | WorkerOutOfSpaceException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n+          if (dirView == null) {\n+            LOG.error(\"Target tier: {} has no evictable space to store {} bytes for session: {}\",\n+                options.getLocation(), options.getSize(), sessionId);\n+            return null;\n+          }\n+        } else {\n+          LOG.error(\"Target tier: {} has no available space to store {} bytes for session: {}\",\n+              options.getLocation(), options.getSize(), sessionId);\n+          return null;\n+        }\n+      } else {\n+        dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+            BlockStoreLocation.anyTier(), allocatorView);\n \n-      // Check if block is pinned on commit\n-      if (pinOnCreate) {\n-        addToPinnedInodes(BlockId.getFileId(blockId));\n-      }\n+        if (dirView != null) {\n+          return dirView;\n+        }\n \n-      return loc;\n-    } finally {\n-      mLockManager.unlockBlock(lockId);\n+        if (options.isEvictionAllowed()) {\n+          // There is no space left on worker.\n+          // Free more than requested by configured free-ahead size.\n+          long freeAheadBytes =\n+              ServerConfiguration.getBytes(PropertyKey.WORKER_TIERED_STORE_FREE_AHEAD_BYTES);\n+          freeSpace(sessionId, options.getSize(), options.getSize() + freeAheadBytes,\n+              BlockStoreLocation.anyTier());\n+\n+          dirView = mAllocator.allocateBlockWithView(sessionId, options.getSize(),\n+              BlockStoreLocation.anyTier(), allocatorView.refreshView());\n+        }\n+      }\n+    } catch (Exception e) {\n+      LOG.error(\"Allocation failure. Options: {}. Error: {}\", options, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34da8bc1ee5eb20657011aeb753484c799cdd923"}, "originalPosition": 617}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMDc2OTY0", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-373076964", "createdAt": "2020-03-11T19:51:24Z", "commit": {"oid": "9303d7e1cfb22219a4ee0bedd5ba7225a2f33aea"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxOTo1MToyNFrOF1GTBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDoxNjo0OFrOF1Hn4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIyMjAyMg==", "bodyText": "We can name it streamList directly?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r391222022", "createdAt": "2020-03-11T19:51:24Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/DefaultStoreLoadTracker.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.ThreadFactoryUtils;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.io.BlockReader;\n+import alluxio.worker.block.io.BlockStreamListener;\n+import alluxio.worker.block.io.BlockStreamTracker;\n+import alluxio.worker.block.io.BlockWriter;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Default {@link StoreLoadTracker} that reports load based on open reader/writer streams to the\n+ * local block store.\n+ *\n+ * TODO(ggezer): TV2 - Add a safety net against close calls not being called.\n+ */\n+public class DefaultStoreLoadTracker implements StoreLoadTracker, BlockStreamListener {\n+  /** Used to keep reference to stream readers/writers per location. */\n+  private final ConcurrentHashMap<BlockStoreLocation, Set<Object>> mStreamsPerLocation;\n+  /** Used for delayed removing of streams in order to emulate activity cool-down. */\n+  private final ScheduledExecutorService mScheduler;\n+  /** For how long, an activity will remain active on load state. */\n+  private final long mLoadDetectionCoolDownMs;\n+\n+  /**\n+   * Creates the default load tracker instance.\n+   */\n+  public DefaultStoreLoadTracker() {\n+    mStreamsPerLocation = new ConcurrentHashMap<>();\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"load-tracker-thread-%d\", true));\n+    mLoadDetectionCoolDownMs =\n+        ServerConfiguration.getMs(PropertyKey.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME);\n+\n+    // BlockStreamTracker provides stream reader/writer events.\n+    BlockStreamTracker.registerListener(this);\n+  }\n+\n+  @Override\n+  public boolean loadDetected(BlockStoreLocation location) {\n+    for (BlockStoreLocation trackedLocation : mStreamsPerLocation.keySet()) {\n+      if (trackedLocation.belongsTo(location)) {\n+        Set<Object> streamsPerLocation = mStreamsPerLocation.get(trackedLocation);\n+        if (streamsPerLocation != null && streamsPerLocation.size() > 0) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void readerOpened(BlockReader reader, BlockStoreLocation location) {\n+    Preconditions.checkState(locationValid(location));\n+    mStreamsPerLocation.compute(location, (k, v) -> {\n+      Set<Object> streamList = v;\n+      if (streamList == null) {\n+        streamList = new ConcurrentHashSet<>();\n+      }\n+      streamList.add(reader);\n+      return streamList;\n+    });\n+  }\n+\n+  @Override\n+  public void readerClosed(BlockReader reader, BlockStoreLocation location) {\n+    Preconditions.checkState(locationValid(location));\n+    mScheduler.schedule(() -> {\n+      mStreamsPerLocation.compute(location, (k, v) -> {\n+        Set<Object> streamList = v;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9303d7e1cfb22219a4ee0bedd5ba7225a2f33aea"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIyMjgxMQ==", "bodyText": "The logic of *Opened and *Closed are the same, perhaps abstract to another method?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r391222811", "createdAt": "2020-03-11T19:52:43Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/DefaultStoreLoadTracker.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.ThreadFactoryUtils;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.io.BlockReader;\n+import alluxio.worker.block.io.BlockStreamListener;\n+import alluxio.worker.block.io.BlockStreamTracker;\n+import alluxio.worker.block.io.BlockWriter;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Default {@link StoreLoadTracker} that reports load based on open reader/writer streams to the\n+ * local block store.\n+ *\n+ * TODO(ggezer): TV2 - Add a safety net against close calls not being called.\n+ */\n+public class DefaultStoreLoadTracker implements StoreLoadTracker, BlockStreamListener {\n+  /** Used to keep reference to stream readers/writers per location. */\n+  private final ConcurrentHashMap<BlockStoreLocation, Set<Object>> mStreamsPerLocation;\n+  /** Used for delayed removing of streams in order to emulate activity cool-down. */\n+  private final ScheduledExecutorService mScheduler;\n+  /** For how long, an activity will remain active on load state. */\n+  private final long mLoadDetectionCoolDownMs;\n+\n+  /**\n+   * Creates the default load tracker instance.\n+   */\n+  public DefaultStoreLoadTracker() {\n+    mStreamsPerLocation = new ConcurrentHashMap<>();\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"load-tracker-thread-%d\", true));\n+    mLoadDetectionCoolDownMs =\n+        ServerConfiguration.getMs(PropertyKey.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME);\n+\n+    // BlockStreamTracker provides stream reader/writer events.\n+    BlockStreamTracker.registerListener(this);\n+  }\n+\n+  @Override\n+  public boolean loadDetected(BlockStoreLocation location) {\n+    for (BlockStoreLocation trackedLocation : mStreamsPerLocation.keySet()) {\n+      if (trackedLocation.belongsTo(location)) {\n+        Set<Object> streamsPerLocation = mStreamsPerLocation.get(trackedLocation);\n+        if (streamsPerLocation != null && streamsPerLocation.size() > 0) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void readerOpened(BlockReader reader, BlockStoreLocation location) {\n+    Preconditions.checkState(locationValid(location));\n+    mStreamsPerLocation.compute(location, (k, v) -> {\n+      Set<Object> streamList = v;\n+      if (streamList == null) {\n+        streamList = new ConcurrentHashSet<>();\n+      }\n+      streamList.add(reader);\n+      return streamList;\n+    });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9303d7e1cfb22219a4ee0bedd5ba7225a2f33aea"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIyNDY4Nw==", "bodyText": "Could we do the cooldown in ManagementTaskCoordinator instead of emulating it here?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r391224687", "createdAt": "2020-03-11T19:54:37Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/DefaultStoreLoadTracker.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.ThreadFactoryUtils;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.io.BlockReader;\n+import alluxio.worker.block.io.BlockStreamListener;\n+import alluxio.worker.block.io.BlockStreamTracker;\n+import alluxio.worker.block.io.BlockWriter;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Default {@link StoreLoadTracker} that reports load based on open reader/writer streams to the\n+ * local block store.\n+ *\n+ * TODO(ggezer): TV2 - Add a safety net against close calls not being called.\n+ */\n+public class DefaultStoreLoadTracker implements StoreLoadTracker, BlockStreamListener {\n+  /** Used to keep reference to stream readers/writers per location. */\n+  private final ConcurrentHashMap<BlockStoreLocation, Set<Object>> mStreamsPerLocation;\n+  /** Used for delayed removing of streams in order to emulate activity cool-down. */\n+  private final ScheduledExecutorService mScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9303d7e1cfb22219a4ee0bedd5ba7225a2f33aea"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNDY2MQ==", "bodyText": "After this method, we only hint at what kind of task is necessary but not the details of the task. What is the computation cost here and could we do more computation to pass onto the execution of the task (ie. which blocks to swap)? Also since the swap will happen at a different time, are there any consistency issues?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r391234661", "createdAt": "2020-03-11T20:05:58Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/TierManagementTaskProvider.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.worker.block.BlockMetadataEvictorView;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStore;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.meta.StorageTier;\n+import alluxio.worker.block.annotator.BlockOrder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.function.Supplier;\n+\n+/**\n+ * {@link ManagementTaskProvider} implementation for tier management tasks.\n+ *\n+ * It currently creates two types of tasks:\n+ *  1- TierSwap task for swapping blocks between tiers in order to promote/demote blocks.\n+ *  2- TierMove task for utilizing speed of higher tiers by moving blocks from below.\n+ */\n+public class TierManagementTaskProvider implements ManagementTaskProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(TierManagementTaskProvider.class);\n+\n+  private final BlockStore mBlockStore;\n+  private final BlockMetadataManager mMetadataManager;\n+  private final Supplier<BlockMetadataEvictorView> mEvictorViewSupplier;\n+  private final StoreLoadTracker mLoadTracker;\n+\n+  /**\n+   * Creates a task provider for tier management functions.\n+   *\n+   * @param blockStore block store\n+   * @param metadataManager meta manager\n+   * @param evictorViewSupplier evictor view supplier\n+   * @param loadTracker load tracker\n+   */\n+  public TierManagementTaskProvider(BlockStore blockStore, BlockMetadataManager metadataManager,\n+      Supplier<BlockMetadataEvictorView> evictorViewSupplier, StoreLoadTracker loadTracker) {\n+    mBlockStore = blockStore;\n+    mMetadataManager = metadataManager;\n+    mEvictorViewSupplier = evictorViewSupplier;\n+    mLoadTracker = loadTracker;\n+  }\n+\n+  @Override\n+  public BlockManagementTask getTask() {\n+    switch (findNextTask()) {\n+      case NONE:\n+        return null;\n+      case TIER_SWAP:\n+        return new TierSwapTask(mBlockStore, mMetadataManager, mEvictorViewSupplier.get(),\n+            mLoadTracker);\n+      case TIER_MOVE:\n+        return new TierMoveTask(mBlockStore, mMetadataManager, mEvictorViewSupplier.get(),\n+            mLoadTracker);\n+      default:\n+        throw new IllegalArgumentException(\"Unknown task type.\");\n+    }\n+  }\n+\n+  /**\n+   * @return the next tier management task that is required\n+   */\n+  private TierManagementTaskType findNextTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9303d7e1cfb22219a4ee0bedd5ba7225a2f33aea"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0Mzc0Nw==", "bodyText": "When will there be no oldValue, does it make sense to set the clock value to 0 (most recent)?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r391243747", "createdAt": "2020-03-11T20:16:48Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/annotator/LRUAnnotator.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.annotator;\n+\n+import alluxio.collections.Pair;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * {@link BlockAnnotator} implementation of LRU scheme.\n+ */\n+public class LRUAnnotator implements BlockAnnotator<LRUAnnotator.LRUSortedField> {\n+  private static final Logger LOG = LoggerFactory.getLogger(LRUAnnotator.class);\n+\n+  private AtomicLong mLRUClock;\n+\n+  /**\n+   * Creates a new LRU annotator.\n+   */\n+  public LRUAnnotator() {\n+    mLRUClock = new AtomicLong(0);\n+  }\n+\n+  @Override\n+  public BlockSortedField updateSortedField(long blockId, LRUSortedField oldValue) {\n+    long clockValue = 0;\n+    if (oldValue != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9303d7e1cfb22219a4ee0bedd5ba7225a2f33aea"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzA3NDE5", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-380707419", "createdAt": "2020-03-24T21:23:48Z", "commit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMToyMzo0OFrOF7DovA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo0OTowMlrOF7F-lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2OTg4NA==", "bodyText": "Can you add some implications, or when one would want it to be true or false?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397469884", "createdAt": "2020-03-24T21:23:48Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2284,21 +2287,126 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_CLASS =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_CLASS)\n+          .setDefaultValue(\"alluxio.worker.block.annotator.LRUAnnotator\")\n+          .setDescription(\"The strategy that a worker uses to annotate blocks \"\n+              + \"in order to have an ordered view of them during internal\"\n+              + \"management tasks such as eviction and promotion/demotion. \"\n+              + \" Valid options include: \"\n+              + \"`alluxio.worker.block.annotator.LRFUAnnotator`, \"\n+              + \"`alluxio.worker.block.annotator.LRUAnnotator`, \")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR)\n           .setDefaultValue(2.0)\n-          .setDescription(\"A attenuation factor in [2, INF) to control the behavior of LRFU.\")\n+          .setDescription(\n+              \"A attenuation factor in [2, INF) to control the behavior of LRFU annotator.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_STEP_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_STEP_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR)\n           .setDefaultValue(0.25)\n           .setDescription(\"A factor in [0, 1] to control the behavior of LRFU: smaller value \"\n               + \"makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to postpone all management tasks under any user activity\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MDEyNQ==", "bodyText": "Can you add some implications, or tradeoffs for a longer time and shorter time?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397470125", "createdAt": "2020-03-24T21:24:16Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2284,21 +2287,126 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_CLASS =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_CLASS)\n+          .setDefaultValue(\"alluxio.worker.block.annotator.LRUAnnotator\")\n+          .setDescription(\"The strategy that a worker uses to annotate blocks \"\n+              + \"in order to have an ordered view of them during internal\"\n+              + \"management tasks such as eviction and promotion/demotion. \"\n+              + \" Valid options include: \"\n+              + \"`alluxio.worker.block.annotator.LRFUAnnotator`, \"\n+              + \"`alluxio.worker.block.annotator.LRUAnnotator`, \")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR)\n           .setDefaultValue(2.0)\n-          .setDescription(\"A attenuation factor in [2, INF) to control the behavior of LRFU.\")\n+          .setDescription(\n+              \"A attenuation factor in [2, INF) to control the behavior of LRFU annotator.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_STEP_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_STEP_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR)\n           .setDefaultValue(0.25)\n           .setDescription(\"A factor in [0, 1] to control the behavior of LRFU: smaller value \"\n               + \"makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to postpone all management tasks under any user activity\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management tasks will not run for this long after load detected.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MDM5Ng==", "bodyText": "It is unclear how this is different from WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397470396", "createdAt": "2020-03-24T21:24:53Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2284,21 +2287,126 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_CLASS =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_CLASS)\n+          .setDefaultValue(\"alluxio.worker.block.annotator.LRUAnnotator\")\n+          .setDescription(\"The strategy that a worker uses to annotate blocks \"\n+              + \"in order to have an ordered view of them during internal\"\n+              + \"management tasks such as eviction and promotion/demotion. \"\n+              + \" Valid options include: \"\n+              + \"`alluxio.worker.block.annotator.LRFUAnnotator`, \"\n+              + \"`alluxio.worker.block.annotator.LRUAnnotator`, \")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR)\n           .setDefaultValue(2.0)\n-          .setDescription(\"A attenuation factor in [2, INF) to control the behavior of LRFU.\")\n+          .setDescription(\n+              \"A attenuation factor in [2, INF) to control the behavior of LRFU annotator.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_STEP_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_STEP_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR)\n           .setDefaultValue(0.25)\n           .setDescription(\"A factor in [0, 1] to control the behavior of LRFU: smaller value \"\n               + \"makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to postpone all management tasks under any user activity\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management tasks will not run for this long after load detected.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_RESERVED_SPACE_BYTES =\n+      new Builder(Name.WORKER_MANAGEMENT_RESERVED_SPACE_BYTES)\n+          .setDefaultValue(\"1GB\")\n+          .setDescription(\"The amount of space that is reserved from each storage directory \"\n+              + \"for internal management tasks.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_IDLE_SLEEP_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_IDLE_SLEEP_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management task coordinator will back-off for specified duration when\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MDkwNQ==", "bodyText": "How does this relate to WORKER_MANAGEMENT_TASK_THREAD_COUNT?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397470905", "createdAt": "2020-03-24T21:25:55Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2284,21 +2287,126 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_CLASS =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_CLASS)\n+          .setDefaultValue(\"alluxio.worker.block.annotator.LRUAnnotator\")\n+          .setDescription(\"The strategy that a worker uses to annotate blocks \"\n+              + \"in order to have an ordered view of them during internal\"\n+              + \"management tasks such as eviction and promotion/demotion. \"\n+              + \" Valid options include: \"\n+              + \"`alluxio.worker.block.annotator.LRFUAnnotator`, \"\n+              + \"`alluxio.worker.block.annotator.LRUAnnotator`, \")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR)\n           .setDefaultValue(2.0)\n-          .setDescription(\"A attenuation factor in [2, INF) to control the behavior of LRFU.\")\n+          .setDescription(\n+              \"A attenuation factor in [2, INF) to control the behavior of LRFU annotator.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_STEP_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_STEP_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR)\n           .setDefaultValue(0.25)\n           .setDescription(\"A factor in [0, 1] to control the behavior of LRFU: smaller value \"\n               + \"makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to postpone all management tasks under any user activity\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management tasks will not run for this long after load detected.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_RESERVED_SPACE_BYTES =\n+      new Builder(Name.WORKER_MANAGEMENT_RESERVED_SPACE_BYTES)\n+          .setDefaultValue(\"1GB\")\n+          .setDescription(\"The amount of space that is reserved from each storage directory \"\n+              + \"for internal management tasks.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_IDLE_SLEEP_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_IDLE_SLEEP_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management task coordinator will back-off for specified duration when\"\n+              + \"no management task is pending.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TASK_THREAD_COUNT =\n+      new Builder(Name.WORKER_MANAGEMENT_TASK_THREAD_COUNT)\n+          .setDefaultSupplier(() -> Runtime.getRuntime().availableProcessors(),\n+              \"Use {CPU core count} threads for all management tasks\")\n+          .setDescription(\"The number of threads for management task executor\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_TASK_CONCURRENCY =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MTQ3Mg==", "bodyText": "What are the implications to setting this to true or false?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397471472", "createdAt": "2020-03-24T21:27:02Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2284,21 +2287,126 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_CLASS =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_CLASS)\n+          .setDefaultValue(\"alluxio.worker.block.annotator.LRUAnnotator\")\n+          .setDescription(\"The strategy that a worker uses to annotate blocks \"\n+              + \"in order to have an ordered view of them during internal\"\n+              + \"management tasks such as eviction and promotion/demotion. \"\n+              + \" Valid options include: \"\n+              + \"`alluxio.worker.block.annotator.LRFUAnnotator`, \"\n+              + \"`alluxio.worker.block.annotator.LRUAnnotator`, \")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR)\n           .setDefaultValue(2.0)\n-          .setDescription(\"A attenuation factor in [2, INF) to control the behavior of LRFU.\")\n+          .setDescription(\n+              \"A attenuation factor in [2, INF) to control the behavior of LRFU annotator.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_STEP_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_STEP_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR)\n           .setDefaultValue(0.25)\n           .setDescription(\"A factor in [0, 1] to control the behavior of LRFU: smaller value \"\n               + \"makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to postpone all management tasks under any user activity\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management tasks will not run for this long after load detected.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_RESERVED_SPACE_BYTES =\n+      new Builder(Name.WORKER_MANAGEMENT_RESERVED_SPACE_BYTES)\n+          .setDefaultValue(\"1GB\")\n+          .setDescription(\"The amount of space that is reserved from each storage directory \"\n+              + \"for internal management tasks.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_IDLE_SLEEP_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_IDLE_SLEEP_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management task coordinator will back-off for specified duration when\"\n+              + \"no management task is pending.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TASK_THREAD_COUNT =\n+      new Builder(Name.WORKER_MANAGEMENT_TASK_THREAD_COUNT)\n+          .setDefaultSupplier(() -> Runtime.getRuntime().availableProcessors(),\n+              \"Use {CPU core count} threads for all management tasks\")\n+          .setDescription(\"The number of threads for management task executor\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_TASK_CONCURRENCY =\n+      new Builder(Name.WORKER_MANAGEMENT_TIER_TASK_CONCURRENCY)\n+          .setDefaultSupplier(() -> Math.max(1, Runtime.getRuntime().availableProcessors() / 2),\n+              \"Use up to {CPU core count / 2} for tier swap/move tasks\")\n+          .setDescription(\"The number of threads used by tier swap/move tasks.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_SWAP_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_TIER_SWAP_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to run management tier-swap task.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_MOVE_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_TIER_MOVE_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to run management tier-move task.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_SWAP_RANGE =\n+      new Builder(Name.WORKER_MANAGEMENT_TIER_SWAP_RANGE)\n+          .setDefaultValue(100)\n+          .setDescription(\n+              \"Maximum number of blocks to consider from one tier when doing tier swap task.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_MOVE_RANGE =\n+      new Builder(Name.WORKER_MANAGEMENT_TIER_MOVE_RANGE)\n+          .setDefaultValue(100)\n+          .setDescription(\n+              \"Maximum number of blocks to consider from one tier when doing tier move task.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_TIER_MOVE_LIMIT =\n+      new Builder(Name.WORKER_MANAGEMENT_TIER_MOVE_LIMIT)\n+          .setDefaultValue(0.1)\n+          .setDescription(\"Ratio of free space per-tier for moving blocks from below.\"\n+              + \" When under this value moving to that tier will be stopped.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_SWAP_USING_FS =\n+      new Builder(Name.WORKER_MANAGEMENT_SWAP_USING_FS)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to use file-system moves to \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MTg2Mg==", "bodyText": "there is no default or description?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397471862", "createdAt": "2020-03-24T21:27:45Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3004,6 +3121,10 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_FILE_TARGET_MEDIA =\n+      new Builder(Name.USER_FILE_TARGET_MEDIA)\n+          .setScope(Scope.CLIENT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MzU0NA==", "bodyText": "Does this have to be static?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397473544", "createdAt": "2020-03-24T21:31:00Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/worker/block/io/BlockStreamTracker.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.io;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.worker.block.BlockStoreLocation;\n+\n+import java.util.Set;\n+\n+/**\n+ * Used to emit block reader/writer open/close events.\n+ */\n+public class BlockStreamTracker {\n+  /** List of listeners for this tracker. */\n+  private static Set<BlockStreamListener> sListeners = new ConcurrentHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3NDIxNA==", "bodyText": "Can we add this to a unit test somewhere?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397474214", "createdAt": "2020-03-24T21:32:23Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/StorageTierAssoc.java", "diffHunk": "@@ -119,4 +121,17 @@ public int size() {\n     }\n     return ret;\n   }\n+\n+  /**\n+   * @return list of intersections between tier levels\n+   */\n+  public List<Pair<BlockStoreLocation, BlockStoreLocation>> intersectionList() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3NjA0NQ==", "bodyText": "do we want to keep this message?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397476045", "createdAt": "2020-03-24T21:36:13Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockMetadataEvictorView.java", "diffHunk": "@@ -111,7 +113,11 @@ public boolean isBlockLocked(long blockId) {\n    * @return boolean, true if the block can be evicted\n    */\n   public boolean isBlockEvictable(long blockId) {\n-    return (!isBlockPinned(blockId) && !isBlockLocked(blockId) && !isBlockMarked(blockId));\n+    boolean pinned = isBlockPinned(blockId);\n+    boolean locked = isBlockLocked(blockId);\n+    boolean marked = isBlockMarked(blockId);\n+    LOG.debug(\"Block: {}. Pinned: {}, Locked: {}, Marked: {}\", blockId, pinned, locked, marked);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3NjkxNA==", "bodyText": "Should we still have the old names, so while deprecated, it still works, until we remove the deprecated version?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397476914", "createdAt": "2020-03-24T21:37:52Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/evictor/LRFUEvictor.java", "diffHunk": "@@ -70,9 +73,10 @@\n    */\n   public LRFUEvictor(BlockMetadataEvictorView view, Allocator allocator) {\n     super(view, allocator);\n-    mStepFactor = ServerConfiguration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_STEP_FACTOR);\n+    mStepFactor =\n+        ServerConfiguration.getDouble(PropertyKey.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR);\n     mAttenuationFactor =\n-        ServerConfiguration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR);\n+        ServerConfiguration.getDouble(PropertyKey.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3ODEzOA==", "bodyText": "are these changes related to the rest of the PR, or is this an independent change?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397478138", "createdAt": "2020-03-24T21:40:21Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractWriteHandler.java", "diffHunk": "@@ -106,7 +106,14 @@ public void write(WriteRequest writeRequest) {\n       try {\n         if (mContext == null) {\n           LOG.debug(\"Received write request {}.\", writeRequest);\n-          mContext = createRequestContext(writeRequest);\n+          try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3OTQ5Ng==", "bodyText": "update the next available id comment", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397479496", "createdAt": "2020-03-24T21:42:44Z", "author": {"login": "gpang"}, "path": "core/transport/src/main/proto/grpc/block_worker.proto", "diffHunk": "@@ -89,6 +89,7 @@ message WriteRequestCommand {\n   optional alluxio.proto.dataserver.CreateUfsBlockOptions create_ufs_block_options = 7;\n   optional string medium_type = 8;\n   optional bool pin_on_create = 9;\n+  optional int64 space_to_reserve = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4NDQ1NQ==", "bodyText": "I don't think we need to include these exceptions in the javadoc", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397484455", "createdAt": "2020-03-24T21:53:24Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockMetadataManager.java", "diffHunk": "@@ -129,6 +159,30 @@ public void commitTempBlockMeta(TempBlockMeta tempBlockMeta)\n     dir.addBlockMeta(block);\n   }\n \n+  /**\n+   * Swaps location of two blocks in metadata.\n+   *\n+   * @param blockMeta1 the first block meta\n+   * @param blockMeta2 the second block meta\n+   * @throws BlockDoesNotExistException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MzE3Mw==", "bodyText": "is this an unrelated bug fix?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397493173", "createdAt": "2020-03-24T22:12:26Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/BlockWriteHandler.java", "diffHunk": "@@ -106,8 +110,10 @@ protected void cancelRequest(BlockWriteRequestContext context) throws Exception\n \n   @Override\n   protected void cleanupRequest(BlockWriteRequestContext context) throws Exception {\n-    WriteRequest request = context.getRequest();\n-    mWorker.cleanupSession(request.getSessionId());\n+    if (context.getBlockWriter() != null) {\n+      context.getBlockWriter().close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMDM3OQ==", "bodyText": "retry is no longer necessary?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397500379", "createdAt": "2020-03-24T22:29:01Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -209,29 +206,23 @@ public BlockReader getBlockReader(long sessionId, long blockId, long lockId)\n     mLockManager.validateLock(sessionId, blockId, lockId);\n     try (LockResource r = new LockResource(mMetadataReadLock)) {\n       BlockMeta blockMeta = mMetaManager.getBlockMeta(blockId);\n-      return new LocalFileBlockReader(blockMeta.getPath());\n+      return new StoreBlockReader(sessionId, blockMeta);\n     }\n   }\n \n   @Override\n-  public TempBlockMeta createBlock(long sessionId, long blockId, BlockStoreLocation location,\n-      long initialBlockSize) throws BlockAlreadyExistsException, WorkerOutOfSpaceException,\n-      IOException {\n-    LOG.debug(\"createBlock: sessionId={}, blockId={}, location={}, initialBlockSize={}\", sessionId,\n-        blockId, location, initialBlockSize);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMDc4Mg==", "bodyText": "should we add pinOnCreate?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397500782", "createdAt": "2020-03-24T22:30:04Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -266,14 +257,40 @@ public void commitBlock(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n     LOG.debug(\"commitBlock: sessionId={}, blockId={}\", sessionId, blockId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMDgyNQ==", "bodyText": "commitBlockLocked? Should we add pinOnCreate?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397500825", "createdAt": "2020-03-24T22:30:11Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -266,14 +257,40 @@ public void commitBlock(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n     LOG.debug(\"commitBlock: sessionId={}, blockId={}\", sessionId, blockId);\n-    BlockStoreLocation loc = commitBlockInternal(sessionId, blockId, pinOnCreate);\n-    synchronized (mBlockStoreEventListeners) {\n-      for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-        listener.onCommitBlock(sessionId, blockId, loc);\n+    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+    try {\n+      BlockStoreLocation loc = commitBlockInternal(sessionId, blockId, pinOnCreate);\n+      synchronized (mBlockStoreEventListeners) {\n+        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n+          listener.onCommitBlock(sessionId, blockId, loc);\n+        }\n       }\n+    } finally {\n+      mLockManager.unlockBlock(lockId);\n     }\n   }\n \n+  @Override\n+  public long commitBlockLocked(long sessionId, long blockId, boolean pinOnCreate)\n+      throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n+      IOException {\n+    LOG.debug(\"commitBlock: sessionId={}, blockId={}\", sessionId, blockId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMTY3MQ==", "bodyText": "can commitBlock reuse commitBlockLocked?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397501671", "createdAt": "2020-03-24T22:32:25Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -266,14 +257,40 @@ public void commitBlock(long sessionId, long blockId, boolean pinOnCreate)\n       throws BlockAlreadyExistsException, InvalidWorkerStateException, BlockDoesNotExistException,\n       IOException {\n     LOG.debug(\"commitBlock: sessionId={}, blockId={}\", sessionId, blockId);\n-    BlockStoreLocation loc = commitBlockInternal(sessionId, blockId, pinOnCreate);\n-    synchronized (mBlockStoreEventListeners) {\n-      for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-        listener.onCommitBlock(sessionId, blockId, loc);\n+    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMjE3MA==", "bodyText": "Is RuntimeException the correct exception to throw? Can we provide more information in the message?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397502170", "createdAt": "2020-03-24T22:33:40Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -291,51 +308,180 @@ public void requestSpace(long sessionId, long blockId, long additionalBytes)\n       throws BlockDoesNotExistException, WorkerOutOfSpaceException, IOException {\n     LOG.debug(\"requestSpace: sessionId={}, blockId={}, additionalBytes={}\", sessionId, blockId,\n         additionalBytes);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {\n-      Pair<Boolean, BlockStoreLocation> requestResult =\n-          requestSpaceInternal(blockId, additionalBytes);\n-      if (requestResult.getFirst()) {\n-        return;\n+\n+    // NOTE: a temp block is only visible to its own writer, unnecessary to acquire\n+    // block lock here since no sharing\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+\n+      StorageDirView allocationDir = allocateSpace(sessionId,\n+          AllocateOptions.forRequestSpace(additionalBytes, tempBlockMeta.getBlockLocation()));\n+      if (allocationDir == null) {\n+        throw new WorkerOutOfSpaceException(String.format(\n+            \"Can't reserve more space for block: %d under session: %d.\", blockId, sessionId));\n+      }\n+\n+      if (!allocationDir.toBlockStoreLocation().equals(tempBlockMeta.getBlockLocation())) {\n+        // If reached here, allocateSpace() failed to enforce 'forceLocation' flag.\n+        throw new RuntimeException(\"Allocation error: location enforcement failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMjY4Ng==", "bodyText": "should there be a log debug message, like the other methods?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397502686", "createdAt": "2020-03-24T22:34:55Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -291,51 +308,180 @@ public void requestSpace(long sessionId, long blockId, long additionalBytes)\n       throws BlockDoesNotExistException, WorkerOutOfSpaceException, IOException {\n     LOG.debug(\"requestSpace: sessionId={}, blockId={}, additionalBytes={}\", sessionId, blockId,\n         additionalBytes);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {\n-      Pair<Boolean, BlockStoreLocation> requestResult =\n-          requestSpaceInternal(blockId, additionalBytes);\n-      if (requestResult.getFirst()) {\n-        return;\n+\n+    // NOTE: a temp block is only visible to its own writer, unnecessary to acquire\n+    // block lock here since no sharing\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+\n+      StorageDirView allocationDir = allocateSpace(sessionId,\n+          AllocateOptions.forRequestSpace(additionalBytes, tempBlockMeta.getBlockLocation()));\n+      if (allocationDir == null) {\n+        throw new WorkerOutOfSpaceException(String.format(\n+            \"Can't reserve more space for block: %d under session: %d.\", blockId, sessionId));\n+      }\n+\n+      if (!allocationDir.toBlockStoreLocation().equals(tempBlockMeta.getBlockLocation())) {\n+        // If reached here, allocateSpace() failed to enforce 'forceLocation' flag.\n+        throw new RuntimeException(\"Allocation error: location enforcement failed\");\n+      }\n+\n+      // Increase the size of this temp block\n+      try {\n+        mMetaManager.resizeTempBlockMeta(\n+            tempBlockMeta, tempBlockMeta.getBlockSize() + additionalBytes);\n+      } catch (InvalidWorkerStateException e) {\n+        throw Throwables.propagate(e); // we shall never reach here\n       }\n     }\n-    // TODO(bin): We are probably seeing a rare transient failure, maybe define and throw some\n-    // other types of exception to indicate this case.\n-    throw new WorkerOutOfSpaceException(ExceptionMessage.NO_SPACE_FOR_BLOCK_REQUEST_SPACE_TIMEOUT,\n-        additionalBytes, FREE_SPACE_TIMEOUT_MS, blockId);\n   }\n \n   @Override\n-  public void moveBlock(long sessionId, long blockId, BlockStoreLocation newLocation)\n+  public void moveBlock(long sessionId, long blockId, AllocateOptions moveOptions)\n       throws BlockDoesNotExistException, BlockAlreadyExistsException, InvalidWorkerStateException,\n       WorkerOutOfSpaceException, IOException {\n-    moveBlock(sessionId, blockId, BlockStoreLocation.anyTier(), newLocation);\n+    moveBlock(sessionId, blockId, BlockStoreLocation.anyTier(), moveOptions);\n   }\n \n   @Override\n   public void moveBlock(long sessionId, long blockId, BlockStoreLocation oldLocation,\n-      BlockStoreLocation newLocation)\n+      AllocateOptions moveOptions)\n           throws BlockDoesNotExistException, BlockAlreadyExistsException,\n           InvalidWorkerStateException, WorkerOutOfSpaceException, IOException {\n-    LOG.debug(\"moveBlock: sessionId={}, blockId={}, oldLocation={}, newLocation={}\", sessionId,\n-        blockId, oldLocation, newLocation);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {\n-      MoveBlockResult result = moveBlockInternal(sessionId, blockId, oldLocation, newLocation);\n-      if (result.getSuccess()) {\n-        synchronized (mBlockStoreEventListeners) {\n-          for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-            listener.onMoveBlockByClient(sessionId, blockId, result.getSrcLocation(),\n-                result.getDstLocation());\n-          }\n+    LOG.debug(\"moveBlock: sessionId={}, blockId={}, oldLocation={}, options={}\", sessionId,\n+        blockId, oldLocation, moveOptions);\n+    MoveBlockResult result = moveBlockInternal(sessionId, blockId, oldLocation, moveOptions);\n+    if (result.getSuccess()) {\n+      synchronized (mBlockStoreEventListeners) {\n+        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n+          listener.onMoveBlockByClient(sessionId, blockId, result.getSrcLocation(),\n+              result.getDstLocation());\n         }\n-        return;\n       }\n+      return;\n     }\n     // TODO(bin): We are probably seeing a rare transient failure, maybe define and throw some\n     // other types of exception to indicate this case.\n-    throw new WorkerOutOfSpaceException(ExceptionMessage.NO_SPACE_FOR_BLOCK_MOVE_TIMEOUT,\n-        newLocation, blockId, FREE_SPACE_TIMEOUT_MS);\n+    throw new WorkerOutOfSpaceException(ExceptionMessage.NO_SPACE_FOR_BLOCK_MOVE,\n+        moveOptions.getLocation(), blockId);\n+  }\n+\n+  @Override\n+  public void swapBlocks(long sessionId, long blockId1, long blockId2)\n+      throws BlockDoesNotExistException, BlockAlreadyExistsException, InvalidWorkerStateException,\n+      WorkerOutOfSpaceException, IOException {\n+    BlockMeta blockMeta1;\n+    BlockMeta blockMeta2;\n+    boolean doFsSwap = false;\n+\n+    long lockId1 = mLockManager.lockBlock(sessionId, blockId1, BlockLockType.READ);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMzAzNw==", "bodyText": "can we split this up and put the directory that ran out of space in the message?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397503037", "createdAt": "2020-03-24T22:35:48Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -291,51 +308,180 @@ public void requestSpace(long sessionId, long blockId, long additionalBytes)\n       throws BlockDoesNotExistException, WorkerOutOfSpaceException, IOException {\n     LOG.debug(\"requestSpace: sessionId={}, blockId={}, additionalBytes={}\", sessionId, blockId,\n         additionalBytes);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {\n-      Pair<Boolean, BlockStoreLocation> requestResult =\n-          requestSpaceInternal(blockId, additionalBytes);\n-      if (requestResult.getFirst()) {\n-        return;\n+\n+    // NOTE: a temp block is only visible to its own writer, unnecessary to acquire\n+    // block lock here since no sharing\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n+\n+      StorageDirView allocationDir = allocateSpace(sessionId,\n+          AllocateOptions.forRequestSpace(additionalBytes, tempBlockMeta.getBlockLocation()));\n+      if (allocationDir == null) {\n+        throw new WorkerOutOfSpaceException(String.format(\n+            \"Can't reserve more space for block: %d under session: %d.\", blockId, sessionId));\n+      }\n+\n+      if (!allocationDir.toBlockStoreLocation().equals(tempBlockMeta.getBlockLocation())) {\n+        // If reached here, allocateSpace() failed to enforce 'forceLocation' flag.\n+        throw new RuntimeException(\"Allocation error: location enforcement failed\");\n+      }\n+\n+      // Increase the size of this temp block\n+      try {\n+        mMetaManager.resizeTempBlockMeta(\n+            tempBlockMeta, tempBlockMeta.getBlockSize() + additionalBytes);\n+      } catch (InvalidWorkerStateException e) {\n+        throw Throwables.propagate(e); // we shall never reach here\n       }\n     }\n-    // TODO(bin): We are probably seeing a rare transient failure, maybe define and throw some\n-    // other types of exception to indicate this case.\n-    throw new WorkerOutOfSpaceException(ExceptionMessage.NO_SPACE_FOR_BLOCK_REQUEST_SPACE_TIMEOUT,\n-        additionalBytes, FREE_SPACE_TIMEOUT_MS, blockId);\n   }\n \n   @Override\n-  public void moveBlock(long sessionId, long blockId, BlockStoreLocation newLocation)\n+  public void moveBlock(long sessionId, long blockId, AllocateOptions moveOptions)\n       throws BlockDoesNotExistException, BlockAlreadyExistsException, InvalidWorkerStateException,\n       WorkerOutOfSpaceException, IOException {\n-    moveBlock(sessionId, blockId, BlockStoreLocation.anyTier(), newLocation);\n+    moveBlock(sessionId, blockId, BlockStoreLocation.anyTier(), moveOptions);\n   }\n \n   @Override\n   public void moveBlock(long sessionId, long blockId, BlockStoreLocation oldLocation,\n-      BlockStoreLocation newLocation)\n+      AllocateOptions moveOptions)\n           throws BlockDoesNotExistException, BlockAlreadyExistsException,\n           InvalidWorkerStateException, WorkerOutOfSpaceException, IOException {\n-    LOG.debug(\"moveBlock: sessionId={}, blockId={}, oldLocation={}, newLocation={}\", sessionId,\n-        blockId, oldLocation, newLocation);\n-    RetryPolicy retryPolicy = new TimeoutRetry(FREE_SPACE_TIMEOUT_MS, EVICTION_INTERVAL_MS);\n-    while (retryPolicy.attempt()) {\n-      MoveBlockResult result = moveBlockInternal(sessionId, blockId, oldLocation, newLocation);\n-      if (result.getSuccess()) {\n-        synchronized (mBlockStoreEventListeners) {\n-          for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-            listener.onMoveBlockByClient(sessionId, blockId, result.getSrcLocation(),\n-                result.getDstLocation());\n-          }\n+    LOG.debug(\"moveBlock: sessionId={}, blockId={}, oldLocation={}, options={}\", sessionId,\n+        blockId, oldLocation, moveOptions);\n+    MoveBlockResult result = moveBlockInternal(sessionId, blockId, oldLocation, moveOptions);\n+    if (result.getSuccess()) {\n+      synchronized (mBlockStoreEventListeners) {\n+        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n+          listener.onMoveBlockByClient(sessionId, blockId, result.getSrcLocation(),\n+              result.getDstLocation());\n         }\n-        return;\n       }\n+      return;\n     }\n     // TODO(bin): We are probably seeing a rare transient failure, maybe define and throw some\n     // other types of exception to indicate this case.\n-    throw new WorkerOutOfSpaceException(ExceptionMessage.NO_SPACE_FOR_BLOCK_MOVE_TIMEOUT,\n-        newLocation, blockId, FREE_SPACE_TIMEOUT_MS);\n+    throw new WorkerOutOfSpaceException(ExceptionMessage.NO_SPACE_FOR_BLOCK_MOVE,\n+        moveOptions.getLocation(), blockId);\n+  }\n+\n+  @Override\n+  public void swapBlocks(long sessionId, long blockId1, long blockId2)\n+      throws BlockDoesNotExistException, BlockAlreadyExistsException, InvalidWorkerStateException,\n+      WorkerOutOfSpaceException, IOException {\n+    BlockMeta blockMeta1;\n+    BlockMeta blockMeta2;\n+    boolean doFsSwap = false;\n+\n+    long lockId1 = mLockManager.lockBlock(sessionId, blockId1, BlockLockType.READ);\n+    long lockId2 = mLockManager.lockBlock(sessionId, blockId2, BlockLockType.READ);\n+    try {\n+      try (LockResource r = new LockResource(mMetadataReadLock)) {\n+        if (mMetaManager.hasTempBlockMeta(blockId1) || mMetaManager.hasTempBlockMeta(blockId2)) {\n+          throw new InvalidWorkerStateException(ExceptionMessage.MOVE_UNCOMMITTED_BLOCK, blockId1);\n+        }\n+        blockMeta1 = mMetaManager.getBlockMeta(blockId1);\n+        blockMeta2 = mMetaManager.getBlockMeta(blockId2);\n+      }\n+\n+      if (ServerConfiguration.getBoolean(PropertyKey.WORKER_MANAGEMENT_SWAP_USING_FS)) {\n+        Path dirPath1 = Paths.get(blockMeta1.getParentDir().getDirPath());\n+        Path dirPath2 = Paths.get(blockMeta2.getParentDir().getDirPath());\n+        if (Objects.equals(dirPath1.getRoot(), dirPath2.getRoot())) {\n+          doFsSwap = true;\n+        }\n+      }\n+\n+      // Allocate swap space from directories for swapping blocks.\n+      if (!blockMeta1.getParentDir().allocateFromReserve(blockMeta2.getBlockSize())\n+          || !blockMeta2.getParentDir().allocateFromReserve(blockMeta1.getBlockSize())) {\n+        throw new WorkerOutOfSpaceException(\"No reserved space left for swapping.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMzkzOQ==", "bodyText": "why is this now synchronized?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397503939", "createdAt": "2020-03-24T22:38:09Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -348,37 +494,61 @@ public void removeBlock(long sessionId, long blockId)\n   public void removeBlock(long sessionId, long blockId, BlockStoreLocation location)\n       throws InvalidWorkerStateException, BlockDoesNotExistException, IOException {\n     LOG.debug(\"removeBlock: sessionId={}, blockId={}, location={}\", sessionId, blockId, location);\n-    removeBlockInternal(sessionId, blockId, location);\n+    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+\n+    BlockMeta blockMeta;\n+    try (LockResource r = new LockResource(mMetadataReadLock)) {\n+      if (mMetaManager.hasTempBlockMeta(blockId)) {\n+        throw new InvalidWorkerStateException(ExceptionMessage.REMOVE_UNCOMMITTED_BLOCK, blockId);\n+      }\n+\n+      blockMeta = mMetaManager.getBlockMeta(blockId);\n+\n+      if (!blockMeta.getBlockLocation().belongsTo(location)) {\n+        throw new BlockDoesNotExistException(ExceptionMessage.BLOCK_NOT_FOUND_AT_LOCATION, blockId,\n+            location);\n+      }\n+    } catch (Exception e) {\n+      mLockManager.unlockBlock(lockId);\n+      throw e;\n+    }\n+\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      removeBlockInternal(blockMeta);\n+    } finally {\n+      mLockManager.unlockBlock(lockId);\n+    }\n+\n     synchronized (mBlockStoreEventListeners) {\n       for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n         listener.onRemoveBlockByClient(sessionId, blockId);\n+        listener.onRemoveBlock(sessionId, blockId, blockMeta.getBlockLocation());\n       }\n     }\n   }\n \n   @Override\n   public void accessBlock(long sessionId, long blockId) throws BlockDoesNotExistException {\n     LOG.debug(\"accessBlock: sessionId={}, blockId={}\", sessionId, blockId);\n-    boolean hasBlock;\n     try (LockResource r = new LockResource(mMetadataReadLock)) {\n-      hasBlock = mMetaManager.hasBlockMeta(blockId);\n-    }\n-    if (!hasBlock) {\n-      throw new BlockDoesNotExistException(ExceptionMessage.NO_BLOCK_ID_FOUND, blockId);\n-    }\n-    synchronized (mBlockStoreEventListeners) {\n-      for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-        listener.onAccessBlock(sessionId, blockId);\n+      BlockMeta blockMeta = mMetaManager.getBlockMeta(blockId);\n+\n+      synchronized (mBlockStoreEventListeners) {\n+        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n+          listener.onAccessBlock(sessionId, blockId);\n+          listener.onAccessBlock(sessionId, blockId, blockMeta.getBlockLocation());\n+        }\n       }\n     }\n   }\n \n   @Override\n-  public void freeSpace(long sessionId, long availableBytes, BlockStoreLocation location)\n+  public synchronized void freeSpace(long sessionId, long minAvailableBytes, long maxAvailableBytes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwNTI4Nw==", "bodyText": "Should this be warn?\nAlso, it is always the case that the block doesn't exist right? The message sounds like the eviction failed, and one possible reason is that the block is already gone.", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397505287", "createdAt": "2020-03-24T22:41:43Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -570,162 +791,107 @@ private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boo\n    *\n    * @param sessionId session id\n    * @param blockId block id\n-   * @param location location to create the block\n-   * @param initialBlockSize initial block size in bytes\n    * @param newBlock true if this temp block is created for a new block\n+   * @param options block allocation options\n    * @return a temp block created if successful, or null if allocation failed (instead of throwing\n    *         {@link WorkerOutOfSpaceException} because allocation failure could be an expected case)\n    * @throws BlockAlreadyExistsException if there is already a block with the same block id\n    */\n-  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId,\n-      BlockStoreLocation location, long initialBlockSize, boolean newBlock)\n-          throws BlockAlreadyExistsException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n+  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId, boolean newBlock,\n+      AllocateOptions options) throws BlockAlreadyExistsException {\n     try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      // NOTE: a temp block is supposed to be visible for its own writer,\n+      // unnecessary to acquire block lock here since no sharing.\n       if (newBlock) {\n         checkTempBlockIdAvailable(blockId);\n       }\n-      StorageDirView dirView = mAllocator.allocateBlockWithView(sessionId,\n-          initialBlockSize, location, new BlockMetadataAllocatorView(mMetaManager));\n+\n+      // Allocate space.\n+      StorageDirView dirView = allocateSpace(sessionId, options);\n+\n       if (dirView == null) {\n-        // Allocator fails to find a proper place for this new block.\n         return null;\n       }\n+\n       // TODO(carson): Add tempBlock to corresponding storageDir and remove the use of\n       // StorageDirView.createTempBlockMeta.\n-      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, initialBlockSize);\n+      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, options.getSize());\n       try {\n         // Add allocated temp block to metadata manager. This should never fail if allocator\n         // correctly assigns a StorageDir.\n         mMetaManager.addTempBlockMeta(tempBlock);\n       } catch (WorkerOutOfSpaceException | BlockAlreadyExistsException e) {\n         // If we reach here, allocator is not working properly\n         LOG.error(\"Unexpected failure: {} bytes allocated at {} by allocator, \"\n-            + \"but addTempBlockMeta failed\", initialBlockSize, location);\n+            + \"but addTempBlockMeta failed\", options.getSize(), options.getLocation());\n         throw Throwables.propagate(e);\n       }\n       return tempBlock;\n     }\n   }\n \n   /**\n-   * Increases the temp block size only if this temp block's parent dir has enough available space.\n-   *\n-   * @param blockId block id\n-   * @param additionalBytes additional bytes to request for this block\n-   * @return a pair of boolean and {@link BlockStoreLocation}. The boolean indicates if the\n-   *         operation succeeds and the {@link BlockStoreLocation} denotes where to free more space\n-   *         if it fails.\n-   * @throws BlockDoesNotExistException if this block is not found\n-   */\n-  private Pair<Boolean, BlockStoreLocation> requestSpaceInternal(long blockId, long additionalBytes)\n-      throws BlockDoesNotExistException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-      if (tempBlockMeta.getParentDir().getAvailableBytes() < additionalBytes) {\n-        return new Pair<>(false, tempBlockMeta.getBlockLocation());\n-      }\n-      // Increase the size of this temp block\n-      try {\n-        mMetaManager.resizeTempBlockMeta(tempBlockMeta,\n-            tempBlockMeta.getBlockSize() + additionalBytes);\n-      } catch (InvalidWorkerStateException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n-      return new Pair<>(true, null);\n-    }\n-  }\n-\n-  /**\n-   * Tries to get an eviction plan to free a certain amount of space in the given location, and\n-   * carries out this plan with the best effort.\n+   * Tries to free a certain amount of space in the given location.\n    *\n    * @param sessionId the session id\n-   * @param availableBytes amount of space in bytes to free\n+   * @param minAvailableBytes the minimum amount of space in bytes to set available\n+   * @param maxAvailableBytes the maximum amount of space in bytes to set available\n    * @param location location of space\n-   * @param mode the eviction mode\n-   * @throws WorkerOutOfSpaceException if it is impossible to achieve the free requirement\n+   * @throws WorkerOutOfSpaceException if it is impossible to achieve minimum space requirement\n    */\n-  private void freeSpaceInternal(long sessionId, long availableBytes, BlockStoreLocation location,\n-      Evictor.Mode mode) throws WorkerOutOfSpaceException, IOException {\n-    EvictionPlan plan;\n-    // NOTE:change the read lock to the write lock due to the endless-loop issue [ALLUXIO-3089]\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      plan = mEvictor.freeSpaceWithView(availableBytes, location, getUpdatedView(), mode);\n-      // Absent plan means failed to evict enough space.\n-      if (plan == null) {\n-        throw new WorkerOutOfSpaceException(\n-            ExceptionMessage.NO_EVICTION_PLAN_TO_FREE_SPACE, availableBytes, location.tierAlias());\n-      }\n-    }\n-\n-    // 1. remove blocks to make room.\n-    for (Pair<Long, BlockStoreLocation> blockInfo : plan.toEvict()) {\n-      try {\n-        removeBlockInternal(Sessions.createInternalSessionId(),\n-            blockInfo.getFirst(), blockInfo.getSecond());\n-      } catch (InvalidWorkerStateException e) {\n-        // Evictor is not working properly\n-        LOG.error(\"Failed to evict blockId {}, this is temp block\", blockInfo.getFirst());\n-        continue;\n-      } catch (BlockDoesNotExistException e) {\n-        LOG.info(\"Failed to evict blockId {}, it could be already deleted\", blockInfo.getFirst());\n-        continue;\n-      }\n-      synchronized (mBlockStoreEventListeners) {\n-        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-          listener.onRemoveBlockByWorker(sessionId, blockInfo.getFirst());\n-        }\n-      }\n-    }\n-    // 2. transfer blocks among tiers.\n-    // 2.1. group blocks move plan by the destination tier.\n-    Map<String, Set<BlockTransferInfo>> blocksGroupedByDestTier = new HashMap<>();\n-    for (BlockTransferInfo entry : plan.toMove()) {\n-      String alias = entry.getDstLocation().tierAlias();\n-      if (!blocksGroupedByDestTier.containsKey(alias)) {\n-        blocksGroupedByDestTier.put(alias, new HashSet());\n-      }\n-      blocksGroupedByDestTier.get(alias).add(entry);\n-    }\n-    // 2.2. move blocks in the order of their dst tiers, from bottom to top\n-    for (int tierOrdinal = mStorageTierAssoc.size() - 1; tierOrdinal >= 0; --tierOrdinal) {\n-      Set<BlockTransferInfo> toMove =\n-          blocksGroupedByDestTier.get(mStorageTierAssoc.getAlias(tierOrdinal));\n-      if (toMove == null) {\n-        toMove = new HashSet<>();\n-      }\n-      for (BlockTransferInfo entry : toMove) {\n-        long blockId = entry.getBlockId();\n-        BlockStoreLocation oldLocation = entry.getSrcLocation();\n-        BlockStoreLocation newLocation = entry.getDstLocation();\n-        MoveBlockResult moveResult;\n+  private void freeSpaceInternal(long sessionId, long minAvailableBytes, long maxAvailableBytes,\n+      BlockStoreLocation location) throws WorkerOutOfSpaceException, IOException {\n+    // TODO(ggezer): TV2 - Too much memory pressure when pinned-inodes list is large.\n+    BlockMetadataEvictorView evictorView = getUpdatedView();\n+    long minBytesToFree = minAvailableBytes - evictorView.getAvailableBytes(location);\n+    long maxBytesToFree = maxAvailableBytes - evictorView.getAvailableBytes(location);\n+\n+    int blocksIterated = 0;\n+    int blocksRemoved = 0;\n+    int spaceFreed = 0;\n+\n+    LOG.debug(\n+        \"Failed to free space. Space requested: {}-{}, Blocks iterated: {}, Blocks removed: {},\"\n+            + \" Freed Space: {}, Remaining: {}\",\n+        minAvailableBytes, maxAvailableBytes, blocksIterated, blocksRemoved, spaceFreed,\n+        maxBytesToFree);\n+\n+    Iterator<Long> evictionCandidates =\n+        mBlockIterator.getIterator(location, BlockOrder.Natural);\n+    while (evictionCandidates.hasNext() && maxBytesToFree > 0) {\n+      long blockToDelete = evictionCandidates.next();\n+      blocksIterated++;\n+      if (evictorView.isBlockEvictable(blockToDelete)) {\n         try {\n-          moveResult = moveBlockInternal(Sessions.createInternalSessionId(),\n-              blockId, oldLocation, newLocation);\n-        } catch (InvalidWorkerStateException e) {\n-          // Evictor is not working properly\n-          LOG.error(\"Failed to demote blockId {}, this is temp block\", blockId);\n-          continue;\n-        } catch (BlockAlreadyExistsException e) {\n-          continue;\n-        } catch (BlockDoesNotExistException e) {\n-          LOG.info(\"Failed to demote blockId {}, it could be already deleted\", blockId);\n-          continue;\n-        }\n-        if (moveResult.getSuccess()) {\n+          BlockMeta blockMeta = mMetaManager.getBlockMeta(blockToDelete);\n+          removeBlockInternal(blockMeta);\n+          blocksRemoved++;\n           synchronized (mBlockStoreEventListeners) {\n             for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-              listener.onMoveBlockByWorker(sessionId, blockId, moveResult.getSrcLocation(),\n-                  newLocation);\n+              listener.onRemoveBlockByClient(sessionId, blockMeta.getBlockId());\n+              listener.onRemoveBlock(sessionId, blockMeta.getBlockId(),\n+                  blockMeta.getBlockLocation());\n             }\n           }\n+          minBytesToFree -= blockMeta.getBlockSize();\n+          maxBytesToFree -= blockMeta.getBlockSize();\n+          spaceFreed += blockMeta.getBlockSize();\n+        } catch (BlockDoesNotExistException e) {\n+          LOG.info(\"Failed to evict blockId {}, it could be already deleted\", blockToDelete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 830}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODI0NQ==", "bodyText": "Do we need to make sure it is not too small either?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r397508245", "createdAt": "2020-03-24T22:49:02Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/meta/StorageDir.java", "diffHunk": "@@ -57,16 +57,23 @@\n   private Map<Long, Set<Long>> mSessionIdToTempBlockIdsMap;\n   private AtomicLong mAvailableBytes;\n   private AtomicLong mCommittedBytes;\n+  private AtomicLong mReservedBytes;\n+  private AtomicLong mUsedReservedBytes;\n   private String mDirPath;\n   private int mDirIndex;\n   private StorageTier mTier;\n \n-  private StorageDir(StorageTier tier, int dirIndex, long capacityBytes, String dirPath,\n-      String dirMedium) {\n+  private StorageDir(StorageTier tier, int dirIndex, long capacityBytes, long reservedBytes,\n+      String dirPath, String dirMedium) {\n     mTier = Preconditions.checkNotNull(tier, \"tier\");\n     mDirIndex = dirIndex;\n     mCapacityBytes = capacityBytes;\n-    mAvailableBytes = new AtomicLong(capacityBytes);\n+    if (capacityBytes < reservedBytes) {\n+      reservedBytes = capacityBytes / 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d105dd4df5f86ef80159c38d1d6634b1c77d2b0e", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/d105dd4df5f86ef80159c38d1d6634b1c77d2b0e", "committedDate": "2020-03-30T20:00:04Z", "message": "Implement swap-restore task"}, "afterCommit": {"oid": "f54f87bf9bc80ddabaa025e69abe9218e98cb23d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/f54f87bf9bc80ddabaa025e69abe9218e98cb23d", "committedDate": "2020-03-30T23:24:41Z", "message": "Implement swap-restore task"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDkxODg3", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-390091887", "createdAt": "2020-04-08T15:35:49Z", "commit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTozNTo1MFrOGC09iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo0NzozOFrOGC6Mrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxODA1OQ==", "bodyText": "It is pretty confusing. I think we will need to add more details to this parameter (possibly explicitly contrasting it with the other one), or getting rid of one of them.", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405618059", "createdAt": "2020-04-08T15:35:50Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2284,21 +2287,126 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_CLASS =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_CLASS)\n+          .setDefaultValue(\"alluxio.worker.block.annotator.LRUAnnotator\")\n+          .setDescription(\"The strategy that a worker uses to annotate blocks \"\n+              + \"in order to have an ordered view of them during internal\"\n+              + \"management tasks such as eviction and promotion/demotion. \"\n+              + \" Valid options include: \"\n+              + \"`alluxio.worker.block.annotator.LRFUAnnotator`, \"\n+              + \"`alluxio.worker.block.annotator.LRUAnnotator`, \")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_ATTENUATION_FACTOR)\n           .setDefaultValue(2.0)\n-          .setDescription(\"A attenuation factor in [2, INF) to control the behavior of LRFU.\")\n+          .setDescription(\n+              \"A attenuation factor in [2, INF) to control the behavior of LRFU annotator.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n-  public static final PropertyKey WORKER_EVICTOR_LRFU_STEP_FACTOR =\n-      new Builder(Name.WORKER_EVICTOR_LRFU_STEP_FACTOR)\n+  public static final PropertyKey WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR =\n+      new Builder(Name.WORKER_BLOCK_ANNOTATOR_LRFU_STEP_FACTOR)\n           .setDefaultValue(0.25)\n           .setDescription(\"A factor in [0, 1] to control the behavior of LRFU: smaller value \"\n               + \"makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.WORKER)\n           .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED =\n+      new Builder(Name.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to postpone all management tasks under any user activity\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management tasks will not run for this long after load detected.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_RESERVED_SPACE_BYTES =\n+      new Builder(Name.WORKER_MANAGEMENT_RESERVED_SPACE_BYTES)\n+          .setDefaultValue(\"1GB\")\n+          .setDescription(\"The amount of space that is reserved from each storage directory \"\n+              + \"for internal management tasks.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.WORKER)\n+          .build();\n+  public static final PropertyKey WORKER_MANAGEMENT_IDLE_SLEEP_TIME =\n+      new Builder(Name.WORKER_MANAGEMENT_IDLE_SLEEP_TIME)\n+          .setDefaultValue(\"10sec\")\n+          .setDescription(\"Management task coordinator will back-off for specified duration when\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MDM5Ng=="}, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NTQwNQ==", "bodyText": "This is a singleton for the worker server? Should this then be in core/server/...?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405655405", "createdAt": "2020-04-08T16:29:35Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/worker/block/io/BlockStreamTracker.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.io;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.worker.block.BlockStoreLocation;\n+\n+import java.util.Set;\n+\n+/**\n+ * Used to emit block reader/writer open/close events.\n+ */\n+public class BlockStreamTracker {\n+  /** List of listeners for this tracker. */\n+  private static Set<BlockStreamListener> sListeners = new ConcurrentHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3MzU0NA=="}, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1Njg3OQ==", "bodyText": "Ok, then should we mention \"evictor\" or something in the line? The message doesn't seem specific enough to me.", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405656879", "createdAt": "2020-04-08T16:31:50Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockMetadataEvictorView.java", "diffHunk": "@@ -111,7 +113,11 @@ public boolean isBlockLocked(long blockId) {\n    * @return boolean, true if the block can be evicted\n    */\n   public boolean isBlockEvictable(long blockId) {\n-    return (!isBlockPinned(blockId) && !isBlockLocked(blockId) && !isBlockMarked(blockId));\n+    boolean pinned = isBlockPinned(blockId);\n+    boolean locked = isBlockLocked(blockId);\n+    boolean marked = isBlockMarked(blockId);\n+    LOG.debug(\"Block: {}. Pinned: {}, Locked: {}, Marked: {}\", blockId, pinned, locked, marked);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ3NjA0NQ=="}, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODcyNg==", "bodyText": "Was this method supposed to be removed? If not, can you remove javadocs for the exceptions, or fill them out?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405658726", "createdAt": "2020-04-08T16:34:36Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockMetadataManager.java", "diffHunk": "@@ -129,6 +159,30 @@ public void commitTempBlockMeta(TempBlockMeta tempBlockMeta)\n     dir.addBlockMeta(block);\n   }\n \n+  /**\n+   * Swaps location of two blocks in metadata.\n+   *\n+   * @param blockMeta1 the first block meta\n+   * @param blockMeta2 the second block meta\n+   * @throws BlockDoesNotExistException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4NDQ1NQ=="}, "originalCommit": {"oid": "4d8faa66ff7f9bf1b033d21c79891e7c4cd05f24"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MjIwOQ==", "bodyText": "could you add a comment mentioning why this method has to be synchronized.", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405662209", "createdAt": "2020-04-08T16:40:08Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -348,37 +375,61 @@ public void removeBlock(long sessionId, long blockId)\n   public void removeBlock(long sessionId, long blockId, BlockStoreLocation location)\n       throws InvalidWorkerStateException, BlockDoesNotExistException, IOException {\n     LOG.debug(\"removeBlock: sessionId={}, blockId={}, location={}\", sessionId, blockId, location);\n-    removeBlockInternal(sessionId, blockId, location);\n+    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n+\n+    BlockMeta blockMeta;\n+    try (LockResource r = new LockResource(mMetadataReadLock)) {\n+      if (mMetaManager.hasTempBlockMeta(blockId)) {\n+        throw new InvalidWorkerStateException(ExceptionMessage.REMOVE_UNCOMMITTED_BLOCK, blockId);\n+      }\n+\n+      blockMeta = mMetaManager.getBlockMeta(blockId);\n+\n+      if (!blockMeta.getBlockLocation().belongsTo(location)) {\n+        throw new BlockDoesNotExistException(ExceptionMessage.BLOCK_NOT_FOUND_AT_LOCATION, blockId,\n+            location);\n+      }\n+    } catch (Exception e) {\n+      mLockManager.unlockBlock(lockId);\n+      throw e;\n+    }\n+\n+    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      removeBlockInternal(blockMeta);\n+    } finally {\n+      mLockManager.unlockBlock(lockId);\n+    }\n+\n     synchronized (mBlockStoreEventListeners) {\n       for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n         listener.onRemoveBlockByClient(sessionId, blockId);\n+        listener.onRemoveBlock(sessionId, blockId, blockMeta.getBlockLocation());\n       }\n     }\n   }\n \n   @Override\n   public void accessBlock(long sessionId, long blockId) throws BlockDoesNotExistException {\n     LOG.debug(\"accessBlock: sessionId={}, blockId={}\", sessionId, blockId);\n-    boolean hasBlock;\n     try (LockResource r = new LockResource(mMetadataReadLock)) {\n-      hasBlock = mMetaManager.hasBlockMeta(blockId);\n-    }\n-    if (!hasBlock) {\n-      throw new BlockDoesNotExistException(ExceptionMessage.NO_BLOCK_ID_FOUND, blockId);\n-    }\n-    synchronized (mBlockStoreEventListeners) {\n-      for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-        listener.onAccessBlock(sessionId, blockId);\n+      BlockMeta blockMeta = mMetaManager.getBlockMeta(blockId);\n+\n+      synchronized (mBlockStoreEventListeners) {\n+        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n+          listener.onAccessBlock(sessionId, blockId);\n+          listener.onAccessBlock(sessionId, blockId, blockMeta.getBlockLocation());\n+        }\n       }\n     }\n   }\n \n   @Override\n-  public void freeSpace(long sessionId, long availableBytes, BlockStoreLocation location)\n+  public synchronized void freeSpace(long sessionId, long minContigiousBytes,\n+      long minAvailableBytes, BlockStoreLocation location)\n       throws BlockDoesNotExistException, WorkerOutOfSpaceException, IOException {\n-    LOG.debug(\"freeSpace: sessionId={}, availableBytes={}, location={}\",\n-        sessionId, availableBytes, location);\n-    freeSpaceInternal(sessionId, availableBytes, location, Mode.BEST_EFFORT);\n+    LOG.debug(\"freeSpace: sessionId={}, minContigiousBytes={}, minAvailableBytes={}, location={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2NDQ2Nw==", "bodyText": "does this need mUseReservedSpace? Also affects equals() and toString().", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405664467", "createdAt": "2020-04-08T16:43:42Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/AllocateOptions.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Used to specify various options while allocating space.\n+ */\n+public class AllocateOptions {\n+  /** Size of allocation. */\n+  private long mSize;\n+  /** Location requested for allocation. */\n+  private BlockStoreLocation mLocation;\n+  /** Whether the given location is to be enforced. */\n+  private boolean mForceLocation;\n+  /** Whether eviction is allowed to satisfy this allocation. */\n+  private boolean mEvictionAllowed;\n+  /** Whether to use the reserved space for allocation. */\n+  private boolean mUseReservedSpace;\n+\n+  /**\n+   * Creates new allocation options object.\n+   *\n+   * @param location the allocation location\n+   * @param size the allocation size\n+   */\n+  private AllocateOptions(BlockStoreLocation location, long size) {\n+    this(location);\n+    mSize = size;\n+  }\n+\n+  /**\n+   * Creates new allocation options object.\n+   *\n+   * @param location the allocation location\n+   */\n+  private AllocateOptions(BlockStoreLocation location) {\n+    mLocation = location;\n+    mUseReservedSpace = false;\n+  }\n+\n+  /**\n+   * Creates default allocation options for block create request.\n+   *  - Locations is not strict\n+   *  - Evicting on destination is allowed\n+   *\n+   * @param sizeBytes size of allocation\n+   * @param location location of allocation\n+   * @return the allocation object initialized with defaults for create\n+   */\n+  public static AllocateOptions forCreate(long sizeBytes, BlockStoreLocation location) {\n+    return new AllocateOptions(location, sizeBytes)\n+        .setForceLocation(false)\n+        .setEvictionAllowed(true);\n+  }\n+\n+  /**\n+   * Creates default allocation options for requesting more space for a block.\n+   *  - Locations is strict\n+   *  - Evicting on destination is allowed\n+   *\n+   * @param sizeBytes size of allocation\n+   * @param location location of allocation\n+   * @return the allocation object initialized with defaults for requesting space\n+   */\n+  public static AllocateOptions forRequestSpace(long sizeBytes, BlockStoreLocation location) {\n+    return new AllocateOptions(location, sizeBytes)\n+        .setForceLocation(true)\n+        .setEvictionAllowed(true);\n+  }\n+\n+  /**\n+   * Creates default allocation options for moving a block during tier-move task.\n+   *  - Locations is strict\n+   *  - Evicting on destination is disallowed\n+   *\n+   * @param location location of allocation\n+   * @return the allocation object initialized with defaults for moving\n+   */\n+  public static AllocateOptions forTierMove(BlockStoreLocation location) {\n+    return new AllocateOptions(location)\n+        .setForceLocation(true)\n+        .setEvictionAllowed(false);\n+  }\n+\n+  /**\n+   * Creates default allocation options for moving a block by a client request.\n+   *  - Locations is strict\n+   *  - Evicting on destination is allowed\n+   *\n+   * @param location location of allocation\n+   * @return the allocation object initialized with defaults for moving\n+   */\n+  public static AllocateOptions forMove(BlockStoreLocation location) {\n+    return new AllocateOptions(location)\n+        .setForceLocation(true)\n+        .setEvictionAllowed(true);\n+  }\n+\n+  /**\n+   * Sets the allocation location.\n+   *\n+   * @param location the allocation location\n+   * @return the updated options\n+   */\n+  public AllocateOptions setLocation(BlockStoreLocation location) {\n+    mLocation = location;\n+    return this;\n+  }\n+\n+  /**\n+   * Sets the allocation size.\n+   *\n+   * @param size the allocation size in bytes\n+   * @return the updated options\n+   */\n+  public AllocateOptions setSize(long size) {\n+    mSize = size;\n+    return this;\n+  }\n+\n+  /**\n+   * Sets value for whether to enforce location of allocation.\n+   *\n+   * @param forceLocation force location\n+   * @return the updated options\n+   */\n+  public AllocateOptions setForceLocation(boolean forceLocation) {\n+    mForceLocation = forceLocation;\n+    return this;\n+  }\n+\n+  /**\n+   * Sets value for whether eviction is allowed for allocation.\n+   *\n+   * @param evictionAllowed eviction allowed\n+   * @return the updated options\n+   */\n+  public AllocateOptions setEvictionAllowed(boolean evictionAllowed) {\n+    mEvictionAllowed = evictionAllowed;\n+    return this;\n+  }\n+\n+  /**\n+   * Sets value for whether this allocation can use reserved space.\n+   *\n+   * @param useReservedSpace use reserved space\n+   * @return the updated options\n+   */\n+  public AllocateOptions setUseReservedSpace(boolean useReservedSpace) {\n+    mUseReservedSpace = useReservedSpace;\n+    return this;\n+  }\n+\n+  /**\n+   * @return the location of allocation\n+   */\n+  public BlockStoreLocation getLocation() {\n+    return mLocation;\n+  }\n+\n+  /**\n+   * @return the size of allocation\n+   */\n+  public long getSize() {\n+    return mSize;\n+  }\n+\n+  /**\n+   * @return whether location is to be enforced\n+   */\n+  public boolean isForceLocation() {\n+    return mForceLocation;\n+  }\n+\n+  /**\n+   * @return whether eviction is allowed for allocation\n+   */\n+  public boolean isEvictionAllowed() {\n+    return mEvictionAllowed;\n+  }\n+\n+  /**\n+   * @return whether this allocation can use reserved space\n+   */\n+  public boolean canUseReservedSpace() {\n+    return mUseReservedSpace;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == null || !(o instanceof AllocateOptions)) {\n+      return false;\n+    }\n+    AllocateOptions other = (AllocateOptions) o;\n+    return mSize == other.mSize\n+        && mLocation.equals(other.mLocation)\n+        && mForceLocation == other.mForceLocation\n+        && mEvictionAllowed == other.mEvictionAllowed;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(mSize, mLocation, mForceLocation, mEvictionAllowed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2NjkxMQ==", "bodyText": "\"available' and \"committed\" all fit within \"capacity\". Is this also true for \"reserved\"? Can we a comment (maybe a class comment) describing the relationship between all of these types of bytes?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405666911", "createdAt": "2020-04-08T16:47:23Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/meta/StorageDir.java", "diffHunk": "@@ -57,16 +57,22 @@\n   private Map<Long, Set<Long>> mSessionIdToTempBlockIdsMap;\n   private AtomicLong mAvailableBytes;\n   private AtomicLong mCommittedBytes;\n+  private AtomicLong mReservedBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMDY5Nw==", "bodyText": "should we have srcBlockId and dstBlockId?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405700697", "createdAt": "2020-04-08T17:41:58Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/evictor/BlockTransferInfo.java", "diffHunk": "@@ -64,7 +102,7 @@ public BlockStoreLocation getDstLocation() {\n   @Override\n   public String toString() {\n     return MoreObjects.toStringHelper(this)\n-        .add(\"blockId\", mBlockId)\n+        .add(\"blockId\", mSrcBlockId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMzg1NA==", "bodyText": "should we also mention \"sleeping X ms\"?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r405703854", "createdAt": "2020-04-08T17:47:38Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/ManagementTaskCoordinator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.ThreadFactoryUtils;\n+import alluxio.worker.block.BlockMetadataEvictorView;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStore;\n+import alluxio.worker.block.BlockStoreLocation;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Coordinator for instantiating and running various block management tasks.\n+ */\n+public class ManagementTaskCoordinator implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(ManagementTaskCoordinator.class);\n+\n+  /** Duration to sleep when there is no pending task. */\n+  private final long mIdleSleepMs;\n+  /** Duration to sleep when load detected on worker. */\n+  private final long mLoadDetectionCoolDownMs;\n+  /** Whether to stop all tasks when any user activity is detected. */\n+  private final boolean mGlobalLoadDetectionEnabled;\n+\n+  /** Runner thread for launching management tasks. */\n+  private final Thread mRunnerThread;\n+  /** Executor that will running the management tasks. */\n+  private final ExecutorService mTaskExecutor;\n+\n+  private final BlockStore mBlockStore;\n+  private final BlockMetadataManager mMetadataManager;\n+  private final StoreLoadTracker mLoadTracker;\n+\n+  /** This coordinator requires to calculate eviction view per each task. */\n+  private final Supplier<BlockMetadataEvictorView> mEvictionViewSupplier;\n+\n+  /** List of management task providers. */\n+  private List<ManagementTaskProvider> mTaskProviders;\n+\n+  /** Whether the coordinator is shut down. */\n+  private volatile boolean mShutdown = false;\n+\n+  /**\n+   * Creates management coordinator.\n+   *\n+   * @param blockStore block store\n+   * @param metadataManager meta manager\n+   * @param loadTracker load tracker\n+   * @param evictionViewSupplier eviction view supplier\n+   */\n+  public ManagementTaskCoordinator(BlockStore blockStore, BlockMetadataManager metadataManager,\n+      StoreLoadTracker loadTracker, Supplier<BlockMetadataEvictorView> evictionViewSupplier) {\n+    mBlockStore = blockStore;\n+    mMetadataManager = metadataManager;\n+    mLoadTracker = loadTracker;\n+    mEvictionViewSupplier = evictionViewSupplier;\n+\n+    // Read configs.\n+    mLoadDetectionCoolDownMs =\n+        ServerConfiguration.getMs(PropertyKey.WORKER_MANAGEMENT_LOAD_DETECTION_COOL_DOWN_TIME);\n+    mIdleSleepMs = ServerConfiguration.getMs(PropertyKey.WORKER_MANAGEMENT_IDLE_SLEEP_TIME);\n+    mGlobalLoadDetectionEnabled =\n+        ServerConfiguration.getBoolean(PropertyKey.WORKER_MANAGEMENT_GLOBAL_LOAD_DETECTION_ENABLED);\n+\n+    mTaskExecutor = Executors.newFixedThreadPool(\n+        ServerConfiguration.getInt(PropertyKey.WORKER_MANAGEMENT_TASK_THREAD_COUNT),\n+        ThreadFactoryUtils.build(\"block-management-task-%d\", true));\n+\n+    initializeTaskProviders();\n+\n+    // Initialize runner thread.\n+    mRunnerThread = new Thread(this::runManagement, \"block-management-runner\");\n+    mRunnerThread.setDaemon(true);\n+  }\n+\n+  /**\n+   * Starts the coordinator.\n+   */\n+  public void start() {\n+    // Start runner thread.\n+    mRunnerThread.start();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      // Shutdown task executor.\n+      mTaskExecutor.shutdownNow();\n+      // Interrupt and wait for runner thread.\n+      mShutdown = true;\n+      mRunnerThread.interrupt();\n+      mRunnerThread.join();\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to close management task coordinator\", e);\n+    }\n+  }\n+\n+  /**\n+   * Register known task providers by priority order.\n+   *\n+   * TODO(ggezer): TV2 - Re-implement async-cache as {@link BlockManagementTask}.\n+   */\n+  private void initializeTaskProviders() {\n+    mTaskProviders = new ArrayList<>(1);\n+    if (ServerConfiguration.isSet(PropertyKey.WORKER_EVICTOR_CLASS)) {\n+      LOG.warn(\"Tier management tasks will be disabled under eviction emulation mode.\");\n+    } else {\n+      mTaskProviders.add(new TierManagementTaskProvider(mBlockStore, mMetadataManager,\n+          mEvictionViewSupplier, mLoadTracker, mTaskExecutor));\n+    }\n+  }\n+\n+  /**\n+   * @return the next management task to run, {@code null} if none pending\n+   */\n+  private BlockManagementTask getNextTask() {\n+    /**\n+     * Order of providers in the registered list imposes an implicit priority of tasks.\n+     * As long as a provider gives a task, providers next to it won't be consulted.\n+     */\n+    for (ManagementTaskProvider taskProvider : mTaskProviders) {\n+      BlockManagementTask task = taskProvider.getTask();\n+      if (task != null) {\n+        return task;\n+      }\n+    }\n+    // No task provided.\n+    return null;\n+  }\n+\n+  /**\n+   * Main management loop.\n+   */\n+  private void runManagement() {\n+    while (true) {\n+      if (Thread.interrupted()) {\n+        // Coordinator closed.\n+        LOG.debug(\"Coordinator interrupted.\");\n+        break;\n+      }\n+\n+      BlockManagementTask currentTask;\n+      try {\n+        // Back off if any load detected.\n+        if (mGlobalLoadDetectionEnabled\n+            && mLoadTracker.loadDetected(BlockStoreLocation.anyTier())) {\n+          LOG.debug(\"Load detected under global load detection mode.\");\n+          Thread.sleep(mLoadDetectionCoolDownMs);\n+          continue;\n+        }\n+\n+        final BlockManagementTask nextTask = getNextTask();\n+        if (nextTask == null) {\n+          LOG.debug(\"No management task pending.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470"}, "originalPosition": 175}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fa456d7828fdbf99fd5dade492f13cc83c9a470", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2fa456d7828fdbf99fd5dade492f13cc83c9a470", "committedDate": "2020-04-06T03:34:34Z", "message": "Add logging for tier management"}, "afterCommit": {"oid": "a9c7d57733afd22d8ab6a69e8f4b5b7a6c8b7a1b", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/a9c7d57733afd22d8ab6a69e8f4b5b7a6c8b7a1b", "committedDate": "2020-04-10T05:55:51Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94d617013ce4dd7b8bc3d8cda2d46752a7e42564", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/94d617013ce4dd7b8bc3d8cda2d46752a7e42564", "committedDate": "2020-04-21T23:49:27Z", "message": "Replace async eviction with on-demand eviction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "082e86b6207b5293895de44a30e1520aa2fd3b7d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/082e86b6207b5293895de44a30e1520aa2fd3b7d", "committedDate": "2020-04-21T23:49:27Z", "message": "Implement async block promotion/demotion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "886023fff5b1b2ae0c2f727e4bd86599df21c108", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/886023fff5b1b2ae0c2f727e4bd86599df21c108", "committedDate": "2020-04-21T23:49:27Z", "message": "Fix existing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f292afb2fc9c316bf9fe8ed5bd2a1e4bfdd0e68d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/f292afb2fc9c316bf9fe8ed5bd2a1e4bfdd0e68d", "committedDate": "2020-04-21T23:49:27Z", "message": "Manage coordinator thread shutdown + minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e820c16c01aba9a45a4beef8a923bab86ef75acd", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/e820c16c01aba9a45a4beef8a923bab86ef75acd", "committedDate": "2020-04-21T23:49:27Z", "message": "Deduplicate load tracker code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2fc26069f5d995ea59410530b2517de5746d6a5", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/d2fc26069f5d995ea59410530b2517de5746d6a5", "committedDate": "2020-04-21T23:49:27Z", "message": "Concurrent tier management + Intelligent back-off"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83d5181c530eac79bc339419cbd76557f7b930d0", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/83d5181c530eac79bc339419cbd76557f7b930d0", "committedDate": "2020-04-21T23:49:27Z", "message": "Implicit reserved space management + Remove swap API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aba18169ed728d67bd1b19f0e998e37d33fdce2", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/3aba18169ed728d67bd1b19f0e998e37d33fdce2", "committedDate": "2020-04-21T23:49:27Z", "message": "Remove dead code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "402950c18d48bfd54fdafa8f43df2eae717c41c7", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/402950c18d48bfd54fdafa8f43df2eae717c41c7", "committedDate": "2020-04-21T23:49:27Z", "message": "Implement block-transfer-executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad1e91d1de272ab906f3587c34942f88e845ce9d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/ad1e91d1de272ab906f3587c34942f88e845ce9d", "committedDate": "2020-04-21T23:49:27Z", "message": "Implement swap-restore task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8aa26f150ae91a603ad5b62d6e2f739c5605d1d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/f8aa26f150ae91a603ad5b62d6e2f739c5605d1d", "committedDate": "2020-04-21T23:49:28Z", "message": "Addressed PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68ebd228342b4a85e4faacf4bda4baca6c3c286d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/68ebd228342b4a85e4faacf4bda4baca6c3c286d", "committedDate": "2020-04-21T23:49:28Z", "message": "Reimplement freeSpace() to free contigious space"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e9af0ddd258c50e351692816355e550935dd6ca", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/0e9af0ddd258c50e351692816355e550935dd6ca", "committedDate": "2020-04-21T23:49:28Z", "message": "Fix BlockIterator#aligned API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58012ae8e598fcd368efbe1fd1af3745cf61d7ef", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/58012ae8e598fcd368efbe1fd1af3745cf61d7ef", "committedDate": "2020-04-21T23:49:28Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2d6130d83acc09f7a4392c5d20828a9905536257", "committedDate": "2020-04-21T23:49:28Z", "message": "TODO cleanup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9c7d57733afd22d8ab6a69e8f4b5b7a6c8b7a1b", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/a9c7d57733afd22d8ab6a69e8f4b5b7a6c8b7a1b", "committedDate": "2020-04-10T05:55:51Z", "message": "PR feedback"}, "afterCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2d6130d83acc09f7a4392c5d20828a9905536257", "committedDate": "2020-04-21T23:49:28Z", "message": "TODO cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjM2OTg3", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-398636987", "createdAt": "2020-04-22T22:33:45Z", "commit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjozMzo0NVrOGKOmWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo0NzowNFrOGK7cOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3ODEzOA==", "bodyText": "this::getUpdatedView\nIs this mostly for backward compatibility, in the new model do we still need to have evictor views?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r413378138", "createdAt": "2020-04-22T22:33:45Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -126,21 +116,23 @@ public TieredBlockStore() {\n     mMetaManager = BlockMetadataManager.createBlockMetadataManager();\n     mLockManager = new BlockLockManager();\n \n+    mBlockIterator = mMetaManager.getBlockIterator();\n+    // Register listeners required by the block iterator.\n+    for (BlockStoreEventListener listener : mBlockIterator.getListeners()) {\n+      registerBlockStoreEventListener(listener);\n+    }\n+\n     BlockMetadataEvictorView initManagerView = new BlockMetadataEvictorView(mMetaManager,\n         Collections.<Long>emptySet(), Collections.<Long>emptySet());\n     mAllocator = Allocator.Factory.create(initManagerView);\n     if (mAllocator instanceof BlockStoreEventListener) {\n       registerBlockStoreEventListener((BlockStoreEventListener) mAllocator);\n     }\n \n-    initManagerView = new BlockMetadataEvictorView(mMetaManager, Collections.<Long>emptySet(),\n-        Collections.<Long>emptySet());\n-    mEvictor = Evictor.Factory.create(initManagerView, mAllocator);\n-    if (mEvictor instanceof BlockStoreEventListener) {\n-      registerBlockStoreEventListener((BlockStoreEventListener) mEvictor);\n-    }\n-\n-    mStorageTierAssoc = new WorkerStorageTierAssoc();\n+    // Initialize and start coordinator.\n+    mTaskCoordinator = new ManagementTaskCoordinator(this, mMetaManager,\n+        new DefaultStoreLoadTracker(), () -> getUpdatedView());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNzgzOA==", "bodyText": "contiguousSpaceFound", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414107838", "createdAt": "2020-04-23T20:38:57Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -570,162 +689,129 @@ private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boo\n    *\n    * @param sessionId session id\n    * @param blockId block id\n-   * @param location location to create the block\n-   * @param initialBlockSize initial block size in bytes\n    * @param newBlock true if this temp block is created for a new block\n+   * @param options block allocation options\n    * @return a temp block created if successful, or null if allocation failed (instead of throwing\n    *         {@link WorkerOutOfSpaceException} because allocation failure could be an expected case)\n    * @throws BlockAlreadyExistsException if there is already a block with the same block id\n    */\n-  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId,\n-      BlockStoreLocation location, long initialBlockSize, boolean newBlock)\n-          throws BlockAlreadyExistsException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n+  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId, boolean newBlock,\n+      AllocateOptions options) throws BlockAlreadyExistsException {\n     try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      // NOTE: a temp block is supposed to be visible for its own writer,\n+      // unnecessary to acquire block lock here since no sharing.\n       if (newBlock) {\n         checkTempBlockIdAvailable(blockId);\n       }\n-      StorageDirView dirView = mAllocator.allocateBlockWithView(sessionId,\n-          initialBlockSize, location, new BlockMetadataAllocatorView(mMetaManager));\n+\n+      // Allocate space.\n+      StorageDirView dirView = allocateSpace(sessionId, options);\n+\n       if (dirView == null) {\n-        // Allocator fails to find a proper place for this new block.\n         return null;\n       }\n+\n       // TODO(carson): Add tempBlock to corresponding storageDir and remove the use of\n       // StorageDirView.createTempBlockMeta.\n-      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, initialBlockSize);\n+      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, options.getSize());\n       try {\n         // Add allocated temp block to metadata manager. This should never fail if allocator\n         // correctly assigns a StorageDir.\n         mMetaManager.addTempBlockMeta(tempBlock);\n       } catch (WorkerOutOfSpaceException | BlockAlreadyExistsException e) {\n         // If we reach here, allocator is not working properly\n         LOG.error(\"Unexpected failure: {} bytes allocated at {} by allocator, \"\n-            + \"but addTempBlockMeta failed\", initialBlockSize, location);\n+            + \"but addTempBlockMeta failed\", options.getSize(), options.getLocation());\n         throw Throwables.propagate(e);\n       }\n       return tempBlock;\n     }\n   }\n \n   /**\n-   * Increases the temp block size only if this temp block's parent dir has enough available space.\n-   *\n-   * @param blockId block id\n-   * @param additionalBytes additional bytes to request for this block\n-   * @return a pair of boolean and {@link BlockStoreLocation}. The boolean indicates if the\n-   *         operation succeeds and the {@link BlockStoreLocation} denotes where to free more space\n-   *         if it fails.\n-   * @throws BlockDoesNotExistException if this block is not found\n-   */\n-  private Pair<Boolean, BlockStoreLocation> requestSpaceInternal(long blockId, long additionalBytes)\n-      throws BlockDoesNotExistException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-      if (tempBlockMeta.getParentDir().getAvailableBytes() < additionalBytes) {\n-        return new Pair<>(false, tempBlockMeta.getBlockLocation());\n-      }\n-      // Increase the size of this temp block\n-      try {\n-        mMetaManager.resizeTempBlockMeta(tempBlockMeta,\n-            tempBlockMeta.getBlockSize() + additionalBytes);\n-      } catch (InvalidWorkerStateException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n-      return new Pair<>(true, null);\n-    }\n-  }\n-\n-  /**\n-   * Tries to get an eviction plan to free a certain amount of space in the given location, and\n-   * carries out this plan with the best effort.\n+   * Tries to free a certain amount of space in the given location.\n    *\n    * @param sessionId the session id\n-   * @param availableBytes amount of space in bytes to free\n+   * @param minContigiousBytes the minimum amount of contigious space in bytes to set available\n+   * @param minAvailableBytes the minimum amount of space in bytes to set available\n    * @param location location of space\n-   * @param mode the eviction mode\n-   * @throws WorkerOutOfSpaceException if it is impossible to achieve the free requirement\n+   * @throws WorkerOutOfSpaceException if it is impossible to achieve minimum space requirement\n    */\n-  private void freeSpaceInternal(long sessionId, long availableBytes, BlockStoreLocation location,\n-      Evictor.Mode mode) throws WorkerOutOfSpaceException, IOException {\n-    EvictionPlan plan;\n-    // NOTE:change the read lock to the write lock due to the endless-loop issue [ALLUXIO-3089]\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      plan = mEvictor.freeSpaceWithView(availableBytes, location, getUpdatedView(), mode);\n-      // Absent plan means failed to evict enough space.\n-      if (plan == null) {\n-        throw new WorkerOutOfSpaceException(\n-            ExceptionMessage.NO_EVICTION_PLAN_TO_FREE_SPACE, availableBytes, location.tierAlias());\n+  private void freeSpaceInternal(long sessionId, long minContigiousBytes, long minAvailableBytes,\n+      BlockStoreLocation location) throws WorkerOutOfSpaceException, IOException {\n+    // TODO(ggezer): Too much memory pressure when pinned-inodes list is large.\n+    BlockMetadataEvictorView evictorView = getUpdatedView();\n+    LOG.debug(\n+        \"freeSpaceInternal - locAvailableBytes: {}, minContigiousBytes: {}, minAvailableBytes: {}\",\n+        evictorView.getAvailableBytes(location), minContigiousBytes, minAvailableBytes);\n+    boolean contigiousSpaceFound = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 637}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwODAwOA==", "bodyText": "Do we care about availableBytesFound? It seems like the only satisfactory condition is contigiousSpaceFound", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414108008", "createdAt": "2020-04-23T20:39:12Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -570,162 +689,129 @@ private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boo\n    *\n    * @param sessionId session id\n    * @param blockId block id\n-   * @param location location to create the block\n-   * @param initialBlockSize initial block size in bytes\n    * @param newBlock true if this temp block is created for a new block\n+   * @param options block allocation options\n    * @return a temp block created if successful, or null if allocation failed (instead of throwing\n    *         {@link WorkerOutOfSpaceException} because allocation failure could be an expected case)\n    * @throws BlockAlreadyExistsException if there is already a block with the same block id\n    */\n-  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId,\n-      BlockStoreLocation location, long initialBlockSize, boolean newBlock)\n-          throws BlockAlreadyExistsException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n+  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId, boolean newBlock,\n+      AllocateOptions options) throws BlockAlreadyExistsException {\n     try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      // NOTE: a temp block is supposed to be visible for its own writer,\n+      // unnecessary to acquire block lock here since no sharing.\n       if (newBlock) {\n         checkTempBlockIdAvailable(blockId);\n       }\n-      StorageDirView dirView = mAllocator.allocateBlockWithView(sessionId,\n-          initialBlockSize, location, new BlockMetadataAllocatorView(mMetaManager));\n+\n+      // Allocate space.\n+      StorageDirView dirView = allocateSpace(sessionId, options);\n+\n       if (dirView == null) {\n-        // Allocator fails to find a proper place for this new block.\n         return null;\n       }\n+\n       // TODO(carson): Add tempBlock to corresponding storageDir and remove the use of\n       // StorageDirView.createTempBlockMeta.\n-      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, initialBlockSize);\n+      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, options.getSize());\n       try {\n         // Add allocated temp block to metadata manager. This should never fail if allocator\n         // correctly assigns a StorageDir.\n         mMetaManager.addTempBlockMeta(tempBlock);\n       } catch (WorkerOutOfSpaceException | BlockAlreadyExistsException e) {\n         // If we reach here, allocator is not working properly\n         LOG.error(\"Unexpected failure: {} bytes allocated at {} by allocator, \"\n-            + \"but addTempBlockMeta failed\", initialBlockSize, location);\n+            + \"but addTempBlockMeta failed\", options.getSize(), options.getLocation());\n         throw Throwables.propagate(e);\n       }\n       return tempBlock;\n     }\n   }\n \n   /**\n-   * Increases the temp block size only if this temp block's parent dir has enough available space.\n-   *\n-   * @param blockId block id\n-   * @param additionalBytes additional bytes to request for this block\n-   * @return a pair of boolean and {@link BlockStoreLocation}. The boolean indicates if the\n-   *         operation succeeds and the {@link BlockStoreLocation} denotes where to free more space\n-   *         if it fails.\n-   * @throws BlockDoesNotExistException if this block is not found\n-   */\n-  private Pair<Boolean, BlockStoreLocation> requestSpaceInternal(long blockId, long additionalBytes)\n-      throws BlockDoesNotExistException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-      if (tempBlockMeta.getParentDir().getAvailableBytes() < additionalBytes) {\n-        return new Pair<>(false, tempBlockMeta.getBlockLocation());\n-      }\n-      // Increase the size of this temp block\n-      try {\n-        mMetaManager.resizeTempBlockMeta(tempBlockMeta,\n-            tempBlockMeta.getBlockSize() + additionalBytes);\n-      } catch (InvalidWorkerStateException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n-      return new Pair<>(true, null);\n-    }\n-  }\n-\n-  /**\n-   * Tries to get an eviction plan to free a certain amount of space in the given location, and\n-   * carries out this plan with the best effort.\n+   * Tries to free a certain amount of space in the given location.\n    *\n    * @param sessionId the session id\n-   * @param availableBytes amount of space in bytes to free\n+   * @param minContigiousBytes the minimum amount of contigious space in bytes to set available\n+   * @param minAvailableBytes the minimum amount of space in bytes to set available\n    * @param location location of space\n-   * @param mode the eviction mode\n-   * @throws WorkerOutOfSpaceException if it is impossible to achieve the free requirement\n+   * @throws WorkerOutOfSpaceException if it is impossible to achieve minimum space requirement\n    */\n-  private void freeSpaceInternal(long sessionId, long availableBytes, BlockStoreLocation location,\n-      Evictor.Mode mode) throws WorkerOutOfSpaceException, IOException {\n-    EvictionPlan plan;\n-    // NOTE:change the read lock to the write lock due to the endless-loop issue [ALLUXIO-3089]\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      plan = mEvictor.freeSpaceWithView(availableBytes, location, getUpdatedView(), mode);\n-      // Absent plan means failed to evict enough space.\n-      if (plan == null) {\n-        throw new WorkerOutOfSpaceException(\n-            ExceptionMessage.NO_EVICTION_PLAN_TO_FREE_SPACE, availableBytes, location.tierAlias());\n+  private void freeSpaceInternal(long sessionId, long minContigiousBytes, long minAvailableBytes,\n+      BlockStoreLocation location) throws WorkerOutOfSpaceException, IOException {\n+    // TODO(ggezer): Too much memory pressure when pinned-inodes list is large.\n+    BlockMetadataEvictorView evictorView = getUpdatedView();\n+    LOG.debug(\n+        \"freeSpaceInternal - locAvailableBytes: {}, minContigiousBytes: {}, minAvailableBytes: {}\",\n+        evictorView.getAvailableBytes(location), minContigiousBytes, minAvailableBytes);\n+    boolean contigiousSpaceFound = false;\n+    boolean availableBytesFound = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 638}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwODY4OA==", "bodyText": "Does this need to be updated over the course of this method?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414108688", "createdAt": "2020-04-23T20:40:16Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -570,162 +689,129 @@ private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boo\n    *\n    * @param sessionId session id\n    * @param blockId block id\n-   * @param location location to create the block\n-   * @param initialBlockSize initial block size in bytes\n    * @param newBlock true if this temp block is created for a new block\n+   * @param options block allocation options\n    * @return a temp block created if successful, or null if allocation failed (instead of throwing\n    *         {@link WorkerOutOfSpaceException} because allocation failure could be an expected case)\n    * @throws BlockAlreadyExistsException if there is already a block with the same block id\n    */\n-  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId,\n-      BlockStoreLocation location, long initialBlockSize, boolean newBlock)\n-          throws BlockAlreadyExistsException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n+  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId, boolean newBlock,\n+      AllocateOptions options) throws BlockAlreadyExistsException {\n     try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      // NOTE: a temp block is supposed to be visible for its own writer,\n+      // unnecessary to acquire block lock here since no sharing.\n       if (newBlock) {\n         checkTempBlockIdAvailable(blockId);\n       }\n-      StorageDirView dirView = mAllocator.allocateBlockWithView(sessionId,\n-          initialBlockSize, location, new BlockMetadataAllocatorView(mMetaManager));\n+\n+      // Allocate space.\n+      StorageDirView dirView = allocateSpace(sessionId, options);\n+\n       if (dirView == null) {\n-        // Allocator fails to find a proper place for this new block.\n         return null;\n       }\n+\n       // TODO(carson): Add tempBlock to corresponding storageDir and remove the use of\n       // StorageDirView.createTempBlockMeta.\n-      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, initialBlockSize);\n+      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, options.getSize());\n       try {\n         // Add allocated temp block to metadata manager. This should never fail if allocator\n         // correctly assigns a StorageDir.\n         mMetaManager.addTempBlockMeta(tempBlock);\n       } catch (WorkerOutOfSpaceException | BlockAlreadyExistsException e) {\n         // If we reach here, allocator is not working properly\n         LOG.error(\"Unexpected failure: {} bytes allocated at {} by allocator, \"\n-            + \"but addTempBlockMeta failed\", initialBlockSize, location);\n+            + \"but addTempBlockMeta failed\", options.getSize(), options.getLocation());\n         throw Throwables.propagate(e);\n       }\n       return tempBlock;\n     }\n   }\n \n   /**\n-   * Increases the temp block size only if this temp block's parent dir has enough available space.\n-   *\n-   * @param blockId block id\n-   * @param additionalBytes additional bytes to request for this block\n-   * @return a pair of boolean and {@link BlockStoreLocation}. The boolean indicates if the\n-   *         operation succeeds and the {@link BlockStoreLocation} denotes where to free more space\n-   *         if it fails.\n-   * @throws BlockDoesNotExistException if this block is not found\n-   */\n-  private Pair<Boolean, BlockStoreLocation> requestSpaceInternal(long blockId, long additionalBytes)\n-      throws BlockDoesNotExistException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-      if (tempBlockMeta.getParentDir().getAvailableBytes() < additionalBytes) {\n-        return new Pair<>(false, tempBlockMeta.getBlockLocation());\n-      }\n-      // Increase the size of this temp block\n-      try {\n-        mMetaManager.resizeTempBlockMeta(tempBlockMeta,\n-            tempBlockMeta.getBlockSize() + additionalBytes);\n-      } catch (InvalidWorkerStateException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n-      return new Pair<>(true, null);\n-    }\n-  }\n-\n-  /**\n-   * Tries to get an eviction plan to free a certain amount of space in the given location, and\n-   * carries out this plan with the best effort.\n+   * Tries to free a certain amount of space in the given location.\n    *\n    * @param sessionId the session id\n-   * @param availableBytes amount of space in bytes to free\n+   * @param minContigiousBytes the minimum amount of contigious space in bytes to set available\n+   * @param minAvailableBytes the minimum amount of space in bytes to set available\n    * @param location location of space\n-   * @param mode the eviction mode\n-   * @throws WorkerOutOfSpaceException if it is impossible to achieve the free requirement\n+   * @throws WorkerOutOfSpaceException if it is impossible to achieve minimum space requirement\n    */\n-  private void freeSpaceInternal(long sessionId, long availableBytes, BlockStoreLocation location,\n-      Evictor.Mode mode) throws WorkerOutOfSpaceException, IOException {\n-    EvictionPlan plan;\n-    // NOTE:change the read lock to the write lock due to the endless-loop issue [ALLUXIO-3089]\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      plan = mEvictor.freeSpaceWithView(availableBytes, location, getUpdatedView(), mode);\n-      // Absent plan means failed to evict enough space.\n-      if (plan == null) {\n-        throw new WorkerOutOfSpaceException(\n-            ExceptionMessage.NO_EVICTION_PLAN_TO_FREE_SPACE, availableBytes, location.tierAlias());\n+  private void freeSpaceInternal(long sessionId, long minContigiousBytes, long minAvailableBytes,\n+      BlockStoreLocation location) throws WorkerOutOfSpaceException, IOException {\n+    // TODO(ggezer): Too much memory pressure when pinned-inodes list is large.\n+    BlockMetadataEvictorView evictorView = getUpdatedView();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 633}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwOTM2OQ==", "bodyText": "We don't need any locks for this?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414109369", "createdAt": "2020-04-23T20:41:25Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -570,162 +689,129 @@ private BlockStoreLocation commitBlockInternal(long sessionId, long blockId, boo\n    *\n    * @param sessionId session id\n    * @param blockId block id\n-   * @param location location to create the block\n-   * @param initialBlockSize initial block size in bytes\n    * @param newBlock true if this temp block is created for a new block\n+   * @param options block allocation options\n    * @return a temp block created if successful, or null if allocation failed (instead of throwing\n    *         {@link WorkerOutOfSpaceException} because allocation failure could be an expected case)\n    * @throws BlockAlreadyExistsException if there is already a block with the same block id\n    */\n-  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId,\n-      BlockStoreLocation location, long initialBlockSize, boolean newBlock)\n-          throws BlockAlreadyExistsException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n+  private TempBlockMeta createBlockMetaInternal(long sessionId, long blockId, boolean newBlock,\n+      AllocateOptions options) throws BlockAlreadyExistsException {\n     try (LockResource r = new LockResource(mMetadataWriteLock)) {\n+      // NOTE: a temp block is supposed to be visible for its own writer,\n+      // unnecessary to acquire block lock here since no sharing.\n       if (newBlock) {\n         checkTempBlockIdAvailable(blockId);\n       }\n-      StorageDirView dirView = mAllocator.allocateBlockWithView(sessionId,\n-          initialBlockSize, location, new BlockMetadataAllocatorView(mMetaManager));\n+\n+      // Allocate space.\n+      StorageDirView dirView = allocateSpace(sessionId, options);\n+\n       if (dirView == null) {\n-        // Allocator fails to find a proper place for this new block.\n         return null;\n       }\n+\n       // TODO(carson): Add tempBlock to corresponding storageDir and remove the use of\n       // StorageDirView.createTempBlockMeta.\n-      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, initialBlockSize);\n+      TempBlockMeta tempBlock = dirView.createTempBlockMeta(sessionId, blockId, options.getSize());\n       try {\n         // Add allocated temp block to metadata manager. This should never fail if allocator\n         // correctly assigns a StorageDir.\n         mMetaManager.addTempBlockMeta(tempBlock);\n       } catch (WorkerOutOfSpaceException | BlockAlreadyExistsException e) {\n         // If we reach here, allocator is not working properly\n         LOG.error(\"Unexpected failure: {} bytes allocated at {} by allocator, \"\n-            + \"but addTempBlockMeta failed\", initialBlockSize, location);\n+            + \"but addTempBlockMeta failed\", options.getSize(), options.getLocation());\n         throw Throwables.propagate(e);\n       }\n       return tempBlock;\n     }\n   }\n \n   /**\n-   * Increases the temp block size only if this temp block's parent dir has enough available space.\n-   *\n-   * @param blockId block id\n-   * @param additionalBytes additional bytes to request for this block\n-   * @return a pair of boolean and {@link BlockStoreLocation}. The boolean indicates if the\n-   *         operation succeeds and the {@link BlockStoreLocation} denotes where to free more space\n-   *         if it fails.\n-   * @throws BlockDoesNotExistException if this block is not found\n-   */\n-  private Pair<Boolean, BlockStoreLocation> requestSpaceInternal(long blockId, long additionalBytes)\n-      throws BlockDoesNotExistException {\n-    // NOTE: a temp block is supposed to be visible for its own writer, unnecessary to acquire\n-    // block lock here since no sharing\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      TempBlockMeta tempBlockMeta = mMetaManager.getTempBlockMeta(blockId);\n-      if (tempBlockMeta.getParentDir().getAvailableBytes() < additionalBytes) {\n-        return new Pair<>(false, tempBlockMeta.getBlockLocation());\n-      }\n-      // Increase the size of this temp block\n-      try {\n-        mMetaManager.resizeTempBlockMeta(tempBlockMeta,\n-            tempBlockMeta.getBlockSize() + additionalBytes);\n-      } catch (InvalidWorkerStateException e) {\n-        throw Throwables.propagate(e); // we shall never reach here\n-      }\n-      return new Pair<>(true, null);\n-    }\n-  }\n-\n-  /**\n-   * Tries to get an eviction plan to free a certain amount of space in the given location, and\n-   * carries out this plan with the best effort.\n+   * Tries to free a certain amount of space in the given location.\n    *\n    * @param sessionId the session id\n-   * @param availableBytes amount of space in bytes to free\n+   * @param minContigiousBytes the minimum amount of contigious space in bytes to set available\n+   * @param minAvailableBytes the minimum amount of space in bytes to set available\n    * @param location location of space\n-   * @param mode the eviction mode\n-   * @throws WorkerOutOfSpaceException if it is impossible to achieve the free requirement\n+   * @throws WorkerOutOfSpaceException if it is impossible to achieve minimum space requirement\n    */\n-  private void freeSpaceInternal(long sessionId, long availableBytes, BlockStoreLocation location,\n-      Evictor.Mode mode) throws WorkerOutOfSpaceException, IOException {\n-    EvictionPlan plan;\n-    // NOTE:change the read lock to the write lock due to the endless-loop issue [ALLUXIO-3089]\n-    try (LockResource r = new LockResource(mMetadataWriteLock)) {\n-      plan = mEvictor.freeSpaceWithView(availableBytes, location, getUpdatedView(), mode);\n-      // Absent plan means failed to evict enough space.\n-      if (plan == null) {\n-        throw new WorkerOutOfSpaceException(\n-            ExceptionMessage.NO_EVICTION_PLAN_TO_FREE_SPACE, availableBytes, location.tierAlias());\n+  private void freeSpaceInternal(long sessionId, long minContigiousBytes, long minAvailableBytes,\n+      BlockStoreLocation location) throws WorkerOutOfSpaceException, IOException {\n+    // TODO(ggezer): Too much memory pressure when pinned-inodes list is large.\n+    BlockMetadataEvictorView evictorView = getUpdatedView();\n+    LOG.debug(\n+        \"freeSpaceInternal - locAvailableBytes: {}, minContigiousBytes: {}, minAvailableBytes: {}\",\n+        evictorView.getAvailableBytes(location), minContigiousBytes, minAvailableBytes);\n+    boolean contigiousSpaceFound = false;\n+    boolean availableBytesFound = false;\n+\n+    int blocksIterated = 0;\n+    int blocksRemoved = 0;\n+    int spaceFreed = 0;\n+\n+    // List of all dirs that belong to the given location.\n+    List<StorageDirView> dirViews = evictorView.getDirs(location);\n+\n+    Iterator<Long> evictionCandidates = mBlockIterator.getIterator(location, BlockOrder.Natural);\n+    while (true) {\n+      // Check if minContigiousBytes is satisfied.\n+      if (!contigiousSpaceFound) {\n+        for (StorageDirView dirView : dirViews) {\n+          if (dirView.getAvailableBytes() >= minContigiousBytes) {\n+            contigiousSpaceFound = true;\n+            break;\n+          }\n+        }\n       }\n-    }\n \n-    // 1. remove blocks to make room.\n-    for (Pair<Long, BlockStoreLocation> blockInfo : plan.toEvict()) {\n-      try {\n-        removeBlockInternal(Sessions.createInternalSessionId(),\n-            blockInfo.getFirst(), blockInfo.getSecond());\n-      } catch (InvalidWorkerStateException e) {\n-        // Evictor is not working properly\n-        LOG.error(\"Failed to evict blockId {}, this is temp block\", blockInfo.getFirst());\n-        continue;\n-      } catch (BlockDoesNotExistException e) {\n-        LOG.info(\"Failed to evict blockId {}, it could be already deleted\", blockInfo.getFirst());\n-        continue;\n-      }\n-      synchronized (mBlockStoreEventListeners) {\n-        for (BlockStoreEventListener listener : mBlockStoreEventListeners) {\n-          listener.onRemoveBlockByWorker(sessionId, blockInfo.getFirst());\n+      // Check minAvailableBytes is satisfied.\n+      if (!availableBytesFound) {\n+        if (evictorView.getAvailableBytes(location) >= minAvailableBytes) {\n+          availableBytesFound = true;\n         }\n       }\n-    }\n-    // 2. transfer blocks among tiers.\n-    // 2.1. group blocks move plan by the destination tier.\n-    Map<String, Set<BlockTransferInfo>> blocksGroupedByDestTier = new HashMap<>();\n-    for (BlockTransferInfo entry : plan.toMove()) {\n-      String alias = entry.getDstLocation().tierAlias();\n-      if (!blocksGroupedByDestTier.containsKey(alias)) {\n-        blocksGroupedByDestTier.put(alias, new HashSet());\n+\n+      if (contigiousSpaceFound && availableBytesFound) {\n+        break;\n       }\n-      blocksGroupedByDestTier.get(alias).add(entry);\n-    }\n-    // 2.2. move blocks in the order of their dst tiers, from bottom to top\n-    for (int tierOrdinal = mStorageTierAssoc.size() - 1; tierOrdinal >= 0; --tierOrdinal) {\n-      Set<BlockTransferInfo> toMove =\n-          blocksGroupedByDestTier.get(mStorageTierAssoc.getAlias(tierOrdinal));\n-      if (toMove == null) {\n-        toMove = new HashSet<>();\n+\n+      if (!evictionCandidates.hasNext()) {\n+        break;\n       }\n-      for (BlockTransferInfo entry : toMove) {\n-        long blockId = entry.getBlockId();\n-        BlockStoreLocation oldLocation = entry.getSrcLocation();\n-        BlockStoreLocation newLocation = entry.getDstLocation();\n-        MoveBlockResult moveResult;\n+\n+      long blockToDelete = evictionCandidates.next();\n+      blocksIterated++;\n+      if (evictorView.isBlockEvictable(blockToDelete)) {\n         try {\n-          moveResult = moveBlockInternal(Sessions.createInternalSessionId(),\n-              blockId, oldLocation, newLocation);\n-        } catch (InvalidWorkerStateException e) {\n-          // Evictor is not working properly\n-          LOG.error(\"Failed to demote blockId {}, this is temp block\", blockId);\n-          continue;\n-        } catch (BlockAlreadyExistsException e) {\n-          continue;\n-        } catch (BlockDoesNotExistException e) {\n-          LOG.info(\"Failed to demote blockId {}, it could be already deleted\", blockId);\n-          continue;\n-        }\n-        if (moveResult.getSuccess()) {\n+          BlockMeta blockMeta = mMetaManager.getBlockMeta(blockToDelete);\n+          removeBlockInternal(blockMeta);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 730}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMjgyNg==", "bodyText": "What is this lock intended to guard against? It looks like BlockTransferExecutor is never shared among threads?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414112826", "createdAt": "2020-04-23T20:47:04Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/management/BlockTransferExecutor.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.management;\n+\n+import alluxio.Sessions;\n+import alluxio.worker.block.AllocateOptions;\n+import alluxio.worker.block.BlockStore;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.evictor.BlockTransferInfo;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Hashtable;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Used to execute list of {@link BlockTransferInfo} orders concurrently.\n+ */\n+public class BlockTransferExecutor {\n+  private static final Logger LOG = LoggerFactory.getLogger(BlockTransferExecutor.class);\n+\n+  private final ExecutorService mExecutor;\n+  private final BlockStore mBlockStore;\n+  private final StoreLoadTracker mLoadTracker;\n+  private final int mMaxConcurrency;\n+\n+  /**\n+   * Creates a new instance for executing block transfers.\n+   *\n+   * @param executor the executor to use\n+   * @param blockStore the block store\n+   * @param loadTracker the load tracker\n+   * @param maxConcurrency the max concurrent transfers\n+   */\n+  public BlockTransferExecutor(ExecutorService executor, BlockStore blockStore,\n+      StoreLoadTracker loadTracker, int maxConcurrency) {\n+    mExecutor = executor;\n+    mBlockStore = blockStore;\n+    mLoadTracker = loadTracker;\n+    mMaxConcurrency = maxConcurrency;\n+  }\n+\n+  /**\n+   * Executes given list of {@link BlockTransferInfo}s.\n+   *\n+   * @param transferInfos the list of transfers\n+   */\n+  public void executeTransferList(List<BlockTransferInfo> transferInfos) {\n+    executeTransferList(transferInfos, null);\n+  }\n+\n+  /**\n+   * Executes given list of {@link BlockTransferInfo}s.\n+   *\n+   * @param transferInfos the list of transfers\n+   * @param exceptionHandler exception handler for when a transfer fails\n+   */\n+  public void executeTransferList(List<BlockTransferInfo> transferInfos,\n+      Consumer<Exception> exceptionHandler) {\n+    LOG.debug(\"Executing transfer list of size:{}\", transferInfos.size());\n+    // Return immediately for an empty transfer list.\n+    if (transferInfos.isEmpty()) {\n+      return;\n+    }\n+    // Partition executions into sub-lists.\n+    List<List<BlockTransferInfo>> executionPartitions =\n+        partitionTransfers(transferInfos, mMaxConcurrency);\n+    LOG.debug(\"Partitioned transfer list of size:{} to {} partitions.\", transferInfos.size(),\n+        executionPartitions.size());\n+    // Execute to-be-transferred blocks from the plan.\n+    Collection<Callable<Void>> executionTasks = new LinkedList<>();\n+    for (List<BlockTransferInfo> executionPartition : executionPartitions) {\n+      executionTasks.add(() -> {\n+        // TODO(ggezer): Prevent collisions by location locking.\n+        // Above to-do requires both source and destination locations to be allocated.\n+        executeTransferPartition(executionPartition, exceptionHandler);\n+        return null;\n+      });\n+    }\n+    LOG.debug(\"Invoking {} concurrent transfer tasks.\", executionTasks.size());\n+    try {\n+      mExecutor.invokeAll(executionTasks);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+    }\n+  }\n+\n+  /**\n+   * Used to partition given transfers into concurrently executable buckets.\n+   */\n+  private List<List<BlockTransferInfo>> partitionTransfers(List<BlockTransferInfo> transferInfos,\n+      int maxPartitionCount) {\n+    // Bucketing is possible if source or destination has exact location.\n+    // Those allocated locations will be bucket key[s].\n+    TransferPartitionKey key = findTransferBucketKey(transferInfos);\n+    // Can't bucketize transfers.\n+    if (key == TransferPartitionKey.NONE) {\n+      LOG.debug(\"Un-optimizable transfer list encountered.\");\n+      return new ArrayList<List<BlockTransferInfo>>() {\n+        {\n+          add(transferInfos);\n+        }\n+      };\n+    }\n+\n+    Hashtable<BlockStoreLocation, List<BlockTransferInfo>> transferBuckets = new Hashtable<>();\n+    for (BlockTransferInfo transferInfo : transferInfos) {\n+      BlockStoreLocation keyLoc;\n+      switch (key) {\n+        case SRC:\n+          keyLoc = transferInfo.getSrcLocation();\n+          break;\n+        case DST:\n+          keyLoc = transferInfo.getDstLocation();\n+          break;\n+        default:\n+          throw new IllegalStateException(\n+              String.format(\"Unsupported key type for bucketing transfer infos: %s\", key.name()));\n+      }\n+\n+      if (!transferBuckets.containsKey(keyLoc)) {\n+        transferBuckets.put(keyLoc, new LinkedList<>());\n+      }\n+\n+      transferBuckets.get(keyLoc).add(transferInfo);\n+    }\n+\n+    return balancePartitions(transferBuckets.values().stream().collect(Collectors.toList()),\n+        maxPartitionCount);\n+  }\n+\n+  /**\n+   * Used to balance partitions into given bucket count.\n+   * It greedily tries to achieve each bucket having close count of tasks.\n+   */\n+  private List<List<BlockTransferInfo>> balancePartitions(List<List<BlockTransferInfo>> partitions,\n+      int partitionCount) {\n+    // Return as is if less than requested bucket count.\n+    if (partitions.size() <= partitionCount) {\n+      return partitions;\n+    }\n+\n+    // Greedily build a balanced partitions by transfer count.\n+\n+    // TODO(ggezer): Capacity based partitioning possible if BlockTransferInfo contains the block\n+    // size.\n+    Collections.sort(partitions, Comparator.comparingInt(List::size));\n+\n+    // Initialize balanced partitions.\n+    List<List<BlockTransferInfo>> balancedPartitions = new ArrayList<>(partitionCount);\n+    for (int i = 0; i < partitionCount; i++) {\n+      balancedPartitions.add(new LinkedList<>());\n+    }\n+    // Place partitions into balanced partitions.\n+    for (List<BlockTransferInfo> partition : partitions) {\n+      // Find the balanced partition with the least element size.\n+      int selectedPartitionIdx = -1;\n+      int selectedPartitionCount = -1;\n+      for (int i = 0; i < partitionCount; i++) {\n+        if (balancedPartitions.get(i).size() > selectedPartitionCount) {\n+          selectedPartitionIdx = i;\n+          selectedPartitionCount = balancedPartitions.get(i).size();\n+        }\n+      }\n+      balancedPartitions.get(selectedPartitionIdx).addAll(partition);\n+    }\n+\n+    return balancedPartitions;\n+  }\n+\n+  /**\n+   * Used to determine right partitioning key by inspecting list of transfers.\n+   */\n+  private TransferPartitionKey findTransferBucketKey(List<BlockTransferInfo> transferInfos) {\n+    int srcAllocatedCount = 0;\n+    int dstAllocatedCount = 0;\n+    for (BlockTransferInfo transferInfo : transferInfos) {\n+      if (transferInfo.getSrcLocation().dir() != BlockStoreLocation.ANY_DIR) {\n+        srcAllocatedCount++;\n+      }\n+      if (transferInfo.getDstLocation().dir() != BlockStoreLocation.ANY_DIR) {\n+        dstAllocatedCount++;\n+      }\n+    }\n+\n+    if (srcAllocatedCount == dstAllocatedCount) {\n+      if (srcAllocatedCount == 0) {\n+        return TransferPartitionKey.NONE;\n+      } else {\n+        // Fall-back to SRC partitioning if all are allocated.\n+        return TransferPartitionKey.SRC;\n+      }\n+    } else if (srcAllocatedCount > dstAllocatedCount) {\n+      return TransferPartitionKey.SRC;\n+    } else {\n+      return TransferPartitionKey.DST;\n+    }\n+  }\n+\n+  /**\n+   * Used as entry point for executing a single transfer partition.\n+   */\n+  private void executeTransferPartition(List<BlockTransferInfo> transferInfos,\n+      Consumer<Exception> exceptionHandler) {\n+    for (BlockTransferInfo transferInfo : transferInfos) {\n+      try {\n+        if (mLoadTracker.loadDetected(transferInfo.getSrcLocation(),\n+            transferInfo.getDstLocation())) {\n+          LOG.warn(\"Skipping transfer-order: {} due to user activity.\", transferInfo);\n+          continue;\n+        }\n+\n+        boolean useReservedSpace = transferInfo.isSwap();\n+\n+        synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTEwODQ1", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-399510845", "createdAt": "2020-04-23T22:06:40Z", "commit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowNjo0MFrOGK-EfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowODozNVrOGK-IDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTkwMQ==", "bodyText": "Does this class need locking on top of the concurrent data structures? Which methods we expect to be called concurrently and what are the guarantees for mPerDirOrderedSets?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414155901", "createdAt": "2020-04-23T22:06:40Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/annotator/DefaultBlockIterator.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.annotator;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.collections.Pair;\n+import alluxio.worker.block.AbstractBlockStoreEventListener;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStoreEventListener;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.meta.StorageDir;\n+import alluxio.worker.block.meta.StorageTier;\n+\n+import com.google.common.collect.Iterators;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The default {@link BlockIterator} implementation that integrates with the\n+ * {@link BlockMetadataManager}.\n+ */\n+public class DefaultBlockIterator implements BlockIterator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NjE1Mw==", "bodyText": "It seems possible this will be modified concurrently during iteration?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414156153", "createdAt": "2020-04-23T22:07:13Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/annotator/DefaultBlockIterator.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.annotator;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.collections.Pair;\n+import alluxio.worker.block.AbstractBlockStoreEventListener;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStoreEventListener;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.meta.StorageDir;\n+import alluxio.worker.block.meta.StorageTier;\n+\n+import com.google.common.collect.Iterators;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The default {@link BlockIterator} implementation that integrates with the\n+ * {@link BlockMetadataManager}.\n+ */\n+public class DefaultBlockIterator implements BlockIterator {\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultBlockIterator.class);\n+\n+  /** Map of sorted block set collections per directory. */\n+  private final HashMap<BlockStoreLocation, SortedBlockSet<BlockSortedField>> mPerDirOrderedSets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NjM1MA==", "bodyText": "For block updated and block removed, do we need to notify the block annotator?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414156350", "createdAt": "2020-04-23T22:07:40Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/annotator/DefaultBlockIterator.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.annotator;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.collections.Pair;\n+import alluxio.worker.block.AbstractBlockStoreEventListener;\n+import alluxio.worker.block.BlockMetadataManager;\n+import alluxio.worker.block.BlockStoreEventListener;\n+import alluxio.worker.block.BlockStoreLocation;\n+import alluxio.worker.block.meta.StorageDir;\n+import alluxio.worker.block.meta.StorageTier;\n+\n+import com.google.common.collect.Iterators;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The default {@link BlockIterator} implementation that integrates with the\n+ * {@link BlockMetadataManager}.\n+ */\n+public class DefaultBlockIterator implements BlockIterator {\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultBlockIterator.class);\n+\n+  /** Map of sorted block set collections per directory. */\n+  private final HashMap<BlockStoreLocation, SortedBlockSet<BlockSortedField>> mPerDirOrderedSets;\n+\n+  /** Used to update total order for offline sorting schemes. */\n+  private final ConcurrentHashSet<BlockStoreLocation> mUnorderedLocations;\n+\n+  /** Configured block annotator class. */\n+  private final BlockAnnotator mBlockAnnotator;\n+\n+  /** Underlying meta manager. */\n+  private final BlockMetadataManager mMetaManager;\n+\n+  /** Block store delegate listener. */\n+  private BlockStoreEventListener mListener;\n+\n+  /**\n+   * Creates default block iterator instance.\n+   *\n+   * @param metaManager meta manager\n+   * @param blockAnnotator block annotator\n+   */\n+  public DefaultBlockIterator(BlockMetadataManager metaManager, BlockAnnotator blockAnnotator) {\n+    mMetaManager = metaManager;\n+    mBlockAnnotator = blockAnnotator;\n+\n+    mPerDirOrderedSets = new HashMap<>();\n+    mUnorderedLocations = new ConcurrentHashSet<>();\n+    mListener = new Listener();\n+\n+    initialize();\n+  }\n+\n+  /**\n+   * Initializes with the existing blocks.\n+   */\n+  private void initialize() {\n+    // Initialize sets per location.\n+    for (StorageTier tier : mMetaManager.getTiers()) {\n+      for (StorageDir dir : tier.getStorageDirs()) {\n+        mPerDirOrderedSets.put(dir.toBlockStoreLocation(), new SortedBlockSet());\n+        mUnorderedLocations.add(dir.toBlockStoreLocation());\n+      }\n+    }\n+\n+    // Initialize with existing items.\n+    for (StorageTier tier : mMetaManager.getTiers()) {\n+      for (StorageDir dir : tier.getStorageDirs()) {\n+        BlockStoreLocation dirLocation = dir.toBlockStoreLocation();\n+        for (long blockId : dir.getBlockIds()) {\n+          blockUpdated(blockId, dirLocation);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called by block-store event callbacks to update a block.\n+   */\n+  private void blockUpdated(long blockId, BlockStoreLocation location) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NjgxNQ==", "bodyText": "Could you clarify the responsibilities of this class? What is the division of work between this class and DefaultBlockIterator?", "url": "https://github.com/Alluxio/alluxio/pull/11129#discussion_r414156815", "createdAt": "2020-04-23T22:08:35Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/annotator/BlockAnnotator.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block.annotator;\n+\n+import alluxio.annotation.PublicApi;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.util.CommonUtils;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.util.List;\n+\n+/**\n+ * Interface for providers that annotates blocks for sorting.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d6130d83acc09f7a4392c5d20828a9905536257"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0db5f44e3c8361f944b7bcca5eef5992d520715a", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/0db5f44e3c8361f944b7bcca5eef5992d520715a", "committedDate": "2020-04-24T17:38:08Z", "message": "Use enum for back-off type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3cdb042e5a70015ed44e2caf3196c825c8debeb", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/a3cdb042e5a70015ed44e2caf3196c825c8debeb", "committedDate": "2020-04-24T18:12:18Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "389e6d45cfa0f33f89ab62ddf0fa28827ddbe210", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/389e6d45cfa0f33f89ab62ddf0fa28827ddbe210", "committedDate": "2020-05-01T06:22:05Z", "message": "Refactor tier-management task names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42e5348d53e0cb997a18993366b3b161d90a8ee4", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/42e5348d53e0cb997a18993366b3b161d90a8ee4", "committedDate": "2020-05-01T07:12:58Z", "message": "Merge remote-tracking branch 'upstream/master' into tier-mgmt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79fc82cf3d1de634c8b5c14e4f142247af51c4d8", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/79fc82cf3d1de634c8b5c14e4f142247af51c4d8", "committedDate": "2020-05-01T07:22:31Z", "message": "Fix test: asyncWriteNoEvictBeforeBlockCommit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b80e841b7ec229d070bd2eebb15a18108f2bb0cf", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/b80e841b7ec229d070bd2eebb15a18108f2bb0cf", "committedDate": "2020-05-01T06:25:25Z", "message": "Merge branch 'master' into tier-mgmt"}, "afterCommit": {"oid": "79fc82cf3d1de634c8b5c14e4f142247af51c4d8", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/79fc82cf3d1de634c8b5c14e4f142247af51c4d8", "committedDate": "2020-05-01T07:22:31Z", "message": "Fix test: asyncWriteNoEvictBeforeBlockCommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ad93168dc904364d143c3178ac2b53f991fcc3c", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2ad93168dc904364d143c3178ac2b53f991fcc3c", "committedDate": "2020-05-01T18:48:09Z", "message": "Treat commit as access on LRU annotator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NDQwNTI1", "url": "https://github.com/Alluxio/alluxio/pull/11129#pullrequestreview-404440525", "createdAt": "2020-05-01T23:02:54Z", "commit": {"oid": "2ad93168dc904364d143c3178ac2b53f991fcc3c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4829, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}