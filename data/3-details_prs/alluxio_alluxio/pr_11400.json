{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MDQ0MDg0", "number": 11400, "title": "Improve HdfsPositionedReadUnderFileInputStream with a heuristic", "bodyText": "The heuristic works as follows :\n\nit starts with a pread, because a lot of times the client only does a single large read, and we want to benefit from pread in that case.\nif there are certain number of sequential reads in a row, we switch to buffered read mode. In this mode, preads are serviced via pread calls, and read calls are services by read calls. A sequential read is defined as a read that is within a movement limit of the previous read. This is to guard against workloads such as read, skip(2), read, skip(3) etc.\nany non-sequential read, we change back to pread mode.", "createdAt": "2020-05-08T04:50:57Z", "url": "https://github.com/Alluxio/alluxio/pull/11400", "merged": true, "mergeCommit": {"oid": "c4eba4706750ffd7ad00c486af9454b4342bf914"}, "closed": true, "closedAt": "2020-05-11T05:48:34Z", "author": {"login": "yuzhu"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcewJKuAH2gAyNDE1MDQ0MDg0OjE0NWJjZDFhODQ3Yjc4MjEzYmM4Y2IwYmIwNGUxMTM0ZjE0NDc5ZDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgFUzBAH2gAyNDE1MDQ0MDg0OjFhNzJlY2I5NGExNzcxNWI2ODNmZWVkODlmOGEwNWVlZjBmMWNiY2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "145bcd1a847b78213bc8cb0bb04e1134f14479d9", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/145bcd1a847b78213bc8cb0bb04e1134f14479d9", "committedDate": "2020-05-06T22:09:16Z", "message": "fix NPE related to blocklocations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c423fc54921ef5d40db511fa9660bcd1cb77f67f", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/c423fc54921ef5d40db511fa9660bcd1cb77f67f", "committedDate": "2020-05-07T01:42:38Z", "message": "add logging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc81f1679a654505e98e120f073ae2d6e2eafd23", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/dc81f1679a654505e98e120f073ae2d6e2eafd23", "committedDate": "2020-05-07T02:50:22Z", "message": "fix logic error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dd690d2c52dbf4b4209a3696aab4ec3ac0f720d", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/1dd690d2c52dbf4b4209a3696aab4ec3ac0f720d", "committedDate": "2020-05-08T00:53:25Z", "message": "better heurstics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "committedDate": "2020-05-08T04:41:10Z", "message": "more comments and less logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MzgzNzQy", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408383742", "createdAt": "2020-05-08T17:06:07Z", "commit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzowNjowN1rOGSssOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzoxMTowNFrOGSs1fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTc3MQ==", "bodyText": "If we seek backward should sequential count always be set to 0?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422259771", "createdAt": "2020-05-08T17:06:07Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDgyNQ==", "bodyText": "Should this only be incremented if bytesRead > 0?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422260825", "createdAt": "2020-05-08T17:08:25Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MTUxOQ==", "bodyText": "Is it guaranteed that in is positioned correctly?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422261519", "createdAt": "2020-05-08T17:09:46Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((FSDataInputStream) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n-    mPos += n;\n-    return n;\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+      mPos += n;\n+      return n;\n+    } else {\n+      long skipped = ((FSDataInputStream) in).skip(n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA==", "bodyText": "Do these numbers require tuning or is the heuristic good enough?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422262140", "createdAt": "2020-05-08T17:11:04Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDQyODE1", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408442815", "createdAt": "2020-05-08T18:40:49Z", "commit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MDo0OVrOGSvjqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0Mzo0MVrOGSvpUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjczMQ==", "bodyText": "good catch, fixed", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422306731", "createdAt": "2020-05-08T18:40:49Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((FSDataInputStream) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n-    mPos += n;\n-    return n;\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+      mPos += n;\n+      return n;\n+    } else {\n+      long skipped = ((FSDataInputStream) in).skip(n);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MTUxOQ=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzQ1OA==", "bodyText": "yeah i was undecided about this one, but probably rare to see someone jump forward and then jump back in the stream?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422307458", "createdAt": "2020-05-08T18:42:18Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTc3MQ=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzQ5NA==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422307494", "createdAt": "2020-05-08T18:42:24Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDgyNQ=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwODE3Nw==", "bodyText": "We could further tune these, but experimentally journal replays are as fast as before, will verify remote spark tpcds behavior soon.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422308177", "createdAt": "2020-05-08T18:43:41Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e334b0533d4903c77a479f31b967019518442096", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/e334b0533d4903c77a479f31b967019518442096", "committedDate": "2020-05-08T20:22:33Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTA3Njc2", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408507676", "createdAt": "2020-05-08T20:30:58Z", "commit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozMDo1OFrOGSyuNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozMDo1OFrOGSyuNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1ODU4MQ==", "bodyText": "nit: add a comment describing these as counts and not a bytes limit", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422358581", "createdAt": "2020-05-08T20:30:58Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTQ5Nzcx", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408549771", "createdAt": "2020-05-08T21:54:34Z", "commit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMTo1NDozNFrOGS03nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMTo1NDozNFrOGS03nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng==", "bodyText": "We still need to skip in the stream if we are in the sequential read mode and n is less than the movement limit?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422393756", "createdAt": "2020-05-08T21:54:34Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +71,46 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84259b50133bb5c4cfe815ed12e60fd8f264f5dc", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/84259b50133bb5c4cfe815ed12e60fd8f264f5dc", "committedDate": "2020-05-09T02:54:17Z", "message": "add test and address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3645fb20761ad43d527345790697991c1fc6dd3", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/c3645fb20761ad43d527345790697991c1fc6dd3", "committedDate": "2020-05-09T06:17:13Z", "message": "update comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "committedDate": "2020-05-09T06:20:01Z", "message": "add TODO"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NzYyNjM2", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408762636", "createdAt": "2020-05-10T16:57:44Z", "commit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNjo1Nzo0NFrOGTFyFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzo1NDo0OFrOGTGNXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MDg3MA==", "bodyText": "nit: this seems to be a clone of FilterInputStream javadoc. I don't think we need a copy here.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422670870", "createdAt": "2020-05-10T16:57:44Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MTQ2NA==", "bodyText": "nit: this doesn't need to be a nested class? separate file for readability", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422671464", "createdAt": "2020-05-10T17:02:33Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Mjk4MA==", "bodyText": "nit: comment why pread is never called", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422672980", "createdAt": "2020-05-10T17:15:31Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzAzOQ==", "bodyText": "nit: comment that skip > MOVEMENT_LIMIT causes pread. maybe even mark MOVEMENT_LIMIT @VisibleForTesting and re-use 2*MOVEMENT_LIMIT to avoid changing the test if we tune the parameter.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422673039", "createdAt": "2020-05-10T17:15:57Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzY0Nw==", "bodyText": "nit: comment that read > SEQUENTIAL_READ_LIMIT causes . similar to above consider exposing SEQUENTIAL_READ_LIMIT for testing and using a for loop here to avoid changing the test after possible tuning", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422673647", "createdAt": "2020-05-10T17:21:09Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);\n+    in.read();\n+    in.read();\n+    in.read();\n+    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.read();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDAyNQ==", "bodyText": "nit: the comment above is mis-placed?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422674025", "createdAt": "2020-05-10T17:24:06Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDA5Mg==", "bodyText": "nit: also this comment seems mis-placed as this method makes no decision about pread api", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422674092", "createdAt": "2020-05-10T17:24:44Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,\n-        options.getOffset(), options.getLength());\n-    for (BlockLocation loc : blockLocations) {\n-      if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n-        // Some blocks are remote only, use pread api to HDFS\n-        return false;\n+    BlockLocation[] blockLocations;\n+    try {\n+      blockLocations = fs.getFileBlockLocations(filePath,\n+          options.getOffset(), options.getLength());\n+      if (blockLocations == null) {\n+        // no blocks exist\n+        return true;\n       }\n+\n+      for (BlockLocation loc : blockLocations) {\n+        if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n+          // Some blocks are remote only, use pread api to HDFS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTA1Nw==", "bodyText": "nit: in this test can we also check if the data read back is what we expect, in addition to the API used to read?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422675057", "createdAt": "2020-05-10T17:32:43Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTYxMw==", "bodyText": "is this seek necessary or guaranteed to be a no-op if say I have 10 continuous reads as we reset mSequentialReadCount and seek after every 3 reads?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422675613", "createdAt": "2020-05-10T17:36:50Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NzU3MQ==", "bodyText": "what if\n\nstream is in random read mode and mPos=0\nHdfsPositionedUnderFileInputeStream.seek(MOVEMENT_LIMIT-1)\nwe end up calling seek on FSDataInputStream and that is undesired?\n\ninstead can we refactor this by creating an auxiliary method isSequentialReadMode=mSequentialReadCount> SEQUENTIAL_READ_LIMIT\n   if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n      mSequentialReadCount = 0;\n    }\n\n    if (isSequentialReadMode()) {\n      ((Seekable) in).seek(position);", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422677571", "createdAt": "2020-05-10T17:53:03Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Nzg1Mw==", "bodyText": "nit: for readability i prefer a method called  isSequentialReadMode to determine whether to seek or not", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422677853", "createdAt": "2020-05-10T17:54:48Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(mPos + n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "657e7024429bee539dde55656432563ba3f24d0b", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/657e7024429bee539dde55656432563ba3f24d0b", "committedDate": "2020-05-10T21:16:34Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NzgyNzE4", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408782718", "createdAt": "2020-05-10T21:18:43Z", "commit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToxODo0M1rOGTHrDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMTo0MlrOGTHsSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTgzOA==", "bodyText": "I changed this part a bit so we don't do the noop seek. Basically we do the seek lazily if we are in sequential mode, and don't reset the counter until we seek or skip a large step.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422701838", "createdAt": "2020-05-10T21:18:43Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTYxMw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA1Ng==", "bodyText": "see above, i now avoid this seek entirely by doing it lazily in the read.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702056", "createdAt": "2020-05-10T21:20:51Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NzU3MQ=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA4MA==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702080", "createdAt": "2020-05-10T21:20:58Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(mPos + n);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Nzg1Mw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA5Ng==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702096", "createdAt": "2020-05-10T21:21:06Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,\n-        options.getOffset(), options.getLength());\n-    for (BlockLocation loc : blockLocations) {\n-      if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n-        // Some blocks are remote only, use pread api to HDFS\n-        return false;\n+    BlockLocation[] blockLocations;\n+    try {\n+      blockLocations = fs.getFileBlockLocations(filePath,\n+          options.getOffset(), options.getLength());\n+      if (blockLocations == null) {\n+        // no blocks exist\n+        return true;\n       }\n+\n+      for (BlockLocation loc : blockLocations) {\n+        if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n+          // Some blocks are remote only, use pread api to HDFS", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDA5Mg=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEwNg==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702106", "createdAt": "2020-05-10T21:21:13Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MTQ2NA=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjExNQ==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702115", "createdAt": "2020-05-10T21:21:19Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MDg3MA=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEyMw==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702123", "createdAt": "2020-05-10T21:21:26Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTA1Nw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEzNQ==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702135", "createdAt": "2020-05-10T21:21:33Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Mjk4MA=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE0Ng==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702146", "createdAt": "2020-05-10T21:21:37Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzAzOQ=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE1Mw==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702153", "createdAt": "2020-05-10T21:21:42Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);\n+    in.read();\n+    in.read();\n+    in.read();\n+    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.read();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzY0Nw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NzkzMjE0", "url": "https://github.com/Alluxio/alluxio/pull/11400#pullrequestreview-408793214", "createdAt": "2020-05-10T23:35:01Z", "commit": {"oid": "657e7024429bee539dde55656432563ba3f24d0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77c420d9fa09c244d029a47c1532521e73716eef", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/77c420d9fa09c244d029a47c1532521e73716eef", "committedDate": "2020-05-11T00:38:32Z", "message": "add header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a72ecb94a17715b683feed89f8a05eef0f1cbcb", "author": {"user": {"login": "yuzhu", "name": "David Zhu"}}, "url": "https://github.com/Alluxio/alluxio/commit/1a72ecb94a17715b683feed89f8a05eef0f1cbcb", "committedDate": "2020-05-11T01:23:54Z", "message": "fix license header"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4614, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}