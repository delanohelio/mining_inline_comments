{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzA1NDk2", "number": 11449, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1NDoyOFrOD-sWFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowOToxOFrOD_FXjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY0ODUzOnYy", "diffSide": "RIGHT", "path": "bin/alluxio", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1NDoyOFrOGY83hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMTozMDo1OFrOGZH9zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNjI2Mg==", "bodyText": "Was this a bug? Why was this change made?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428816262", "createdAt": "2020-05-21T17:54:28Z", "author": {"login": "gpang"}, "path": "bin/alluxio", "diffHunk": "@@ -149,7 +149,7 @@ function runJavaClass {\n               CLASS_ARGS+=(\"${arg}\")\n       esac\n   done\n-  \"${JAVA}\" -cp ${CLASSPATH} ${ALLUXIO_USER_JAVA_OPTS} ${ALLUXIO_SHELL_JAVA_OPTS} ${CLASS} ${PARAMETER} \"${CLASS_ARGS[@]}\"\n+  exec \"${JAVA}\" -cp ${CLASSPATH} ${ALLUXIO_USER_JAVA_OPTS} ${ALLUXIO_SHELL_JAVA_OPTS} ${CLASS} ${PARAMETER} \"${CLASS_ARGS[@]}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NTAyNw==", "bodyText": "Oh I should make this a separate PR. I'll remove it.\nI think technically it is a bug. Without using exec a ctrl-c doesn't actually kill the java process running if it's a CLI program. Rather it just kills the shell running the CLI command, so a haning CLI command i.e because of a large listStatus, or master unavailable doesn't actually get killed if the USER ctrl-Cs and it may continue to run in the background. I'm not sure but the shell might also send a SIGHUP too, but it doesn't necessarily guarantee stopping the JVM", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428955027", "createdAt": "2020-05-21T22:45:27Z", "author": {"login": "ZacBlanco"}, "path": "bin/alluxio", "diffHunk": "@@ -149,7 +149,7 @@ function runJavaClass {\n               CLASS_ARGS+=(\"${arg}\")\n       esac\n   done\n-  \"${JAVA}\" -cp ${CLASSPATH} ${ALLUXIO_USER_JAVA_OPTS} ${ALLUXIO_SHELL_JAVA_OPTS} ${CLASS} ${PARAMETER} \"${CLASS_ARGS[@]}\"\n+  exec \"${JAVA}\" -cp ${CLASSPATH} ${ALLUXIO_USER_JAVA_OPTS} ${ALLUXIO_SHELL_JAVA_OPTS} ${CLASS} ${PARAMETER} \"${CLASS_ARGS[@]}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNjI2Mg=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk5ODA5NA==", "bodyText": "reverted", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428998094", "createdAt": "2020-05-22T01:30:58Z", "author": {"login": "ZacBlanco"}, "path": "bin/alluxio", "diffHunk": "@@ -149,7 +149,7 @@ function runJavaClass {\n               CLASS_ARGS+=(\"${arg}\")\n       esac\n   done\n-  \"${JAVA}\" -cp ${CLASSPATH} ${ALLUXIO_USER_JAVA_OPTS} ${ALLUXIO_SHELL_JAVA_OPTS} ${CLASS} ${PARAMETER} \"${CLASS_ARGS[@]}\"\n+  exec \"${JAVA}\" -cp ${CLASSPATH} ${ALLUXIO_USER_JAVA_OPTS} ${ALLUXIO_SHELL_JAVA_OPTS} ${CLASS} ${PARAMETER} \"${CLASS_ARGS[@]}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNjI2Mg=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY1NDg2OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1NjoxOVrOGY87nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMTozMToxM1rOGZH9_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNzMwOQ==", "bodyText": "Could you add the implications of too high or too low value of this?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428817309", "createdAt": "2020-05-21T17:56:19Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1973,7 +1973,8 @@ public String toString() {\n           .build();\n   public static final PropertyKey MASTER_UFS_ACTIVE_SYNC_THREAD_POOL_SIZE =\n       new Builder(Name.MASTER_UFS_ACTIVE_SYNC_THREAD_POOL_SIZE)\n-          .setDefaultValue(\"3\")\n+          .setDefaultSupplier(() -> Math.max(2, Runtime.getRuntime().availableProcessors() / 2),\n+              \"The number of threads used by the active sync provider process active sync events\")\n           .setDescription(\"Max number of threads used to perform active sync\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk5ODE0MQ==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428998141", "createdAt": "2020-05-22T01:31:13Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1973,7 +1973,8 @@ public String toString() {\n           .build();\n   public static final PropertyKey MASTER_UFS_ACTIVE_SYNC_THREAD_POOL_SIZE =\n       new Builder(Name.MASTER_UFS_ACTIVE_SYNC_THREAD_POOL_SIZE)\n-          .setDefaultValue(\"3\")\n+          .setDefaultSupplier(() -> Math.max(2, Runtime.getRuntime().availableProcessors() / 2),\n+              \"The number of threads used by the active sync provider process active sync events\")\n           .setDescription(\"Max number of threads used to perform active sync\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNzMwOQ=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY1ODg5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo1NzozNVrOGY8-bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMzozMToyMVrOGZGJgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODAzMA==", "bodyText": "is this supposed to be MASTER_UFS_ACTIVE_SYNC_THREAD_POOL_SIZE?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428818030", "createdAt": "2020-05-21T17:57:35Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -384,12 +384,18 @@\n       1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(),\n       ThreadFactoryUtils.build(\"alluxio-ufs-sync-prefetch-%d\", false));\n \n-  final ThreadPoolExecutor mMetadataSyncExecutor = new ThreadPoolExecutor(\n+  final ThreadPoolExecutor mSyncMetadataExecutor = new ThreadPoolExecutor(\n       ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE),\n       ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE),\n       1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(),\n       ThreadFactoryUtils.build(\"alluxio-ufs-sync-%d\", false));\n \n+  final ThreadPoolExecutor mActiveSyncMetadataExecutor = new ThreadPoolExecutor(\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2ODMyMw==", "bodyText": "no", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428968323", "createdAt": "2020-05-21T23:31:21Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -384,12 +384,18 @@\n       1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(),\n       ThreadFactoryUtils.build(\"alluxio-ufs-sync-prefetch-%d\", false));\n \n-  final ThreadPoolExecutor mMetadataSyncExecutor = new ThreadPoolExecutor(\n+  final ThreadPoolExecutor mSyncMetadataExecutor = new ThreadPoolExecutor(\n       ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE),\n       ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE),\n       1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(),\n       ThreadFactoryUtils.build(\"alluxio-ufs-sync-%d\", false));\n \n+  final ThreadPoolExecutor mActiveSyncMetadataExecutor = new ThreadPoolExecutor(\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODAzMA=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDY4MzkyOnYy", "diffSide": "LEFT", "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODowNToxNFrOGY9O9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMzo0NzoyNFrOGZGaKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMjI2MA==", "bodyText": "Why was this removed?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428822260", "createdAt": "2020-05-21T18:05:14Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncManager.java", "diffHunk": "@@ -342,10 +348,6 @@ public void stopSyncAndJournal(RpcContext rpcContext, AlluxioURI syncPoint)\n     }\n     try (LockResource r = new LockResource(mLock)) {\n       MountTable.Resolution resolution = mMountTable.resolve(syncPoint);\n-      if (resolution == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NTc5Mw==", "bodyText": "resolve is not nullable, so resolution is never null", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428955793", "createdAt": "2020-05-21T22:47:44Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncManager.java", "diffHunk": "@@ -342,10 +348,6 @@ public void stopSyncAndJournal(RpcContext rpcContext, AlluxioURI syncPoint)\n     }\n     try (LockResource r = new LockResource(mLock)) {\n       MountTable.Resolution resolution = mMountTable.resolve(syncPoint);\n-      if (resolution == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMjI2MA=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3MjU4NA==", "bodyText": "Also, if you inspect the code, we either throw an exception or always return a non-null object", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428972584", "createdAt": "2020-05-21T23:47:24Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncManager.java", "diffHunk": "@@ -342,10 +348,6 @@ public void stopSyncAndJournal(RpcContext rpcContext, AlluxioURI syncPoint)\n     }\n     try (LockResource r = new LockResource(mLock)) {\n       MountTable.Resolution resolution = mMountTable.resolve(syncPoint);\n-      if (resolution == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMjI2MA=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDkwMDk5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToxMjo0MlrOGY_ZoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjo0ODowN1rOGZFZDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1Nzc2MQ==", "bodyText": "NIT: can we add the mount id, and maybe the mount path in this message?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428857761", "createdAt": "2020-05-21T19:12:42Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -61,11 +68,16 @@ public ActiveSyncer(FileSystemMaster fileSystemMaster, ActiveSyncManager syncMan\n     mSyncManager = syncManager;\n     mMountId = mountId;\n     mMountTable = mountTable;\n+    mSyncTasks = new LinkedBlockingQueue<>(32);\n   }\n \n   @Override\n   public void heartbeat() {\n     LOG.debug(\"start Active Syncer heartbeat\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NTkxOA==", "bodyText": "sure", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428955918", "createdAt": "2020-05-21T22:48:07Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -61,11 +68,16 @@ public ActiveSyncer(FileSystemMaster fileSystemMaster, ActiveSyncManager syncMan\n     mSyncManager = syncManager;\n     mMountId = mountId;\n     mMountTable = mountTable;\n+    mSyncTasks = new LinkedBlockingQueue<>(32);\n   }\n \n   @Override\n   public void heartbeat() {\n     LOG.debug(\"start Active Syncer heartbeat\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1Nzc2MQ=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDkxODk0OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToxODo0NVrOGY_lWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToxODo0NVrOGY_lWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDc2MA==", "bodyText": "should this be mSyncTasks.peek().isDone()? Don't we want to remove the ones that are considered done?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428860760", "createdAt": "2020-05-21T19:18:45Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -61,11 +68,16 @@ public ActiveSyncer(FileSystemMaster fileSystemMaster, ActiveSyncManager syncMan\n     mSyncManager = syncManager;\n     mMountId = mountId;\n     mMountTable = mountTable;\n+    mSyncTasks = new LinkedBlockingQueue<>(32);\n   }\n \n   @Override\n   public void heartbeat() {\n     LOG.debug(\"start Active Syncer heartbeat\");\n+    // Remove any previously completed sync tasks\n+    while (mSyncTasks.peek() != null && !mSyncTasks.peek().isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDk0MDk5OnYy", "diffSide": "LEFT", "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToyNTo0MVrOGY_zMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjo0OTowNlrOGZFaSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDMwNA==", "bodyText": "Was this wrong before, journaling too early?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428864304", "createdAt": "2020-05-21T19:25:41Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -74,29 +86,47 @@ public void heartbeat() {\n     }\n \n     try {\n-      UfsManager.UfsClient ufsclient = mMountTable.getUfsClient(mMountId);\n+      UfsManager.UfsClient ufsclient = Objects.requireNonNull(mMountTable.getUfsClient(mMountId));\n       try (CloseableResource<UnderFileSystem> ufsResource = ufsclient.acquireUfsResource()) {\n         UnderFileSystem ufs = ufsResource.get();\n         if (ufs.supportsActiveSync()) {\n           SyncInfo syncInfo = ufs.getActiveSyncInfo();\n           // This returns a list of ufsUris that we need to sync.\n           Set<AlluxioURI> ufsSyncPoints = syncInfo.getSyncPoints();\n           // Parallelize across sync points\n-          List<Callable<Void>> tasksPerSyncPoint = new ArrayList<>(ufsSyncPoints.size());\n+          List<CompletableFuture<Long>> tasksPerSync = new ArrayList<>();\n           for (AlluxioURI ufsUri : ufsSyncPoints) {\n-            tasksPerSyncPoint.add(() -> {\n+            tasksPerSync.add(CompletableFuture.supplyAsync(() -> {\n               processSyncPoint(ufsUri, syncInfo);\n-              return null;\n-            });\n+              return syncInfo.getTxId();\n+            }, mSyncManager.getExecutor()));\n           }\n-          mSyncManager.getExecutor().invokeAll(tasksPerSyncPoint);\n           // Journal the latest processed txId\n-          mFileSystemMaster.recordActiveSyncTxid(syncInfo.getTxId(), mMountId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NjIzMg==", "bodyText": "no, it worked properly before because the sync occurred synchronously within the heartbeat", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428956232", "createdAt": "2020-05-21T22:49:06Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -74,29 +86,47 @@ public void heartbeat() {\n     }\n \n     try {\n-      UfsManager.UfsClient ufsclient = mMountTable.getUfsClient(mMountId);\n+      UfsManager.UfsClient ufsclient = Objects.requireNonNull(mMountTable.getUfsClient(mMountId));\n       try (CloseableResource<UnderFileSystem> ufsResource = ufsclient.acquireUfsResource()) {\n         UnderFileSystem ufs = ufsResource.get();\n         if (ufs.supportsActiveSync()) {\n           SyncInfo syncInfo = ufs.getActiveSyncInfo();\n           // This returns a list of ufsUris that we need to sync.\n           Set<AlluxioURI> ufsSyncPoints = syncInfo.getSyncPoints();\n           // Parallelize across sync points\n-          List<Callable<Void>> tasksPerSyncPoint = new ArrayList<>(ufsSyncPoints.size());\n+          List<CompletableFuture<Long>> tasksPerSync = new ArrayList<>();\n           for (AlluxioURI ufsUri : ufsSyncPoints) {\n-            tasksPerSyncPoint.add(() -> {\n+            tasksPerSync.add(CompletableFuture.supplyAsync(() -> {\n               processSyncPoint(ufsUri, syncInfo);\n-              return null;\n-            });\n+              return syncInfo.getTxId();\n+            }, mSyncManager.getExecutor()));\n           }\n-          mSyncManager.getExecutor().invokeAll(tasksPerSyncPoint);\n           // Journal the latest processed txId\n-          mFileSystemMaster.recordActiveSyncTxid(syncInfo.getTxId(), mMountId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDMwNA=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDk0OTYwOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToyODozNVrOGY_4tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMTozMzoyOFrOGZH_4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NTcxOA==", "bodyText": "If the first task in the queue is slow for some reason, would that hold up all the rest of the processing, even if the rest of the tasks have completed?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428865718", "createdAt": "2020-05-21T19:28:35Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -74,29 +86,47 @@ public void heartbeat() {\n     }\n \n     try {\n-      UfsManager.UfsClient ufsclient = mMountTable.getUfsClient(mMountId);\n+      UfsManager.UfsClient ufsclient = Objects.requireNonNull(mMountTable.getUfsClient(mMountId));\n       try (CloseableResource<UnderFileSystem> ufsResource = ufsclient.acquireUfsResource()) {\n         UnderFileSystem ufs = ufsResource.get();\n         if (ufs.supportsActiveSync()) {\n           SyncInfo syncInfo = ufs.getActiveSyncInfo();\n           // This returns a list of ufsUris that we need to sync.\n           Set<AlluxioURI> ufsSyncPoints = syncInfo.getSyncPoints();\n           // Parallelize across sync points\n-          List<Callable<Void>> tasksPerSyncPoint = new ArrayList<>(ufsSyncPoints.size());\n+          List<CompletableFuture<Long>> tasksPerSync = new ArrayList<>();\n           for (AlluxioURI ufsUri : ufsSyncPoints) {\n-            tasksPerSyncPoint.add(() -> {\n+            tasksPerSync.add(CompletableFuture.supplyAsync(() -> {\n               processSyncPoint(ufsUri, syncInfo);\n-              return null;\n-            });\n+              return syncInfo.getTxId();\n+            }, mSyncManager.getExecutor()));\n           }\n-          mSyncManager.getExecutor().invokeAll(tasksPerSyncPoint);\n           // Journal the latest processed txId\n-          mFileSystemMaster.recordActiveSyncTxid(syncInfo.getTxId(), mMountId);\n+          CompletableFuture<Void> syncTask =\n+              CompletableFuture.allOf(tasksPerSync.toArray(new CompletableFuture<?>[0]))\n+              .thenRunAsync(() -> mFileSystemMaster\n+                      .recordActiveSyncTxid(syncInfo.getTxId(), mMountId),\n+                  mSyncManager.getExecutor());\n+          while (!mSyncTasks.offer(syncTask)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MDMyNQ==", "bodyText": "its possible that it holds up removing tasks from the queue, though for this to happen is would require filling the incremental sync queue which right now holds up to 32 items. Given the standard heartbeat interval of 30 seconds that means this would need to take 16 minutes to finish the incremental sync.\nI can try improving this by using a set to iterate over all of the elements and removing any that are finished, but would require iterating over all futures. I think for the size of the futures added to this queue that is a reasonable solution", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428960325", "createdAt": "2020-05-21T23:02:27Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -74,29 +86,47 @@ public void heartbeat() {\n     }\n \n     try {\n-      UfsManager.UfsClient ufsclient = mMountTable.getUfsClient(mMountId);\n+      UfsManager.UfsClient ufsclient = Objects.requireNonNull(mMountTable.getUfsClient(mMountId));\n       try (CloseableResource<UnderFileSystem> ufsResource = ufsclient.acquireUfsResource()) {\n         UnderFileSystem ufs = ufsResource.get();\n         if (ufs.supportsActiveSync()) {\n           SyncInfo syncInfo = ufs.getActiveSyncInfo();\n           // This returns a list of ufsUris that we need to sync.\n           Set<AlluxioURI> ufsSyncPoints = syncInfo.getSyncPoints();\n           // Parallelize across sync points\n-          List<Callable<Void>> tasksPerSyncPoint = new ArrayList<>(ufsSyncPoints.size());\n+          List<CompletableFuture<Long>> tasksPerSync = new ArrayList<>();\n           for (AlluxioURI ufsUri : ufsSyncPoints) {\n-            tasksPerSyncPoint.add(() -> {\n+            tasksPerSync.add(CompletableFuture.supplyAsync(() -> {\n               processSyncPoint(ufsUri, syncInfo);\n-              return null;\n-            });\n+              return syncInfo.getTxId();\n+            }, mSyncManager.getExecutor()));\n           }\n-          mSyncManager.getExecutor().invokeAll(tasksPerSyncPoint);\n           // Journal the latest processed txId\n-          mFileSystemMaster.recordActiveSyncTxid(syncInfo.getTxId(), mMountId);\n+          CompletableFuture<Void> syncTask =\n+              CompletableFuture.allOf(tasksPerSync.toArray(new CompletableFuture<?>[0]))\n+              .thenRunAsync(() -> mFileSystemMaster\n+                      .recordActiveSyncTxid(syncInfo.getTxId(), mMountId),\n+                  mSyncManager.getExecutor());\n+          while (!mSyncTasks.offer(syncTask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NTcxOA=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk5ODYyNg==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428998626", "createdAt": "2020-05-22T01:33:28Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/activesync/ActiveSyncer.java", "diffHunk": "@@ -74,29 +86,47 @@ public void heartbeat() {\n     }\n \n     try {\n-      UfsManager.UfsClient ufsclient = mMountTable.getUfsClient(mMountId);\n+      UfsManager.UfsClient ufsclient = Objects.requireNonNull(mMountTable.getUfsClient(mMountId));\n       try (CloseableResource<UnderFileSystem> ufsResource = ufsclient.acquireUfsResource()) {\n         UnderFileSystem ufs = ufsResource.get();\n         if (ufs.supportsActiveSync()) {\n           SyncInfo syncInfo = ufs.getActiveSyncInfo();\n           // This returns a list of ufsUris that we need to sync.\n           Set<AlluxioURI> ufsSyncPoints = syncInfo.getSyncPoints();\n           // Parallelize across sync points\n-          List<Callable<Void>> tasksPerSyncPoint = new ArrayList<>(ufsSyncPoints.size());\n+          List<CompletableFuture<Long>> tasksPerSync = new ArrayList<>();\n           for (AlluxioURI ufsUri : ufsSyncPoints) {\n-            tasksPerSyncPoint.add(() -> {\n+            tasksPerSync.add(CompletableFuture.supplyAsync(() -> {\n               processSyncPoint(ufsUri, syncInfo);\n-              return null;\n-            });\n+              return syncInfo.getTxId();\n+            }, mSyncManager.getExecutor()));\n           }\n-          mSyncManager.getExecutor().invokeAll(tasksPerSyncPoint);\n           // Journal the latest processed txId\n-          mFileSystemMaster.recordActiveSyncTxid(syncInfo.getTxId(), mMountId);\n+          CompletableFuture<Void> syncTask =\n+              CompletableFuture.allOf(tasksPerSync.toArray(new CompletableFuture<?>[0]))\n+              .thenRunAsync(() -> mFileSystemMaster\n+                      .recordActiveSyncTxid(syncInfo.getTxId(), mMountId),\n+                  mSyncManager.getExecutor());\n+          while (!mSyncTasks.offer(syncTask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NTcxOA=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDk1OTY2OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/activesync/SupportedHdfsActiveSyncProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTozMTozMFrOGY_-1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMTozMzo0NlrOGZIAFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzI4NQ==", "bodyText": "Is this supposed to be final? Can the previous EventBatch batch = ... just be final?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428867285", "createdAt": "2020-05-21T19:31:30Z", "author": {"login": "gpang"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/activesync/SupportedHdfsActiveSyncProvider.java", "diffHunk": "@@ -258,38 +273,52 @@ public void stopSync(AlluxioURI ufsUri) {\n    * @param eventStream event stream\n    */\n   public void pollEvent(DFSInotifyEventInputStream eventStream) {\n-    EventBatch batch;\n     LOG.debug(\"Polling thread starting, with timeout {} ms\", mActiveUfsPollTimeoutMs);\n-    int count = 0;\n     long start = System.currentTimeMillis();\n \n     long behind = eventStream.getTxidsBehindEstimate();\n \n     while (!Thread.currentThread().isInterrupted()) {\n       try {\n-        batch = eventStream.poll(mActiveUfsPollTimeoutMs, TimeUnit.MILLISECONDS);\n \n-        if (batch != null) {\n-          long txId = batch.getTxid();\n-          count += batch.getEvents().length;\n-          for (Event event : batch.getEvents()) {\n-            processEvent(event, mUfsUriList, txId);\n+        List<Callable<Integer>> process = new LinkedList<>();\n+        for (int i = 0; i < mBatchSize; i++) {\n+          EventBatch batch = eventStream.poll(mActiveUfsPollTimeoutMs, TimeUnit.MILLISECONDS);\n+          if (batch == null) {\n+            break;\n           }\n+          EventBatch finalBatch = batch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk5ODY3OA==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r428998678", "createdAt": "2020-05-22T01:33:46Z", "author": {"login": "ZacBlanco"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/activesync/SupportedHdfsActiveSyncProvider.java", "diffHunk": "@@ -258,38 +273,52 @@ public void stopSync(AlluxioURI ufsUri) {\n    * @param eventStream event stream\n    */\n   public void pollEvent(DFSInotifyEventInputStream eventStream) {\n-    EventBatch batch;\n     LOG.debug(\"Polling thread starting, with timeout {} ms\", mActiveUfsPollTimeoutMs);\n-    int count = 0;\n     long start = System.currentTimeMillis();\n \n     long behind = eventStream.getTxidsBehindEstimate();\n \n     while (!Thread.currentThread().isInterrupted()) {\n       try {\n-        batch = eventStream.poll(mActiveUfsPollTimeoutMs, TimeUnit.MILLISECONDS);\n \n-        if (batch != null) {\n-          long txId = batch.getTxid();\n-          count += batch.getEvents().length;\n-          for (Event event : batch.getEvents()) {\n-            processEvent(event, mUfsUriList, txId);\n+        List<Callable<Integer>> process = new LinkedList<>();\n+        for (int i = 0; i < mBatchSize; i++) {\n+          EventBatch batch = eventStream.poll(mActiveUfsPollTimeoutMs, TimeUnit.MILLISECONDS);\n+          if (batch == null) {\n+            break;\n           }\n+          EventBatch finalBatch = batch;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzI4NQ=="}, "originalCommit": {"oid": "78fd91ae391c4798106c6070f071c7f2fda33a3f"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDY5ODQ3OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTo1Mjo0NVrOGZkkMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOToxNTozNlrOGasnpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NjY3Mg==", "bodyText": "check return value and log errors?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r429466672", "createdAt": "2020-05-22T21:52:45Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -3103,19 +3118,18 @@ public void activeSyncMetadata(AlluxioURI path, Collection<AlluxioURI> changedFi\n     try (RpcContext rpcContext = createRpcContext()) {\n       if (changedFiles == null) {\n         // full sync\n-        long start = System.currentTimeMillis();\n-\n         // Set sync interval to 0 to force a sync.\n         FileSystemMasterCommonPOptions options =\n             FileSystemMasterCommonPOptions.newBuilder().setSyncIntervalMs(0).build();\n-        try {\n-          syncMetadata(rpcContext, path, options, DescendantType.ALL, null, null, null);\n-        } catch (AccessControlException e) {\n-          // This shouldn never happen because the permission check function is passed as null.\n-          LOG.error(\"Active sync full scan failed on {}\", path, e);\n+        LockingScheme scheme = createSyncLockingScheme(path, options, false);\n+        try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+          InodeSyncStream sync = new InodeSyncStream(inodePath, mActiveSyncMetadataExecutor, this,\n+              mInodeTree, mInodeStore, mInodeLockManager, mMountTable, rpcContext,\n+              DescendantType.ALL, mUfsSyncPathCache, options, false, false, false);\n+          sync.sync();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0NzIwNQ==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r430647205", "createdAt": "2020-05-26T19:15:36Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -3103,19 +3118,18 @@ public void activeSyncMetadata(AlluxioURI path, Collection<AlluxioURI> changedFi\n     try (RpcContext rpcContext = createRpcContext()) {\n       if (changedFiles == null) {\n         // full sync\n-        long start = System.currentTimeMillis();\n-\n         // Set sync interval to 0 to force a sync.\n         FileSystemMasterCommonPOptions options =\n             FileSystemMasterCommonPOptions.newBuilder().setSyncIntervalMs(0).build();\n-        try {\n-          syncMetadata(rpcContext, path, options, DescendantType.ALL, null, null, null);\n-        } catch (AccessControlException e) {\n-          // This shouldn never happen because the permission check function is passed as null.\n-          LOG.error(\"Active sync full scan failed on {}\", path, e);\n+        LockingScheme scheme = createSyncLockingScheme(path, options, false);\n+        try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+          InodeSyncStream sync = new InodeSyncStream(inodePath, mActiveSyncMetadataExecutor, this,\n+              mInodeTree, mInodeStore, mInodeLockManager, mMountTable, rpcContext,\n+              DescendantType.ALL, mUfsSyncPathCache, options, false, false, false);\n+          sync.sync();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NjY3Mg=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDcwMzU4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTo1Mzo1NlrOGZknZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOToxNTozMlrOGasnfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NzQ5NQ==", "bodyText": "check return value and log errors?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r429467495", "createdAt": "2020-05-22T21:53:56Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -3125,9 +3139,13 @@ public void activeSyncMetadata(AlluxioURI path, Collection<AlluxioURI> changedFi\n             // Set sync interval to 0 to force a sync.\n             FileSystemMasterCommonPOptions options =\n                 FileSystemMasterCommonPOptions.newBuilder().setSyncIntervalMs(0).build();\n-            try {\n-              syncMetadata(rpcContext, changedFile, options, DescendantType.ONE, null, null, null);\n-            } catch (InvalidPathException | AccessControlException e) {\n+            LockingScheme scheme = createSyncLockingScheme(changedFile, options, false);\n+            try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+              InodeSyncStream sync = new InodeSyncStream(inodePath, mActiveSyncMetadataExecutor,\n+                  this, mInodeTree, mInodeStore, mInodeLockManager, mMountTable, rpcContext,\n+                  DescendantType.NONE, mUfsSyncPathCache, options, false, false, false);\n+              sync.sync();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0NzE2NA==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r430647164", "createdAt": "2020-05-26T19:15:32Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -3125,9 +3139,13 @@ public void activeSyncMetadata(AlluxioURI path, Collection<AlluxioURI> changedFi\n             // Set sync interval to 0 to force a sync.\n             FileSystemMasterCommonPOptions options =\n                 FileSystemMasterCommonPOptions.newBuilder().setSyncIntervalMs(0).build();\n-            try {\n-              syncMetadata(rpcContext, changedFile, options, DescendantType.ONE, null, null, null);\n-            } catch (InvalidPathException | AccessControlException e) {\n+            LockingScheme scheme = createSyncLockingScheme(changedFile, options, false);\n+            try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+              InodeSyncStream sync = new InodeSyncStream(inodePath, mActiveSyncMetadataExecutor,\n+                  this, mInodeTree, mInodeStore, mInodeLockManager, mMountTable, rpcContext,\n+                  DescendantType.NONE, mUfsSyncPathCache, options, false, false, false);\n+              sync.sync();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NzQ5NQ=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDc0ODMxOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMjowOToxOFrOGZlEQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzozMDozMFrOGbgp-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDg4Mw==", "bodyText": "you might want to use computeIfAbsent or putIfAbsent to implement this?  otherwise k concurrent calls to this function with the same path might result in k ufs calls.   Using one of those methods ensures only one call to the UFS is made.", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r429474883", "createdAt": "2020-05-22T22:09:18Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -132,6 +132,37 @@ public UfsStatus getStatus(AlluxioURI path) {\n     return mStatuses.get(path);\n   }\n \n+  /**\n+   * Attempts to return a status from the cache. If it doesn't exist, reaches to the UFS for it.\n+   *\n+   * @param path the path the retrieve\n+   * @param mountTable the Alluxio mount table\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public UfsStatus fetchStatusIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    UfsStatus status = mStatuses.get(path);\n+    if (status != null) {\n+      return status;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NzQ1Ng==", "bodyText": "Unfortunately I can't with the current implementation or else it will result in deadlock. This function calls addStatus which actually does the insert into the map. Calling ConcurrentHashMap#put while within a computeIfAbsent function will deadlock", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r430567456", "createdAt": "2020-05-26T16:59:16Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -132,6 +132,37 @@ public UfsStatus getStatus(AlluxioURI path) {\n     return mStatuses.get(path);\n   }\n \n+  /**\n+   * Attempts to return a status from the cache. If it doesn't exist, reaches to the UFS for it.\n+   *\n+   * @param path the path the retrieve\n+   * @param mountTable the Alluxio mount table\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public UfsStatus fetchStatusIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    UfsStatus status = mStatuses.get(path);\n+    if (status != null) {\n+      return status;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDg4Mw=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MTQ3Mg==", "bodyText": "instead of calling addStatus perhaps you could just return the right value, which will result in the values being inserted into the map by computeIfAbsent right?", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r431441472", "createdAt": "2020-05-27T21:05:01Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -132,6 +132,37 @@ public UfsStatus getStatus(AlluxioURI path) {\n     return mStatuses.get(path);\n   }\n \n+  /**\n+   * Attempts to return a status from the cache. If it doesn't exist, reaches to the UFS for it.\n+   *\n+   * @param path the path the retrieve\n+   * @param mountTable the Alluxio mount table\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public UfsStatus fetchStatusIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    UfsStatus status = mStatuses.get(path);\n+    if (status != null) {\n+      return status;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDg4Mw=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MjE3MA==", "bodyText": "I use addStatus because it performs a check to make sure the status has the correct naming scheme.", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r431442170", "createdAt": "2020-05-27T21:06:27Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -132,6 +132,37 @@ public UfsStatus getStatus(AlluxioURI path) {\n     return mStatuses.get(path);\n   }\n \n+  /**\n+   * Attempts to return a status from the cache. If it doesn't exist, reaches to the UFS for it.\n+   *\n+   * @param path the path the retrieve\n+   * @param mountTable the Alluxio mount table\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public UfsStatus fetchStatusIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    UfsStatus status = mStatuses.get(path);\n+    if (status != null) {\n+      return status;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDg4Mw=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MjU3Mg==", "bodyText": "I guess I can refactor out the check and put it elsewhere. It just seems more error prone because then statuses could still be inserted without that check performed", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r431442572", "createdAt": "2020-05-27T21:07:16Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -132,6 +132,37 @@ public UfsStatus getStatus(AlluxioURI path) {\n     return mStatuses.get(path);\n   }\n \n+  /**\n+   * Attempts to return a status from the cache. If it doesn't exist, reaches to the UFS for it.\n+   *\n+   * @param path the path the retrieve\n+   * @param mountTable the Alluxio mount table\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public UfsStatus fetchStatusIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    UfsStatus status = mStatuses.get(path);\n+    if (status != null) {\n+      return status;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDg4Mw=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5OTc3MA==", "bodyText": "i see, sounds good to me", "url": "https://github.com/Alluxio/alluxio/pull/11449#discussion_r431499770", "createdAt": "2020-05-27T23:30:30Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -132,6 +132,37 @@ public UfsStatus getStatus(AlluxioURI path) {\n     return mStatuses.get(path);\n   }\n \n+  /**\n+   * Attempts to return a status from the cache. If it doesn't exist, reaches to the UFS for it.\n+   *\n+   * @param path the path the retrieve\n+   * @param mountTable the Alluxio mount table\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public UfsStatus fetchStatusIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    UfsStatus status = mStatuses.get(path);\n+    if (status != null) {\n+      return status;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDg4Mw=="}, "originalCommit": {"oid": "33f8a60a08b124e386817b7a2f9a02d21dd06863"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1765, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}