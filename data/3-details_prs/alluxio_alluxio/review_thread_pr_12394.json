{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMzM2OTE2", "number": 12394, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDo0NToxMlrOEz9Sxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjowNzoxOFrOE0kWgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTE3MDYyOnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDo0NToxMlrOHrf97A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzozNTozN1rOHsO7Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM3NDU3Mg==", "bodyText": "Can we add a CLI option for the user to be able to change this setting?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515374572", "createdAt": "2020-10-30T20:45:12Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0Mzk1MQ==", "bodyText": "This number is large enough and it hasn't actually mattered in distributedLoad case.", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516143951", "createdAt": "2020-11-02T17:35:37Z", "author": {"login": "bradyoo"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM3NDU3Mg=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTIwMTMxOnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDo1Njo1NVrOHrgQ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDo1Njo1NVrOHrgQ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM3OTQyNw==", "bodyText": "Do we need these variables anymore if this class extends AbstractDistributedJobCommand?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515379427", "createdAt": "2020-10-30T20:56:55Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -35,7 +43,11 @@\n  */\n @ThreadSafe\n @PublicApi\n-public final class DistributedCpCommand extends AbstractFileSystemCommand {\n+public class DistributedCpCommand extends AbstractDistributedJobCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  private int mActiveJobs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTIxODQwOnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTowMzo1N1rOHrgbJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo1MzowNVrOHsXAMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4MjA1NA==", "bodyText": "If this can throw an exception, should we try to catch it, to let the user know that the copy phase did not complete, so it might be in an inconsistent state?\nIf it is in an inconsistent state, what happens if we run distributedMv again?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515382054", "createdAt": "2020-10-30T21:03:57Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java", "diffHunk": "@@ -50,31 +44,22 @@ public String getCommandName() {\n \n   @Override\n   public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n-    CommandUtils.checkNumOfArgsEquals(this, cl, 2);\n+    mCpCommand.validateArgs(cl);\n   }\n \n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n+    mCpCommand.run(cl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0MTk2MA==", "bodyText": "distributedMv fails because overwrite is broken. But at the very least, you can delete the destination directory and then rerun distributedMv", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516141960", "createdAt": "2020-11-02T17:32:12Z", "author": {"login": "bradyoo"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java", "diffHunk": "@@ -50,31 +44,22 @@ public String getCommandName() {\n \n   @Override\n   public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n-    CommandUtils.checkNumOfArgsEquals(this, cl, 2);\n+    mCpCommand.validateArgs(cl);\n   }\n \n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n+    mCpCommand.run(cl);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4MjA1NA=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3NjI3Mg==", "bodyText": "Ok, but when the cp part fails, the user won't know what to do right? Should we catch this error, print out some instructions on what to do, and then re-throw the error, so we can show that they will have to delete the destination dir, and then rerun mv?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516276272", "createdAt": "2020-11-02T21:53:05Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java", "diffHunk": "@@ -50,31 +44,22 @@ public String getCommandName() {\n \n   @Override\n   public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n-    CommandUtils.checkNumOfArgsEquals(this, cl, 2);\n+    mCpCommand.validateArgs(cl);\n   }\n \n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n+    mCpCommand.run(cl);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4MjA1NA=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTIyODk1OnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTowODoyMFrOHrghrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTowODoyMFrOHrghrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4MzcyNQ==", "bodyText": "Is it intentional that this while loop is very tight? Can we add a sleep in here to avoid too much unnecessary cpu?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515383725", "createdAt": "2020-10-30T21:08:20Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+  }\n+\n+  protected void drain() {\n+    while (!mSubmittedJobAttempts.isEmpty()) {\n+      waitJob();\n+    }\n+  }\n+\n+  /**\n+   * Waits for at least one job to complete.\n+   */\n+  protected void waitJob() {\n+    AtomicBoolean removed = new AtomicBoolean(false);\n+    while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTI1OTYzOnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMToyMDo1MVrOHrgzbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzozMjo1MFrOHsO1AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4ODI3MQ==", "bodyText": "Did we always print out every file? This could be a huge output, if we are copying a large tree?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515388271", "createdAt": "2020-10-30T21:20:51Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -59,23 +71,85 @@ public int run(CommandLine cl) throws AlluxioException, IOException {\n     String[] args = cl.getArgs();\n     AlluxioURI srcPath = new AlluxioURI(args[0]);\n     AlluxioURI dstPath = new AlluxioURI(args[1]);\n-    Thread thread = CommonUtils.createProgressThread(2L * Constants.SECOND_MS, System.out);\n-    thread.start();\n-    try {\n-      AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n-      JobGrpcClientUtils.run(new MigrateConfig(srcPath.getPath(), dstPath.getPath(),\n-          conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT), true,\n-          false), 1, mFsContext.getPathConf(dstPath));\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      return -1;\n-    } finally {\n-      thread.interrupt();\n+\n+    if (PathUtils.hasPrefix(dstPath.toString(), srcPath.toString())) {\n+      throw new RuntimeException(ExceptionMessage.MIGRATE_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n+          srcPath, dstPath));\n     }\n-    System.out.println(\"Copied \" + srcPath + \" to \" + dstPath);\n+\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+\n+    AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n+    mWriteType = conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT);\n+\n+    distributedCp(srcPath, dstPath);\n     return 0;\n   }\n \n+  private CopyJobAttempt newJob(String srcPath, String dstPath) {\n+    CopyJobAttempt jobAttempt = new CopyJobAttempt(mClient,\n+        new MigrateConfig(srcPath, dstPath, mWriteType, true, false),\n+        new CountingRetry(3));\n+\n+    jobAttempt.run();\n+\n+    return jobAttempt;\n+  }\n+\n+  private void distributedCp(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+    if (mFileSystem.getStatus(srcPath).isFolder()) {\n+      createFolders(srcPath, dstPath);\n+    }\n+    copy(srcPath, dstPath);\n+    // Wait remaining jobs to complete.\n+    drain();\n+  }\n+\n+  private void createFolders(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+\n+    try {\n+      mFileSystem.createDirectory(dstPath);\n+      System.out.println(\"Created directory at \" + dstPath.getPath());\n+    } catch (FileAlreadyExistsException e) {\n+      if (!mFileSystem.getStatus(dstPath).isFolder()) {\n+        throw e;\n+      }\n+    }\n+\n+    for (URIStatus srcInnerStatus : mFileSystem.listStatus(srcPath)) {\n+      if (srcInnerStatus.isFolder()) {\n+        String dstInnerPath = computeTargetPath(srcInnerStatus.getPath(),\n+            srcPath.getPath(), dstPath.getPath());\n+        createFolders(new AlluxioURI(srcInnerStatus.getPath()), new AlluxioURI(dstInnerPath));\n+      }\n+    }\n+  }\n+\n+  private void copy(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+\n+    for (URIStatus srcInnerStatus : mFileSystem.listStatus(srcPath)) {\n+      String dstInnerPath = computeTargetPath(srcInnerStatus.getPath(),\n+          srcPath.getPath(), dstPath.getPath());\n+      if (srcInnerStatus.isFolder()) {\n+        copy(new AlluxioURI(srcInnerStatus.getPath()), new AlluxioURI(dstInnerPath));\n+      } else {\n+        addJob(srcInnerStatus.getPath(), dstInnerPath);\n+      }\n+    }\n+  }\n+\n+  private void addJob(String srcPath, String dstPath) {\n+    if (mSubmittedJobAttempts.size() >= mActiveJobs) {\n+      // Wait one job to complete.\n+      waitJob();\n+    }\n+    mSubmittedJobAttempts.add(newJob(srcPath, dstPath));\n+    System.out.println(\"Copying \" + srcPath + \" to \" + dstPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0MjMzNg==", "bodyText": "We didn't but we did for distributedLoad and that has been popular so choosing that instead.", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516142336", "createdAt": "2020-11-02T17:32:50Z", "author": {"login": "bradyoo"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -59,23 +71,85 @@ public int run(CommandLine cl) throws AlluxioException, IOException {\n     String[] args = cl.getArgs();\n     AlluxioURI srcPath = new AlluxioURI(args[0]);\n     AlluxioURI dstPath = new AlluxioURI(args[1]);\n-    Thread thread = CommonUtils.createProgressThread(2L * Constants.SECOND_MS, System.out);\n-    thread.start();\n-    try {\n-      AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n-      JobGrpcClientUtils.run(new MigrateConfig(srcPath.getPath(), dstPath.getPath(),\n-          conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT), true,\n-          false), 1, mFsContext.getPathConf(dstPath));\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      return -1;\n-    } finally {\n-      thread.interrupt();\n+\n+    if (PathUtils.hasPrefix(dstPath.toString(), srcPath.toString())) {\n+      throw new RuntimeException(ExceptionMessage.MIGRATE_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n+          srcPath, dstPath));\n     }\n-    System.out.println(\"Copied \" + srcPath + \" to \" + dstPath);\n+\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+\n+    AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n+    mWriteType = conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT);\n+\n+    distributedCp(srcPath, dstPath);\n     return 0;\n   }\n \n+  private CopyJobAttempt newJob(String srcPath, String dstPath) {\n+    CopyJobAttempt jobAttempt = new CopyJobAttempt(mClient,\n+        new MigrateConfig(srcPath, dstPath, mWriteType, true, false),\n+        new CountingRetry(3));\n+\n+    jobAttempt.run();\n+\n+    return jobAttempt;\n+  }\n+\n+  private void distributedCp(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+    if (mFileSystem.getStatus(srcPath).isFolder()) {\n+      createFolders(srcPath, dstPath);\n+    }\n+    copy(srcPath, dstPath);\n+    // Wait remaining jobs to complete.\n+    drain();\n+  }\n+\n+  private void createFolders(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+\n+    try {\n+      mFileSystem.createDirectory(dstPath);\n+      System.out.println(\"Created directory at \" + dstPath.getPath());\n+    } catch (FileAlreadyExistsException e) {\n+      if (!mFileSystem.getStatus(dstPath).isFolder()) {\n+        throw e;\n+      }\n+    }\n+\n+    for (URIStatus srcInnerStatus : mFileSystem.listStatus(srcPath)) {\n+      if (srcInnerStatus.isFolder()) {\n+        String dstInnerPath = computeTargetPath(srcInnerStatus.getPath(),\n+            srcPath.getPath(), dstPath.getPath());\n+        createFolders(new AlluxioURI(srcInnerStatus.getPath()), new AlluxioURI(dstInnerPath));\n+      }\n+    }\n+  }\n+\n+  private void copy(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+\n+    for (URIStatus srcInnerStatus : mFileSystem.listStatus(srcPath)) {\n+      String dstInnerPath = computeTargetPath(srcInnerStatus.getPath(),\n+          srcPath.getPath(), dstPath.getPath());\n+      if (srcInnerStatus.isFolder()) {\n+        copy(new AlluxioURI(srcInnerStatus.getPath()), new AlluxioURI(dstInnerPath));\n+      } else {\n+        addJob(srcInnerStatus.getPath(), dstInnerPath);\n+      }\n+    }\n+  }\n+\n+  private void addJob(String srcPath, String dstPath) {\n+    if (mSubmittedJobAttempts.size() >= mActiveJobs) {\n+      // Wait one job to complete.\n+      waitJob();\n+    }\n+    mSubmittedJobAttempts.add(newJob(srcPath, dstPath));\n+    System.out.println(\"Copying \" + srcPath + \" to \" + dstPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4ODI3MQ=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTI2NzgxOnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMToyNDozNVrOHrg4WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzozMzozM1rOHsO2dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4OTUyOQ==", "bodyText": "This is not threadsafe so we should add synchronized for this method.\nAlso, maybe rename to waitForCompleteJob?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515389529", "createdAt": "2020-10-30T21:24:35Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+  }\n+\n+  protected void drain() {\n+    while (!mSubmittedJobAttempts.isEmpty()) {\n+      waitJob();\n+    }\n+  }\n+\n+  /**\n+   * Waits for at least one job to complete.\n+   */\n+  protected void waitJob() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0MjcwOQ==", "bodyText": "This is a command. There is nothing threadsafe about anything in any of these series of classes.", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516142709", "createdAt": "2020-11-02T17:33:33Z", "author": {"login": "bradyoo"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+  }\n+\n+  protected void drain() {\n+    while (!mSubmittedJobAttempts.isEmpty()) {\n+      waitJob();\n+    }\n+  }\n+\n+  /**\n+   * Waits for at least one job to complete.\n+   */\n+  protected void waitJob() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM4OTUyOQ=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTI5MDY3OnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTozNDo1OFrOHrhGJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjowOTo0NFrOHsXeWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5MzA2Mw==", "bodyText": "createFolders does a listing, and copy also does a listing. Can we avoid doing a double recursive listing of the source?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r515393063", "createdAt": "2020-10-30T21:34:58Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -59,23 +71,85 @@ public int run(CommandLine cl) throws AlluxioException, IOException {\n     String[] args = cl.getArgs();\n     AlluxioURI srcPath = new AlluxioURI(args[0]);\n     AlluxioURI dstPath = new AlluxioURI(args[1]);\n-    Thread thread = CommonUtils.createProgressThread(2L * Constants.SECOND_MS, System.out);\n-    thread.start();\n-    try {\n-      AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n-      JobGrpcClientUtils.run(new MigrateConfig(srcPath.getPath(), dstPath.getPath(),\n-          conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT), true,\n-          false), 1, mFsContext.getPathConf(dstPath));\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      return -1;\n-    } finally {\n-      thread.interrupt();\n+\n+    if (PathUtils.hasPrefix(dstPath.toString(), srcPath.toString())) {\n+      throw new RuntimeException(ExceptionMessage.MIGRATE_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n+          srcPath, dstPath));\n     }\n-    System.out.println(\"Copied \" + srcPath + \" to \" + dstPath);\n+\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+\n+    AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n+    mWriteType = conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT);\n+\n+    distributedCp(srcPath, dstPath);\n     return 0;\n   }\n \n+  private CopyJobAttempt newJob(String srcPath, String dstPath) {\n+    CopyJobAttempt jobAttempt = new CopyJobAttempt(mClient,\n+        new MigrateConfig(srcPath, dstPath, mWriteType, true, false),\n+        new CountingRetry(3));\n+\n+    jobAttempt.run();\n+\n+    return jobAttempt;\n+  }\n+\n+  private void distributedCp(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+    if (mFileSystem.getStatus(srcPath).isFolder()) {\n+      createFolders(srcPath, dstPath);\n+    }\n+    copy(srcPath, dstPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0MzcwNg==", "bodyText": "I would prefer not because:\n\ncopy is expensive anyways so listStatus is a small cost here.\nMore intuitive log messages.", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516143706", "createdAt": "2020-11-02T17:35:09Z", "author": {"login": "bradyoo"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -59,23 +71,85 @@ public int run(CommandLine cl) throws AlluxioException, IOException {\n     String[] args = cl.getArgs();\n     AlluxioURI srcPath = new AlluxioURI(args[0]);\n     AlluxioURI dstPath = new AlluxioURI(args[1]);\n-    Thread thread = CommonUtils.createProgressThread(2L * Constants.SECOND_MS, System.out);\n-    thread.start();\n-    try {\n-      AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n-      JobGrpcClientUtils.run(new MigrateConfig(srcPath.getPath(), dstPath.getPath(),\n-          conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT), true,\n-          false), 1, mFsContext.getPathConf(dstPath));\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      return -1;\n-    } finally {\n-      thread.interrupt();\n+\n+    if (PathUtils.hasPrefix(dstPath.toString(), srcPath.toString())) {\n+      throw new RuntimeException(ExceptionMessage.MIGRATE_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n+          srcPath, dstPath));\n     }\n-    System.out.println(\"Copied \" + srcPath + \" to \" + dstPath);\n+\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+\n+    AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n+    mWriteType = conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT);\n+\n+    distributedCp(srcPath, dstPath);\n     return 0;\n   }\n \n+  private CopyJobAttempt newJob(String srcPath, String dstPath) {\n+    CopyJobAttempt jobAttempt = new CopyJobAttempt(mClient,\n+        new MigrateConfig(srcPath, dstPath, mWriteType, true, false),\n+        new CountingRetry(3));\n+\n+    jobAttempt.run();\n+\n+    return jobAttempt;\n+  }\n+\n+  private void distributedCp(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+    if (mFileSystem.getStatus(srcPath).isFolder()) {\n+      createFolders(srcPath, dstPath);\n+    }\n+    copy(srcPath, dstPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5MzA2Mw=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4Mzk5Mw==", "bodyText": "Could you explain why it is more intuitive with 2 listings, and why 1 listing cannot have good messages?\nOne concern is that if a listing is a large tree, it would have to lock that large tree twice. Ideally, we would only have to lock that subtree once.", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516283993", "createdAt": "2020-11-02T22:09:44Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -59,23 +71,85 @@ public int run(CommandLine cl) throws AlluxioException, IOException {\n     String[] args = cl.getArgs();\n     AlluxioURI srcPath = new AlluxioURI(args[0]);\n     AlluxioURI dstPath = new AlluxioURI(args[1]);\n-    Thread thread = CommonUtils.createProgressThread(2L * Constants.SECOND_MS, System.out);\n-    thread.start();\n-    try {\n-      AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n-      JobGrpcClientUtils.run(new MigrateConfig(srcPath.getPath(), dstPath.getPath(),\n-          conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT), true,\n-          false), 1, mFsContext.getPathConf(dstPath));\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      return -1;\n-    } finally {\n-      thread.interrupt();\n+\n+    if (PathUtils.hasPrefix(dstPath.toString(), srcPath.toString())) {\n+      throw new RuntimeException(ExceptionMessage.MIGRATE_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n+          srcPath, dstPath));\n     }\n-    System.out.println(\"Copied \" + srcPath + \" to \" + dstPath);\n+\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+\n+    AlluxioConfiguration conf = mFsContext.getPathConf(dstPath);\n+    mWriteType = conf.get(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT);\n+\n+    distributedCp(srcPath, dstPath);\n     return 0;\n   }\n \n+  private CopyJobAttempt newJob(String srcPath, String dstPath) {\n+    CopyJobAttempt jobAttempt = new CopyJobAttempt(mClient,\n+        new MigrateConfig(srcPath, dstPath, mWriteType, true, false),\n+        new CountingRetry(3));\n+\n+    jobAttempt.run();\n+\n+    return jobAttempt;\n+  }\n+\n+  private void distributedCp(AlluxioURI srcPath, AlluxioURI dstPath)\n+      throws IOException, AlluxioException {\n+    if (mFileSystem.getStatus(srcPath).isFolder()) {\n+      createFolders(srcPath, dstPath);\n+    }\n+    copy(srcPath, dstPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5MzA2Mw=="}, "originalCommit": {"oid": "8460fc49f281b1b99cab008f389df48e5c3ad21d"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTUyMzk0OnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo1MTo0NVrOHsW9zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo1MTo0NVrOHsW9zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3NTY2Mw==", "bodyText": "Can we just use the abstract class DEFAULT_ACTIVE_JOBS, instead of defining it again here?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516275663", "createdAt": "2020-11-02T21:51:45Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/DistributedCpCommand.java", "diffHunk": "@@ -35,7 +43,10 @@\n  */\n @ThreadSafe\n @PublicApi\n-public final class DistributedCpCommand extends AbstractFileSystemCommand {\n+public class DistributedCpCommand extends AbstractDistributedJobCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c20795c00f9dc77a0356cb6687730a2c1cc47836"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTU2OTk1OnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjowNzoxOFrOHsXZ4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxODozODoxOVrOHs7unQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4Mjg0OA==", "bodyText": "Is there a specific reason we need to loop so quickly? For example, if we loop every second, does that slow anything down unnecessarily?", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516282848", "createdAt": "2020-11-02T22:07:18Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.util.CommonUtils;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+  }\n+\n+  protected void drain() {\n+    while (!mSubmittedJobAttempts.isEmpty()) {\n+      waitJob();\n+    }\n+  }\n+\n+  /**\n+   * Waits for at least one job to complete.\n+   */\n+  protected void waitJob() {\n+    AtomicBoolean removed = new AtomicBoolean(false);\n+    while (true) {\n+      mSubmittedJobAttempts = mSubmittedJobAttempts.stream().filter((jobAttempt) -> {\n+        Status check = jobAttempt.check();\n+        switch (check) {\n+          case CREATED:\n+          case RUNNING:\n+            return true;\n+          case CANCELED:\n+          case COMPLETED:\n+            removed.set(true);\n+            return false;\n+          case FAILED:\n+            removed.set(true);\n+            return false;\n+          default:\n+            throw new IllegalStateException(String.format(\"Unexpected Status: %s\", check));\n+        }\n+      }).collect(Collectors.toList());\n+      if (removed.get()) {\n+        return;\n+      }\n+      CommonUtils.sleepMs(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c20795c00f9dc77a0356cb6687730a2c1cc47836"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwNzg5Mg==", "bodyText": "Second will be quite detrimental to the performance of this when copying lots of small files that were initially held back by a backlog of other jobs.", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516807892", "createdAt": "2020-11-03T16:44:07Z", "author": {"login": "bradyoo"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.util.CommonUtils;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+  }\n+\n+  protected void drain() {\n+    while (!mSubmittedJobAttempts.isEmpty()) {\n+      waitJob();\n+    }\n+  }\n+\n+  /**\n+   * Waits for at least one job to complete.\n+   */\n+  protected void waitJob() {\n+    AtomicBoolean removed = new AtomicBoolean(false);\n+    while (true) {\n+      mSubmittedJobAttempts = mSubmittedJobAttempts.stream().filter((jobAttempt) -> {\n+        Status check = jobAttempt.check();\n+        switch (check) {\n+          case CREATED:\n+          case RUNNING:\n+            return true;\n+          case CANCELED:\n+          case COMPLETED:\n+            removed.set(true);\n+            return false;\n+          case FAILED:\n+            removed.set(true);\n+            return false;\n+          default:\n+            throw new IllegalStateException(String.format(\"Unexpected Status: %s\", check));\n+        }\n+      }).collect(Collectors.toList());\n+      if (removed.get()) {\n+        return;\n+      }\n+      CommonUtils.sleepMs(5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4Mjg0OA=="}, "originalCommit": {"oid": "c20795c00f9dc77a0356cb6687730a2c1cc47836"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg3Nzk4MQ==", "bodyText": "ok, sounds good", "url": "https://github.com/Alluxio/alluxio/pull/12394#discussion_r516877981", "createdAt": "2020-11-03T18:38:19Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/fs/command/AbstractDistributedJobCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.cli.fs.command;\n+\n+import alluxio.ClientContext;\n+import alluxio.cli.fs.command.job.JobAttempt;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.client.job.JobMasterClient;\n+import alluxio.job.wire.Status;\n+import alluxio.util.CommonUtils;\n+import alluxio.worker.job.JobMasterClientContext;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The base class for all the distributed job based {@link alluxio.cli.Command} classes.\n+ * It provides handling for submitting multiple jobs and handling retries of them.\n+ */\n+public abstract class AbstractDistributedJobCommand extends AbstractFileSystemCommand {\n+  private static final int DEFAULT_ACTIVE_JOBS = 1000;\n+\n+  protected List<JobAttempt> mSubmittedJobAttempts;\n+  protected int mActiveJobs;\n+  protected final JobMasterClient mClient;\n+\n+  protected AbstractDistributedJobCommand(FileSystemContext fsContext) {\n+    super(fsContext);\n+    mSubmittedJobAttempts = Lists.newArrayList();\n+    final ClientContext clientContext = mFsContext.getClientContext();\n+    mClient = JobMasterClient.Factory.create(\n+        JobMasterClientContext.newBuilder(clientContext).build());\n+    mActiveJobs = DEFAULT_ACTIVE_JOBS;\n+  }\n+\n+  protected void drain() {\n+    while (!mSubmittedJobAttempts.isEmpty()) {\n+      waitJob();\n+    }\n+  }\n+\n+  /**\n+   * Waits for at least one job to complete.\n+   */\n+  protected void waitJob() {\n+    AtomicBoolean removed = new AtomicBoolean(false);\n+    while (true) {\n+      mSubmittedJobAttempts = mSubmittedJobAttempts.stream().filter((jobAttempt) -> {\n+        Status check = jobAttempt.check();\n+        switch (check) {\n+          case CREATED:\n+          case RUNNING:\n+            return true;\n+          case CANCELED:\n+          case COMPLETED:\n+            removed.set(true);\n+            return false;\n+          case FAILED:\n+            removed.set(true);\n+            return false;\n+          default:\n+            throw new IllegalStateException(String.format(\"Unexpected Status: %s\", check));\n+        }\n+      }).collect(Collectors.toList());\n+      if (removed.get()) {\n+        return;\n+      }\n+      CommonUtils.sleepMs(5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4Mjg0OA=="}, "originalCommit": {"oid": "c20795c00f9dc77a0356cb6687730a2c1cc47836"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1093, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}