{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNzg2MDky", "number": 12606, "reviewThreads": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoxNjoxMlrOFBAJRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo0Mjo1MlrOFDoKNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTk1MjY4OnYy", "diffSide": "RIGHT", "path": "conf/log4j.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoxNjoxMlrOH_kOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDo0ODoxN1rOH_nNuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNTgwMA==", "bodyText": "Is the big  fuse log size needed?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536415800", "createdAt": "2020-12-04T22:16:12Z", "author": {"login": "LuQQiu"}, "path": "conf/log4j.properties", "diffHunk": "@@ -172,7 +172,7 @@ log4j.appender.USER_LOGGER.layout.ConversionPattern=%d{ISO8601} %-5p %c{1} - %m%\n # Appender for Fuse\n log4j.appender.FUSE_LOGGER=org.apache.log4j.RollingFileAppender\n log4j.appender.FUSE_LOGGER.File=${alluxio.logs.dir}/fuse.log\n-log4j.appender.FUSE_LOGGER.MaxFileSize=10MB\n+log4j.appender.FUSE_LOGGER.MaxFileSize=500MB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NDgyNA==", "bodyText": "it turns out quite useful for debugging when set bigger.  I leave this to 100MB for now", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536464824", "createdAt": "2020-12-05T00:48:17Z", "author": {"login": "apc999"}, "path": "conf/log4j.properties", "diffHunk": "@@ -172,7 +172,7 @@ log4j.appender.USER_LOGGER.layout.ConversionPattern=%d{ISO8601} %-5p %c{1} - %m%\n # Appender for Fuse\n log4j.appender.FUSE_LOGGER=org.apache.log4j.RollingFileAppender\n log4j.appender.FUSE_LOGGER.File=${alluxio.logs.dir}/fuse.log\n-log4j.appender.FUSE_LOGGER.MaxFileSize=10MB\n+log4j.appender.FUSE_LOGGER.MaxFileSize=500MB", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNTgwMA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTk2Mjc3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoxOToyM1rOH_kTxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDo1NDoyMFrOH_nTFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNzIyMA==", "bodyText": "Can  be changed to a local variable", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536417220", "createdAt": "2020-12-04T22:19:23Z", "author": {"login": "LuQQiu"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -60,8 +61,9 @@\n   private final long mId;\n   /** The size in bytes of the block. */\n   private final long mLength;\n-\n+  private final FileSystemContext mContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NjE5Nw==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536466197", "createdAt": "2020-12-05T00:54:20Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -60,8 +61,9 @@\n   private final long mId;\n   /** The size in bytes of the block. */\n   private final long mLength;\n-\n+  private final FileSystemContext mContext;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNzIyMA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTk2NzQyOnYy", "diffSide": "RIGHT", "path": "conf/log4j.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoyMTowMFrOH_kWWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTowOTozNlrOH_nhew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNzg4MA==", "bodyText": "why is this changed to something so large?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536417880", "createdAt": "2020-12-04T22:21:00Z", "author": {"login": "gpang"}, "path": "conf/log4j.properties", "diffHunk": "@@ -172,7 +172,7 @@ log4j.appender.USER_LOGGER.layout.ConversionPattern=%d{ISO8601} %-5p %c{1} - %m%\n # Appender for Fuse\n log4j.appender.FUSE_LOGGER=org.apache.log4j.RollingFileAppender\n log4j.appender.FUSE_LOGGER.File=${alluxio.logs.dir}/fuse.log\n-log4j.appender.FUSE_LOGGER.MaxFileSize=10MB\n+log4j.appender.FUSE_LOGGER.MaxFileSize=500MB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2OTg4Mw==", "bodyText": "this is much easier for debugging currently. when using docker (most likely when playing with Fuse), it is hard to change it with makefile.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536469883", "createdAt": "2020-12-05T01:09:36Z", "author": {"login": "apc999"}, "path": "conf/log4j.properties", "diffHunk": "@@ -172,7 +172,7 @@ log4j.appender.USER_LOGGER.layout.ConversionPattern=%d{ISO8601} %-5p %c{1} - %m%\n # Appender for Fuse\n log4j.appender.FUSE_LOGGER=org.apache.log4j.RollingFileAppender\n log4j.appender.FUSE_LOGGER.File=${alluxio.logs.dir}/fuse.log\n-log4j.appender.FUSE_LOGGER.MaxFileSize=10MB\n+log4j.appender.FUSE_LOGGER.MaxFileSize=500MB", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNzg4MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTk4MDU1OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoyNTowNlrOH_kdYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTowMToyNlrOH_nZ9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxOTY4MA==", "bodyText": "This property is unused, can it be removed? The description is not very clear as well", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536419680", "createdAt": "2020-12-04T22:25:06Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4346,6 +4365,30 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey FUSE_JNIFUSE_ENABLED =\n+      new Builder(Name.FUSE_JNIFUSE_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Use experimental JNIFUSE library for better performance.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_SHARED_CACHING_READER_ENABLED =\n+      new Builder(Name.FUSE_SHARED_CACHING_READER_ENABLED)\n+          .setDefaultValue(false)\n+          .setDescription(\"(Experimental) Use share grpc data reader for better performance \"\n+              + \"on multi-process file reading through Alluxio JNI Fuse. \"\n+              + \"Blocks data will be cached on the client side \"\n+              + \"so more memory is required for the Fuse process.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_MAXCACHE_BYTES =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2Nzk1Ng==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536467956", "createdAt": "2020-12-05T01:01:26Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4346,6 +4365,30 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey FUSE_JNIFUSE_ENABLED =\n+      new Builder(Name.FUSE_JNIFUSE_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Use experimental JNIFUSE library for better performance.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_SHARED_CACHING_READER_ENABLED =\n+      new Builder(Name.FUSE_SHARED_CACHING_READER_ENABLED)\n+          .setDefaultValue(false)\n+          .setDescription(\"(Experimental) Use share grpc data reader for better performance \"\n+              + \"on multi-process file reading through Alluxio JNI Fuse. \"\n+              + \"Blocks data will be cached on the client side \"\n+              + \"so more memory is required for the Fuse process.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_MAXCACHE_BYTES =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxOTY4MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTk4MzI5OnYy", "diffSide": "RIGHT", "path": "integration/docker/Dockerfile.fuse", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjoyNTo1N1rOH_ke5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMjo0NjowOVrOIA-Q-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMDA3MA==", "bodyText": "Can alluxio dockerhub directly  host the image?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536420070", "createdAt": "2020-12-04T22:25:57Z", "author": {"login": "LuQQiu"}, "path": "integration/docker/Dockerfile.fuse", "diffHunk": "@@ -35,18 +35,23 @@ RUN if [ ${ENABLE_DYNAMIC_USER} = \"true\" ] ; then \\\n        chmod -R 777 /opt/* ; \\\n     fi\n \n-FROM ubuntu:16.04\n+# instead of ubuntu:16.04, use cheyang/fuse2:ubuntu1604-customize for now\n+# which has customized libfuse installed\n+# to use standard ubuntu1604, add \"fuse\" to the list of \"apt-get install\"\n+FROM cheyang/fuse2:ubuntu1604-customize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1OTMxNA==", "bodyText": "will do", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536459314", "createdAt": "2020-12-05T00:26:28Z", "author": {"login": "apc999"}, "path": "integration/docker/Dockerfile.fuse", "diffHunk": "@@ -35,18 +35,23 @@ RUN if [ ${ENABLE_DYNAMIC_USER} = \"true\" ] ; then \\\n        chmod -R 777 /opt/* ; \\\n     fi\n \n-FROM ubuntu:16.04\n+# instead of ubuntu:16.04, use cheyang/fuse2:ubuntu1604-customize for now\n+# which has customized libfuse installed\n+# to use standard ubuntu1604, add \"fuse\" to the list of \"apt-get install\"\n+FROM cheyang/fuse2:ubuntu1604-customize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMDA3MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDg5MQ==", "bodyText": "Can be updated to alluxio/alluxio-ubuntu:1604-customize", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r537890891", "createdAt": "2020-12-07T22:45:46Z", "author": {"login": "LuQQiu"}, "path": "integration/docker/Dockerfile.fuse", "diffHunk": "@@ -35,18 +35,23 @@ RUN if [ ${ENABLE_DYNAMIC_USER} = \"true\" ] ; then \\\n        chmod -R 777 /opt/* ; \\\n     fi\n \n-FROM ubuntu:16.04\n+# instead of ubuntu:16.04, use cheyang/fuse2:ubuntu1604-customize for now\n+# which has customized libfuse installed\n+# to use standard ubuntu1604, add \"fuse\" to the list of \"apt-get install\"\n+FROM cheyang/fuse2:ubuntu1604-customize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMDA3MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MTA2NQ==", "bodyText": "https://hub.docker.com/repository/docker/alluxio/alluxio-ubuntu/tags?page=1&ordering=last_updated", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r537891065", "createdAt": "2020-12-07T22:46:09Z", "author": {"login": "LuQQiu"}, "path": "integration/docker/Dockerfile.fuse", "diffHunk": "@@ -35,18 +35,23 @@ RUN if [ ${ENABLE_DYNAMIC_USER} = \"true\" ] ; then \\\n        chmod -R 777 /opt/* ; \\\n     fi\n \n-FROM ubuntu:16.04\n+# instead of ubuntu:16.04, use cheyang/fuse2:ubuntu1604-customize for now\n+# which has customized libfuse installed\n+# to use standard ubuntu1604, add \"fuse\" to the list of \"apt-get install\"\n+FROM cheyang/fuse2:ubuntu1604-customize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMDA3MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTk5NjUwOnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjozMDowOVrOH_kl6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTowODowN1rOH_ngKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMTg2Ng==", "bodyText": "Are we using kernel_cache now?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536421866", "createdAt": "2020-12-04T22:30:09Z", "author": {"login": "LuQQiu"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java", "diffHunk": "@@ -41,51 +47,107 @@\n public final class AlluxioFuse {\n   private static final Logger LOG = LoggerFactory.getLogger(AlluxioFuse.class);\n \n+  private static final Option MOUNT_POINT_OPTION = Option.builder(\"m\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"mount-point\")\n+      .desc(\"Desired local mount point for alluxio-fuse.\")\n+      .build();\n+\n+  private static final Option ALLUXIO_ROOT_OPTION = Option.builder(\"r\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"alluxio-root\")\n+      .desc(\"Path within alluxio that will be used as the root of the FUSE mount \"\n+          + \"(e.g., /users/foo; defaults to /)\")\n+      .build();\n+\n+  private static final Option HELP_OPTION = Option.builder(\"h\")\n+      .required(false)\n+      .desc(\"Print this help message\")\n+      .build();\n+\n+  private static final Option FUSE_MOUNT_OPTION = Option.builder(\"o\")\n+      .valueSeparator(',')\n+      .required(false)\n+      .hasArgs()\n+      .desc(\"FUSE mount options\")\n+      .build();\n+\n+  private static final Options OPTIONS = new Options()\n+      .addOption(MOUNT_POINT_OPTION)\n+      .addOption(ALLUXIO_ROOT_OPTION)\n+      .addOption(HELP_OPTION)\n+      .addOption(FUSE_MOUNT_OPTION);\n+\n   // prevent instantiation\n   private AlluxioFuse() {}\n \n   /**\n-   * Running this class will mount the file system according to\n-   * the options passed to this function {@link #parseOptions(String[], AlluxioConfiguration)}.\n-   * The user-space fuse application will stay on the foreground and keep\n-   * the file system mounted. The user can unmount the file system by\n-   * gracefully killing (SIGINT) the process.\n+   * Running this class will mount the file system according to the options passed to this function\n+   * {@link #parseOptions(String[], AlluxioConfiguration)}. The user-space fuse application will\n+   * stay on the foreground and keep the file system mounted. The user can unmount the file system\n+   * by gracefully killing (SIGINT) the process.\n    *\n    * @param args arguments to run the command line\n    */\n   public static void main(String[] args) {\n-    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    LOG.info(\"Alluxio version: {}-{}\", RuntimeConstants.VERSION, ProjectConstants.REVISION);\n+    AlluxioConfiguration conf = InstancedConfiguration.defaults();\n+    FileSystemContext fsContext = FileSystemContext.create(conf);\n+    try {\n+      InetSocketAddress confMasterAddress =\n+          fsContext.getMasterClientContext().getConfMasterInquireClient().getPrimaryRpcAddress();\n+      RetryUtils.retry(\"load cluster default configuration with master \" + confMasterAddress,\n+          () -> fsContext.getClientContext().loadConfIfNotLoaded(confMasterAddress),\n+          RetryUtils.defaultClientRetry(\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_DURATION),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS)));\n+    } catch (IOException e) {\n+      LOG.warn(\"Failed to load cluster default configuration for Fuse process. \"\n+          + \"Proceed with local configuration for FUSE: {}\", e.toString());\n+    }\n+    conf = fsContext.getClusterConf();\n     final AlluxioFuseOptions opts = parseOptions(args, conf);\n     if (opts == null) {\n       System.exit(1);\n     }\n-\n-    final FileSystem tfs = FileSystem.Factory.create(conf);\n-    final AlluxioFuseFileSystem fs = new AlluxioFuseFileSystem(tfs, opts, conf);\n-    final List<String> fuseOpts = opts.getFuseOpts();\n-    // Force direct_io in FUSE: writes and reads bypass the kernel page\n-    // cache and go directly to alluxio. This avoids extra memory copies\n-    // in the write path.\n-    fuseOpts.add(\"-odirect_io\");\n-\n-    try {\n-      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n-          fuseOpts.toArray(new String[0]));\n-      LOG.info(\"Mounted Alluxio: mount point=\\\"{}\\\", opts=\\\"{}\\\"\",\n-          opts.getMountPoint(), fuseOpts.toArray(new String[0]));\n-    } catch (FuseException e) {\n-      LOG.error(\"Failed to mount {}\", opts.getMountPoint(), e);\n-      // only try to umount file system when exception occurred.\n-      // jnr-fuse registers JVM shutdown hook to ensure fs.umount()\n-      // will be executed when this process is exiting.\n-      fs.umount();\n-    } finally {\n-      try {\n-        tfs.close();\n-        LOG.info(\"Closed Alluxio file system.\");\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to close Alluxio file system\", e);\n+    try (final FileSystem fs = FileSystem.Factory.create(fsContext)) {\n+      final List<String> fuseOpts = opts.getFuseOpts();\n+      // Force direct_io in FUSE: writes and reads bypass the kernel page\n+      // cache and go directly to alluxio. This avoids extra memory copies\n+      // in the write path.\n+      // TODO(binfan): support kernel_cache (issues#10840)\n+      //fuseOpts.add(\"-odirect_io\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2OTU0Ng==", "bodyText": "yes kernel cache can be supported now. I didn't set it here though.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536469546", "createdAt": "2020-12-05T01:08:07Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java", "diffHunk": "@@ -41,51 +47,107 @@\n public final class AlluxioFuse {\n   private static final Logger LOG = LoggerFactory.getLogger(AlluxioFuse.class);\n \n+  private static final Option MOUNT_POINT_OPTION = Option.builder(\"m\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"mount-point\")\n+      .desc(\"Desired local mount point for alluxio-fuse.\")\n+      .build();\n+\n+  private static final Option ALLUXIO_ROOT_OPTION = Option.builder(\"r\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"alluxio-root\")\n+      .desc(\"Path within alluxio that will be used as the root of the FUSE mount \"\n+          + \"(e.g., /users/foo; defaults to /)\")\n+      .build();\n+\n+  private static final Option HELP_OPTION = Option.builder(\"h\")\n+      .required(false)\n+      .desc(\"Print this help message\")\n+      .build();\n+\n+  private static final Option FUSE_MOUNT_OPTION = Option.builder(\"o\")\n+      .valueSeparator(',')\n+      .required(false)\n+      .hasArgs()\n+      .desc(\"FUSE mount options\")\n+      .build();\n+\n+  private static final Options OPTIONS = new Options()\n+      .addOption(MOUNT_POINT_OPTION)\n+      .addOption(ALLUXIO_ROOT_OPTION)\n+      .addOption(HELP_OPTION)\n+      .addOption(FUSE_MOUNT_OPTION);\n+\n   // prevent instantiation\n   private AlluxioFuse() {}\n \n   /**\n-   * Running this class will mount the file system according to\n-   * the options passed to this function {@link #parseOptions(String[], AlluxioConfiguration)}.\n-   * The user-space fuse application will stay on the foreground and keep\n-   * the file system mounted. The user can unmount the file system by\n-   * gracefully killing (SIGINT) the process.\n+   * Running this class will mount the file system according to the options passed to this function\n+   * {@link #parseOptions(String[], AlluxioConfiguration)}. The user-space fuse application will\n+   * stay on the foreground and keep the file system mounted. The user can unmount the file system\n+   * by gracefully killing (SIGINT) the process.\n    *\n    * @param args arguments to run the command line\n    */\n   public static void main(String[] args) {\n-    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    LOG.info(\"Alluxio version: {}-{}\", RuntimeConstants.VERSION, ProjectConstants.REVISION);\n+    AlluxioConfiguration conf = InstancedConfiguration.defaults();\n+    FileSystemContext fsContext = FileSystemContext.create(conf);\n+    try {\n+      InetSocketAddress confMasterAddress =\n+          fsContext.getMasterClientContext().getConfMasterInquireClient().getPrimaryRpcAddress();\n+      RetryUtils.retry(\"load cluster default configuration with master \" + confMasterAddress,\n+          () -> fsContext.getClientContext().loadConfIfNotLoaded(confMasterAddress),\n+          RetryUtils.defaultClientRetry(\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_DURATION),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS)));\n+    } catch (IOException e) {\n+      LOG.warn(\"Failed to load cluster default configuration for Fuse process. \"\n+          + \"Proceed with local configuration for FUSE: {}\", e.toString());\n+    }\n+    conf = fsContext.getClusterConf();\n     final AlluxioFuseOptions opts = parseOptions(args, conf);\n     if (opts == null) {\n       System.exit(1);\n     }\n-\n-    final FileSystem tfs = FileSystem.Factory.create(conf);\n-    final AlluxioFuseFileSystem fs = new AlluxioFuseFileSystem(tfs, opts, conf);\n-    final List<String> fuseOpts = opts.getFuseOpts();\n-    // Force direct_io in FUSE: writes and reads bypass the kernel page\n-    // cache and go directly to alluxio. This avoids extra memory copies\n-    // in the write path.\n-    fuseOpts.add(\"-odirect_io\");\n-\n-    try {\n-      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n-          fuseOpts.toArray(new String[0]));\n-      LOG.info(\"Mounted Alluxio: mount point=\\\"{}\\\", opts=\\\"{}\\\"\",\n-          opts.getMountPoint(), fuseOpts.toArray(new String[0]));\n-    } catch (FuseException e) {\n-      LOG.error(\"Failed to mount {}\", opts.getMountPoint(), e);\n-      // only try to umount file system when exception occurred.\n-      // jnr-fuse registers JVM shutdown hook to ensure fs.umount()\n-      // will be executed when this process is exiting.\n-      fs.umount();\n-    } finally {\n-      try {\n-        tfs.close();\n-        LOG.info(\"Closed Alluxio file system.\");\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to close Alluxio file system\", e);\n+    try (final FileSystem fs = FileSystem.Factory.create(fsContext)) {\n+      final List<String> fuseOpts = opts.getFuseOpts();\n+      // Force direct_io in FUSE: writes and reads bypass the kernel page\n+      // cache and go directly to alluxio. This avoids extra memory copies\n+      // in the write path.\n+      // TODO(binfan): support kernel_cache (issues#10840)\n+      //fuseOpts.add(\"-odirect_io\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMTg2Ng=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA0OTM4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjo0ODowMVrOH_lCOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMToxMDoxNFrOH_nh9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyOTExMw==", "bodyText": "Can we use !mResponses .isEmpty()?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536429113", "createdAt": "2020-12-04T22:48:01Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -216,6 +216,13 @@ public ResT receive(long timeoutMs) throws IOException {\n     }\n   }\n \n+  /**\n+   * @return true if the current stream has responses received but hasn't processed\n+   */\n+  public boolean hasResponseInCache() {\n+    return mResponses.size() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3MDAwNg==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536470006", "createdAt": "2020-12-05T01:10:14Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -216,6 +216,13 @@ public ResT receive(long timeoutMs) throws IOException {\n     }\n   }\n \n+  /**\n+   * @return true if the current stream has responses received but hasn't processed\n+   */\n+  public boolean hasResponseInCache() {\n+    return mResponses.size() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyOTExMw=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA1NjYwOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjo1MDozMlrOH_lGHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMToxOToyMVrOH_nqLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDEwOA==", "bodyText": "I'm not really sure what this means. How can it read from the first dir in the first tier if the block is not in that dir?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536430108", "createdAt": "2020-12-04T22:50:32Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,16 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)\n+          .setDefaultValue(false)\n+          .setIsHidden(true)\n+          .setDescription(\"(Experimental) If this is enabled, when clients read from local \"\n+              + \"worker, they read the block directly from the first directory of the first \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3MjEwOA==", "bodyText": "more details added. note that, this is a hidden property, requested by Alibaba", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536472108", "createdAt": "2020-12-05T01:19:21Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,16 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)\n+          .setDefaultValue(false)\n+          .setIsHidden(true)\n+          .setDescription(\"(Experimental) If this is enabled, when clients read from local \"\n+              + \"worker, they read the block directly from the first directory of the first \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDEwOA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA1NzIxOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjo1MDo0OFrOH_lGbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMToxOTozMFrOH_nqTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDE5MA==", "bodyText": "What implications are there for this \"unsafe\" behavior?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536430190", "createdAt": "2020-12-04T22:50:48Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,16 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)\n+          .setDefaultValue(false)\n+          .setIsHidden(true)\n+          .setDescription(\"(Experimental) If this is enabled, when clients read from local \"\n+              + \"worker, they read the block directly from the first directory of the first \"\n+              + \"tier of that worker. Note this optimization can be unsafe.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3MjE0MA==", "bodyText": "implication added.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536472140", "createdAt": "2020-12-05T01:19:30Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,16 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)\n+          .setDefaultValue(false)\n+          .setIsHidden(true)\n+          .setDescription(\"(Experimental) If this is enabled, when clients read from local \"\n+              + \"worker, they read the block directly from the first directory of the first \"\n+              + \"tier of that worker. Note this optimization can be unsafe.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDE5MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA2MTk0OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjo1MjoyM1rOH_lI4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMToxOTo0NVrOH_nqcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDgxNw==", "bodyText": "What is this caching? Is it related to the shared grpc readers?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536430817", "createdAt": "2020-12-04T22:52:23Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4346,6 +4365,30 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey FUSE_JNIFUSE_ENABLED =\n+      new Builder(Name.FUSE_JNIFUSE_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Use experimental JNIFUSE library for better performance.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_SHARED_CACHING_READER_ENABLED =\n+      new Builder(Name.FUSE_SHARED_CACHING_READER_ENABLED)\n+          .setDefaultValue(false)\n+          .setDescription(\"(Experimental) Use share grpc data reader for better performance \"\n+              + \"on multi-process file reading through Alluxio JNI Fuse. \"\n+              + \"Blocks data will be cached on the client side \"\n+              + \"so more memory is required for the Fuse process.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_MAXCACHE_BYTES =\n+      new Builder(Name.FUSE_MAXCACHE_BYTES)\n+          .setDefaultValue(\"1MB\")\n+          .setDescription(\"(Experimental) Maximum cache size of AlluxioJniFuse.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3MjE3OQ==", "bodyText": "this propertykey is removed.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536472179", "createdAt": "2020-12-05T01:19:45Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4346,6 +4365,30 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey FUSE_JNIFUSE_ENABLED =\n+      new Builder(Name.FUSE_JNIFUSE_ENABLED)\n+          .setDefaultValue(true)\n+          .setDescription(\"Use experimental JNIFUSE library for better performance.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_SHARED_CACHING_READER_ENABLED =\n+      new Builder(Name.FUSE_SHARED_CACHING_READER_ENABLED)\n+          .setDefaultValue(false)\n+          .setDescription(\"(Experimental) Use share grpc data reader for better performance \"\n+              + \"on multi-process file reading through Alluxio JNI Fuse. \"\n+              + \"Blocks data will be cached on the client side \"\n+              + \"so more memory is required for the Fuse process.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  public static final PropertyKey FUSE_MAXCACHE_BYTES =\n+      new Builder(Name.FUSE_MAXCACHE_BYTES)\n+          .setDefaultValue(\"1MB\")\n+          .setDescription(\"(Experimental) Maximum cache size of AlluxioJniFuse.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMDgxNw=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA2NDc0OnYy", "diffSide": "RIGHT", "path": "integration/docker/Dockerfile.fuse", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjo1MzoyN1rOH_lKVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMToyMDozMVrOH_nrMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMTE4OQ==", "bodyText": "We are not able to just install the libfuse library?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536431189", "createdAt": "2020-12-04T22:53:27Z", "author": {"login": "gpang"}, "path": "integration/docker/Dockerfile.fuse", "diffHunk": "@@ -35,18 +35,23 @@ RUN if [ ${ENABLE_DYNAMIC_USER} = \"true\" ] ; then \\\n        chmod -R 777 /opt/* ; \\\n     fi\n \n-FROM ubuntu:16.04\n+# instead of ubuntu:16.04, use cheyang/fuse2:ubuntu1604-customize for now\n+# which has customized libfuse installed\n+# to use standard ubuntu1604, add \"fuse\" to the list of \"apt-get install\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3MjM2OQ==", "bodyText": "this fuse2:ubuntu1604-customiz image has customized libfuse", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536472369", "createdAt": "2020-12-05T01:20:31Z", "author": {"login": "apc999"}, "path": "integration/docker/Dockerfile.fuse", "diffHunk": "@@ -35,18 +35,23 @@ RUN if [ ${ENABLE_DYNAMIC_USER} = \"true\" ] ; then \\\n        chmod -R 777 /opt/* ; \\\n     fi\n \n-FROM ubuntu:16.04\n+# instead of ubuntu:16.04, use cheyang/fuse2:ubuntu1604-customize for now\n+# which has customized libfuse installed\n+# to use standard ubuntu1604, add \"fuse\" to the list of \"apt-get install\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMTE4OQ=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA4Mjc4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjo1OToyOFrOH_lTww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMToyNjo0M1rOH_nwVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMzYwMw==", "bodyText": "Is this a bug to get a null client?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536433603", "createdAt": "2020-12-04T22:59:28Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "diffHunk": "@@ -538,6 +538,9 @@ public void close() {\n   private static void releaseBlockWorkerClient(WorkerNetAddress workerNetAddress,\n       BlockWorkerClient client, final ClientContext context, ConcurrentHashMap<ClientPoolKey,\n       BlockWorkerClientPool> poolMap) {\n+    if (client == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3MzY4Ng==", "bodyText": "I think this is to prevent nullptr when USER_DIRECT_MEMORY_IO_ENABLED", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536473686", "createdAt": "2020-12-05T01:26:43Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "diffHunk": "@@ -538,6 +538,9 @@ public void close() {\n   private static void releaseBlockWorkerClient(WorkerNetAddress workerNetAddress,\n       BlockWorkerClient client, final ClientContext context, ConcurrentHashMap<ClientPoolKey,\n       BlockWorkerClientPool> poolMap) {\n+    if (client == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMzYwMw=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA4OTU5OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzowMTo0MFrOH_lXMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTo0NDoxMVrOH_n98w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNDQ4Mg==", "bodyText": "Is this ((blockSize > (chunkSize * 4)) some heuristic? What is the thinking behind this?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536434482", "createdAt": "2020-12-04T23:01:40Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -177,10 +179,16 @@ private static BlockInStream createGrpcBlockInStream(FileSystemContext context,\n     long chunkSize = context.getClusterConf().getBytes(\n         PropertyKey.USER_STREAMING_READER_CHUNK_SIZE_BYTES);\n     readRequestBuilder.setChunkSize(chunkSize);\n-    DataReader.Factory factory =\n-        new GrpcDataReader.Factory(context, address, readRequestBuilder.build());\n-    return new BlockInStream(factory, address, blockSource, readRequestPartial.getBlockId(),\n-        blockSize);\n+    DataReader.Factory factory;\n+    if (context.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)\n+        && (blockSize > (chunkSize * 4))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3NzE3MQ==", "bodyText": "yes this is a heuristic motivated by tests done by MSFT and verified & contributed by them too.\nessentially, for concurrent reads for the same large file through FUSE, the reads likely ended up at different FileInputStream, and introduce frequent blockInStream construction & destruction, causing performance down by 100x.\nthis fix can effectively mitigate this issue. Note that, this heuristic is always guarded by the flag. More comments added", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536477171", "createdAt": "2020-12-05T01:44:11Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -177,10 +179,16 @@ private static BlockInStream createGrpcBlockInStream(FileSystemContext context,\n     long chunkSize = context.getClusterConf().getBytes(\n         PropertyKey.USER_STREAMING_READER_CHUNK_SIZE_BYTES);\n     readRequestBuilder.setChunkSize(chunkSize);\n-    DataReader.Factory factory =\n-        new GrpcDataReader.Factory(context, address, readRequestBuilder.build());\n-    return new BlockInStream(factory, address, blockSource, readRequestPartial.getBlockId(),\n-        blockSize);\n+    DataReader.Factory factory;\n+    if (context.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)\n+        && (blockSize > (chunkSize * 4))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNDQ4Mg=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjA5MzYyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzowMzoyNFrOH_lZWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTo1NTowNlrOH_oGbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNTAzMw==", "bodyText": "I think this comment is confusing? The flag is about using the shared grpc reader, so this comment is talking about a fuse flag.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536435033", "createdAt": "2020-12-04T23:03:24Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -327,11 +340,54 @@ public void seek(long pos) throws IOException {\n     if (pos == mPos) {\n       return;\n     }\n+    // Protect the original seek logic under fuse flag to minimize and isolate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3OTM0MQ==", "bodyText": "clarified.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536479341", "createdAt": "2020-12-05T01:55:06Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -327,11 +340,54 @@ public void seek(long pos) throws IOException {\n     if (pos == mPos) {\n       return;\n     }\n+    // Protect the original seek logic under fuse flag to minimize and isolate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNTAzMw=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjExMDkxOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzowOTo1MlrOH_liUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0MjozNVrOICI0aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNzMyOQ==", "bodyText": "This block looks like the seek logic for when we are NOT using the shared grpc reader. Is there a reason why we cannot just have 2 types of seek logic (1) using shared grpc reader, (2) without shared grpc reader?\nInstead, we have 3 types of seek logic now.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536437329", "createdAt": "2020-12-04T23:09:52Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -327,11 +340,54 @@ public void seek(long pos) throws IOException {\n     if (pos == mPos) {\n       return;\n     }\n+    // Protect the original seek logic under fuse flag to minimize and isolate\n+    // the fuse related changes\n+    if (!mSharedCacheReader) {\n+      if (pos < mPos) {\n+        mEOF = false;\n+      }\n+      closeDataReader();\n+      mPos = pos;\n+      return;\n+    }\n+\n     if (pos < mPos) {\n       mEOF = false;\n-    }\n+      if (mDataReader instanceof SharedGrpcDataReader) {\n+        SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else {\n+      // TODO(lu) combine the original seek logic and the following general improvements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNTY0OQ==", "bodyText": "put the newly added two seek logic separately guarded by the flag.\nin this way we introduce minimal change to existing codepath", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536515649", "createdAt": "2020-12-05T05:09:32Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -327,11 +340,54 @@ public void seek(long pos) throws IOException {\n     if (pos == mPos) {\n       return;\n     }\n+    // Protect the original seek logic under fuse flag to minimize and isolate\n+    // the fuse related changes\n+    if (!mSharedCacheReader) {\n+      if (pos < mPos) {\n+        mEOF = false;\n+      }\n+      closeDataReader();\n+      mPos = pos;\n+      return;\n+    }\n+\n     if (pos < mPos) {\n       mEOF = false;\n-    }\n+      if (mDataReader instanceof SharedGrpcDataReader) {\n+        SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else {\n+      // TODO(lu) combine the original seek logic and the following general improvements", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNzMyOQ=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMjU1Mg==", "bodyText": "I changed the code a bit. so this code path is only executed when mDataReader instanceof SharedGrpcDataReader", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r539112552", "createdAt": "2020-12-09T08:42:35Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -327,11 +340,54 @@ public void seek(long pos) throws IOException {\n     if (pos == mPos) {\n       return;\n     }\n+    // Protect the original seek logic under fuse flag to minimize and isolate\n+    // the fuse related changes\n+    if (!mSharedCacheReader) {\n+      if (pos < mPos) {\n+        mEOF = false;\n+      }\n+      closeDataReader();\n+      mPos = pos;\n+      return;\n+    }\n+\n     if (pos < mPos) {\n       mEOF = false;\n-    }\n+      if (mDataReader instanceof SharedGrpcDataReader) {\n+        SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else {\n+      // TODO(lu) combine the original seek logic and the following general improvements", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzNzMyOQ=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjExNzEzOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoxMjoxNVrOH_llng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMjowNTozNlrOH_oOLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzODE3NA==", "bodyText": "Is it required that this path is ramdisk? What happens with an SSD top-tier?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536438174", "createdAt": "2020-12-04T23:12:15Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java", "diffHunk": "@@ -122,6 +128,17 @@ public Factory(FileSystemContext context, WorkerNetAddress address, long blockId\n       mLocalReaderChunkSize = localReaderChunkSize;\n       mReadBufferSize = conf.getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n       mDataTimeoutMs = conf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+      boolean isDirectMemoryIOEnabled = conf.getBoolean(PropertyKey.USER_DIRECT_MEMORY_IO_ENABLED);\n+      if (isDirectMemoryIOEnabled) {\n+        mBlockWorker = null;\n+        mStream = null;\n+        PropertyKey tierDirPathConf =\n+            PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(0);\n+        String ramdiskPath = conf.get(tierDirPathConf).split(\",\")[0];\n+        String workerDir = conf.get(PropertyKey.WORKER_DATA_FOLDER);\n+        mPath = Paths.get(ramdiskPath, workerDir, Long.toString(blockId)).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ4MTMyNg==", "bodyText": "toptier. name changed", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536481326", "createdAt": "2020-12-05T02:05:36Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java", "diffHunk": "@@ -122,6 +128,17 @@ public Factory(FileSystemContext context, WorkerNetAddress address, long blockId\n       mLocalReaderChunkSize = localReaderChunkSize;\n       mReadBufferSize = conf.getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n       mDataTimeoutMs = conf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+      boolean isDirectMemoryIOEnabled = conf.getBoolean(PropertyKey.USER_DIRECT_MEMORY_IO_ENABLED);\n+      if (isDirectMemoryIOEnabled) {\n+        mBlockWorker = null;\n+        mStream = null;\n+        PropertyKey tierDirPathConf =\n+            PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(0);\n+        String ramdiskPath = conf.get(tierDirPathConf).split(\",\")[0];\n+        String workerDir = conf.get(PropertyKey.WORKER_DATA_FOLDER);\n+        mPath = Paths.get(ramdiskPath, workerDir, Long.toString(blockId)).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzODE3NA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjEyMTA0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoxNDowMVrOH_lnzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNDo0NTo1N1rOH_qG0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzODczMg==", "bodyText": "It is strange to me that something called BufferCachingGrpcDataReader is not implementing DataReader. Is there a reason for that?\nAlso, is a unittest possible for this?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536438732", "createdAt": "2020-12-04T23:14:01Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxMjIxMA==", "bodyText": "I asked the same question in its PR and the author said it is very different from other DataReader, indicating it does not make sense to inherit DataReader.\nLet's aim to add test in #12474 too", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536512210", "createdAt": "2020-12-05T04:45:57Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzODczMg=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjEyNTgyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoxNjowNVrOH_lqTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNDo0MDowNlrOH_qDkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzOTM3Mw==", "bodyText": "Is a unittest possible for this?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536439373", "createdAt": "2020-12-04T23:16:05Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxMTM3Nw==", "bodyText": "it is in a separate PR, not merged yet #12474", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536511377", "createdAt": "2020-12-05T04:40:06Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzOTM3Mw=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjEzMDY2OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoxNzo1OFrOH_ls9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMTo1Njo0NVrOH_oHnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MDA1NA==", "bodyText": "Would it be useful for this to be configurable?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536440054", "createdAt": "2020-12-04T23:17:58Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ3OTY0NA==", "bodyText": "I don't think this value needs to be configured", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536479644", "createdAt": "2020-12-05T01:56:45Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MDA1NA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjEzMTQ0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoxODoyNFrOH_ltag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNDo1Mzo1MlrOH_qLOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MDE3MA==", "bodyText": "Can you explain why we need external locks (BLOCK_LOCKS) when we are using a ConcurrentHashMap? What is the block lock protecting?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536440170", "createdAt": "2020-12-04T23:18:24Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxMzMzOA==", "bodyText": "block lock is used to ensure thread-safety when referencing or updating the shared data reader for block i in different fileinstream\nConcurrentHashMap is store the map from block i to the shared data reader, as different fileinstream may handle different blocks at the same time\n\nI added more javadoc on the locking scheme", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536513338", "createdAt": "2020-12-05T04:53:52Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MDE3MA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjE0MjY0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoyMzoxOVrOH_lzRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTowNDozNlrOH_qRag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MTY2OA==", "bodyText": "There is no \"hashing\" happening to the block id. block ids are a concatenation of 2 numbers: <container id>:<sequence number>. For all files, the first block of the file will always start with sequence number 0. That means the first block of every file may always hash to the the same block lock, the second block of all files will be the next block, and so on. There would be a pattern.\nIs behavior ok? I would imagine that we would want a more \"random\" distribution of the block locks?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536441668", "createdAt": "2020-12-04T23:23:19Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getBlockLock(long blockId) {\n+    return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNDkyMg==", "bodyText": "good catch! Added a hash func to distribute the lock", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536514922", "createdAt": "2020-12-05T05:04:36Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getBlockLock(long blockId) {\n+    return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MTY2OA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjE0NzQyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoyNToyNVrOH_l1wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTowNDo0NVrOH_qRnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjMwNA==", "bodyText": "I'm not sure what this means. Does this mean this reader is always going to be ready?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536442304", "createdAt": "2020-12-04T23:25:25Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getBlockLock(long blockId) {\n+    return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNDk3NQ==", "bodyText": "removed", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536514975", "createdAt": "2020-12-05T05:04:45Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getBlockLock(long blockId) {\n+    return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjMwNA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjE4NjY1OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo0MzoxNFrOH_mKgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTowNjo1MlrOH_qSpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0NzYxOA==", "bodyText": "This makes is sound like this is just like the normal grpc data reader, but just caches the data.\nIf that is the case, why can't we just add caching option to the grpc data reader? Or, wrap the existing grpc data reader? This looks like a reimplementation, with caching functionality.\nAlso, could you briefly describe the relationship between this BufferCachingGrpcDataReader and SharedGrpcDataReader ?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536447618", "createdAt": "2020-12-04T23:43:14Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNTIzNw==", "bodyText": "what you described is correct. We choose to reimplement to ensure no existing code path is modified.\nSharedGrpcDataReader is re-using existing DataReaders to reduce the cost on creation and close.\nBufferCachingGrpcDataReader is providing the caching function.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536515237", "createdAt": "2020-12-05T05:06:52Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0NzYxOA=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjE4ODc2OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo0NDoxNVrOH_mLlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTowNjo1OVrOH_qStQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0Nzg5NQ==", "bodyText": "Can we change this comment without saying \"I\"?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536447895", "createdAt": "2020-12-04T23:44:15Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getBlockLock(long blockId) {\n+    return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() > 0) {\n+      return;\n+    }\n+    try (LockResource lockResource = new LockResource(\n+        getBlockLock(mBlockId).writeLock())) {\n+      if (mCachedDataReader.getRefCount() == 0) {\n+        BLOCK_READERS.remove(mBlockId);\n+      }\n+    }\n+    if (mCachedDataReader.getRefCount() == 0) {\n+      mCachedDataReader.close();\n+    }\n+  }\n+\n+  /**\n+   * Factory class to create {@link SharedGrpcDataReader}s.\n+   */\n+  public static class Factory implements DataReader.Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequestPartial;\n+    private final long mBlockSize;\n+\n+    /**\n+     * Creates an instance of {@link SharedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequestPartial the partial read request\n+     * @param blockSize the block size\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequestPartial, long blockSize) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequestPartial = readRequestPartial;\n+      mBlockSize = blockSize;\n+    }\n+\n+    @Override\n+    public DataReader create(long offset, long len) throws IOException {\n+      long blockId = mReadRequestPartial.getBlockId();\n+      BufferCachingGrpcDataReader reader;\n+      try (LockResource lockResource = new LockResource(\n+          getBlockLock(blockId).writeLock())) {\n+        reader = BLOCK_READERS.get(blockId);\n+        if (reader == null) {\n+          // I'm naive, I always read from 0 and read the whole block", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNTI1Mw==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536515253", "createdAt": "2020-12-05T05:06:59Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getBlockLock(long blockId) {\n+    return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() > 0) {\n+      return;\n+    }\n+    try (LockResource lockResource = new LockResource(\n+        getBlockLock(mBlockId).writeLock())) {\n+      if (mCachedDataReader.getRefCount() == 0) {\n+        BLOCK_READERS.remove(mBlockId);\n+      }\n+    }\n+    if (mCachedDataReader.getRefCount() == 0) {\n+      mCachedDataReader.close();\n+    }\n+  }\n+\n+  /**\n+   * Factory class to create {@link SharedGrpcDataReader}s.\n+   */\n+  public static class Factory implements DataReader.Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequestPartial;\n+    private final long mBlockSize;\n+\n+    /**\n+     * Creates an instance of {@link SharedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequestPartial the partial read request\n+     * @param blockSize the block size\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequestPartial, long blockSize) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequestPartial = readRequestPartial;\n+      mBlockSize = blockSize;\n+    }\n+\n+    @Override\n+    public DataReader create(long offset, long len) throws IOException {\n+      long blockId = mReadRequestPartial.getBlockId();\n+      BufferCachingGrpcDataReader reader;\n+      try (LockResource lockResource = new LockResource(\n+          getBlockLock(blockId).writeLock())) {\n+        reader = BLOCK_READERS.get(blockId);\n+        if (reader == null) {\n+          // I'm naive, I always read from 0 and read the whole block", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0Nzg5NQ=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjE5MjY0OnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo0NjowN1rOH_mNow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwNTowNzoxOVrOH_qTCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0ODQxOQ==", "bodyText": "If this is commented out, does this mean the comment about Force direct_io in FUSE... is inaccurate?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536448419", "createdAt": "2020-12-04T23:46:07Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java", "diffHunk": "@@ -41,51 +47,107 @@\n public final class AlluxioFuse {\n   private static final Logger LOG = LoggerFactory.getLogger(AlluxioFuse.class);\n \n+  private static final Option MOUNT_POINT_OPTION = Option.builder(\"m\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"mount-point\")\n+      .desc(\"Desired local mount point for alluxio-fuse.\")\n+      .build();\n+\n+  private static final Option ALLUXIO_ROOT_OPTION = Option.builder(\"r\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"alluxio-root\")\n+      .desc(\"Path within alluxio that will be used as the root of the FUSE mount \"\n+          + \"(e.g., /users/foo; defaults to /)\")\n+      .build();\n+\n+  private static final Option HELP_OPTION = Option.builder(\"h\")\n+      .required(false)\n+      .desc(\"Print this help message\")\n+      .build();\n+\n+  private static final Option FUSE_MOUNT_OPTION = Option.builder(\"o\")\n+      .valueSeparator(',')\n+      .required(false)\n+      .hasArgs()\n+      .desc(\"FUSE mount options\")\n+      .build();\n+\n+  private static final Options OPTIONS = new Options()\n+      .addOption(MOUNT_POINT_OPTION)\n+      .addOption(ALLUXIO_ROOT_OPTION)\n+      .addOption(HELP_OPTION)\n+      .addOption(FUSE_MOUNT_OPTION);\n+\n   // prevent instantiation\n   private AlluxioFuse() {}\n \n   /**\n-   * Running this class will mount the file system according to\n-   * the options passed to this function {@link #parseOptions(String[], AlluxioConfiguration)}.\n-   * The user-space fuse application will stay on the foreground and keep\n-   * the file system mounted. The user can unmount the file system by\n-   * gracefully killing (SIGINT) the process.\n+   * Running this class will mount the file system according to the options passed to this function\n+   * {@link #parseOptions(String[], AlluxioConfiguration)}. The user-space fuse application will\n+   * stay on the foreground and keep the file system mounted. The user can unmount the file system\n+   * by gracefully killing (SIGINT) the process.\n    *\n    * @param args arguments to run the command line\n    */\n   public static void main(String[] args) {\n-    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    LOG.info(\"Alluxio version: {}-{}\", RuntimeConstants.VERSION, ProjectConstants.REVISION);\n+    AlluxioConfiguration conf = InstancedConfiguration.defaults();\n+    FileSystemContext fsContext = FileSystemContext.create(conf);\n+    try {\n+      InetSocketAddress confMasterAddress =\n+          fsContext.getMasterClientContext().getConfMasterInquireClient().getPrimaryRpcAddress();\n+      RetryUtils.retry(\"load cluster default configuration with master \" + confMasterAddress,\n+          () -> fsContext.getClientContext().loadConfIfNotLoaded(confMasterAddress),\n+          RetryUtils.defaultClientRetry(\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_DURATION),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS)));\n+    } catch (IOException e) {\n+      LOG.warn(\"Failed to load cluster default configuration for Fuse process. \"\n+          + \"Proceed with local configuration for FUSE: {}\", e.toString());\n+    }\n+    conf = fsContext.getClusterConf();\n     final AlluxioFuseOptions opts = parseOptions(args, conf);\n     if (opts == null) {\n       System.exit(1);\n     }\n-\n-    final FileSystem tfs = FileSystem.Factory.create(conf);\n-    final AlluxioFuseFileSystem fs = new AlluxioFuseFileSystem(tfs, opts, conf);\n-    final List<String> fuseOpts = opts.getFuseOpts();\n-    // Force direct_io in FUSE: writes and reads bypass the kernel page\n-    // cache and go directly to alluxio. This avoids extra memory copies\n-    // in the write path.\n-    fuseOpts.add(\"-odirect_io\");\n-\n-    try {\n-      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n-          fuseOpts.toArray(new String[0]));\n-      LOG.info(\"Mounted Alluxio: mount point=\\\"{}\\\", opts=\\\"{}\\\"\",\n-          opts.getMountPoint(), fuseOpts.toArray(new String[0]));\n-    } catch (FuseException e) {\n-      LOG.error(\"Failed to mount {}\", opts.getMountPoint(), e);\n-      // only try to umount file system when exception occurred.\n-      // jnr-fuse registers JVM shutdown hook to ensure fs.umount()\n-      // will be executed when this process is exiting.\n-      fs.umount();\n-    } finally {\n-      try {\n-        tfs.close();\n-        LOG.info(\"Closed Alluxio file system.\");\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to close Alluxio file system\", e);\n+    try (final FileSystem fs = FileSystem.Factory.create(fsContext)) {\n+      final List<String> fuseOpts = opts.getFuseOpts();\n+      // Force direct_io in FUSE: writes and reads bypass the kernel page\n+      // cache and go directly to alluxio. This avoids extra memory copies\n+      // in the write path.\n+      // TODO(binfan): support kernel_cache (issues#10840)\n+      //fuseOpts.add(\"-odirect_io\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNTMzNg==", "bodyText": "updated. it should be in JNR fuse", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r536515336", "createdAt": "2020-12-05T05:07:19Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java", "diffHunk": "@@ -41,51 +47,107 @@\n public final class AlluxioFuse {\n   private static final Logger LOG = LoggerFactory.getLogger(AlluxioFuse.class);\n \n+  private static final Option MOUNT_POINT_OPTION = Option.builder(\"m\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"mount-point\")\n+      .desc(\"Desired local mount point for alluxio-fuse.\")\n+      .build();\n+\n+  private static final Option ALLUXIO_ROOT_OPTION = Option.builder(\"r\")\n+      .hasArg()\n+      .required(true)\n+      .longOpt(\"alluxio-root\")\n+      .desc(\"Path within alluxio that will be used as the root of the FUSE mount \"\n+          + \"(e.g., /users/foo; defaults to /)\")\n+      .build();\n+\n+  private static final Option HELP_OPTION = Option.builder(\"h\")\n+      .required(false)\n+      .desc(\"Print this help message\")\n+      .build();\n+\n+  private static final Option FUSE_MOUNT_OPTION = Option.builder(\"o\")\n+      .valueSeparator(',')\n+      .required(false)\n+      .hasArgs()\n+      .desc(\"FUSE mount options\")\n+      .build();\n+\n+  private static final Options OPTIONS = new Options()\n+      .addOption(MOUNT_POINT_OPTION)\n+      .addOption(ALLUXIO_ROOT_OPTION)\n+      .addOption(HELP_OPTION)\n+      .addOption(FUSE_MOUNT_OPTION);\n+\n   // prevent instantiation\n   private AlluxioFuse() {}\n \n   /**\n-   * Running this class will mount the file system according to\n-   * the options passed to this function {@link #parseOptions(String[], AlluxioConfiguration)}.\n-   * The user-space fuse application will stay on the foreground and keep\n-   * the file system mounted. The user can unmount the file system by\n-   * gracefully killing (SIGINT) the process.\n+   * Running this class will mount the file system according to the options passed to this function\n+   * {@link #parseOptions(String[], AlluxioConfiguration)}. The user-space fuse application will\n+   * stay on the foreground and keep the file system mounted. The user can unmount the file system\n+   * by gracefully killing (SIGINT) the process.\n    *\n    * @param args arguments to run the command line\n    */\n   public static void main(String[] args) {\n-    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    LOG.info(\"Alluxio version: {}-{}\", RuntimeConstants.VERSION, ProjectConstants.REVISION);\n+    AlluxioConfiguration conf = InstancedConfiguration.defaults();\n+    FileSystemContext fsContext = FileSystemContext.create(conf);\n+    try {\n+      InetSocketAddress confMasterAddress =\n+          fsContext.getMasterClientContext().getConfMasterInquireClient().getPrimaryRpcAddress();\n+      RetryUtils.retry(\"load cluster default configuration with master \" + confMasterAddress,\n+          () -> fsContext.getClientContext().loadConfIfNotLoaded(confMasterAddress),\n+          RetryUtils.defaultClientRetry(\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_DURATION),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS),\n+              conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS)));\n+    } catch (IOException e) {\n+      LOG.warn(\"Failed to load cluster default configuration for Fuse process. \"\n+          + \"Proceed with local configuration for FUSE: {}\", e.toString());\n+    }\n+    conf = fsContext.getClusterConf();\n     final AlluxioFuseOptions opts = parseOptions(args, conf);\n     if (opts == null) {\n       System.exit(1);\n     }\n-\n-    final FileSystem tfs = FileSystem.Factory.create(conf);\n-    final AlluxioFuseFileSystem fs = new AlluxioFuseFileSystem(tfs, opts, conf);\n-    final List<String> fuseOpts = opts.getFuseOpts();\n-    // Force direct_io in FUSE: writes and reads bypass the kernel page\n-    // cache and go directly to alluxio. This avoids extra memory copies\n-    // in the write path.\n-    fuseOpts.add(\"-odirect_io\");\n-\n-    try {\n-      fs.mount(Paths.get(opts.getMountPoint()), true, opts.isDebug(),\n-          fuseOpts.toArray(new String[0]));\n-      LOG.info(\"Mounted Alluxio: mount point=\\\"{}\\\", opts=\\\"{}\\\"\",\n-          opts.getMountPoint(), fuseOpts.toArray(new String[0]));\n-    } catch (FuseException e) {\n-      LOG.error(\"Failed to mount {}\", opts.getMountPoint(), e);\n-      // only try to umount file system when exception occurred.\n-      // jnr-fuse registers JVM shutdown hook to ensure fs.umount()\n-      // will be executed when this process is exiting.\n-      fs.umount();\n-    } finally {\n-      try {\n-        tfs.close();\n-        LOG.info(\"Closed Alluxio file system.\");\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to close Alluxio file system\", e);\n+    try (final FileSystem fs = FileSystem.Factory.create(fsContext)) {\n+      final List<String> fuseOpts = opts.getFuseOpts();\n+      // Force direct_io in FUSE: writes and reads bypass the kernel page\n+      // cache and go directly to alluxio. This avoids extra memory copies\n+      // in the write path.\n+      // TODO(binfan): support kernel_cache (issues#10840)\n+      //fuseOpts.add(\"-odirect_io\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0ODQxOQ=="}, "originalCommit": {"oid": "3745c016049645d5603488508916408d9459b293"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTA3ODQxOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozMjo0NVrOICv5ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwMDowNToyMFrOIDjHJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1Mjg5MA==", "bodyText": "I don't think this is actually direct memory access, right? https://en.wikipedia.org/wiki/Direct_memory_access", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r539752890", "createdAt": "2020-12-10T00:32:45Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,17 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwNzM2Mw==", "bodyText": "you are correct. any good naming suggested?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540507363", "createdAt": "2020-12-10T21:24:38Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,17 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1Mjg5MA=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5MTkwOA==", "bodyText": "It can be read from the only tier no matter it's memory or SSD/HDD. USER_DIRECT_READ_ENABLED? would be better to differentiate this property fro the USER_SHORT_CIRCUIT_ENABLED", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540591908", "createdAt": "2020-12-11T00:05:20Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3490,6 +3490,17 @@ public String toString() {\n               + \"format pattern.\")\n           .setScope(Scope.CLIENT)\n           .build();\n+  public static final PropertyKey USER_DIRECT_MEMORY_IO_ENABLED =\n+      new Builder(Name.USER_DIRECT_MEMORY_IO_ENABLED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1Mjg5MA=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzI4OTQyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzo1ODo1MlrOIDWN5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxMjoyOFrOIDhv0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MDY0NQ==", "bodyText": "What does this protect? mDataBuffers? Anything else?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540380645", "createdAt": "2020-12-10T17:58:52Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2OTU1NQ==", "bodyText": "yes, added annotation", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540569555", "createdAt": "2020-12-10T23:12:28Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MDY0NQ=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzM4MTg0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxOTo0MlrOIDXEag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxODozNFrOIDh6Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NDYwMg==", "bodyText": "I don't think this is atomic.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540394602", "createdAt": "2020-12-10T18:19:42Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.hash.HashFunction;\n+import com.google.common.hash.Hashing;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  //\n+  // BLOCK_LOCKS is used to ensure thread-safety when referencing or updating the shared data\n+  // reader for block i in different FileInStream instances.\n+  // BLOCK_READERS is a ConcurrentHashMap from block id to its shared data reader, as different\n+  // DataReader may be needed to handle different blocks at the same time.\n+  //\n+  /** An array of locks to guard cached data readers based on block id. */\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS =\n+      new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+  /** A map from block id to the block's cached data reader. */\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS =\n+      new ConcurrentHashMap<>();\n+  /** A hashing function to map block id to one of the locks. */\n+  private static final HashFunction HASH_FUNC = Hashing.murmur3_32();\n+\n+  static {\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getLock(long blockId) {\n+    return BLOCK_LOCKS[HASH_FUNC.hashLong(blockId).asInt() % BLOCK_LOCKS.length];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() > 0) {\n+      return;\n+    }\n+    try (LockResource lockResource = new LockResource(getLock(mBlockId).writeLock())) {\n+      if (mCachedDataReader.getRefCount() == 0) {\n+        BLOCK_READERS.remove(mBlockId);\n+      }\n+    }\n+    if (mCachedDataReader.getRefCount() == 0) {\n+      mCachedDataReader.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MjIxMA==", "bodyText": "good catch. fixed", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540572210", "createdAt": "2020-12-10T23:18:34Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.hash.HashFunction;\n+import com.google.common.hash.Hashing;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  //\n+  // BLOCK_LOCKS is used to ensure thread-safety when referencing or updating the shared data\n+  // reader for block i in different FileInStream instances.\n+  // BLOCK_READERS is a ConcurrentHashMap from block id to its shared data reader, as different\n+  // DataReader may be needed to handle different blocks at the same time.\n+  //\n+  /** An array of locks to guard cached data readers based on block id. */\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS =\n+      new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+  /** A map from block id to the block's cached data reader. */\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS =\n+      new ConcurrentHashMap<>();\n+  /** A hashing function to map block id to one of the locks. */\n+  private static final HashFunction HASH_FUNC = Hashing.murmur3_32();\n+\n+  static {\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getLock(long blockId) {\n+    return BLOCK_LOCKS[HASH_FUNC.hashLong(blockId).asInt() % BLOCK_LOCKS.length];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() > 0) {\n+      return;\n+    }\n+    try (LockResource lockResource = new LockResource(getLock(mBlockId).writeLock())) {\n+      if (mCachedDataReader.getRefCount() == 0) {\n+        BLOCK_READERS.remove(mBlockId);\n+      }\n+    }\n+    if (mCachedDataReader.getRefCount() == 0) {\n+      mCachedDataReader.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NDYwMg=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzM4ODY3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyMToyMlrOIDXIfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxODo1MFrOIDh67w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NTY0Ng==", "bodyText": "Is this SharedGrpcDataReader the only class that will create a BufferCachingGrpcDataReader instance?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540395646", "createdAt": "2020-12-10T18:21:22Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.hash.HashFunction;\n+import com.google.common.hash.Hashing;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  //\n+  // BLOCK_LOCKS is used to ensure thread-safety when referencing or updating the shared data\n+  // reader for block i in different FileInStream instances.\n+  // BLOCK_READERS is a ConcurrentHashMap from block id to its shared data reader, as different\n+  // DataReader may be needed to handle different blocks at the same time.\n+  //\n+  /** An array of locks to guard cached data readers based on block id. */\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS =\n+      new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+  /** A map from block id to the block's cached data reader. */\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS =\n+      new ConcurrentHashMap<>();\n+  /** A hashing function to map block id to one of the locks. */\n+  private static final HashFunction HASH_FUNC = Hashing.murmur3_32();\n+\n+  static {\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getLock(long blockId) {\n+    return BLOCK_LOCKS[HASH_FUNC.hashLong(blockId).asInt() % BLOCK_LOCKS.length];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() > 0) {\n+      return;\n+    }\n+    try (LockResource lockResource = new LockResource(getLock(mBlockId).writeLock())) {\n+      if (mCachedDataReader.getRefCount() == 0) {\n+        BLOCK_READERS.remove(mBlockId);\n+      }\n+    }\n+    if (mCachedDataReader.getRefCount() == 0) {\n+      mCachedDataReader.close();\n+    }\n+  }\n+\n+  /**\n+   * Factory class to create {@link SharedGrpcDataReader}s.\n+   */\n+  public static class Factory implements DataReader.Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequestPartial;\n+    private final long mBlockSize;\n+\n+    /**\n+     * Creates an instance of {@link SharedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequestPartial the partial read request\n+     * @param blockSize the block size\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequestPartial, long blockSize) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequestPartial = readRequestPartial;\n+      mBlockSize = blockSize;\n+    }\n+\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+        value = \"AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION\",\n+        justification = \"operation is still atomic guarded by block \u00d8lock\")\n+    @Override\n+    public DataReader create(long offset, long len) throws IOException {\n+      long blockId = mReadRequestPartial.getBlockId();\n+      BufferCachingGrpcDataReader reader;\n+      try (LockResource lockResource = new LockResource(getLock(blockId).writeLock())) {\n+        reader = BLOCK_READERS.get(blockId);\n+        if (reader == null) {\n+          // Even we may only need a portion, create a reader to read the whole block\n+          ReadRequest cacheRequest = mReadRequestPartial\n+              .toBuilder().setOffset(0).setLength(mBlockSize).build();\n+          reader = BufferCachingGrpcDataReader.create(mContext, mAddress, cacheRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MjM5OQ==", "bodyText": "yes", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540572399", "createdAt": "2020-12-10T23:18:50Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import com.google.common.hash.HashFunction;\n+import com.google.common.hash.Hashing;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final int BLOCK_LOCK_NUM = 32;\n+  //\n+  // BLOCK_LOCKS is used to ensure thread-safety when referencing or updating the shared data\n+  // reader for block i in different FileInStream instances.\n+  // BLOCK_READERS is a ConcurrentHashMap from block id to its shared data reader, as different\n+  // DataReader may be needed to handle different blocks at the same time.\n+  //\n+  /** An array of locks to guard cached data readers based on block id. */\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS =\n+      new ReentrantReadWriteLock[BLOCK_LOCK_NUM];\n+  /** A map from block id to the block's cached data reader. */\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS =\n+      new ConcurrentHashMap<>();\n+  /** A hashing function to map block id to one of the locks. */\n+  private static final HashFunction HASH_FUNC = Hashing.murmur3_32();\n+\n+  static {\n+    for (int i = 0; i < BLOCK_LOCK_NUM; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private static ReentrantReadWriteLock getLock(long blockId) {\n+    return BLOCK_LOCKS[HASH_FUNC.hashLong(blockId).asInt() % BLOCK_LOCKS.length];\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() > 0) {\n+      return;\n+    }\n+    try (LockResource lockResource = new LockResource(getLock(mBlockId).writeLock())) {\n+      if (mCachedDataReader.getRefCount() == 0) {\n+        BLOCK_READERS.remove(mBlockId);\n+      }\n+    }\n+    if (mCachedDataReader.getRefCount() == 0) {\n+      mCachedDataReader.close();\n+    }\n+  }\n+\n+  /**\n+   * Factory class to create {@link SharedGrpcDataReader}s.\n+   */\n+  public static class Factory implements DataReader.Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequestPartial;\n+    private final long mBlockSize;\n+\n+    /**\n+     * Creates an instance of {@link SharedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequestPartial the partial read request\n+     * @param blockSize the block size\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequestPartial, long blockSize) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequestPartial = readRequestPartial;\n+      mBlockSize = blockSize;\n+    }\n+\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+        value = \"AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION\",\n+        justification = \"operation is still atomic guarded by block \u00d8lock\")\n+    @Override\n+    public DataReader create(long offset, long len) throws IOException {\n+      long blockId = mReadRequestPartial.getBlockId();\n+      BufferCachingGrpcDataReader reader;\n+      try (LockResource lockResource = new LockResource(getLock(blockId).writeLock())) {\n+        reader = BLOCK_READERS.get(blockId);\n+        if (reader == null) {\n+          // Even we may only need a portion, create a reader to read the whole block\n+          ReadRequest cacheRequest = mReadRequestPartial\n+              .toBuilder().setOffset(0).setLength(mBlockSize).build();\n+          reader = BufferCachingGrpcDataReader.create(mContext, mAddress, cacheRequest);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NTY0Ng=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzM5OTg1OnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyMzo1NlrOIDXPEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoyOTozMFrOIDiNDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NzMzMA==", "bodyText": "Is the group name also supposed to be the user name?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540397330", "createdAt": "2020-12-10T18:23:56Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NzAzOA==", "bodyText": "it was here in JNRFuse Integration from the beginning. We just copied from there.\nAnd java seems not providing a group name system property", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540577038", "createdAt": "2020-12-10T23:29:30Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5NzMzMA=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQxMDYxOnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNjoyNVrOIDXVcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoyNzoxNVrOIDiJWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5ODk2MA==", "bodyText": "This feels like a striped lock? Would this work? https://guava.dev/releases/19.0/api/docs/com/google/common/util/concurrent/Striped.html\nI know we are using this in other parts of the codebase.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540398960", "createdAt": "2020-12-10T18:26:25Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NjA4OQ==", "bodyText": "good to know! updated to Striped", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540576089", "createdAt": "2020-12-10T23:27:15Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5ODk2MA=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQxOTg1OnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyODozNVrOIDXbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzozMDo1NFrOIDiPJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMDM4Ng==", "bodyText": "is this message correct?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540400386", "createdAt": "2020-12-10T18:28:35Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");\n+  private static final long DEFAULT_UID = AlluxioFuseUtils.getUid(USER_NAME);\n+  private static final long DEFAULT_GID = AlluxioFuseUtils.getGid(GROUP_NAME);\n+\n+  /**\n+   * Creates a new instance of {@link AlluxioJniFuseFileSystem}.\n+   *\n+   * @param fs Alluxio file system\n+   * @param opts options\n+   * @param conf Alluxio configuration\n+   */\n+  public AlluxioJniFuseFileSystem(\n+      FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {\n+    super(Paths.get(opts.getMountPoint()));\n+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);\n+    mFileSystem = fs;\n+    mConf = conf;\n+    mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());\n+    mPathResolverCache = CacheBuilder.newBuilder()\n+        .maximumSize(conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX))\n+        .build(new CacheLoader<String, AlluxioURI>() {\n+          @Override\n+          public AlluxioURI load(String fusePath) {\n+            // fusePath is guaranteed to always be an absolute path (i.e., starts\n+            // with a fwd slash) - relative to the FUSE mount point\n+            final String relPath = fusePath.substring(1);\n+            final Path tpath = mAlluxioRootPath.resolve(relPath);\n+            return new AlluxioURI(tpath.toString());\n+          }\n+        });\n+    mUidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String userName) {\n+            return AlluxioFuseUtils.getUid(userName);\n+          }\n+        });\n+    mGidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String groupName) {\n+            return AlluxioFuseUtils.getGidFromGroupName(groupName);\n+          }\n+        });\n+    mIsUserGroupTranslation = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mFileLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple path may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fd the file id\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getFileLock(long fd) {\n+    return mFileLocks[Math.floorMod((int) fd, LOCK_SIZE)];\n+  }\n+\n+  private void setUserGroupIfNeeded(AlluxioURI uri) throws Exception {\n+    SetAttributePOptions.Builder attributeOptionsBuilder = SetAttributePOptions.newBuilder();\n+    FuseContext fc = getContext();\n+    long uid = fc.uid.get();\n+    long gid = fc.gid.get();\n+    if (gid != DEFAULT_GID) {\n+      String groupName = AlluxioFuseUtils.getGroupName(gid);\n+      if (groupName.isEmpty()) {\n+        // This should never be reached since input gid is always valid\n+        LOG.error(\"Failed to get group name from gid {}, fallback to {}.\", gid, GROUP_NAME);\n+        groupName = GROUP_NAME;\n+      }\n+      attributeOptionsBuilder.setGroup(groupName);\n+    }\n+    if (uid != DEFAULT_UID) {\n+      String userName = AlluxioFuseUtils.getUserName(uid);\n+      if (userName.isEmpty()) {\n+        // This should never be reached since input uid is always valid\n+        LOG.error(\"Failed to get user name from uid {}, fallback to {}\", uid, USER_NAME);\n+        userName = USER_NAME;\n+      }\n+      attributeOptionsBuilder.setOwner(userName);\n+    }\n+    SetAttributePOptions setAttributePOptions =  attributeOptionsBuilder.build();\n+    if (gid != DEFAULT_GID || uid != DEFAULT_UID) {\n+      LOG.debug(\"Set attributes of path {} to {}\", uri, setAttributePOptions);\n+      mFileSystem.setAttribute(uri, setAttributePOptions);\n+    }\n+  }\n+\n+  @Override\n+  public int create(String path, long mode, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> createInternal(path, mode, fi),\n+        \"create\", \"path=%s,mode=%o\", path, mode);\n+  }\n+\n+  private int createInternal(String path, long mode, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    if (uri.getName().length() > MAX_NAME_LENGTH) {\n+      LOG.error(\"Failed to create {}: file name longer than {} characters\",\n+          path, MAX_NAME_LENGTH);\n+      return -ErrorCodes.ENAMETOOLONG();\n+    }\n+    try {\n+      FileOutStream os = mFileSystem.createFile(uri,\n+          CreateFilePOptions.newBuilder()\n+              .setMode(new Mode((short) mode).toProto())\n+              .build());\n+      long fid = mNextOpenFileId.getAndIncrement();\n+      mCreateFileEntries.put(fid, os);\n+      fi.fh.set(fid);\n+      setUserGroupIfNeeded(uri);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NzU3Mw==", "bodyText": "fixed", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540577573", "createdAt": "2020-12-10T23:30:54Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");\n+  private static final long DEFAULT_UID = AlluxioFuseUtils.getUid(USER_NAME);\n+  private static final long DEFAULT_GID = AlluxioFuseUtils.getGid(GROUP_NAME);\n+\n+  /**\n+   * Creates a new instance of {@link AlluxioJniFuseFileSystem}.\n+   *\n+   * @param fs Alluxio file system\n+   * @param opts options\n+   * @param conf Alluxio configuration\n+   */\n+  public AlluxioJniFuseFileSystem(\n+      FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {\n+    super(Paths.get(opts.getMountPoint()));\n+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);\n+    mFileSystem = fs;\n+    mConf = conf;\n+    mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());\n+    mPathResolverCache = CacheBuilder.newBuilder()\n+        .maximumSize(conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX))\n+        .build(new CacheLoader<String, AlluxioURI>() {\n+          @Override\n+          public AlluxioURI load(String fusePath) {\n+            // fusePath is guaranteed to always be an absolute path (i.e., starts\n+            // with a fwd slash) - relative to the FUSE mount point\n+            final String relPath = fusePath.substring(1);\n+            final Path tpath = mAlluxioRootPath.resolve(relPath);\n+            return new AlluxioURI(tpath.toString());\n+          }\n+        });\n+    mUidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String userName) {\n+            return AlluxioFuseUtils.getUid(userName);\n+          }\n+        });\n+    mGidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String groupName) {\n+            return AlluxioFuseUtils.getGidFromGroupName(groupName);\n+          }\n+        });\n+    mIsUserGroupTranslation = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mFileLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple path may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fd the file id\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getFileLock(long fd) {\n+    return mFileLocks[Math.floorMod((int) fd, LOCK_SIZE)];\n+  }\n+\n+  private void setUserGroupIfNeeded(AlluxioURI uri) throws Exception {\n+    SetAttributePOptions.Builder attributeOptionsBuilder = SetAttributePOptions.newBuilder();\n+    FuseContext fc = getContext();\n+    long uid = fc.uid.get();\n+    long gid = fc.gid.get();\n+    if (gid != DEFAULT_GID) {\n+      String groupName = AlluxioFuseUtils.getGroupName(gid);\n+      if (groupName.isEmpty()) {\n+        // This should never be reached since input gid is always valid\n+        LOG.error(\"Failed to get group name from gid {}, fallback to {}.\", gid, GROUP_NAME);\n+        groupName = GROUP_NAME;\n+      }\n+      attributeOptionsBuilder.setGroup(groupName);\n+    }\n+    if (uid != DEFAULT_UID) {\n+      String userName = AlluxioFuseUtils.getUserName(uid);\n+      if (userName.isEmpty()) {\n+        // This should never be reached since input uid is always valid\n+        LOG.error(\"Failed to get user name from uid {}, fallback to {}\", uid, USER_NAME);\n+        userName = USER_NAME;\n+      }\n+      attributeOptionsBuilder.setOwner(userName);\n+    }\n+    SetAttributePOptions setAttributePOptions =  attributeOptionsBuilder.build();\n+    if (gid != DEFAULT_GID || uid != DEFAULT_UID) {\n+      LOG.debug(\"Set attributes of path {} to {}\", uri, setAttributePOptions);\n+      mFileSystem.setAttribute(uri, setAttributePOptions);\n+    }\n+  }\n+\n+  @Override\n+  public int create(String path, long mode, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> createInternal(path, mode, fi),\n+        \"create\", \"path=%s,mode=%o\", path, mode);\n+  }\n+\n+  private int createInternal(String path, long mode, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    if (uri.getName().length() > MAX_NAME_LENGTH) {\n+      LOG.error(\"Failed to create {}: file name longer than {} characters\",\n+          path, MAX_NAME_LENGTH);\n+      return -ErrorCodes.ENAMETOOLONG();\n+    }\n+    try {\n+      FileOutStream os = mFileSystem.createFile(uri,\n+          CreateFilePOptions.newBuilder()\n+              .setMode(new Mode((short) mode).toProto())\n+              .build());\n+      long fid = mNextOpenFileId.getAndIncrement();\n+      mCreateFileEntries.put(fid, os);\n+      fi.fh.set(fid);\n+      setUserGroupIfNeeded(uri);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMDM4Ng=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQyNzUzOnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODozMDoyNFrOIDXf4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo0MDowMVrOIDie9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTYzMg==", "bodyText": "Is this supposed to be nanoseconds? Aren't there 1000000ns in 1ms?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540401632", "createdAt": "2020-12-10T18:30:24Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");\n+  private static final long DEFAULT_UID = AlluxioFuseUtils.getUid(USER_NAME);\n+  private static final long DEFAULT_GID = AlluxioFuseUtils.getGid(GROUP_NAME);\n+\n+  /**\n+   * Creates a new instance of {@link AlluxioJniFuseFileSystem}.\n+   *\n+   * @param fs Alluxio file system\n+   * @param opts options\n+   * @param conf Alluxio configuration\n+   */\n+  public AlluxioJniFuseFileSystem(\n+      FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {\n+    super(Paths.get(opts.getMountPoint()));\n+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);\n+    mFileSystem = fs;\n+    mConf = conf;\n+    mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());\n+    mPathResolverCache = CacheBuilder.newBuilder()\n+        .maximumSize(conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX))\n+        .build(new CacheLoader<String, AlluxioURI>() {\n+          @Override\n+          public AlluxioURI load(String fusePath) {\n+            // fusePath is guaranteed to always be an absolute path (i.e., starts\n+            // with a fwd slash) - relative to the FUSE mount point\n+            final String relPath = fusePath.substring(1);\n+            final Path tpath = mAlluxioRootPath.resolve(relPath);\n+            return new AlluxioURI(tpath.toString());\n+          }\n+        });\n+    mUidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String userName) {\n+            return AlluxioFuseUtils.getUid(userName);\n+          }\n+        });\n+    mGidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String groupName) {\n+            return AlluxioFuseUtils.getGidFromGroupName(groupName);\n+          }\n+        });\n+    mIsUserGroupTranslation = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mFileLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple path may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fd the file id\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getFileLock(long fd) {\n+    return mFileLocks[Math.floorMod((int) fd, LOCK_SIZE)];\n+  }\n+\n+  private void setUserGroupIfNeeded(AlluxioURI uri) throws Exception {\n+    SetAttributePOptions.Builder attributeOptionsBuilder = SetAttributePOptions.newBuilder();\n+    FuseContext fc = getContext();\n+    long uid = fc.uid.get();\n+    long gid = fc.gid.get();\n+    if (gid != DEFAULT_GID) {\n+      String groupName = AlluxioFuseUtils.getGroupName(gid);\n+      if (groupName.isEmpty()) {\n+        // This should never be reached since input gid is always valid\n+        LOG.error(\"Failed to get group name from gid {}, fallback to {}.\", gid, GROUP_NAME);\n+        groupName = GROUP_NAME;\n+      }\n+      attributeOptionsBuilder.setGroup(groupName);\n+    }\n+    if (uid != DEFAULT_UID) {\n+      String userName = AlluxioFuseUtils.getUserName(uid);\n+      if (userName.isEmpty()) {\n+        // This should never be reached since input uid is always valid\n+        LOG.error(\"Failed to get user name from uid {}, fallback to {}\", uid, USER_NAME);\n+        userName = USER_NAME;\n+      }\n+      attributeOptionsBuilder.setOwner(userName);\n+    }\n+    SetAttributePOptions setAttributePOptions =  attributeOptionsBuilder.build();\n+    if (gid != DEFAULT_GID || uid != DEFAULT_UID) {\n+      LOG.debug(\"Set attributes of path {} to {}\", uri, setAttributePOptions);\n+      mFileSystem.setAttribute(uri, setAttributePOptions);\n+    }\n+  }\n+\n+  @Override\n+  public int create(String path, long mode, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> createInternal(path, mode, fi),\n+        \"create\", \"path=%s,mode=%o\", path, mode);\n+  }\n+\n+  private int createInternal(String path, long mode, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    if (uri.getName().length() > MAX_NAME_LENGTH) {\n+      LOG.error(\"Failed to create {}: file name longer than {} characters\",\n+          path, MAX_NAME_LENGTH);\n+      return -ErrorCodes.ENAMETOOLONG();\n+    }\n+    try {\n+      FileOutStream os = mFileSystem.createFile(uri,\n+          CreateFilePOptions.newBuilder()\n+              .setMode(new Mode((short) mode).toProto())\n+              .build());\n+      long fid = mNextOpenFileId.getAndIncrement();\n+      mCreateFileEntries.put(fid, os);\n+      fi.fh.set(fid);\n+      setUserGroupIfNeeded(uri);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+    return 0;\n+  }\n+\n+  @Override\n+  public int getattr(String path, FileStat stat) {\n+    return AlluxioFuseUtils.call(\n+        LOG, () -> getattrInternal(path, stat), \"getattr\", \"path=%s\", path);\n+  }\n+\n+  private int getattrInternal(String path, FileStat stat) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      URIStatus status = mFileSystem.getStatus(uri);\n+      long size = status.getLength();\n+      stat.st_size.set(size);\n+\n+      // Sets block number to fulfill du command needs\n+      // `st_blksize` is ignored in `getattr` according to\n+      // https://github.com/libfuse/libfuse/blob/d4a7ba44b022e3b63fc215374d87ed9e930d9974/include/fuse.h#L302\n+      // According to http://man7.org/linux/man-pages/man2/stat.2.html,\n+      // `st_blocks` is the number of 512B blocks allocated\n+      stat.st_blocks.set((int) Math.ceil((double) size / 512));\n+\n+      final long ctime_sec = status.getLastModificationTimeMs() / 1000;\n+      // Keeps only the \"residual\" nanoseconds not caputred in citme_sec\n+      final long ctime_nsec = (status.getLastModificationTimeMs() % 1000) * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MTYyMA==", "bodyText": "good catch, fixed", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540581620", "createdAt": "2020-12-10T23:40:01Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");\n+  private static final long DEFAULT_UID = AlluxioFuseUtils.getUid(USER_NAME);\n+  private static final long DEFAULT_GID = AlluxioFuseUtils.getGid(GROUP_NAME);\n+\n+  /**\n+   * Creates a new instance of {@link AlluxioJniFuseFileSystem}.\n+   *\n+   * @param fs Alluxio file system\n+   * @param opts options\n+   * @param conf Alluxio configuration\n+   */\n+  public AlluxioJniFuseFileSystem(\n+      FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {\n+    super(Paths.get(opts.getMountPoint()));\n+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);\n+    mFileSystem = fs;\n+    mConf = conf;\n+    mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());\n+    mPathResolverCache = CacheBuilder.newBuilder()\n+        .maximumSize(conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX))\n+        .build(new CacheLoader<String, AlluxioURI>() {\n+          @Override\n+          public AlluxioURI load(String fusePath) {\n+            // fusePath is guaranteed to always be an absolute path (i.e., starts\n+            // with a fwd slash) - relative to the FUSE mount point\n+            final String relPath = fusePath.substring(1);\n+            final Path tpath = mAlluxioRootPath.resolve(relPath);\n+            return new AlluxioURI(tpath.toString());\n+          }\n+        });\n+    mUidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String userName) {\n+            return AlluxioFuseUtils.getUid(userName);\n+          }\n+        });\n+    mGidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String groupName) {\n+            return AlluxioFuseUtils.getGidFromGroupName(groupName);\n+          }\n+        });\n+    mIsUserGroupTranslation = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mFileLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple path may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fd the file id\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getFileLock(long fd) {\n+    return mFileLocks[Math.floorMod((int) fd, LOCK_SIZE)];\n+  }\n+\n+  private void setUserGroupIfNeeded(AlluxioURI uri) throws Exception {\n+    SetAttributePOptions.Builder attributeOptionsBuilder = SetAttributePOptions.newBuilder();\n+    FuseContext fc = getContext();\n+    long uid = fc.uid.get();\n+    long gid = fc.gid.get();\n+    if (gid != DEFAULT_GID) {\n+      String groupName = AlluxioFuseUtils.getGroupName(gid);\n+      if (groupName.isEmpty()) {\n+        // This should never be reached since input gid is always valid\n+        LOG.error(\"Failed to get group name from gid {}, fallback to {}.\", gid, GROUP_NAME);\n+        groupName = GROUP_NAME;\n+      }\n+      attributeOptionsBuilder.setGroup(groupName);\n+    }\n+    if (uid != DEFAULT_UID) {\n+      String userName = AlluxioFuseUtils.getUserName(uid);\n+      if (userName.isEmpty()) {\n+        // This should never be reached since input uid is always valid\n+        LOG.error(\"Failed to get user name from uid {}, fallback to {}\", uid, USER_NAME);\n+        userName = USER_NAME;\n+      }\n+      attributeOptionsBuilder.setOwner(userName);\n+    }\n+    SetAttributePOptions setAttributePOptions =  attributeOptionsBuilder.build();\n+    if (gid != DEFAULT_GID || uid != DEFAULT_UID) {\n+      LOG.debug(\"Set attributes of path {} to {}\", uri, setAttributePOptions);\n+      mFileSystem.setAttribute(uri, setAttributePOptions);\n+    }\n+  }\n+\n+  @Override\n+  public int create(String path, long mode, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> createInternal(path, mode, fi),\n+        \"create\", \"path=%s,mode=%o\", path, mode);\n+  }\n+\n+  private int createInternal(String path, long mode, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    if (uri.getName().length() > MAX_NAME_LENGTH) {\n+      LOG.error(\"Failed to create {}: file name longer than {} characters\",\n+          path, MAX_NAME_LENGTH);\n+      return -ErrorCodes.ENAMETOOLONG();\n+    }\n+    try {\n+      FileOutStream os = mFileSystem.createFile(uri,\n+          CreateFilePOptions.newBuilder()\n+              .setMode(new Mode((short) mode).toProto())\n+              .build());\n+      long fid = mNextOpenFileId.getAndIncrement();\n+      mCreateFileEntries.put(fid, os);\n+      fi.fh.set(fid);\n+      setUserGroupIfNeeded(uri);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+    return 0;\n+  }\n+\n+  @Override\n+  public int getattr(String path, FileStat stat) {\n+    return AlluxioFuseUtils.call(\n+        LOG, () -> getattrInternal(path, stat), \"getattr\", \"path=%s\", path);\n+  }\n+\n+  private int getattrInternal(String path, FileStat stat) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      URIStatus status = mFileSystem.getStatus(uri);\n+      long size = status.getLength();\n+      stat.st_size.set(size);\n+\n+      // Sets block number to fulfill du command needs\n+      // `st_blksize` is ignored in `getattr` according to\n+      // https://github.com/libfuse/libfuse/blob/d4a7ba44b022e3b63fc215374d87ed9e930d9974/include/fuse.h#L302\n+      // According to http://man7.org/linux/man-pages/man2/stat.2.html,\n+      // `st_blocks` is the number of 512B blocks allocated\n+      stat.st_blocks.set((int) Math.ceil((double) size / 512));\n+\n+      final long ctime_sec = status.getLastModificationTimeMs() / 1000;\n+      // Keeps only the \"residual\" nanoseconds not caputred in citme_sec\n+      final long ctime_nsec = (status.getLastModificationTimeMs() % 1000) * 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTYzMg=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQzNjg4OnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODozMjoyNFrOIDXlRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo0MTozNFrOIDihYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMzAxNQ==", "bodyText": "Can we add labels to the log, like \"path: {}, size: {}, offset: {}\"?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540403015", "createdAt": "2020-12-10T18:32:24Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");\n+  private static final long DEFAULT_UID = AlluxioFuseUtils.getUid(USER_NAME);\n+  private static final long DEFAULT_GID = AlluxioFuseUtils.getGid(GROUP_NAME);\n+\n+  /**\n+   * Creates a new instance of {@link AlluxioJniFuseFileSystem}.\n+   *\n+   * @param fs Alluxio file system\n+   * @param opts options\n+   * @param conf Alluxio configuration\n+   */\n+  public AlluxioJniFuseFileSystem(\n+      FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {\n+    super(Paths.get(opts.getMountPoint()));\n+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);\n+    mFileSystem = fs;\n+    mConf = conf;\n+    mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());\n+    mPathResolverCache = CacheBuilder.newBuilder()\n+        .maximumSize(conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX))\n+        .build(new CacheLoader<String, AlluxioURI>() {\n+          @Override\n+          public AlluxioURI load(String fusePath) {\n+            // fusePath is guaranteed to always be an absolute path (i.e., starts\n+            // with a fwd slash) - relative to the FUSE mount point\n+            final String relPath = fusePath.substring(1);\n+            final Path tpath = mAlluxioRootPath.resolve(relPath);\n+            return new AlluxioURI(tpath.toString());\n+          }\n+        });\n+    mUidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String userName) {\n+            return AlluxioFuseUtils.getUid(userName);\n+          }\n+        });\n+    mGidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String groupName) {\n+            return AlluxioFuseUtils.getGidFromGroupName(groupName);\n+          }\n+        });\n+    mIsUserGroupTranslation = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mFileLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple path may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fd the file id\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getFileLock(long fd) {\n+    return mFileLocks[Math.floorMod((int) fd, LOCK_SIZE)];\n+  }\n+\n+  private void setUserGroupIfNeeded(AlluxioURI uri) throws Exception {\n+    SetAttributePOptions.Builder attributeOptionsBuilder = SetAttributePOptions.newBuilder();\n+    FuseContext fc = getContext();\n+    long uid = fc.uid.get();\n+    long gid = fc.gid.get();\n+    if (gid != DEFAULT_GID) {\n+      String groupName = AlluxioFuseUtils.getGroupName(gid);\n+      if (groupName.isEmpty()) {\n+        // This should never be reached since input gid is always valid\n+        LOG.error(\"Failed to get group name from gid {}, fallback to {}.\", gid, GROUP_NAME);\n+        groupName = GROUP_NAME;\n+      }\n+      attributeOptionsBuilder.setGroup(groupName);\n+    }\n+    if (uid != DEFAULT_UID) {\n+      String userName = AlluxioFuseUtils.getUserName(uid);\n+      if (userName.isEmpty()) {\n+        // This should never be reached since input uid is always valid\n+        LOG.error(\"Failed to get user name from uid {}, fallback to {}\", uid, USER_NAME);\n+        userName = USER_NAME;\n+      }\n+      attributeOptionsBuilder.setOwner(userName);\n+    }\n+    SetAttributePOptions setAttributePOptions =  attributeOptionsBuilder.build();\n+    if (gid != DEFAULT_GID || uid != DEFAULT_UID) {\n+      LOG.debug(\"Set attributes of path {} to {}\", uri, setAttributePOptions);\n+      mFileSystem.setAttribute(uri, setAttributePOptions);\n+    }\n+  }\n+\n+  @Override\n+  public int create(String path, long mode, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> createInternal(path, mode, fi),\n+        \"create\", \"path=%s,mode=%o\", path, mode);\n+  }\n+\n+  private int createInternal(String path, long mode, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    if (uri.getName().length() > MAX_NAME_LENGTH) {\n+      LOG.error(\"Failed to create {}: file name longer than {} characters\",\n+          path, MAX_NAME_LENGTH);\n+      return -ErrorCodes.ENAMETOOLONG();\n+    }\n+    try {\n+      FileOutStream os = mFileSystem.createFile(uri,\n+          CreateFilePOptions.newBuilder()\n+              .setMode(new Mode((short) mode).toProto())\n+              .build());\n+      long fid = mNextOpenFileId.getAndIncrement();\n+      mCreateFileEntries.put(fid, os);\n+      fi.fh.set(fid);\n+      setUserGroupIfNeeded(uri);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+    return 0;\n+  }\n+\n+  @Override\n+  public int getattr(String path, FileStat stat) {\n+    return AlluxioFuseUtils.call(\n+        LOG, () -> getattrInternal(path, stat), \"getattr\", \"path=%s\", path);\n+  }\n+\n+  private int getattrInternal(String path, FileStat stat) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      URIStatus status = mFileSystem.getStatus(uri);\n+      long size = status.getLength();\n+      stat.st_size.set(size);\n+\n+      // Sets block number to fulfill du command needs\n+      // `st_blksize` is ignored in `getattr` according to\n+      // https://github.com/libfuse/libfuse/blob/d4a7ba44b022e3b63fc215374d87ed9e930d9974/include/fuse.h#L302\n+      // According to http://man7.org/linux/man-pages/man2/stat.2.html,\n+      // `st_blocks` is the number of 512B blocks allocated\n+      stat.st_blocks.set((int) Math.ceil((double) size / 512));\n+\n+      final long ctime_sec = status.getLastModificationTimeMs() / 1000;\n+      // Keeps only the \"residual\" nanoseconds not caputred in citme_sec\n+      final long ctime_nsec = (status.getLastModificationTimeMs() % 1000) * 1000;\n+\n+      stat.st_ctim.tv_sec.set(ctime_sec);\n+      stat.st_ctim.tv_nsec.set(ctime_nsec);\n+      stat.st_mtim.tv_sec.set(ctime_sec);\n+      stat.st_mtim.tv_nsec.set(ctime_nsec);\n+\n+      if (mIsUserGroupTranslation) {\n+        // Translate the file owner/group to unix uid/gid\n+        // Show as uid==-1 (nobody) if owner does not exist in unix\n+        // Show as gid==-1 (nogroup) if group does not exist in unix\n+        stat.st_uid.set(mUidCache.get(status.getOwner()));\n+        stat.st_gid.set(mGidCache.get(status.getGroup()));\n+      } else {\n+        stat.st_uid.set(DEFAULT_UID);\n+        stat.st_gid.set(DEFAULT_GID);\n+      }\n+\n+      int mode = status.getMode();\n+      if (status.isFolder()) {\n+        mode |= FileStat.S_IFDIR;\n+      } else {\n+        mode |= FileStat.S_IFREG;\n+      }\n+      stat.st_mode.set(mode);\n+      stat.st_nlink.set(1);\n+    } catch (FileDoesNotExistException | InvalidPathException e) {\n+      LOG.debug(\"Failed to get info of {}, path does not exist or is invalid\", path);\n+      return -ErrorCodes.ENOENT();\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+\n+    return 0;\n+  }\n+\n+  @Override\n+  public int readdir(String path, long buff, FuseFillDir filter, long offset,\n+      FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> readdirInternal(path, buff, filter, offset, fi),\n+        \"readdir\", \"path=%s,buf=%s\", path, buff);\n+  }\n+\n+  private int readdirInternal(String path, long buff, FuseFillDir filter, long offset,\n+      FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      // standard . and .. entries\n+      filter.apply(buff, \".\", null, 0);\n+      filter.apply(buff, \"..\", null, 0);\n+\n+      mFileSystem.iterateStatus(uri, file -> {\n+        filter.apply(buff, file.getName(), null, 0);\n+      });\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to readdir {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+\n+    return 0;\n+  }\n+\n+  @Override\n+  public int open(String path, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> openInternal(path, fi), \"open\", \"path=%s\", path);\n+  }\n+\n+  private int openInternal(String path, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      long fd = mNextOpenFileId.getAndIncrement();\n+      FileInStream is = mFileSystem.openFile(uri);\n+      mOpenFileEntries.put(fd, is);\n+      fi.fh.set(fd);\n+      return 0;\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to open {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+  }\n+\n+  @Override\n+  public int read(String path, ByteBuffer buf, long size, long offset, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> readInternal(path, buf, size, offset, fi),\n+        \"read\", \"path=%s,buf=%s,size=%d,offset=%d\", path, buf, size, offset);\n+  }\n+\n+  private int readInternal(String path, ByteBuffer buf, long size, long offset, FuseFileInfo fi) {\n+    int nread = 0;\n+    int rd = 0;\n+    final int sz = (int) size;\n+    long fd = fi.fh.get();\n+    // FileInStream is not thread safe\n+    try (LockResource r1 = new LockResource(getFileLock(fd).writeLock())) {\n+      FileInStream is = mOpenFileEntries.get(fd);\n+      if (is == null) {\n+        LOG.error(\"Cannot find fd {} for {}\", fd, path);\n+        return -ErrorCodes.EBADFD();\n+      }\n+      is.seek(offset);\n+      final byte[] dest = new byte[sz];\n+      while (rd >= 0 && nread < size) {\n+        rd = is.read(dest, nread, sz - nread);\n+        if (rd >= 0) {\n+          nread += rd;\n+        }\n+      }\n+\n+      if (nread == -1) { // EOF\n+        nread = 0;\n+      } else if (nread > 0) {\n+        buf.put(dest, 0, nread);\n+      }\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to read {},{},{}: \", path, size, offset, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MjI0Mg==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540582242", "createdAt": "2020-12-10T23:41:34Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/fuse/AlluxioJniFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.fuse;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileOutStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.CreateFilePOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.jnifuse.AbstractFuseFileSystem;\n+import alluxio.jnifuse.ErrorCodes;\n+import alluxio.jnifuse.FuseFillDir;\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseContext;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.resource.LockResource;\n+import alluxio.security.authorization.Mode;\n+import alluxio.util.ThreadUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Main FUSE implementation class.\n+ * <p>\n+ * Implements the FUSE callbacks defined by jni-fuse.\n+ */\n+@ThreadSafe\n+public final class AlluxioJniFuseFileSystem extends AbstractFuseFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(AlluxioJniFuseFileSystem.class);\n+  private final FileSystem mFileSystem;\n+  private final AlluxioConfiguration mConf;\n+  // base path within Alluxio namespace that is used for FUSE operations\n+  // For example, if alluxio-fuse is mounted in /mnt/alluxio and mAlluxioRootPath\n+  // is /users/foo, then an operation on /mnt/alluxio/bar will be translated on\n+  // an action on the URI alluxio://<master>:<port>/users/foo/bar\n+  private final Path mAlluxioRootPath;\n+  // Keeps a cache of the most recently translated paths from String to Alluxio URI\n+  private final LoadingCache<String, AlluxioURI> mPathResolverCache;\n+  private final LoadingCache<String, Long> mUidCache;\n+  private final LoadingCache<String, Long> mGidCache;\n+  private final AtomicLong mNextOpenFileId = new AtomicLong(0);\n+  private final String mFsName;\n+\n+  private static final int LOCK_SIZE = 2048;\n+  /** A readwrite lock pool to guard individual files based on striping. */\n+  private final ReadWriteLock[] mFileLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+\n+  private final Map<Long, FileInStream> mOpenFileEntries = new ConcurrentHashMap<>();\n+  private final Map<Long, FileOutStream> mCreateFileEntries = new ConcurrentHashMap<>();\n+  private final boolean mIsUserGroupTranslation;\n+\n+  // To make test build\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE = -1;\n+  @VisibleForTesting\n+  public static final long ID_NOT_SET_VALUE_UNSIGNED = 4294967295L;\n+  /**\n+   * df command will treat -1 as an unknown value.\n+   */\n+  @VisibleForTesting\n+  public static final int UNKNOWN_INODES = -1;\n+  /**\n+   * Most FileSystems on linux limit the length of file name beyond 255 characters.\n+   */\n+  @VisibleForTesting\n+  public static final int MAX_NAME_LENGTH = 255;\n+\n+  private static final String USER_NAME = System.getProperty(\"user.name\");\n+  private static final String GROUP_NAME = System.getProperty(\"user.name\");\n+  private static final long DEFAULT_UID = AlluxioFuseUtils.getUid(USER_NAME);\n+  private static final long DEFAULT_GID = AlluxioFuseUtils.getGid(GROUP_NAME);\n+\n+  /**\n+   * Creates a new instance of {@link AlluxioJniFuseFileSystem}.\n+   *\n+   * @param fs Alluxio file system\n+   * @param opts options\n+   * @param conf Alluxio configuration\n+   */\n+  public AlluxioJniFuseFileSystem(\n+      FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {\n+    super(Paths.get(opts.getMountPoint()));\n+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);\n+    mFileSystem = fs;\n+    mConf = conf;\n+    mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());\n+    mPathResolverCache = CacheBuilder.newBuilder()\n+        .maximumSize(conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX))\n+        .build(new CacheLoader<String, AlluxioURI>() {\n+          @Override\n+          public AlluxioURI load(String fusePath) {\n+            // fusePath is guaranteed to always be an absolute path (i.e., starts\n+            // with a fwd slash) - relative to the FUSE mount point\n+            final String relPath = fusePath.substring(1);\n+            final Path tpath = mAlluxioRootPath.resolve(relPath);\n+            return new AlluxioURI(tpath.toString());\n+          }\n+        });\n+    mUidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String userName) {\n+            return AlluxioFuseUtils.getUid(userName);\n+          }\n+        });\n+    mGidCache = CacheBuilder.newBuilder()\n+        .maximumSize(100)\n+        .build(new CacheLoader<String, Long>() {\n+          @Override\n+          public Long load(String groupName) {\n+            return AlluxioFuseUtils.getGidFromGroupName(groupName);\n+          }\n+        });\n+    mIsUserGroupTranslation = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mFileLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple path may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fd the file id\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getFileLock(long fd) {\n+    return mFileLocks[Math.floorMod((int) fd, LOCK_SIZE)];\n+  }\n+\n+  private void setUserGroupIfNeeded(AlluxioURI uri) throws Exception {\n+    SetAttributePOptions.Builder attributeOptionsBuilder = SetAttributePOptions.newBuilder();\n+    FuseContext fc = getContext();\n+    long uid = fc.uid.get();\n+    long gid = fc.gid.get();\n+    if (gid != DEFAULT_GID) {\n+      String groupName = AlluxioFuseUtils.getGroupName(gid);\n+      if (groupName.isEmpty()) {\n+        // This should never be reached since input gid is always valid\n+        LOG.error(\"Failed to get group name from gid {}, fallback to {}.\", gid, GROUP_NAME);\n+        groupName = GROUP_NAME;\n+      }\n+      attributeOptionsBuilder.setGroup(groupName);\n+    }\n+    if (uid != DEFAULT_UID) {\n+      String userName = AlluxioFuseUtils.getUserName(uid);\n+      if (userName.isEmpty()) {\n+        // This should never be reached since input uid is always valid\n+        LOG.error(\"Failed to get user name from uid {}, fallback to {}\", uid, USER_NAME);\n+        userName = USER_NAME;\n+      }\n+      attributeOptionsBuilder.setOwner(userName);\n+    }\n+    SetAttributePOptions setAttributePOptions =  attributeOptionsBuilder.build();\n+    if (gid != DEFAULT_GID || uid != DEFAULT_UID) {\n+      LOG.debug(\"Set attributes of path {} to {}\", uri, setAttributePOptions);\n+      mFileSystem.setAttribute(uri, setAttributePOptions);\n+    }\n+  }\n+\n+  @Override\n+  public int create(String path, long mode, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> createInternal(path, mode, fi),\n+        \"create\", \"path=%s,mode=%o\", path, mode);\n+  }\n+\n+  private int createInternal(String path, long mode, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    if (uri.getName().length() > MAX_NAME_LENGTH) {\n+      LOG.error(\"Failed to create {}: file name longer than {} characters\",\n+          path, MAX_NAME_LENGTH);\n+      return -ErrorCodes.ENAMETOOLONG();\n+    }\n+    try {\n+      FileOutStream os = mFileSystem.createFile(uri,\n+          CreateFilePOptions.newBuilder()\n+              .setMode(new Mode((short) mode).toProto())\n+              .build());\n+      long fid = mNextOpenFileId.getAndIncrement();\n+      mCreateFileEntries.put(fid, os);\n+      fi.fh.set(fid);\n+      setUserGroupIfNeeded(uri);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+    return 0;\n+  }\n+\n+  @Override\n+  public int getattr(String path, FileStat stat) {\n+    return AlluxioFuseUtils.call(\n+        LOG, () -> getattrInternal(path, stat), \"getattr\", \"path=%s\", path);\n+  }\n+\n+  private int getattrInternal(String path, FileStat stat) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      URIStatus status = mFileSystem.getStatus(uri);\n+      long size = status.getLength();\n+      stat.st_size.set(size);\n+\n+      // Sets block number to fulfill du command needs\n+      // `st_blksize` is ignored in `getattr` according to\n+      // https://github.com/libfuse/libfuse/blob/d4a7ba44b022e3b63fc215374d87ed9e930d9974/include/fuse.h#L302\n+      // According to http://man7.org/linux/man-pages/man2/stat.2.html,\n+      // `st_blocks` is the number of 512B blocks allocated\n+      stat.st_blocks.set((int) Math.ceil((double) size / 512));\n+\n+      final long ctime_sec = status.getLastModificationTimeMs() / 1000;\n+      // Keeps only the \"residual\" nanoseconds not caputred in citme_sec\n+      final long ctime_nsec = (status.getLastModificationTimeMs() % 1000) * 1000;\n+\n+      stat.st_ctim.tv_sec.set(ctime_sec);\n+      stat.st_ctim.tv_nsec.set(ctime_nsec);\n+      stat.st_mtim.tv_sec.set(ctime_sec);\n+      stat.st_mtim.tv_nsec.set(ctime_nsec);\n+\n+      if (mIsUserGroupTranslation) {\n+        // Translate the file owner/group to unix uid/gid\n+        // Show as uid==-1 (nobody) if owner does not exist in unix\n+        // Show as gid==-1 (nogroup) if group does not exist in unix\n+        stat.st_uid.set(mUidCache.get(status.getOwner()));\n+        stat.st_gid.set(mGidCache.get(status.getGroup()));\n+      } else {\n+        stat.st_uid.set(DEFAULT_UID);\n+        stat.st_gid.set(DEFAULT_GID);\n+      }\n+\n+      int mode = status.getMode();\n+      if (status.isFolder()) {\n+        mode |= FileStat.S_IFDIR;\n+      } else {\n+        mode |= FileStat.S_IFREG;\n+      }\n+      stat.st_mode.set(mode);\n+      stat.st_nlink.set(1);\n+    } catch (FileDoesNotExistException | InvalidPathException e) {\n+      LOG.debug(\"Failed to get info of {}, path does not exist or is invalid\", path);\n+      return -ErrorCodes.ENOENT();\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to getattr {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+\n+    return 0;\n+  }\n+\n+  @Override\n+  public int readdir(String path, long buff, FuseFillDir filter, long offset,\n+      FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> readdirInternal(path, buff, filter, offset, fi),\n+        \"readdir\", \"path=%s,buf=%s\", path, buff);\n+  }\n+\n+  private int readdirInternal(String path, long buff, FuseFillDir filter, long offset,\n+      FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      // standard . and .. entries\n+      filter.apply(buff, \".\", null, 0);\n+      filter.apply(buff, \"..\", null, 0);\n+\n+      mFileSystem.iterateStatus(uri, file -> {\n+        filter.apply(buff, file.getName(), null, 0);\n+      });\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to readdir {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+\n+    return 0;\n+  }\n+\n+  @Override\n+  public int open(String path, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> openInternal(path, fi), \"open\", \"path=%s\", path);\n+  }\n+\n+  private int openInternal(String path, FuseFileInfo fi) {\n+    final AlluxioURI uri = mPathResolverCache.getUnchecked(path);\n+    try {\n+      long fd = mNextOpenFileId.getAndIncrement();\n+      FileInStream is = mFileSystem.openFile(uri);\n+      mOpenFileEntries.put(fd, is);\n+      fi.fh.set(fd);\n+      return 0;\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to open {}: \", path, e);\n+      return -ErrorCodes.EIO();\n+    }\n+  }\n+\n+  @Override\n+  public int read(String path, ByteBuffer buf, long size, long offset, FuseFileInfo fi) {\n+    return AlluxioFuseUtils.call(LOG, () -> readInternal(path, buf, size, offset, fi),\n+        \"read\", \"path=%s,buf=%s,size=%d,offset=%d\", path, buf, size, offset);\n+  }\n+\n+  private int readInternal(String path, ByteBuffer buf, long size, long offset, FuseFileInfo fi) {\n+    int nread = 0;\n+    int rd = 0;\n+    final int sz = (int) size;\n+    long fd = fi.fh.get();\n+    // FileInStream is not thread safe\n+    try (LockResource r1 = new LockResource(getFileLock(fd).writeLock())) {\n+      FileInStream is = mOpenFileEntries.get(fd);\n+      if (is == null) {\n+        LOG.error(\"Cannot find fd {} for {}\", fd, path);\n+        return -ErrorCodes.EBADFD();\n+      }\n+      is.seek(offset);\n+      final byte[] dest = new byte[sz];\n+      while (rd >= 0 && nread < size) {\n+        rd = is.read(dest, nread, sz - nread);\n+        if (rd >= 0) {\n+          nread += rd;\n+        }\n+      }\n+\n+      if (nread == -1) { // EOF\n+        nread = 0;\n+      } else if (nread > 0) {\n+        buf.put(dest, 0, nread);\n+      }\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to read {},{},{}: \", path, size, offset, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMzAxNQ=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQ1NTAzOnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/jnifuse/AbstractFuseFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODozNjo0OFrOIDXwJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo0MzoyN1rOIDikUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNTc5Ng==", "bodyText": "Should this be configurable somehow?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540405796", "createdAt": "2020-12-10T18:36:48Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/jnifuse/AbstractFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.jnifuse;\n+\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.jnifuse.struct.Statvfs;\n+import alluxio.jnifuse.utils.SecurityUtils;\n+import alluxio.util.OSUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Abstract class for other File System to extend and integrate with Fuse.\n+ */\n+public abstract class AbstractFuseFileSystem implements FuseFileSystem {\n+\n+  static {\n+    System.loadLibrary(\"jnifuse\");\n+  }\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractFuseFileSystem.class);\n+\n+  private static final int TIMEOUT = 2000; // ms", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4Mjk5NQ==", "bodyText": "this is only used for initialization, not worthy.\nI added more javadoc", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540582995", "createdAt": "2020-12-10T23:43:27Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/jnifuse/AbstractFuseFileSystem.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.jnifuse;\n+\n+import alluxio.jnifuse.struct.FileStat;\n+import alluxio.jnifuse.struct.FuseFileInfo;\n+import alluxio.jnifuse.struct.Statvfs;\n+import alluxio.jnifuse.utils.SecurityUtils;\n+import alluxio.util.OSUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Abstract class for other File System to extend and integrate with Fuse.\n+ */\n+public abstract class AbstractFuseFileSystem implements FuseFileSystem {\n+\n+  static {\n+    System.loadLibrary(\"jnifuse\");\n+  }\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractFuseFileSystem.class);\n+\n+  private static final int TIMEOUT = 2000; // ms", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNTc5Ng=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQ3MzcwOnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/jnifuse/struct/FileStat.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo0MToyN1rOIDX7ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo0NDoxMVrOIDilbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwODY3Nw==", "bodyText": "were these all copied from some other code/library?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540408677", "createdAt": "2020-12-10T18:41:27Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/jnifuse/struct/FileStat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.jnifuse.struct;\n+\n+import alluxio.util.OSUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+public class FileStat extends Struct {\n+  public static final int S_IFIFO = 0010000; // named pipe (fifo)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MzI3OA==", "bodyText": "based on JNR fuse", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540583278", "createdAt": "2020-12-10T23:44:11Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/jnifuse/struct/FileStat.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.jnifuse.struct;\n+\n+import alluxio.util.OSUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+public class FileStat extends Struct {\n+  public static final int S_IFIFO = 0010000; // named pipe (fifo)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwODY3Nw=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQ4MDIwOnYy", "diffSide": "RIGHT", "path": "integration/fuse/src/main/java/alluxio/jnifuse/struct/FuseFileInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo0Mjo1MlrOIDX_JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzo0NTowM1rOIDim4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwOTYzNg==", "bodyText": "Don't all these public classes/methods require javadoc? Why isn't checkstyle complaining?", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540409636", "createdAt": "2020-12-10T18:42:52Z", "author": {"login": "gpang"}, "path": "integration/fuse/src/main/java/alluxio/jnifuse/struct/FuseFileInfo.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.jnifuse.struct;\n+\n+import java.nio.ByteBuffer;\n+\n+public class FuseFileInfo extends Struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU4MzY0OA==", "bodyText": "i disabled style check for jnifuse/, as this intentionally preserves a lot C style to match linux kernel for readability.", "url": "https://github.com/Alluxio/alluxio/pull/12606#discussion_r540583648", "createdAt": "2020-12-10T23:45:03Z", "author": {"login": "apc999"}, "path": "integration/fuse/src/main/java/alluxio/jnifuse/struct/FuseFileInfo.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.jnifuse.struct;\n+\n+import java.nio.ByteBuffer;\n+\n+public class FuseFileInfo extends Struct {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwOTYzNg=="}, "originalCommit": {"oid": "46187f86b355ea86654186c33f9a4111e46b7359"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 941, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}