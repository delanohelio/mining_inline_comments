{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMTU1MjY5", "number": 11205, "title": "Add Glue UDB to Catalog Service", "bodyText": "", "createdAt": "2020-03-24T17:44:31Z", "url": "https://github.com/Alluxio/alluxio/pull/11205", "merged": true, "mergeCommit": {"oid": "c3b22f914b5e87ef5c2b5caa94661cf75b0f60c7"}, "closed": true, "closedAt": "2020-04-25T17:13:58Z", "author": {"login": "HelloHorizon"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcT1Ue1gFqTM4MDc4NDI1NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbJUjdAFqTQwMDQxMzAwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzg0MjU0", "url": "https://github.com/Alluxio/alluxio/pull/11205#pullrequestreview-380784254", "createdAt": "2020-03-25T00:19:18Z", "commit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMDoxOToxOVrOF7H3-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzo1MjowMlrOGAAdCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzOTMyMA==", "bodyText": "why is this change included in this PR? seems unrelated?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r397539320", "createdAt": "2020-03-25T00:19:19Z", "author": {"login": "yuzhu"}, "path": "docs/en/operation/Metrics-System.md", "diffHunk": "@@ -89,6 +89,7 @@ sink.csv.directory=/tmp/alluxio-metrics\n ```\n \n If Alluxio is deployed in a cluster, this file needs to be distributed to all the nodes.\n+Restart the Alluxio servers to active new configuration changes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYxMDU3Mg==", "bodyText": "This class seems identical/ very similar to HiveLayout? can we refactor?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402610572", "createdAt": "2020-04-02T21:36:59Z", "author": {"login": "yuzhu"}, "path": "table/server/common/src/main/java/alluxio/table/common/layout/GlueLayout.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.common.layout;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.job.plan.transform.HiveConstants;\n+import alluxio.table.common.Layout;\n+import alluxio.table.common.transform.TransformContext;\n+import alluxio.table.common.transform.TransformDefinition;\n+import alluxio.table.common.transform.TransformPlan;\n+import alluxio.util.ConfigurationUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Glue table layout implementation.\n+ * Glue use same proto as hive.\n+ */\n+public class GlueLayout implements Layout {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYxMTQxOQ==", "bodyText": "we need to document the glue version we support in our documentation", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402611419", "createdAt": "2020-04-02T21:38:59Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/pom.xml", "diffHunk": "@@ -0,0 +1,52 @@\n+<!--\n+\n+    The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+    (the \"License\"). You may not use this work except in compliance with the License, which is\n+    available at www.apache.org/licenses/LICENSE-2.0\n+\n+    This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+    either express or implied, as more fully set forth in the License.\n+\n+    See the NOTICE file distributed with this work for information regarding copyright ownership.\n+\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>alluxio-table-server-underdb</artifactId>\n+        <groupId>org.alluxio</groupId>\n+        <version>2.3.0-SNAPSHOT</version>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>alluxio-table-server-underdb-glue</artifactId>\n+    <packaging>jar</packaging>\n+    <name>Alluxio Table - Server - UnderDB - Glue</name>\n+    <description>Alluxio table underDB implementation for aws glue</description>\n+\n+    <properties>\n+        <!-- The following paths need to be defined here as well as in the parent pom so that mvn can -->\n+        <!-- run properly from sub-project directories -->\n+        <build.path>${project.parent.parent.parent.parent.basedir}/build</build.path>\n+        <glue.version>1.11.602</glue.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYxMjIyNw==", "bodyText": "could you make this log message specific to glue?  error messages are ideally unique in each class", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402612227", "createdAt": "2020-04-02T21:40:48Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.layout.GlueLayoutFactory;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.table.under.glue.util.PathTranslator;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Geting database information from database: \" + mGlueDbName + \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYxNDQwNw==", "bodyText": "does the default provider chain fail all the time? because it has no credentials?\nor does it use the user credentials who launched the machine to determine>?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402614407", "createdAt": "2020-04-02T21:45:43Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.layout.GlueLayoutFactory;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.table.under.glue.util.PathTranslator;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Geting database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.debug(\"Set Glue region: \" + config.get(Property.GLUE_REGION) + \".\");\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYxNTM5OA==", "bodyText": "can this method be merged with the mounting method in the hive UDB implementation? they should not be that different right?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402615398", "createdAt": "2020-04-02T21:48:00Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.layout.GlueLayoutFactory;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.table.under.glue.util.PathTranslator;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Geting database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.debug(\"Set Glue region: \" + config.get(Property.GLUE_REGION) + \".\");\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private String mountAlluxioPath(String tableName, AlluxioURI ufsUri, AlluxioURI tableUri)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1OTgyOQ==", "bodyText": "similarly , can this be refactored?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402659829", "createdAt": "2020-04-02T23:49:13Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.layout.GlueLayoutFactory;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.table.under.glue.util.PathTranslator;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Geting database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.debug(\"Set Glue region: \" + config.get(Property.GLUE_REGION) + \".\");\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private String mountAlluxioPath(String tableName, AlluxioURI ufsUri, AlluxioURI tableUri)\n+      throws IOException, AlluxioException {\n+    if (Objects.equals(ufsUri.getScheme(), Constants.SCHEME)) {\n+      // already an alluxio uri, return the alluxio uri\n+      return ufsUri.toString();\n+    }\n+    try {\n+      tableUri = mUdbContext.getFileSystem().reverseResolve(ufsUri);\n+      LOG.debug(\"Trying to mount table {} location {}, but it is already mounted at location {}\",\n+          tableName, ufsUri, tableUri);\n+      return tableUri.getPath();\n+    } catch (InvalidPathException e) {\n+      // ufs path not mounted, continue\n+    }\n+    // make sure the parent exists\n+    mUdbContext.getFileSystem().createDirectory(tableUri.getParent(),\n+        CreateDirectoryPOptions.newBuilder().setRecursive(true).setAllowExists(true).build());\n+    Map<String, String> mountOptionMap = mGlueConfiguration.getMountOption(\n+        String.format(\"%s://%s/\", ufsUri.getScheme(), ufsUri.getAuthority().toString()));\n+    MountPOptions.Builder option = MountPOptions.newBuilder();\n+    for (Map.Entry<String, String> entry : mountOptionMap.entrySet()) {\n+      if (entry.getKey().equals(UdbConfiguration.READ_ONLY_OPTION)) {\n+        option.setReadOnly(Boolean.parseBoolean(entry.getValue()));\n+      } else if (entry.getKey().equals(UdbConfiguration.SHARED_OPTION)) {\n+        option.setShared(Boolean.parseBoolean(entry.getValue()));\n+      } else {\n+        option.putProperties(entry.getKey(), entry.getValue());\n+      }\n+    }\n+    mUdbContext.getFileSystem().mount(tableUri, ufsUri, option.build());\n+\n+    LOG.info(\"mounted table {} location {} to Alluxio location {} with mountOption {}\",\n+        tableName, ufsUri, tableUri, option.build());\n+    return tableUri.getPath();\n+  }\n+\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2MDE0Nw==", "bodyText": "one thing i noticed when doing the Hive version of this, is that the client sometimes does not handle disconnection well. Have you tested the case where the connection is not always stable?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402660147", "createdAt": "2020-04-02T23:50:25Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.layout.GlueLayoutFactory;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.table.under.glue.util.PathTranslator;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Geting database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.debug(\"Set Glue region: \" + config.get(Property.GLUE_REGION) + \".\");\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private String mountAlluxioPath(String tableName, AlluxioURI ufsUri, AlluxioURI tableUri)\n+      throws IOException, AlluxioException {\n+    if (Objects.equals(ufsUri.getScheme(), Constants.SCHEME)) {\n+      // already an alluxio uri, return the alluxio uri\n+      return ufsUri.toString();\n+    }\n+    try {\n+      tableUri = mUdbContext.getFileSystem().reverseResolve(ufsUri);\n+      LOG.debug(\"Trying to mount table {} location {}, but it is already mounted at location {}\",\n+          tableName, ufsUri, tableUri);\n+      return tableUri.getPath();\n+    } catch (InvalidPathException e) {\n+      // ufs path not mounted, continue\n+    }\n+    // make sure the parent exists\n+    mUdbContext.getFileSystem().createDirectory(tableUri.getParent(),\n+        CreateDirectoryPOptions.newBuilder().setRecursive(true).setAllowExists(true).build());\n+    Map<String, String> mountOptionMap = mGlueConfiguration.getMountOption(\n+        String.format(\"%s://%s/\", ufsUri.getScheme(), ufsUri.getAuthority().toString()));\n+    MountPOptions.Builder option = MountPOptions.newBuilder();\n+    for (Map.Entry<String, String> entry : mountOptionMap.entrySet()) {\n+      if (entry.getKey().equals(UdbConfiguration.READ_ONLY_OPTION)) {\n+        option.setReadOnly(Boolean.parseBoolean(entry.getValue()));\n+      } else if (entry.getKey().equals(UdbConfiguration.SHARED_OPTION)) {\n+        option.setShared(Boolean.parseBoolean(entry.getValue()));\n+      } else {\n+        option.putProperties(entry.getKey(), entry.getValue());\n+      }\n+    }\n+    mUdbContext.getFileSystem().mount(tableUri, ufsUri, option.build());\n+\n+    LOG.info(\"mounted table {} location {} to Alluxio location {} with mountOption {}\",\n+        tableName, ufsUri, tableUri, option.build());\n+    return tableUri.getPath();\n+  }\n+\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)\n+      throws IOException {\n+    String tableName = table.getName();\n+    AlluxioURI ufsUri;\n+    AlluxioURI alluxioUri = mUdbContext.getTableLocation(tableName);\n+    String glueUfsUri = table.getStorageDescriptor().getLocation();\n+\n+    try {\n+      PathTranslator pathTranslator = new PathTranslator();\n+      ufsUri = new AlluxioURI(table.getStorageDescriptor().getLocation());\n+      pathTranslator.addMapping(mountAlluxioPath(tableName, ufsUri, alluxioUri), glueUfsUri);\n+\n+      for (Partition partition : partitions) {\n+        AlluxioURI partitionUri;\n+        if (partition.getStorageDescriptor() != null\n+            && partition.getStorageDescriptor().getLocation() != null\n+            && ufsUri.isAncestorOf(\n+            partitionUri = new AlluxioURI(\n+                partition.getStorageDescriptor().getLocation()))) {\n+          glueUfsUri = partition.getStorageDescriptor().getLocation();\n+          String partitionName = partition.getValues().toString();\n+          // Glue does not provide makePartName as Hive, use a simple conveter for place holder\n+          try {\n+            partitionName = GlueUtils.makePartitionName(table, partition);\n+          } catch (IOException e) {\n+            LOG.warn(\"Error making partition name for table {}, partition {}\", tableName,\n+                partition.getValues().toString());\n+          }\n+          alluxioUri = new AlluxioURI(\n+              PathUtils.concatPath(\n+                  mUdbContext.getTableLocation(tableName).getPath(),\n+                  partitionName));\n+          // mount partition path if it is not already mounted as part of the table path mount\n+          pathTranslator\n+              .addMapping(mountAlluxioPath(tableName, partitionUri, alluxioUri), glueUfsUri);\n+        }\n+      }\n+      return pathTranslator;\n+    } catch (AlluxioException e) {\n+      throw new IOException(\n+          \"Failed to mount table location. tableName: \" + tableName\n+              + \" glueUfsLocation: \" + glueUfsUri\n+              + \" AlluxioLocation: \" + alluxioUri + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @Override\n+  public UdbTable getTable(String tableName) throws IOException {\n+    Table table;\n+    try {\n+      GetTableRequest tableRequest = new GetTableRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withDatabaseName(mGlueDbName)\n+          .withName(tableName);\n+      table = getClient().getTable(tableRequest).getTable();\n+\n+      List<Partition> partitions = batchGetPartitions(getClient(), tableName);\n+      PathTranslator pathTranslator = mountAlluxioPaths(table, partitions);\n+\n+      // Glue does not provide column statistic information\n+      List<ColumnStatisticsInfo> columnStatisticsData = new ArrayList<>();\n+\n+      PartitionInfo partitionInfo = PartitionInfo.newBuilder()\n+          .setDbName(mGlueDbName)\n+          .setTableName(tableName)\n+          .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+          .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+          .putAllParameters(table.getParameters())\n+          .build();\n+\n+      Layout layout = Layout.newBuilder()\n+          .setLayoutType(GlueLayoutFactory.TYPE)\n+          .setLayoutData(partitionInfo.toByteString())\n+          .build();\n+\n+      return new GlueTable(this,\n+          pathTranslator,\n+          tableName,\n+          GlueUtils.toProtoSchema(table.getStorageDescriptor().getColumns()),\n+          columnStatisticsData,\n+          // Glue does not provide FieldSchema from API directly\n+          // Get FieldSchema from storage description\n+          GlueUtils.toProto(table.getPartitionKeys()),\n+          partitions,\n+          layout,\n+          table);\n+    } catch (EntityNotFoundException e) {\n+      throw new NotFoundException(\"Table \" + tableName + \" does not exist.\", e);\n+    } catch (ValidationException e) {\n+      e.printStackTrace();\n+      throw new IOException(\"Failed to get table: \"\n+          + tableName + \" with validation error: \" + e.getMessage(), e);\n+    } catch (GlueEncryptionException e) {\n+      throw new IOException(\"Failed to get table: \" + tableName + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private List<Partition> batchGetPartitions(AWSGlueAsync glueClient, String tableName)\n+      throws IOException {\n+    List<Partition> partitions = new ArrayList<>();\n+    try {\n+      GetPartitionsRequest getPartitionsRequest =\n+          new GetPartitionsRequest()\n+              .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+              .withDatabaseName(mGlueDbName)\n+              .withTableName(tableName);\n+      if (glueClient.getPartitions(getPartitionsRequest).getPartitions() != null) {\n+        partitions = glueClient.getPartitions(getPartitionsRequest).getPartitions();\n+      }\n+      return partitions;\n+    } catch (AWSGlueException e) {\n+      throw new IOException(\"WARNING: Cannot get partition information for table: \"\n+          + tableName + \". error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * Get Glue Client.\n+   *\n+   * @return async glue client\n+   */\n+  public AWSGlueAsync getClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2MDYxNg==", "bodyText": "what is the difference between this class and the HiveTable class? can we refactor to reduce duplicated code?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r402660616", "createdAt": "2020-04-02T23:52:02Z", "author": {"login": "yuzhu"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueTable.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.FieldSchema;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.Schema;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.GlueLayout;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.under.glue.util.PathTranslator;\n+\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Glue table implementation.\n+ */\n+public class GlueTable implements UdbTable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 41}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72401057b372ae12bc95737498d4fcba8999d5cc", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/72401057b372ae12bc95737498d4fcba8999d5cc", "committedDate": "2020-04-03T23:15:30Z", "message": "Optimize Glue Database log information"}, "afterCommit": {"oid": "0a688b1a97a1f49acaa18c78658cca61e76972aa", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/0a688b1a97a1f49acaa18c78658cca61e76972aa", "committedDate": "2020-04-04T05:17:02Z", "message": "Remove redudant glue layout"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjQxNTQ3", "url": "https://github.com/Alluxio/alluxio/pull/11205#pullrequestreview-392241547", "createdAt": "2020-04-13T16:03:13Z", "commit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjowMzoxM1rOGErUxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjozOTo0NFrOGEsiSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1NzMxNg==", "bodyText": "Is this parameter used anywhere?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407557316", "createdAt": "2020-04-13T16:03:13Z", "author": {"login": "gpang"}, "path": "table/server/common/pom.xml", "diffHunk": "@@ -27,6 +27,7 @@\n     <!-- run properly from sub-project directories -->\n     <build.path>${project.parent.parent.parent.basedir}/build</build.path>\n     <failIfNoTests>false</failIfNoTests>\n+    <hive.version>2.2.0</hive.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODUwMw==", "bodyText": "does the glue udb connect to a hive metastore?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407558503", "createdAt": "2020-04-13T16:05:25Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/pom.xml", "diffHunk": "@@ -0,0 +1,74 @@\n+<!--\n+\n+    The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+    (the \"License\"). You may not use this work except in compliance with the License, which is\n+    available at www.apache.org/licenses/LICENSE-2.0\n+\n+    This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+    either express or implied, as more fully set forth in the License.\n+\n+    See the NOTICE file distributed with this work for information regarding copyright ownership.\n+\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>alluxio-table-server-underdb</artifactId>\n+        <groupId>org.alluxio</groupId>\n+        <version>2.3.0-SNAPSHOT</version>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>alluxio-table-server-underdb-glue</artifactId>\n+    <packaging>jar</packaging>\n+    <name>Alluxio Table - Server - UnderDB - Glue</name>\n+    <description>Alluxio table underDB implementation for aws glue</description>\n+\n+    <properties>\n+        <!-- The following paths need to be defined here as well as in the parent pom so that mvn can -->\n+        <!-- run properly from sub-project directories -->\n+        <build.path>${project.parent.parent.parent.parent.basedir}/build</build.path>\n+        <glue.version>1.11.602</glue.version>\n+        <aws.java.jdk.version>1.11.475</aws.java.jdk.version>\n+        <hive-metastore.version>2.2.0</hive-metastore.version>\n+    </properties>\n+\n+    <dependencies>\n+        <!-- External dependencies -->\n+        <dependency>\n+            <groupId>com.amazonaws</groupId>\n+            <artifactId>aws-java-sdk-glue</artifactId>\n+            <version>${glue.version}</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>com.amazonaws</groupId>\n+            <artifactId>aws-java-sdk-core</artifactId>\n+            <version>${aws.java.jdk.version}</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.apache.hive</groupId>\n+            <artifactId>hive-metastore</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MDE3NA==", "bodyText": "I think udbProperty should just be property", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407560174", "createdAt": "2020-04-13T16:08:32Z", "author": {"login": "gpang"}, "path": "table/server/common/src/main/java/alluxio/table/common/BaseConfiguration.java", "diffHunk": "@@ -55,6 +57,23 @@ public String get(T property) {\n     return value;\n   }\n \n+  /**\n+   * Return the int value of this property , or the default value if the property is not defined.\n+   *\n+   * @param udbProperty the udb property to get the int value\n+   * @return the int value of udb property\n+   */\n+  public int getInt(T udbProperty) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MDI4MQ==", "bodyText": "\"udb property\" should just be \"property\"", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407560281", "createdAt": "2020-04-13T16:08:43Z", "author": {"login": "gpang"}, "path": "table/server/common/src/main/java/alluxio/table/common/BaseConfiguration.java", "diffHunk": "@@ -55,6 +57,23 @@ public String get(T property) {\n     return value;\n   }\n \n+  /**\n+   * Return the int value of this property , or the default value if the property is not defined.\n+   *\n+   * @param udbProperty the udb property to get the int value\n+   * @return the int value of udb property", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MjA5Mw==", "bodyText": "I think we typically name these types of class with \"Utils\". So, it should be UdbUtils", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407562093", "createdAt": "2020-04-13T16:12:07Z", "author": {"login": "gpang"}, "path": "table/server/common/src/main/java/alluxio/table/common/udb/UdbUtil.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.common.udb;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Udb related utils.\n+ */\n+public class UdbUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzgwMA==", "bodyText": "is it ok if it is an empty string?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407563800", "createdAt": "2020-04-13T16:15:09Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NDI1OA==", "bodyText": "Is this log message necessary? Should it be debug level?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407564258", "createdAt": "2020-04-13T16:16:06Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NDc0OQ==", "bodyText": "instead of taking the glue map, can we instead add all those parameters into glueParameters?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407564749", "createdAt": "2020-04-13T16:17:05Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NTU0OA==", "bodyText": "This needs a space after \"database\" and  space before the e.getMessage(). Also, can we add the catalog id to the message?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407565548", "createdAt": "2020-04-13T16:18:34Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NjI1NA==", "bodyText": "which test uses this?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407566254", "createdAt": "2020-04-13T16:19:48Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NzUwNg==", "bodyText": "Wasn't this already moved to a Utils class?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407567506", "createdAt": "2020-04-13T16:22:12Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.Constants;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.CreateDirectoryPOptions;\n+import alluxio.grpc.MountPOptions;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.layout.GlueLayoutFactory;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.table.under.glue.util.PathTranslator;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Geting database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.debug(\"Set Glue region: \" + config.get(Property.GLUE_REGION) + \".\");\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private String mountAlluxioPath(String tableName, AlluxioURI ufsUri, AlluxioURI tableUri)\n+      throws IOException, AlluxioException {\n+    if (Objects.equals(ufsUri.getScheme(), Constants.SCHEME)) {\n+      // already an alluxio uri, return the alluxio uri\n+      return ufsUri.toString();\n+    }\n+    try {\n+      tableUri = mUdbContext.getFileSystem().reverseResolve(ufsUri);\n+      LOG.debug(\"Trying to mount table {} location {}, but it is already mounted at location {}\",\n+          tableName, ufsUri, tableUri);\n+      return tableUri.getPath();\n+    } catch (InvalidPathException e) {\n+      // ufs path not mounted, continue\n+    }\n+    // make sure the parent exists\n+    mUdbContext.getFileSystem().createDirectory(tableUri.getParent(),\n+        CreateDirectoryPOptions.newBuilder().setRecursive(true).setAllowExists(true).build());\n+    Map<String, String> mountOptionMap = mGlueConfiguration.getMountOption(\n+        String.format(\"%s://%s/\", ufsUri.getScheme(), ufsUri.getAuthority().toString()));\n+    MountPOptions.Builder option = MountPOptions.newBuilder();\n+    for (Map.Entry<String, String> entry : mountOptionMap.entrySet()) {\n+      if (entry.getKey().equals(UdbConfiguration.READ_ONLY_OPTION)) {\n+        option.setReadOnly(Boolean.parseBoolean(entry.getValue()));\n+      } else if (entry.getKey().equals(UdbConfiguration.SHARED_OPTION)) {\n+        option.setShared(Boolean.parseBoolean(entry.getValue()));\n+      } else {\n+        option.putProperties(entry.getKey(), entry.getValue());\n+      }\n+    }\n+    mUdbContext.getFileSystem().mount(tableUri, ufsUri, option.build());\n+\n+    LOG.info(\"mounted table {} location {} to Alluxio location {} with mountOption {}\",\n+        tableName, ufsUri, tableUri, option.build());\n+    return tableUri.getPath();\n+  }\n+\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1OTgyOQ=="}, "originalCommit": {"oid": "08b396f38815969a7666b2c30cd0afe81b27489f"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NzkwMw==", "bodyText": "can you also add catalog id and database name into the message?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407567903", "createdAt": "2020-04-13T16:22:54Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.info(\"Set Glue region: {}.\", config.get(Property.GLUE_REGION));\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access key id.\");\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access secret key.\");\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2ODcxMg==", "bodyText": "is this necessary?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407568712", "createdAt": "2020-04-13T16:24:25Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.info(\"Set Glue region: {}.\", config.get(Property.GLUE_REGION));\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access key id.\");\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access secret key.\");\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)\n+      throws IOException {\n+    String tableName = table.getName();\n+    AlluxioURI ufsUri;\n+    AlluxioURI alluxioUri = mUdbContext.getTableLocation(tableName);\n+    String glueUfsUri = table.getStorageDescriptor().getLocation();\n+\n+    try {\n+      PathTranslator pathTranslator = new PathTranslator();\n+      ufsUri = new AlluxioURI(table.getStorageDescriptor().getLocation());\n+      pathTranslator.addMapping(\n+          UdbUtil.mountAlluxioPath(\n+              tableName,\n+              ufsUri,\n+              alluxioUri,\n+              mUdbContext,\n+              mGlueConfiguration),\n+          glueUfsUri);\n+\n+      for (Partition partition : partitions) {\n+        AlluxioURI partitionUri;\n+        String partitionName;\n+        if (partition.getStorageDescriptor() != null\n+            && partition.getStorageDescriptor().getLocation() != null\n+            && ufsUri.isAncestorOf(\n+            partitionUri = new AlluxioURI(\n+                partition.getStorageDescriptor().getLocation()))) {\n+          glueUfsUri = partition.getStorageDescriptor().getLocation();\n+          partitionName = partition.getValues().toString();\n+          try {\n+            partitionName = GlueUtils.makePartitionName(\n+                table.getPartitionKeys(),\n+                partition.getValues());\n+          } catch (IOException e) {\n+            LOG.warn(\"Error making partition name for table {}, partition {}\", tableName,\n+                partition.getValues().toString());\n+          }\n+          alluxioUri = new AlluxioURI(\n+              PathUtils.concatPath(\n+                  mUdbContext.getTableLocation(tableName).getPath(),\n+                  partitionName));\n+          // mount partition path if it is not already mounted as part of the table path mount\n+          pathTranslator\n+              .addMapping(\n+                  UdbUtil.mountAlluxioPath(\n+                      tableName,\n+                      partitionUri,\n+                      alluxioUri,\n+                      mUdbContext,\n+                      mGlueConfiguration),\n+                  glueUfsUri);\n+        }\n+      }\n+      return pathTranslator;\n+    } catch (AlluxioException e) {\n+      throw new IOException(\n+          \"Failed to mount table location. tableName: \" + tableName\n+              + \" glueUfsLocation: \" + glueUfsUri\n+              + \" AlluxioLocation: \" + alluxioUri + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @Override\n+  public UdbTable getTable(String tableName) throws IOException {\n+    Table table;\n+    List<Partition> partitions;\n+    // Glue doesn't support column statistics infomation\n+    Map<String, List<ColumnStatisticsInfo>> statsMap = new HashMap<>();\n+    try {\n+      GetTableRequest tableRequest = new GetTableRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withDatabaseName(mGlueDbName)\n+          .withName(tableName);\n+      table = getClient().getTable(tableRequest).getTable();\n+\n+      partitions = batchGetPartitions(getClient(), tableName);\n+      PathTranslator pathTranslator = mountAlluxioPaths(table, partitions);\n+\n+      // Glue does not provide column statistic information\n+      List<ColumnStatisticsInfo> columnStatisticsData = new ArrayList<>();\n+\n+      PartitionInfo partitionInfo = PartitionInfo.newBuilder()\n+          .setDbName(mGlueDbName)\n+          .setTableName(tableName)\n+          .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+          .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+          .putAllParameters(table.getParameters())\n+          .build();\n+\n+      Layout layout = Layout.newBuilder()\n+          .setLayoutType(HiveLayout.TYPE)\n+          .setLayoutData(partitionInfo.toByteString())\n+          .build();\n+\n+      List<Column> partitionColumns = table.getPartitionKeys();\n+\n+      List<UdbPartition> udbPartitions = new ArrayList<>();\n+      if (partitionColumns.isEmpty()) {\n+        PartitionInfo.Builder partitionInfoBuilder = PartitionInfo.newBuilder()\n+            .setDbName(mUdbContext.getDbName())\n+            .setTableName(tableName)\n+            .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+            .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+            .setPartitionName(tableName)\n+            .putAllParameters(table.getParameters());\n+        udbPartitions.add(new GluePartition(\n+            new HiveLayout(partitionInfoBuilder.build(), Collections.emptyList())));\n+      } else {\n+        for (Partition partition : partitions) {\n+          String partName = GlueUtils.makePartitionName(partitionColumns, partition.getValues());\n+          PartitionInfo.Builder pib = PartitionInfo.newBuilder()\n+              .setDbName(getUdbContext().getDbName())\n+              .setTableName(tableName)\n+              .addAllDataCols(GlueUtils.toProto(partition.getStorageDescriptor().getColumns()))\n+              .setStorage(GlueUtils.toProto(partition.getStorageDescriptor(), pathTranslator))\n+              .setPartitionName(partName)\n+              .putAllParameters(partition.getParameters());\n+          if (partition.getValues() != null) {\n+            pib.addAllValues(partition.getValues());\n+          }\n+          udbPartitions.add(new GluePartition(new HiveLayout(pib.build(),\n+              statsMap.getOrDefault(partName, Collections.emptyList()))));\n+        }\n+      }\n+\n+      return new GlueTable(this,\n+          pathTranslator,\n+          tableName,\n+          GlueUtils.toProtoSchema(table.getStorageDescriptor().getColumns()),\n+          columnStatisticsData,\n+          // Glue does not provide FieldSchema from API directly\n+          // Get FieldSchema from partition keys\n+          GlueUtils.toProto(table.getPartitionKeys()),\n+          udbPartitions,\n+          layout,\n+          table);\n+    } catch (EntityNotFoundException e) {\n+      throw new NotFoundException(\"Table \" + tableName + \" does not exist.\", e);\n+    } catch (ValidationException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjE2Ng==", "bodyText": "For this exception and others in this method, can you add catalog id and database name?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407572166", "createdAt": "2020-04-13T16:30:29Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.info(\"Set Glue region: {}.\", config.get(Property.GLUE_REGION));\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access key id.\");\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access secret key.\");\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)\n+      throws IOException {\n+    String tableName = table.getName();\n+    AlluxioURI ufsUri;\n+    AlluxioURI alluxioUri = mUdbContext.getTableLocation(tableName);\n+    String glueUfsUri = table.getStorageDescriptor().getLocation();\n+\n+    try {\n+      PathTranslator pathTranslator = new PathTranslator();\n+      ufsUri = new AlluxioURI(table.getStorageDescriptor().getLocation());\n+      pathTranslator.addMapping(\n+          UdbUtil.mountAlluxioPath(\n+              tableName,\n+              ufsUri,\n+              alluxioUri,\n+              mUdbContext,\n+              mGlueConfiguration),\n+          glueUfsUri);\n+\n+      for (Partition partition : partitions) {\n+        AlluxioURI partitionUri;\n+        String partitionName;\n+        if (partition.getStorageDescriptor() != null\n+            && partition.getStorageDescriptor().getLocation() != null\n+            && ufsUri.isAncestorOf(\n+            partitionUri = new AlluxioURI(\n+                partition.getStorageDescriptor().getLocation()))) {\n+          glueUfsUri = partition.getStorageDescriptor().getLocation();\n+          partitionName = partition.getValues().toString();\n+          try {\n+            partitionName = GlueUtils.makePartitionName(\n+                table.getPartitionKeys(),\n+                partition.getValues());\n+          } catch (IOException e) {\n+            LOG.warn(\"Error making partition name for table {}, partition {}\", tableName,\n+                partition.getValues().toString());\n+          }\n+          alluxioUri = new AlluxioURI(\n+              PathUtils.concatPath(\n+                  mUdbContext.getTableLocation(tableName).getPath(),\n+                  partitionName));\n+          // mount partition path if it is not already mounted as part of the table path mount\n+          pathTranslator\n+              .addMapping(\n+                  UdbUtil.mountAlluxioPath(\n+                      tableName,\n+                      partitionUri,\n+                      alluxioUri,\n+                      mUdbContext,\n+                      mGlueConfiguration),\n+                  glueUfsUri);\n+        }\n+      }\n+      return pathTranslator;\n+    } catch (AlluxioException e) {\n+      throw new IOException(\n+          \"Failed to mount table location. tableName: \" + tableName\n+              + \" glueUfsLocation: \" + glueUfsUri\n+              + \" AlluxioLocation: \" + alluxioUri + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @Override\n+  public UdbTable getTable(String tableName) throws IOException {\n+    Table table;\n+    List<Partition> partitions;\n+    // Glue doesn't support column statistics infomation\n+    Map<String, List<ColumnStatisticsInfo>> statsMap = new HashMap<>();\n+    try {\n+      GetTableRequest tableRequest = new GetTableRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withDatabaseName(mGlueDbName)\n+          .withName(tableName);\n+      table = getClient().getTable(tableRequest).getTable();\n+\n+      partitions = batchGetPartitions(getClient(), tableName);\n+      PathTranslator pathTranslator = mountAlluxioPaths(table, partitions);\n+\n+      // Glue does not provide column statistic information\n+      List<ColumnStatisticsInfo> columnStatisticsData = new ArrayList<>();\n+\n+      PartitionInfo partitionInfo = PartitionInfo.newBuilder()\n+          .setDbName(mGlueDbName)\n+          .setTableName(tableName)\n+          .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+          .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+          .putAllParameters(table.getParameters())\n+          .build();\n+\n+      Layout layout = Layout.newBuilder()\n+          .setLayoutType(HiveLayout.TYPE)\n+          .setLayoutData(partitionInfo.toByteString())\n+          .build();\n+\n+      List<Column> partitionColumns = table.getPartitionKeys();\n+\n+      List<UdbPartition> udbPartitions = new ArrayList<>();\n+      if (partitionColumns.isEmpty()) {\n+        PartitionInfo.Builder partitionInfoBuilder = PartitionInfo.newBuilder()\n+            .setDbName(mUdbContext.getDbName())\n+            .setTableName(tableName)\n+            .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+            .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+            .setPartitionName(tableName)\n+            .putAllParameters(table.getParameters());\n+        udbPartitions.add(new GluePartition(\n+            new HiveLayout(partitionInfoBuilder.build(), Collections.emptyList())));\n+      } else {\n+        for (Partition partition : partitions) {\n+          String partName = GlueUtils.makePartitionName(partitionColumns, partition.getValues());\n+          PartitionInfo.Builder pib = PartitionInfo.newBuilder()\n+              .setDbName(getUdbContext().getDbName())\n+              .setTableName(tableName)\n+              .addAllDataCols(GlueUtils.toProto(partition.getStorageDescriptor().getColumns()))\n+              .setStorage(GlueUtils.toProto(partition.getStorageDescriptor(), pathTranslator))\n+              .setPartitionName(partName)\n+              .putAllParameters(partition.getParameters());\n+          if (partition.getValues() != null) {\n+            pib.addAllValues(partition.getValues());\n+          }\n+          udbPartitions.add(new GluePartition(new HiveLayout(pib.build(),\n+              statsMap.getOrDefault(partName, Collections.emptyList()))));\n+        }\n+      }\n+\n+      return new GlueTable(this,\n+          pathTranslator,\n+          tableName,\n+          GlueUtils.toProtoSchema(table.getStorageDescriptor().getColumns()),\n+          columnStatisticsData,\n+          // Glue does not provide FieldSchema from API directly\n+          // Get FieldSchema from partition keys\n+          GlueUtils.toProto(table.getPartitionKeys()),\n+          udbPartitions,\n+          layout,\n+          table);\n+    } catch (EntityNotFoundException e) {\n+      throw new NotFoundException(\"Table \" + tableName + \" does not exist.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjQzMg==", "bodyText": "You can remove \"WARNING\", and also add the catalog id and the database name.", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407572432", "createdAt": "2020-04-13T16:30:59Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.info(\"Set Glue region: {}.\", config.get(Property.GLUE_REGION));\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access key id.\");\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access secret key.\");\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)\n+      throws IOException {\n+    String tableName = table.getName();\n+    AlluxioURI ufsUri;\n+    AlluxioURI alluxioUri = mUdbContext.getTableLocation(tableName);\n+    String glueUfsUri = table.getStorageDescriptor().getLocation();\n+\n+    try {\n+      PathTranslator pathTranslator = new PathTranslator();\n+      ufsUri = new AlluxioURI(table.getStorageDescriptor().getLocation());\n+      pathTranslator.addMapping(\n+          UdbUtil.mountAlluxioPath(\n+              tableName,\n+              ufsUri,\n+              alluxioUri,\n+              mUdbContext,\n+              mGlueConfiguration),\n+          glueUfsUri);\n+\n+      for (Partition partition : partitions) {\n+        AlluxioURI partitionUri;\n+        String partitionName;\n+        if (partition.getStorageDescriptor() != null\n+            && partition.getStorageDescriptor().getLocation() != null\n+            && ufsUri.isAncestorOf(\n+            partitionUri = new AlluxioURI(\n+                partition.getStorageDescriptor().getLocation()))) {\n+          glueUfsUri = partition.getStorageDescriptor().getLocation();\n+          partitionName = partition.getValues().toString();\n+          try {\n+            partitionName = GlueUtils.makePartitionName(\n+                table.getPartitionKeys(),\n+                partition.getValues());\n+          } catch (IOException e) {\n+            LOG.warn(\"Error making partition name for table {}, partition {}\", tableName,\n+                partition.getValues().toString());\n+          }\n+          alluxioUri = new AlluxioURI(\n+              PathUtils.concatPath(\n+                  mUdbContext.getTableLocation(tableName).getPath(),\n+                  partitionName));\n+          // mount partition path if it is not already mounted as part of the table path mount\n+          pathTranslator\n+              .addMapping(\n+                  UdbUtil.mountAlluxioPath(\n+                      tableName,\n+                      partitionUri,\n+                      alluxioUri,\n+                      mUdbContext,\n+                      mGlueConfiguration),\n+                  glueUfsUri);\n+        }\n+      }\n+      return pathTranslator;\n+    } catch (AlluxioException e) {\n+      throw new IOException(\n+          \"Failed to mount table location. tableName: \" + tableName\n+              + \" glueUfsLocation: \" + glueUfsUri\n+              + \" AlluxioLocation: \" + alluxioUri + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @Override\n+  public UdbTable getTable(String tableName) throws IOException {\n+    Table table;\n+    List<Partition> partitions;\n+    // Glue doesn't support column statistics infomation\n+    Map<String, List<ColumnStatisticsInfo>> statsMap = new HashMap<>();\n+    try {\n+      GetTableRequest tableRequest = new GetTableRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withDatabaseName(mGlueDbName)\n+          .withName(tableName);\n+      table = getClient().getTable(tableRequest).getTable();\n+\n+      partitions = batchGetPartitions(getClient(), tableName);\n+      PathTranslator pathTranslator = mountAlluxioPaths(table, partitions);\n+\n+      // Glue does not provide column statistic information\n+      List<ColumnStatisticsInfo> columnStatisticsData = new ArrayList<>();\n+\n+      PartitionInfo partitionInfo = PartitionInfo.newBuilder()\n+          .setDbName(mGlueDbName)\n+          .setTableName(tableName)\n+          .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+          .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+          .putAllParameters(table.getParameters())\n+          .build();\n+\n+      Layout layout = Layout.newBuilder()\n+          .setLayoutType(HiveLayout.TYPE)\n+          .setLayoutData(partitionInfo.toByteString())\n+          .build();\n+\n+      List<Column> partitionColumns = table.getPartitionKeys();\n+\n+      List<UdbPartition> udbPartitions = new ArrayList<>();\n+      if (partitionColumns.isEmpty()) {\n+        PartitionInfo.Builder partitionInfoBuilder = PartitionInfo.newBuilder()\n+            .setDbName(mUdbContext.getDbName())\n+            .setTableName(tableName)\n+            .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+            .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+            .setPartitionName(tableName)\n+            .putAllParameters(table.getParameters());\n+        udbPartitions.add(new GluePartition(\n+            new HiveLayout(partitionInfoBuilder.build(), Collections.emptyList())));\n+      } else {\n+        for (Partition partition : partitions) {\n+          String partName = GlueUtils.makePartitionName(partitionColumns, partition.getValues());\n+          PartitionInfo.Builder pib = PartitionInfo.newBuilder()\n+              .setDbName(getUdbContext().getDbName())\n+              .setTableName(tableName)\n+              .addAllDataCols(GlueUtils.toProto(partition.getStorageDescriptor().getColumns()))\n+              .setStorage(GlueUtils.toProto(partition.getStorageDescriptor(), pathTranslator))\n+              .setPartitionName(partName)\n+              .putAllParameters(partition.getParameters());\n+          if (partition.getValues() != null) {\n+            pib.addAllValues(partition.getValues());\n+          }\n+          udbPartitions.add(new GluePartition(new HiveLayout(pib.build(),\n+              statsMap.getOrDefault(partName, Collections.emptyList()))));\n+        }\n+      }\n+\n+      return new GlueTable(this,\n+          pathTranslator,\n+          tableName,\n+          GlueUtils.toProtoSchema(table.getStorageDescriptor().getColumns()),\n+          columnStatisticsData,\n+          // Glue does not provide FieldSchema from API directly\n+          // Get FieldSchema from partition keys\n+          GlueUtils.toProto(table.getPartitionKeys()),\n+          udbPartitions,\n+          layout,\n+          table);\n+    } catch (EntityNotFoundException e) {\n+      throw new NotFoundException(\"Table \" + tableName + \" does not exist.\", e);\n+    } catch (ValidationException e) {\n+      e.printStackTrace();\n+      throw new IOException(\"Failed to get table: \"\n+          + tableName + \" with validation error: \" + e.getMessage(), e);\n+    } catch (GlueEncryptionException e) {\n+      throw new IOException(\"Failed to get table: \" + tableName + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private List<Partition> batchGetPartitions(AWSGlueAsync glueClient, String tableName)\n+      throws IOException {\n+    List<Partition> partitions = new ArrayList<>();\n+    try {\n+      GetPartitionsRequest getPartitionsRequest =\n+          new GetPartitionsRequest()\n+              .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+              .withDatabaseName(mGlueDbName)\n+              .withTableName(tableName);\n+      if (glueClient.getPartitions(getPartitionsRequest).getPartitions() != null) {\n+        partitions = glueClient.getPartitions(getPartitionsRequest).getPartitions();\n+      }\n+      return partitions;\n+    } catch (AWSGlueException e) {\n+      throw new IOException(\"WARNING: Cannot get partition information for table: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NDk3Mg==", "bodyText": "why is this necessary?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407574972", "createdAt": "2020-04-13T16:35:34Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/Property.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.table.common.udb.UdbProperty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * This contains all the properties for Glue UDB.\n+ */\n+public class Property extends UdbProperty {\n+  private static final Logger LOG = LoggerFactory.getLogger(Property.class);\n+  /** A map from default property key's string name to the key. */\n+  private static final Map<String, Property> DEFAULT_KEYS_MAP = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NTkwNA==", "bodyText": "can we just create a local map to pass into UdbConfiguration(conf) on the next line?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407575904", "createdAt": "2020-04-13T16:37:25Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/test/java/alluxio/table/under/glue/GlueDatabaseTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class GlueDatabaseTest {\n+\n+  private static final String DB_NAME = \"test\";\n+  private static final Map<String, String> CONF = new HashMap<>();\n+\n+  @Rule\n+  public ExpectedException mExpection = ExpectedException.none();\n+\n+  private UdbContext mUdbContext;\n+  private UdbConfiguration mUdbConfiguration;\n+\n+  @Before\n+  public void before() {\n+    CONF.put(\"aws.region\", \"us-east-1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NjM0Mw==", "bodyText": "instead of ignoring each method, can you ignore the entire class?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407576343", "createdAt": "2020-04-13T16:38:13Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/test/java/alluxio/table/under/glue/RemoteGlueTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class RemoteGlueTest {\n+\n+  private static final String DB_NAME = \"test\";\n+  private static final Map<String, String> CONF = new HashMap<>();\n+\n+  private UdbContext mUdbContext;\n+  private UdbConfiguration mUdbConfiguration;\n+  private GlueDatabase mGlueDatabase;\n+  private AWSGlueAsync mGlueClient;\n+\n+  private static final String AWS_ACCESS_KEY_ID = \"<PUT_YOUR_ACCESS_KEY_ID_HERE>\";\n+  private static final String AWS_SECRET_KEY = \"<PUT_YOUR_SECRET_KEY_HERE>\";\n+  private static final String CATALOG_ID = \"<PUT_YOUR_CATALOG_ID_HERE>\";\n+  private static final String AWS_REGION = \"<PUT_GLUE_REGION_HERE>\";\n+\n+  @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3Njg2OA==", "bodyText": "For all of these conversions, does it handle when fields don't exist or are null? We have hit several issues with the hive one because of these scenarios.", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407576868", "createdAt": "2020-04-13T16:39:11Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueUtils.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.grpc.table.Schema;\n+import alluxio.grpc.table.layout.hive.HiveBucketProperty;\n+import alluxio.grpc.table.layout.hive.SortingColumn;\n+import alluxio.grpc.table.layout.hive.Storage;\n+import alluxio.grpc.table.layout.hive.StorageFormat;\n+import alluxio.table.common.udb.PathTranslator;\n+\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Order;\n+import com.amazonaws.services.glue.model.StorageDescriptor;\n+import org.apache.hadoop.hive.common.FileUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Glue utils.\n+ */\n+public class GlueUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NzE2Mw==", "bodyText": "Did you figure out if this is required or not?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r407577163", "createdAt": "2020-04-13T16:39:44Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/Property.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.table.common.udb.UdbProperty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * This contains all the properties for Glue UDB.\n+ */\n+public class Property extends UdbProperty {\n+  private static final Logger LOG = LoggerFactory.getLogger(Property.class);\n+  /** A map from default property key's string name to the key. */\n+  private static final Map<String, Property> DEFAULT_KEYS_MAP = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Create a alluxio.table.under.glue.Property instance.\n+   *\n+   * @param name the property name\n+   * @param description the property description\n+   * @param defaultValue the default value\n+   */\n+  public Property(String name, String description, String defaultValue) {\n+    super(name, description, defaultValue);\n+  }\n+\n+  /**\n+   * UDB property builder.\n+   */\n+  public static final class Builder {\n+    private String mName;\n+    private String mDescription;\n+    private String mDefaultValue;\n+\n+    /**\n+     * @param name name of property\n+     */\n+    public Builder(String name) {\n+      mName = name;\n+    }\n+\n+    /**\n+     * @param name name for the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setName(String name) {\n+      mName = name;\n+      return this;\n+    }\n+\n+    /**\n+     * @param defaultValue the property's default value\n+     * @return the updated builder instance\n+     */\n+    public Builder setDefaultValue(String defaultValue) {\n+      mDefaultValue = defaultValue;\n+      return this;\n+    }\n+\n+    /**\n+     * @param description of the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setDescription(String description) {\n+      mDescription = description;\n+      return this;\n+    }\n+\n+    /**\n+     * Register the unregistered udb property.\n+     *\n+     * @return registered udb property\n+     */\n+    public Property build() {\n+      Property property = buildUnregistered();\n+      Preconditions.checkState(\n+          Property.register(property),\n+          \"Cannot register existing alluxio.table.under.glue.Property \\\"%s\\\"\", mName);\n+      return property;\n+    }\n+\n+    /**\n+     * Creates the Udb alluxio.table.under.glue.Property\n+     * without registering it with default property list.\n+     *\n+     * @return udb property\n+     */\n+    public Property buildUnregistered() {\n+      Property property = new Property(mName, mDescription, mDefaultValue);\n+      return property;\n+    }\n+  }\n+\n+  /**\n+   * Registers the given UDB alluxio.table.under.glue.Property to the global map.\n+   *\n+   * @param Property the udb property\n+   * @return whether the udb property is successfully registered\n+   */\n+  @VisibleForTesting\n+  public static boolean register(Property Property) {\n+    String name = Property.getName();\n+    if (DEFAULT_KEYS_MAP.containsKey(name)) {\n+      return false;\n+    }\n+\n+    DEFAULT_KEYS_MAP.put(name, Property);\n+    return true;\n+  }\n+\n+  /**\n+   * Unregisters the given key from the global map.\n+   *\n+   * @param Property the property to unregister\n+   */\n+  @VisibleForTesting\n+  public static void unregister(Property Property) {\n+    String name = Property.getName();\n+    DEFAULT_KEYS_MAP.remove(name);\n+  }\n+\n+  public static final Property MAX_GLUE_CONNECTION =\n+      new Builder(Name.MAX_GLUE_CONNECTION)\n+          .setDefaultValue(\"5\")\n+          .setDescription(\"The maximum number of connection to glue metastore.\")\n+          .build();\n+\n+  public static final Property GLUE_REGION =\n+      new Builder(Name.GLUE_REGION)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The regional endpoint for client service calls.\")\n+        .build();\n+\n+  public static final Property CATALOG_ID =\n+      new Builder(Name.CATALOG_ID)\n+          .setDefaultValue(\"\")\n+          .setDescription(\"The catalog id of aws glue.\")\n+          .build();\n+\n+  public static final Property AWS_GLUE_ACCESS_KEY =\n+      new Builder(Name.AWS_GLUE_ACCESS_KEY)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The access key to access the aws glue.\")\n+        .build();\n+\n+  public static final Property AWS_GLUE_SECRET_KEY =\n+      new Builder(Name.AWS_GLUE_SECRET_KEY)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The secret key to access the aws glue.\")\n+        .build();\n+\n+  /**\n+   * @return the name of alluxio.table.under.glue.Property\n+   */\n+  public String getName() {\n+    return mName;\n+  }\n+\n+  /**\n+   * @return the description of a property\n+   */\n+  public String getDescription() {\n+    return mDescription;\n+  }\n+\n+  /**\n+   * @return the default value of udb property or null if value not set\n+   */\n+  @Nullable\n+  @Override\n+  public String getDefaultValue() {\n+    Object defaultValue = mDefaultValue;\n+    return defaultValue == null ? null : defaultValue.toString();\n+  }\n+\n+  /**\n+   * Corresponding configurations of GLUE configurations.\n+   */\n+  public static final class Name {\n+    // AWS Glue related properties\n+    public static final String MAX_GLUE_CONNECTION = \"max.connection\";\n+    public static final String GLUE_REGION = \"aws.region\";\n+    public static final String CATALOG_ID = \"aws.catalog.id\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6688aed85e583dc1bd6378dbef16a62c87a344c8", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/6688aed85e583dc1bd6378dbef16a62c87a344c8", "committedDate": "2020-04-14T04:30:56Z", "message": "Glue Udb implemetation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "109bb0bd2edefa597f3b16bf2909e15543924e1c", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/109bb0bd2edefa597f3b16bf2909e15543924e1c", "committedDate": "2020-04-14T04:30:57Z", "message": "Fix jar issue for GlueDatabaseFacory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e008b0997f1d01d80b30b5939c1e35861eb9ef18", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/e008b0997f1d01d80b30b5939c1e35861eb9ef18", "committedDate": "2020-04-14T04:30:57Z", "message": "Fix fileds conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "520e79d734d2ef16319872dce24f803d3e288166", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/520e79d734d2ef16319872dce24f803d3e288166", "committedDate": "2020-04-14T04:30:57Z", "message": "Fix column information for presto"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07f80c438f25cf7c89d8c81c5045acae641e79cf", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/07f80c438f25cf7c89d8c81c5045acae641e79cf", "committedDate": "2020-04-14T04:30:58Z", "message": "Remove redudant log info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1670b57f4d619c4786e000c2c633b1142d083f6c", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/1670b57f4d619c4786e000c2c633b1142d083f6c", "committedDate": "2020-04-14T04:30:58Z", "message": "Fix minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248fbdb048ff6e915528e091ec522baa8a256b1a", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/248fbdb048ff6e915528e091ec522baa8a256b1a", "committedDate": "2020-04-14T04:30:58Z", "message": "Fix Glue test configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1d96c54030f9cad9a2c67d60ac44dddc4929683", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/e1d96c54030f9cad9a2c67d60ac44dddc4929683", "committedDate": "2020-04-14T04:30:59Z", "message": "Optimize Glue Database log information"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a313229489032dd5dd7c6cc130a523bab5f943c", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/9a313229489032dd5dd7c6cc130a523bab5f943c", "committedDate": "2020-04-14T04:30:59Z", "message": "Remove redudant glue layout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e2a263a078737321cd46d50bbaed7cb522640d", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/a2e2a263a078737321cd46d50bbaed7cb522640d", "committedDate": "2020-04-14T04:31:00Z", "message": "Refact alluxioMount, GlueDatabase and GlueTable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "728df18eee97d1ac315711fc7ca1b6702ed54209", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/728df18eee97d1ac315711fc7ca1b6702ed54209", "committedDate": "2020-04-14T04:31:00Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "428741deb49a926a947281e1d4e15f957047e8a4", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/428741deb49a926a947281e1d4e15f957047e8a4", "committedDate": "2020-04-14T04:31:00Z", "message": "Remove redudant mountAlluxioPath in HiveDatabase, Implement makePartName for Glue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b70c79a7eee3223c9d8f4ed7d5ec4a46fd7eba5d", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/b70c79a7eee3223c9d8f4ed7d5ec4a46fd7eba5d", "committedDate": "2020-04-14T04:31:01Z", "message": "Enhance Glue Udb UT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1c680f45319b86304cb9515a2ea2c8dbdfe14a5", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/d1c680f45319b86304cb9515a2ea2c8dbdfe14a5", "committedDate": "2020-04-14T04:31:01Z", "message": "Fix log, style and pom files"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "876048f70ddd927f66f924d53e6d82d40232ab87", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/876048f70ddd927f66f924d53e6d82d40232ab87", "committedDate": "2020-04-14T02:56:34Z", "message": "Fix log, style and pom files"}, "afterCommit": {"oid": "d1c680f45319b86304cb9515a2ea2c8dbdfe14a5", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/d1c680f45319b86304cb9515a2ea2c8dbdfe14a5", "committedDate": "2020-04-14T04:31:01Z", "message": "Fix log, style and pom files"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjgzMDM0", "url": "https://github.com/Alluxio/alluxio/pull/11205#pullrequestreview-396683034", "createdAt": "2020-04-20T17:55:18Z", "commit": {"oid": "d1c680f45319b86304cb9515a2ea2c8dbdfe14a5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzo1NToxOVrOGIgqog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTowNzoyOVrOGIjY5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3Njk5NA==", "bodyText": "what are register and unregister for?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411576994", "createdAt": "2020-04-20T17:55:19Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/Property.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.table.common.udb.UdbProperty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * This contains all the properties for Glue UDB.\n+ */\n+public class Property extends UdbProperty {\n+  private static final Logger LOG = LoggerFactory.getLogger(Property.class);\n+  /** A map from default property key's string name to the key. */\n+  private static final Map<String, Property> DEFAULT_KEYS_MAP = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Create a alluxio.table.under.glue.Property instance.\n+   *\n+   * @param name the property name\n+   * @param description the property description\n+   * @param defaultValue the default value\n+   */\n+  public Property(String name, String description, String defaultValue) {\n+    super(name, description, defaultValue);\n+  }\n+\n+  /**\n+   * UDB property builder.\n+   */\n+  public static final class Builder {\n+    private String mName;\n+    private String mDescription;\n+    private String mDefaultValue;\n+\n+    /**\n+     * @param name name of property\n+     */\n+    public Builder(String name) {\n+      mName = name;\n+    }\n+\n+    /**\n+     * @param name name for the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setName(String name) {\n+      mName = name;\n+      return this;\n+    }\n+\n+    /**\n+     * @param defaultValue the property's default value\n+     * @return the updated builder instance\n+     */\n+    public Builder setDefaultValue(String defaultValue) {\n+      mDefaultValue = defaultValue;\n+      return this;\n+    }\n+\n+    /**\n+     * @param description of the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setDescription(String description) {\n+      mDescription = description;\n+      return this;\n+    }\n+\n+    /**\n+     * Register the unregistered udb property.\n+     *\n+     * @return registered udb property\n+     */\n+    public Property build() {\n+      Property property = buildUnregistered();\n+      Preconditions.checkState(\n+          Property.register(property),\n+          \"Cannot register existing alluxio.table.under.glue.Property \\\"%s\\\"\", mName);\n+      return property;\n+    }\n+\n+    /**\n+     * Creates the Udb alluxio.table.under.glue.Property\n+     * without registering it with default property list.\n+     *\n+     * @return udb property\n+     */\n+    public Property buildUnregistered() {\n+      Property property = new Property(mName, mDescription, mDefaultValue);\n+      return property;\n+    }\n+  }\n+\n+  /**\n+   * Registers the given UDB alluxio.table.under.glue.Property to the global map.\n+   *\n+   * @param Property the udb property\n+   * @return whether the udb property is successfully registered\n+   */\n+  @VisibleForTesting\n+  public static boolean register(Property Property) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1c680f45319b86304cb9515a2ea2c8dbdfe14a5"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3NzE2Mg==", "bodyText": "Is this needed?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411577162", "createdAt": "2020-04-20T17:55:30Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/Property.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.table.common.udb.UdbProperty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * This contains all the properties for Glue UDB.\n+ */\n+public class Property extends UdbProperty {\n+  private static final Logger LOG = LoggerFactory.getLogger(Property.class);\n+  /** A map from default property key's string name to the key. */\n+  private static final Map<String, Property> DEFAULT_KEYS_MAP = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NDk3Mg=="}, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3NzkwMA==", "bodyText": "can we get rid of this static map, and just use a local one when needed?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411577900", "createdAt": "2020-04-20T17:56:38Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/test/java/alluxio/table/under/glue/GlueDatabaseTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class GlueDatabaseTest {\n+\n+  private static final String DB_NAME = \"test\";\n+  private static final Map<String, String> CONF = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1c680f45319b86304cb9515a2ea2c8dbdfe14a5"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3ODYxMw==", "bodyText": "Is this required? Or, how can this work without specifying the catalog id?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411578613", "createdAt": "2020-04-20T17:57:45Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/Property.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.table.common.udb.UdbProperty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * This contains all the properties for Glue UDB.\n+ */\n+public class Property extends UdbProperty {\n+  private static final Logger LOG = LoggerFactory.getLogger(Property.class);\n+  /** A map from default property key's string name to the key. */\n+  private static final Map<String, Property> DEFAULT_KEYS_MAP = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Create a alluxio.table.under.glue.Property instance.\n+   *\n+   * @param name the property name\n+   * @param description the property description\n+   * @param defaultValue the default value\n+   */\n+  public Property(String name, String description, String defaultValue) {\n+    super(name, description, defaultValue);\n+  }\n+\n+  /**\n+   * UDB property builder.\n+   */\n+  public static final class Builder {\n+    private String mName;\n+    private String mDescription;\n+    private String mDefaultValue;\n+\n+    /**\n+     * @param name name of property\n+     */\n+    public Builder(String name) {\n+      mName = name;\n+    }\n+\n+    /**\n+     * @param name name for the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setName(String name) {\n+      mName = name;\n+      return this;\n+    }\n+\n+    /**\n+     * @param defaultValue the property's default value\n+     * @return the updated builder instance\n+     */\n+    public Builder setDefaultValue(String defaultValue) {\n+      mDefaultValue = defaultValue;\n+      return this;\n+    }\n+\n+    /**\n+     * @param description of the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setDescription(String description) {\n+      mDescription = description;\n+      return this;\n+    }\n+\n+    /**\n+     * Register the unregistered udb property.\n+     *\n+     * @return registered udb property\n+     */\n+    public Property build() {\n+      Property property = buildUnregistered();\n+      Preconditions.checkState(\n+          Property.register(property),\n+          \"Cannot register existing alluxio.table.under.glue.Property \\\"%s\\\"\", mName);\n+      return property;\n+    }\n+\n+    /**\n+     * Creates the Udb alluxio.table.under.glue.Property\n+     * without registering it with default property list.\n+     *\n+     * @return udb property\n+     */\n+    public Property buildUnregistered() {\n+      Property property = new Property(mName, mDescription, mDefaultValue);\n+      return property;\n+    }\n+  }\n+\n+  /**\n+   * Registers the given UDB alluxio.table.under.glue.Property to the global map.\n+   *\n+   * @param Property the udb property\n+   * @return whether the udb property is successfully registered\n+   */\n+  @VisibleForTesting\n+  public static boolean register(Property Property) {\n+    String name = Property.getName();\n+    if (DEFAULT_KEYS_MAP.containsKey(name)) {\n+      return false;\n+    }\n+\n+    DEFAULT_KEYS_MAP.put(name, Property);\n+    return true;\n+  }\n+\n+  /**\n+   * Unregisters the given key from the global map.\n+   *\n+   * @param Property the property to unregister\n+   */\n+  @VisibleForTesting\n+  public static void unregister(Property Property) {\n+    String name = Property.getName();\n+    DEFAULT_KEYS_MAP.remove(name);\n+  }\n+\n+  public static final Property MAX_GLUE_CONNECTION =\n+      new Builder(Name.MAX_GLUE_CONNECTION)\n+          .setDefaultValue(\"5\")\n+          .setDescription(\"The maximum number of connection to glue metastore.\")\n+          .build();\n+\n+  public static final Property GLUE_REGION =\n+      new Builder(Name.GLUE_REGION)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The regional endpoint for client service calls.\")\n+        .build();\n+\n+  public static final Property CATALOG_ID =\n+      new Builder(Name.CATALOG_ID)\n+          .setDefaultValue(\"\")\n+          .setDescription(\"The catalog id of aws glue.\")\n+          .build();\n+\n+  public static final Property AWS_GLUE_ACCESS_KEY =\n+      new Builder(Name.AWS_GLUE_ACCESS_KEY)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The access key to access the aws glue.\")\n+        .build();\n+\n+  public static final Property AWS_GLUE_SECRET_KEY =\n+      new Builder(Name.AWS_GLUE_SECRET_KEY)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The secret key to access the aws glue.\")\n+        .build();\n+\n+  /**\n+   * @return the name of alluxio.table.under.glue.Property\n+   */\n+  public String getName() {\n+    return mName;\n+  }\n+\n+  /**\n+   * @return the description of a property\n+   */\n+  public String getDescription() {\n+    return mDescription;\n+  }\n+\n+  /**\n+   * @return the default value of udb property or null if value not set\n+   */\n+  @Nullable\n+  @Override\n+  public String getDefaultValue() {\n+    Object defaultValue = mDefaultValue;\n+    return defaultValue == null ? null : defaultValue.toString();\n+  }\n+\n+  /**\n+   * Corresponding configurations of GLUE configurations.\n+   */\n+  public static final class Name {\n+    // AWS Glue related properties\n+    public static final String MAX_GLUE_CONNECTION = \"max.connection\";\n+    public static final String GLUE_REGION = \"aws.region\";\n+    public static final String CATALOG_ID = \"aws.catalog.id\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NzE2Mw=="}, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxODM0OQ==", "bodyText": "Is empty string region allowed?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411618349", "createdAt": "2020-04-20T19:01:55Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzgwMA=="}, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMDM5MQ==", "bodyText": "Can you add the db name and catalog id?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411620391", "createdAt": "2020-04-20T19:05:23Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.info(\"Set Glue region: {}.\", config.get(Property.GLUE_REGION));\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access key id.\");\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access secret key.\");\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NzkwMw=="}, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyMTYwNg==", "bodyText": "I don't see the updated exception messages which include the db name and catalog id.", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r411621606", "createdAt": "2020-04-20T19:07:29Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/GlueDatabase.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.exception.AlluxioException;\n+import alluxio.exception.status.NotFoundException;\n+import alluxio.grpc.table.ColumnStatisticsInfo;\n+import alluxio.grpc.table.Layout;\n+import alluxio.grpc.table.layout.hive.PartitionInfo;\n+import alluxio.master.table.DatabaseInfo;\n+import alluxio.table.common.UdbPartition;\n+import alluxio.table.common.layout.HiveLayout;\n+import alluxio.table.common.udb.PathTranslator;\n+import alluxio.table.common.udb.UdbConfiguration;\n+import alluxio.table.common.udb.UdbContext;\n+import alluxio.table.common.udb.UdbTable;\n+import alluxio.table.common.udb.UdbUtil;\n+import alluxio.table.common.udb.UnderDatabase;\n+import alluxio.util.io.PathUtils;\n+\n+import com.amazonaws.ClientConfiguration;\n+import com.amazonaws.auth.AWSCredentialsProvider;\n+import com.amazonaws.auth.AWSStaticCredentialsProvider;\n+import com.amazonaws.auth.BasicAWSCredentials;\n+import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.AWSGlueAsyncClientBuilder;\n+import com.amazonaws.services.glue.model.AWSGlueException;\n+import com.amazonaws.services.glue.model.Column;\n+import com.amazonaws.services.glue.model.Database;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetDatabaseRequest;\n+import com.amazonaws.services.glue.model.GetDatabaseResult;\n+import com.amazonaws.services.glue.model.GetPartitionsRequest;\n+import com.amazonaws.services.glue.model.GetTableRequest;\n+import com.amazonaws.services.glue.model.GetTablesRequest;\n+import com.amazonaws.services.glue.model.GetTablesResult;\n+import com.amazonaws.services.glue.model.GlueEncryptionException;\n+import com.amazonaws.services.glue.model.Partition;\n+import com.amazonaws.services.glue.model.Table;\n+import com.amazonaws.services.glue.model.ValidationException;\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Glue database implementation.\n+ */\n+public class GlueDatabase implements UnderDatabase {\n+  private static final Logger LOG = LoggerFactory.getLogger(GlueDatabase.class);\n+\n+  private final UdbContext mUdbContext;\n+  private final AWSGlueAsync mGlueClient;\n+  private final UdbConfiguration mGlueConfiguration;\n+  /** the name of the glue db. */\n+  private final String mGlueDbName;\n+\n+  /** the owner name of glue database, which is an fake place holder. */\n+  private final String mOwnerName = \"PUBLIC_OWNER\";\n+  private final alluxio.grpc.table.PrincipalType mOwnerType = alluxio.grpc.table.PrincipalType.ROLE;\n+\n+  @VisibleForTesting\n+  protected GlueDatabase(UdbContext udbContext, UdbConfiguration glueConfig, String glueDbName) {\n+    mUdbContext = udbContext;\n+    mGlueConfiguration = glueConfig;\n+    mGlueClient = createAsyncGlueClient(glueConfig);\n+    mGlueDbName = glueDbName;\n+  }\n+\n+  /**\n+   * Create an instance of the Glue database UDB.\n+   *\n+   * @param udbContext the db context\n+   * @param configuration the configuration\n+   * @return the new instance\n+   */\n+  public static GlueDatabase create(UdbContext udbContext, UdbConfiguration configuration) {\n+    String glueDbName = udbContext.getUdbDbName();\n+    if (glueDbName == null || glueDbName.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Glue database name cannot be empty: \" + glueDbName);\n+    } else if (configuration.get(Property.GLUE_REGION) == null) {\n+      throw new IllegalArgumentException(\"GlueUdb Error: AWS region cannot be empty.\");\n+    }\n+\n+    return new GlueDatabase(udbContext, configuration, glueDbName);\n+  }\n+\n+  @Override\n+  public UdbContext getUdbContext() {\n+    return mUdbContext;\n+  }\n+\n+  @Override\n+  public DatabaseInfo getDatabaseInfo() throws IOException {\n+    LOG.info(\"Getting Glue database information from database: \" + mGlueDbName + \".\");\n+    try {\n+      GetDatabaseRequest dbRequest = new GetDatabaseRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withName(mGlueDbName);\n+      GetDatabaseResult dbResult = mGlueClient.getDatabase(dbRequest);\n+      Database glueDatabase = dbResult.getDatabase();\n+      String glueDbLocation = glueDatabase.getLocationUri();\n+      String glueDbDescription = glueDatabase.getDescription();\n+      Map<String, String> glueParameters = new HashMap<>();\n+      // Returned parameter can be null while Alluxio require non-null hash map for parameters\n+      if (glueDatabase.getParameters() != null) {\n+        glueParameters = glueDatabase.getParameters();\n+      }\n+      return new DatabaseInfo(\n+          glueDbLocation,\n+          mOwnerName,\n+          mOwnerType,\n+          glueDbDescription,\n+          glueParameters);\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Cannot find glue database\" + mGlueDbName\n+          + \".\" + e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This method allows user to test udb glue client with remote glue server.\n+   *\n+   * @param config udbconfiguration\n+   * @return glue async client\n+   */\n+  @VisibleForTesting\n+  protected static AWSGlueAsync createAsyncGlueClient(UdbConfiguration config) {\n+    ClientConfiguration clientConfig = new ClientConfiguration()\n+        .withMaxConnections(config.getInt(Property.MAX_GLUE_CONNECTION));\n+    AWSGlueAsyncClientBuilder asyncClientBuilder = AWSGlueAsyncClientBuilder\n+        .standard()\n+        .withClientConfiguration(clientConfig);\n+\n+    if (!config.get(Property.GLUE_REGION).isEmpty()) {\n+      LOG.info(\"Set Glue region: {}.\", config.get(Property.GLUE_REGION));\n+      asyncClientBuilder.setRegion(config.get(Property.GLUE_REGION));\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access key id.\");\n+    }\n+\n+    if (!config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      LOG.warn(\"Please setup the AWS access secret key.\");\n+    }\n+\n+    asyncClientBuilder.setCredentials(getAWSCredentialsProvider(config));\n+\n+    return asyncClientBuilder.build();\n+  }\n+\n+  private static AWSCredentialsProvider getAWSCredentialsProvider(UdbConfiguration config) {\n+    //TODO(shouwei): add compelete authentication method for glue udb\n+    if (!config.get(Property.AWS_GLUE_ACCESS_KEY).isEmpty()\n+        && !config.get(Property.AWS_GLUE_SECRET_KEY).isEmpty()) {\n+      return new AWSStaticCredentialsProvider(\n+        new BasicAWSCredentials(\n+          config.get(Property.AWS_GLUE_ACCESS_KEY),\n+          config.get(Property.AWS_GLUE_SECRET_KEY)));\n+    }\n+    return DefaultAWSCredentialsProviderChain.getInstance();\n+  }\n+\n+  @Override\n+  public String getType() {\n+    return GlueDatabaseFactory.TYPE;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return mGlueDbName;\n+  }\n+\n+  @Override\n+  public List<String> getTableNames() throws IOException {\n+    try {\n+      String nextToken = null;\n+      List<String> tableNames = new ArrayList<>();\n+      do {\n+        GetTablesRequest tablesRequest =\n+            new GetTablesRequest()\n+                .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+                .withDatabaseName(mGlueDbName)\n+                .withNextToken(nextToken);\n+        GetTablesResult tablesResult = mGlueClient.getTables(tablesRequest);\n+        tablesResult.getTableList().forEach(table -> tableNames.add(table.getName()));\n+        nextToken = tablesResult.getNextToken();\n+      } while (nextToken != null);\n+      return tableNames;\n+    } catch (EntityNotFoundException e) {\n+      throw new IOException(\"Failed to get glue tables: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private PathTranslator mountAlluxioPaths(Table table, List<Partition> partitions)\n+      throws IOException {\n+    String tableName = table.getName();\n+    AlluxioURI ufsUri;\n+    AlluxioURI alluxioUri = mUdbContext.getTableLocation(tableName);\n+    String glueUfsUri = table.getStorageDescriptor().getLocation();\n+\n+    try {\n+      PathTranslator pathTranslator = new PathTranslator();\n+      ufsUri = new AlluxioURI(table.getStorageDescriptor().getLocation());\n+      pathTranslator.addMapping(\n+          UdbUtil.mountAlluxioPath(\n+              tableName,\n+              ufsUri,\n+              alluxioUri,\n+              mUdbContext,\n+              mGlueConfiguration),\n+          glueUfsUri);\n+\n+      for (Partition partition : partitions) {\n+        AlluxioURI partitionUri;\n+        String partitionName;\n+        if (partition.getStorageDescriptor() != null\n+            && partition.getStorageDescriptor().getLocation() != null\n+            && ufsUri.isAncestorOf(\n+            partitionUri = new AlluxioURI(\n+                partition.getStorageDescriptor().getLocation()))) {\n+          glueUfsUri = partition.getStorageDescriptor().getLocation();\n+          partitionName = partition.getValues().toString();\n+          try {\n+            partitionName = GlueUtils.makePartitionName(\n+                table.getPartitionKeys(),\n+                partition.getValues());\n+          } catch (IOException e) {\n+            LOG.warn(\"Error making partition name for table {}, partition {}\", tableName,\n+                partition.getValues().toString());\n+          }\n+          alluxioUri = new AlluxioURI(\n+              PathUtils.concatPath(\n+                  mUdbContext.getTableLocation(tableName).getPath(),\n+                  partitionName));\n+          // mount partition path if it is not already mounted as part of the table path mount\n+          pathTranslator\n+              .addMapping(\n+                  UdbUtil.mountAlluxioPath(\n+                      tableName,\n+                      partitionUri,\n+                      alluxioUri,\n+                      mUdbContext,\n+                      mGlueConfiguration),\n+                  glueUfsUri);\n+        }\n+      }\n+      return pathTranslator;\n+    } catch (AlluxioException e) {\n+      throw new IOException(\n+          \"Failed to mount table location. tableName: \" + tableName\n+              + \" glueUfsLocation: \" + glueUfsUri\n+              + \" AlluxioLocation: \" + alluxioUri + \" error: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  @Override\n+  public UdbTable getTable(String tableName) throws IOException {\n+    Table table;\n+    List<Partition> partitions;\n+    // Glue doesn't support column statistics infomation\n+    Map<String, List<ColumnStatisticsInfo>> statsMap = new HashMap<>();\n+    try {\n+      GetTableRequest tableRequest = new GetTableRequest()\n+          .withCatalogId(mGlueConfiguration.get(Property.CATALOG_ID))\n+          .withDatabaseName(mGlueDbName)\n+          .withName(tableName);\n+      table = getClient().getTable(tableRequest).getTable();\n+\n+      partitions = batchGetPartitions(getClient(), tableName);\n+      PathTranslator pathTranslator = mountAlluxioPaths(table, partitions);\n+\n+      // Glue does not provide column statistic information\n+      List<ColumnStatisticsInfo> columnStatisticsData = new ArrayList<>();\n+\n+      PartitionInfo partitionInfo = PartitionInfo.newBuilder()\n+          .setDbName(mGlueDbName)\n+          .setTableName(tableName)\n+          .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+          .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+          .putAllParameters(table.getParameters())\n+          .build();\n+\n+      Layout layout = Layout.newBuilder()\n+          .setLayoutType(HiveLayout.TYPE)\n+          .setLayoutData(partitionInfo.toByteString())\n+          .build();\n+\n+      List<Column> partitionColumns = table.getPartitionKeys();\n+\n+      List<UdbPartition> udbPartitions = new ArrayList<>();\n+      if (partitionColumns.isEmpty()) {\n+        PartitionInfo.Builder partitionInfoBuilder = PartitionInfo.newBuilder()\n+            .setDbName(mUdbContext.getDbName())\n+            .setTableName(tableName)\n+            .addAllDataCols(GlueUtils.toProto(table.getStorageDescriptor().getColumns()))\n+            .setStorage(GlueUtils.toProto(table.getStorageDescriptor(), pathTranslator))\n+            .setPartitionName(tableName)\n+            .putAllParameters(table.getParameters());\n+        udbPartitions.add(new GluePartition(\n+            new HiveLayout(partitionInfoBuilder.build(), Collections.emptyList())));\n+      } else {\n+        for (Partition partition : partitions) {\n+          String partName = GlueUtils.makePartitionName(partitionColumns, partition.getValues());\n+          PartitionInfo.Builder pib = PartitionInfo.newBuilder()\n+              .setDbName(getUdbContext().getDbName())\n+              .setTableName(tableName)\n+              .addAllDataCols(GlueUtils.toProto(partition.getStorageDescriptor().getColumns()))\n+              .setStorage(GlueUtils.toProto(partition.getStorageDescriptor(), pathTranslator))\n+              .setPartitionName(partName)\n+              .putAllParameters(partition.getParameters());\n+          if (partition.getValues() != null) {\n+            pib.addAllValues(partition.getValues());\n+          }\n+          udbPartitions.add(new GluePartition(new HiveLayout(pib.build(),\n+              statsMap.getOrDefault(partName, Collections.emptyList()))));\n+        }\n+      }\n+\n+      return new GlueTable(this,\n+          pathTranslator,\n+          tableName,\n+          GlueUtils.toProtoSchema(table.getStorageDescriptor().getColumns()),\n+          columnStatisticsData,\n+          // Glue does not provide FieldSchema from API directly\n+          // Get FieldSchema from partition keys\n+          GlueUtils.toProto(table.getPartitionKeys()),\n+          udbPartitions,\n+          layout,\n+          table);\n+    } catch (EntityNotFoundException e) {\n+      throw new NotFoundException(\"Table \" + tableName + \" does not exist.\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjE2Ng=="}, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 352}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d43c20ee9b0cf916cc2ad6f27457d0b576ca106e", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/d43c20ee9b0cf916cc2ad6f27457d0b576ca106e", "committedDate": "2020-04-24T01:00:18Z", "message": "Fix log; Fix parameter null point in databaseinfo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDg5MTUx", "url": "https://github.com/Alluxio/alluxio/pull/11205#pullrequestreview-400089151", "createdAt": "2020-04-24T16:18:31Z", "commit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoxODozMVrOGLfPFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoxODozMVrOGLfPFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5OTI4Nw==", "bodyText": "I don't see the TODO comment?", "url": "https://github.com/Alluxio/alluxio/pull/11205#discussion_r414699287", "createdAt": "2020-04-24T16:18:31Z", "author": {"login": "gpang"}, "path": "table/server/underdb/glue/src/main/java/alluxio/table/under/glue/Property.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.table.under.glue;\n+\n+import alluxio.table.common.udb.UdbProperty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * This contains all the properties for Glue UDB.\n+ */\n+public class Property extends UdbProperty {\n+  private static final Logger LOG = LoggerFactory.getLogger(Property.class);\n+  /** A map from default property key's string name to the key. */\n+  private static final Map<String, Property> DEFAULT_KEYS_MAP = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Create a alluxio.table.under.glue.Property instance.\n+   *\n+   * @param name the property name\n+   * @param description the property description\n+   * @param defaultValue the default value\n+   */\n+  public Property(String name, String description, String defaultValue) {\n+    super(name, description, defaultValue);\n+  }\n+\n+  /**\n+   * UDB property builder.\n+   */\n+  public static final class Builder {\n+    private String mName;\n+    private String mDescription;\n+    private String mDefaultValue;\n+\n+    /**\n+     * @param name name of property\n+     */\n+    public Builder(String name) {\n+      mName = name;\n+    }\n+\n+    /**\n+     * @param name name for the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setName(String name) {\n+      mName = name;\n+      return this;\n+    }\n+\n+    /**\n+     * @param defaultValue the property's default value\n+     * @return the updated builder instance\n+     */\n+    public Builder setDefaultValue(String defaultValue) {\n+      mDefaultValue = defaultValue;\n+      return this;\n+    }\n+\n+    /**\n+     * @param description of the property\n+     * @return the updated builder instance\n+     */\n+    public Builder setDescription(String description) {\n+      mDescription = description;\n+      return this;\n+    }\n+\n+    /**\n+     * Register the unregistered udb property.\n+     *\n+     * @return registered udb property\n+     */\n+    public Property build() {\n+      Property property = buildUnregistered();\n+      Preconditions.checkState(\n+          Property.register(property),\n+          \"Cannot register existing alluxio.table.under.glue.Property \\\"%s\\\"\", mName);\n+      return property;\n+    }\n+\n+    /**\n+     * Creates the Udb alluxio.table.under.glue.Property\n+     * without registering it with default property list.\n+     *\n+     * @return udb property\n+     */\n+    public Property buildUnregistered() {\n+      Property property = new Property(mName, mDescription, mDefaultValue);\n+      return property;\n+    }\n+  }\n+\n+  /**\n+   * Registers the given UDB alluxio.table.under.glue.Property to the global map.\n+   *\n+   * @param Property the udb property\n+   * @return whether the udb property is successfully registered\n+   */\n+  @VisibleForTesting\n+  public static boolean register(Property Property) {\n+    String name = Property.getName();\n+    if (DEFAULT_KEYS_MAP.containsKey(name)) {\n+      return false;\n+    }\n+\n+    DEFAULT_KEYS_MAP.put(name, Property);\n+    return true;\n+  }\n+\n+  /**\n+   * Unregisters the given key from the global map.\n+   *\n+   * @param Property the property to unregister\n+   */\n+  @VisibleForTesting\n+  public static void unregister(Property Property) {\n+    String name = Property.getName();\n+    DEFAULT_KEYS_MAP.remove(name);\n+  }\n+\n+  public static final Property MAX_GLUE_CONNECTION =\n+      new Builder(Name.MAX_GLUE_CONNECTION)\n+          .setDefaultValue(\"5\")\n+          .setDescription(\"The maximum number of connection to glue metastore.\")\n+          .build();\n+\n+  public static final Property GLUE_REGION =\n+      new Builder(Name.GLUE_REGION)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The regional endpoint for client service calls.\")\n+        .build();\n+\n+  public static final Property CATALOG_ID =\n+      new Builder(Name.CATALOG_ID)\n+          .setDefaultValue(\"\")\n+          .setDescription(\"The catalog id of aws glue.\")\n+          .build();\n+\n+  public static final Property AWS_GLUE_ACCESS_KEY =\n+      new Builder(Name.AWS_GLUE_ACCESS_KEY)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The access key to access the aws glue.\")\n+        .build();\n+\n+  public static final Property AWS_GLUE_SECRET_KEY =\n+      new Builder(Name.AWS_GLUE_SECRET_KEY)\n+        .setDefaultValue(\"\")\n+        .setDescription(\"The secret key to access the aws glue.\")\n+        .build();\n+\n+  /**\n+   * @return the name of alluxio.table.under.glue.Property\n+   */\n+  public String getName() {\n+    return mName;\n+  }\n+\n+  /**\n+   * @return the description of a property\n+   */\n+  public String getDescription() {\n+    return mDescription;\n+  }\n+\n+  /**\n+   * @return the default value of udb property or null if value not set\n+   */\n+  @Nullable\n+  @Override\n+  public String getDefaultValue() {\n+    Object defaultValue = mDefaultValue;\n+    return defaultValue == null ? null : defaultValue.toString();\n+  }\n+\n+  /**\n+   * Corresponding configurations of GLUE configurations.\n+   */\n+  public static final class Name {\n+    // AWS Glue related properties\n+    public static final String MAX_GLUE_CONNECTION = \"max.connection\";\n+    public static final String GLUE_REGION = \"aws.region\";\n+    public static final String CATALOG_ID = \"aws.catalog.id\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NzE2Mw=="}, "originalCommit": {"oid": "5b207a42d53f26208c40ff80bcb6192352566611"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b68a8755255d7a2f7939ba1e93291978c9891cb0", "author": {"user": {"login": "HelloHorizon", "name": "Shouwei Chen"}}, "url": "https://github.com/Alluxio/alluxio/commit/b68a8755255d7a2f7939ba1e93291978c9891cb0", "committedDate": "2020-04-24T16:26:49Z", "message": "Add TODO for catalogid"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDEzMDA1", "url": "https://github.com/Alluxio/alluxio/pull/11205#pullrequestreview-400413005", "createdAt": "2020-04-25T17:13:38Z", "commit": {"oid": "b68a8755255d7a2f7939ba1e93291978c9891cb0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4702, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}