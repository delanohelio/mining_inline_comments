{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMDA2OTE5", "number": 12643, "title": "Prevent removeBlock from waiting indefinitly", "bodyText": "aim to fix the symptom of #12444 and #11309\nUse tryLock() instead of lock() when locking worker blocks to prevent forever waiting for block locks.\nand replace https://github.com/Alluxio/alluxio/pull/12507/files\nThis PR fixes the symptom of frozen AsycBlockRemover caused by failing block lock acquisition by using tryLock.", "createdAt": "2020-12-15T06:18:47Z", "url": "https://github.com/Alluxio/alluxio/pull/12643", "merged": true, "mergeCommit": {"oid": "5d301bda675a300f3651745774836f7b2ae194db"}, "closed": true, "closedAt": "2021-01-27T01:31:51Z", "author": {"login": "apc999"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmea7FgH2gAyNTQwMDA2OTE5OjI2Mjg2YzhhZDBkNTE3ZjY4ODE1OTBlYzg1ODJjZGQxZWIyNDIxNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdm3iFfAFqTU1NDE2NzkzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "26286c8ad0d517f6881590ec8582cdd1eb242162", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/26286c8ad0d517f6881590ec8582cdd1eb242162", "committedDate": "2020-12-15T18:12:55Z", "message": "Prevent removeBlock from waiting indefinitly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c311f2fd8920a40f00374950b92642f98771785f", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/c311f2fd8920a40f00374950b92642f98771785f", "committedDate": "2020-12-15T06:16:19Z", "message": "Prevent removeBlock from waiting indefinitly"}, "afterCommit": {"oid": "26286c8ad0d517f6881590ec8582cdd1eb242162", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/26286c8ad0d517f6881590ec8582cdd1eb242162", "committedDate": "2020-12-15T18:12:55Z", "message": "Prevent removeBlock from waiting indefinitly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b48d65307514b4c927c755657805d6b8255ac5d7", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/b48d65307514b4c927c755657805d6b8255ac5d7", "committedDate": "2020-12-15T18:59:00Z", "message": "Add more unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01c5c9d7b58be011a4db8612a78fa166b3053b05", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/01c5c9d7b58be011a4db8612a78fa166b3053b05", "committedDate": "2020-12-15T21:17:43Z", "message": "More unit tests on AsyncBlockRemover"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/a53db7ccdc54861105d338fcc08150c1fa51a5ab", "committedDate": "2020-12-15T23:05:10Z", "message": "Cleanup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4799ba8b8791c2770f375e84292214e6e8af627", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/b4799ba8b8791c2770f375e84292214e6e8af627", "committedDate": "2020-12-15T21:19:27Z", "message": "Cleanup"}, "afterCommit": {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/a53db7ccdc54861105d338fcc08150c1fa51a5ab", "committedDate": "2020-12-15T23:05:10Z", "message": "Cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMzkwNjQz", "url": "https://github.com/Alluxio/alluxio/pull/12643#pullrequestreview-553390643", "createdAt": "2020-12-16T06:31:14Z", "commit": {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjozMToxNFrOIG0qPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjo0Njo1OVrOIG1eXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNTE0OQ==", "bodyText": "Maybe it would be better if you could abstract a private method lockBlock(long, long, BlockLockType, boolean useTryLock, long, unit), and add the following logic into this method\nif (useTryLock) {\n    try {\n     if (!lock.tryLock(time, unit)) {\n        LOG.warn(\"Failed to acquire lock for block {} after {} {}.  \"\n                + \"session: {}, blockLockType: {}, lock reference count = {}\",\n            blockId, time, unit, sessionId, blockLockType, blockLock.getReferenceCount());\n        return INVALID_LOCK_ID;\n      }\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n} else {\n  lock.lock()\n}\nIt can reduce redundancy code.", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544025149", "createdAt": "2020-12-16T06:31:14Z", "author": {"login": "maobaolong"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java", "diffHunk": "@@ -99,31 +99,60 @@ public BlockLockManager() {}\n    */\n   public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n     ClientRWLock blockLock = getBlockLock(blockId);\n-    Lock lock;\n-    if (blockLockType == BlockLockType.READ) {\n-      lock = blockLock.readLock();\n-    } else {\n-      // Make sure the session isn't already holding the block lock.\n-      if (sessionHoldsLock(sessionId, blockId)) {\n-        throw new IllegalStateException(String\n-            .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n-                + \" holds a lock on the block\", sessionId, blockId));\n-      }\n-      lock = blockLock.writeLock();\n+    Lock lock = blockLockType == BlockLockType.READ ? blockLock.readLock() : blockLock.writeLock();\n+    // Make sure the session isn't already holding the block lock.\n+    if (blockLockType == BlockLockType.WRITE && sessionHoldsLock(sessionId, blockId)) {\n+      throw new IllegalStateException(String\n+          .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n+              + \" holds a lock on the block\", sessionId, blockId));\n     }\n     lock.lock();\n     try {\n-      long lockId = LOCK_ID_GEN.getAndIncrement();\n-      try (LockResource r = new LockResource(mSharedMapsLock.writeLock())) {\n-        mLockIdToRecordMap.put(lockId, new LockRecord(sessionId, blockId, lock));\n-        Set<Long> sessionLockIds = mSessionIdToLockIdsMap.get(sessionId);\n-        if (sessionLockIds == null) {\n-          mSessionIdToLockIdsMap.put(sessionId, Sets.newHashSet(lockId));\n-        } else {\n-          sessionLockIds.add(lockId);\n-        }\n+      return allocateLockId(sessionId, blockId, lock);\n+    } catch (Throwable e) {\n+      // If an unexpected exception occurs, we should release the lock to be conservative.\n+      unlock(lock, blockId);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Tries to lock a block within the given time.\n+   * Note that even if this block does not exist, a lock id is still returned.\n+   *\n+   * If all {@link PropertyKey#WORKER_TIERED_STORE_BLOCK_LOCKS} are already in use and no lock has\n+   * been allocated for the specified block, this method will need to wait until a lock can be\n+   * acquired from the lock pool.\n+   *\n+   * @param sessionId the session id\n+   * @param blockId the block id\n+   * @param blockLockType {@link BlockLockType#READ} or {@link BlockLockType#WRITE}\n+   * @param time the maximum time to wait for the lock\n+   * @param unit the time unit of the {@code time} argument\n+   * @return lock id or INVALID_LOCK_ID if not able to lock within the given time\n+   */\n+  public long tryLockBlock(long sessionId, long blockId, BlockLockType blockLockType,\n+      long time, TimeUnit unit) {\n+    ClientRWLock blockLock = getBlockLock(blockId);\n+    Lock lock = blockLockType == BlockLockType.READ ? blockLock.readLock() : blockLock.writeLock();\n+    // Make sure the session isn't already holding the block lock.\n+    if (blockLockType == BlockLockType.WRITE && sessionHoldsLock(sessionId, blockId)) {\n+      throw new IllegalStateException(String\n+          .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n+              + \" holds a lock on the block\", sessionId, blockId));\n+    }\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzODQ5Mg==", "bodyText": "Just a question:\nWhen we meet this exception, we need more information to know what has happened, something like who(sessionId) hold this block write lock, how long has been held by this session? If user has already know there are something wrong with the session client, is there a way to let user/admin to clear the specific session's locks? So that, we don't have to wait the session timeout.", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544038492", "createdAt": "2020-12-16T06:46:59Z", "author": {"login": "maobaolong"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -378,8 +379,11 @@ public void removeBlock(long sessionId, long blockId)\n   public void removeBlock(long sessionId, long blockId, BlockStoreLocation location)\n       throws InvalidWorkerStateException, BlockDoesNotExistException, IOException {\n     LOG.debug(\"removeBlock: sessionId={}, blockId={}, location={}\", sessionId, blockId, location);\n-    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n-\n+    long lockId = mLockManager.tryLockBlock(sessionId, blockId, BlockLockType.WRITE,\n+        REMOVE_BLOCK_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    if (lockId == BlockLockManager.INVALID_LOCK_ID) {\n+      throw new IOException(String.format(\"Can not acquire lock for block %d\", blockId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96ffe7b570ee4510e174956210bae93e707b2360", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/96ffe7b570ee4510e174956210bae93e707b2360", "committedDate": "2020-12-16T07:50:54Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDQ1NTY5", "url": "https://github.com/Alluxio/alluxio/pull/12643#pullrequestreview-553445569", "createdAt": "2020-12-16T08:17:33Z", "commit": {"oid": "96ffe7b570ee4510e174956210bae93e707b2360"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "committedDate": "2020-12-16T19:34:31Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MDg1Njg0", "url": "https://github.com/Alluxio/alluxio/pull/12643#pullrequestreview-554085684", "createdAt": "2020-12-16T21:09:01Z", "commit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTowOTowMVrOIHZPIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTozNjoyNFrOIHaMeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNDQxNw==", "bodyText": "will this still log the stack of the Exception?", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544624417", "createdAt": "2020-12-16T21:09:01Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/AsyncBlockRemover.java", "diffHunk": "@@ -110,41 +122,31 @@ public void shutDown() {\n   }\n \n   private class BlockRemover implements Runnable {\n-    private String mThreadName;\n-\n     @Override\n     public void run() {\n-      mThreadName = Thread.currentThread().getName();\n-      long blockToBeRemoved;\n+      String threadName = Thread.currentThread().getName();\n       while (true) {\n-        blockToBeRemoved = INVALID_BLOCK_ID;\n+        Long blockToBeRemoved = null;\n         try {\n           blockToBeRemoved = mBlocksToRemove.take();\n           mTakeCount.inc();\n           mBlockWorker.removeBlock(Sessions.MASTER_COMMAND_SESSION_ID, blockToBeRemoved);\n           mRemovedSuccessCount.inc();\n-          LOG.debug(\"Block {} is removed in thread {}.\", blockToBeRemoved, mThreadName);\n+          LOG.debug(\"Block {} is removed in thread {}.\", blockToBeRemoved, threadName);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           // Only log warning if interrupted not due to a shutdown.\n           if (!mShutdown) {\n-            LOG.warn(\"{} got interrupted while it was cleaning block {}.\", mThreadName,\n+            LOG.warn(\"{} got interrupted while it was cleaning block {}.\", threadName,\n                 blockToBeRemoved);\n           }\n           break;\n-        } catch (IOException e) {\n-          LOG.warn(\"IOException occurred while {} was cleaning block {}, exception is {}.\",\n-              mThreadName, blockToBeRemoved, e.getMessage());\n-        } catch (BlockDoesNotExistException e) {\n-          LOG.warn(\"{}: block {} may be deleted already. exception is {}.\",\n-              mThreadName, blockToBeRemoved, e.getMessage());\n-        } catch (InvalidWorkerStateException e) {\n-          LOG.warn(\"{}: invalid block state for block {}, exception is {}.\",\n-              mThreadName, blockToBeRemoved, e.getMessage());\n         } catch (Exception e) {\n-          LOG.warn(\"Unexpected exception: {}.\", e);\n+          LOG.warn(\"Failed to remove block {} instructed by master. This is best-effort and \"\n+              + \"will be tried later. threadName {}, error {}\", blockToBeRemoved,\n+              threadName, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyOTYwOA==", "bodyText": "This will either wait for a free lock, or timeout (if the timeout is set), right?", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544629608", "createdAt": "2020-12-16T21:18:02Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java", "diffHunk": "@@ -98,20 +100,57 @@ public BlockLockManager() {}\n    * @return lock id\n    */\n   public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n+    return lockBlockInternal(sessionId, blockId, blockLockType, true, null, null);\n+  }\n+\n+  /**\n+   * Tries to lock a block within the given time.\n+   * Note that even if this block does not exist, a lock id is still returned.\n+   *\n+   * If all {@link PropertyKey#WORKER_TIERED_STORE_BLOCK_LOCKS} are already in use and no lock has\n+   * been allocated for the specified block, this method will need to wait until a lock can be\n+   * acquired from the lock pool.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzNzYxMw==", "bodyText": "Is this only called by the async block remover? Are there any other callers which may be affected by the new locking behavior?", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544637613", "createdAt": "2020-12-16T21:31:52Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -378,8 +379,13 @@ public void removeBlock(long sessionId, long blockId)\n   public void removeBlock(long sessionId, long blockId, BlockStoreLocation location)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MDEyMA==", "bodyText": "If all the removes failed, why is this list still empty?", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544640120", "createdAt": "2020-12-16T21:36:24Z", "author": {"login": "gpang"}, "path": "core/server/worker/src/test/java/alluxio/worker/block/AsyncBlockRemoverTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.doAnswer;\n+\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * Tests for AsyncBlockRemover.\n+ */\n+public class AsyncBlockRemoverTest {\n+  private AsyncBlockRemover mRemover;\n+  private final BlockingQueue<Long> mBlocksToRemove = new LinkedBlockingQueue<>();\n+  private final Set<Long> mBlocksTriedToRemoved =\n+      Collections.newSetFromMap(new ConcurrentHashMap<>());\n+  private final BlockWorker mMockWorker = Mockito.mock(BlockWorker.class);\n+\n+  @Test\n+  public void blockRemove() throws Exception {\n+    doAnswer(args -> {\n+      // keeps track the blocks to remove\n+      mBlocksTriedToRemoved.add(args.getArgument(1));\n+      return null;\n+    }).when(mMockWorker).removeBlock(anyLong(), anyLong());\n+    mRemover = new AsyncBlockRemover(mMockWorker, 10, mBlocksToRemove,\n+        Collections.newSetFromMap(new ConcurrentHashMap<>()));\n+    List<Long> blocks = new ArrayList<>();\n+    for (long i = 0; i < 100; i++) {\n+      blocks.add(i);\n+    }\n+    mRemover.addBlocksToDelete(blocks);\n+    CommonUtils.waitFor(\"async block removal completed\",\n+        () -> mBlocksTriedToRemoved.size() == blocks.size(),\n+        WaitForOptions.defaults().setTimeoutMs(10000));\n+    assertEquals(0, mBlocksToRemove.size());\n+  }\n+\n+  @Test\n+  public void failedBlockRemove() throws Exception {\n+    doAnswer(args -> {\n+      // keeps track the blocks to remove\n+      mBlocksTriedToRemoved.add(args.getArgument(1));\n+      // throw exception\n+      throw new IOException(\"Failed to remove block\");\n+    }).when(mMockWorker).removeBlock(anyLong(), anyLong());\n+    mRemover = new AsyncBlockRemover(mMockWorker, 10, mBlocksToRemove,\n+        Collections.newSetFromMap(new ConcurrentHashMap<>()));\n+    List<Long> blocks = new ArrayList<>();\n+    for (long i = 0; i < 100; i++) {\n+      blocks.add(i);\n+    }\n+    mRemover.addBlocksToDelete(blocks);\n+    CommonUtils.waitFor(\"async block removal completed\",\n+        () -> mBlocksTriedToRemoved.size() == blocks.size(),\n+        WaitForOptions.defaults().setTimeoutMs(10000));\n+    assertEquals(0, mBlocksToRemove.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTY3OTM2", "url": "https://github.com/Alluxio/alluxio/pull/12643#pullrequestreview-554167936", "createdAt": "2020-12-16T23:28:22Z", "commit": {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3348, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}