{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2NDEwNDk1", "number": 12466, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMToxN1rOE2_rzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozNzowOFrOE2_xfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTAxOTY0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMToxN1rOHwFuqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMDo1MjoyN1rOHwHb6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzU2Mw==", "bodyText": "Is the default buffer size (16) not large enough? With 2MB message size we are looking at 32MB buffer per reader, this can grow quickly if multi-thread reading is used.", "url": "https://github.com/Alluxio/alluxio/pull/12466#discussion_r520187563", "createdAt": "2020-11-09T23:31:17Z", "author": {"login": "bf8086"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -77,7 +78,9 @@\n   public GrpcBlockingStream(Function<StreamObserver<ResT>, StreamObserver<ReqT>> rpcFunc,\n       int bufferSize, String description) {\n     LOG.debug(\"Opening stream ({})\", description);\n-    mResponses = new ArrayBlockingQueue<>(bufferSize);\n+    // Use an unlimited queue to avoid blocking the network threads. Depend on custom flow\n+    // control to limit the size of buffer.\n+    mResponses = new LinkedBlockingQueue<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92473d5211490f35dc21b3067baedc389535d9f5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMzc1Ng==", "bodyText": "I originally saw this grow to around 20-25 before.\nI changed it back, but is it a bad thing to block the grpc thread? Because that will sometimes happen if the size is 16.", "url": "https://github.com/Alluxio/alluxio/pull/12466#discussion_r520203756", "createdAt": "2020-11-10T00:16:40Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -77,7 +78,9 @@\n   public GrpcBlockingStream(Function<StreamObserver<ResT>, StreamObserver<ReqT>> rpcFunc,\n       int bufferSize, String description) {\n     LOG.debug(\"Opening stream ({})\", description);\n-    mResponses = new ArrayBlockingQueue<>(bufferSize);\n+    // Use an unlimited queue to avoid blocking the network threads. Depend on custom flow\n+    // control to limit the size of buffer.\n+    mResponses = new LinkedBlockingQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzU2Mw=="}, "originalCommit": {"oid": "92473d5211490f35dc21b3067baedc389535d9f5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxNTUyOA==", "bodyText": "I think when a grpc thread is blocked it will potentially result in new thread being created for handling other concurrent RPC calls, so there is a potential overhead of one blocking thread per stream.", "url": "https://github.com/Alluxio/alluxio/pull/12466#discussion_r520215528", "createdAt": "2020-11-10T00:52:27Z", "author": {"login": "bf8086"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -77,7 +78,9 @@\n   public GrpcBlockingStream(Function<StreamObserver<ResT>, StreamObserver<ReqT>> rpcFunc,\n       int bufferSize, String description) {\n     LOG.debug(\"Opening stream ({})\", description);\n-    mResponses = new ArrayBlockingQueue<>(bufferSize);\n+    // Use an unlimited queue to avoid blocking the network threads. Depend on custom flow\n+    // control to limit the size of buffer.\n+    mResponses = new LinkedBlockingQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzU2Mw=="}, "originalCommit": {"oid": "92473d5211490f35dc21b3067baedc389535d9f5"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTAzNDIxOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozNzowOFrOHwF3NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0NzowM1rOHwtAwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTc0OQ==", "bodyText": "Some applications may depend on the closure to be done on the server side so they can perform other operations on the file safely. Having the reader skip the wait may cause subsequent operations to fail.", "url": "https://github.com/Alluxio/alluxio/pull/12466#discussion_r520189749", "createdAt": "2020-11-09T23:37:08Z", "author": {"login": "bf8086"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java", "diffHunk": "@@ -168,7 +169,19 @@ public void close() throws IOException {\n         return;\n       }\n       mStream.close();\n-      mStream.waitForComplete(mDataTimeoutMs);\n+\n+      // When a reader is closed, there is technically nothing the client requires from the server.\n+      // However, the server does need to cleanup resources for a client close(), including closing\n+      // or canceling any temp blocks. Therefore, we should wait for some amount of time for the\n+      // server to finish cleanup, but it should not be very long (since the client is finished\n+      // with the read). Also, if there is any error when waiting for the complete, it should be\n+      // ignored since again, the client is completely finished with the read.\n+      try {\n+        // Wait a short time for the server to finish the close, and then let the client continue.\n+        mStream.waitForComplete(5 * Constants.SECOND_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92473d5211490f35dc21b3067baedc389535d9f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NDQ0MA==", "bodyText": "If another client tries to read this block, there shouldn't be an issue, since they would only be grabbing a read lock, which should be allowed. I don't think another client can write lock the block, since Alluxio blocks are write-once-read-many. Can you think of any other problem behavior?\nIdeally, I would have just removed this waitForComplete entirely, but there are some tests which require some async caching tasks to complete (even though async caching in general is best-effort). Because of these tests, waiting some short amount of time is beneficial for the tests.", "url": "https://github.com/Alluxio/alluxio/pull/12466#discussion_r520794440", "createdAt": "2020-11-10T18:51:04Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java", "diffHunk": "@@ -168,7 +169,19 @@ public void close() throws IOException {\n         return;\n       }\n       mStream.close();\n-      mStream.waitForComplete(mDataTimeoutMs);\n+\n+      // When a reader is closed, there is technically nothing the client requires from the server.\n+      // However, the server does need to cleanup resources for a client close(), including closing\n+      // or canceling any temp blocks. Therefore, we should wait for some amount of time for the\n+      // server to finish cleanup, but it should not be very long (since the client is finished\n+      // with the read). Also, if there is any error when waiting for the complete, it should be\n+      // ignored since again, the client is completely finished with the read.\n+      try {\n+        // Wait a short time for the server to finish the close, and then let the client continue.\n+        mStream.waitForComplete(5 * Constants.SECOND_MS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTc0OQ=="}, "originalCommit": {"oid": "92473d5211490f35dc21b3067baedc389535d9f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMTE3MA==", "bodyText": "One possible issue is when the same client which just closes a stream tries to do another write operation such as rename or delete. If the stream close function does not wait until server release the lock, the subsequent write operation may fail when attempting to acquire a lock. This breaks the file stream contract that many applications assumes.", "url": "https://github.com/Alluxio/alluxio/pull/12466#discussion_r520831170", "createdAt": "2020-11-10T19:47:03Z", "author": {"login": "bf8086"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java", "diffHunk": "@@ -168,7 +169,19 @@ public void close() throws IOException {\n         return;\n       }\n       mStream.close();\n-      mStream.waitForComplete(mDataTimeoutMs);\n+\n+      // When a reader is closed, there is technically nothing the client requires from the server.\n+      // However, the server does need to cleanup resources for a client close(), including closing\n+      // or canceling any temp blocks. Therefore, we should wait for some amount of time for the\n+      // server to finish cleanup, but it should not be very long (since the client is finished\n+      // with the read). Also, if there is any error when waiting for the complete, it should be\n+      // ignored since again, the client is completely finished with the read.\n+      try {\n+        // Wait a short time for the server to finish the close, and then let the client continue.\n+        mStream.waitForComplete(5 * Constants.SECOND_MS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTc0OQ=="}, "originalCommit": {"oid": "92473d5211490f35dc21b3067baedc389535d9f5"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1009, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}