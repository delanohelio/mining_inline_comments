{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUyOTgzMDcz", "number": 11783, "title": "Add more options to collectInfo command", "bodyText": "This adds 3 features to collectInfo\n\nWith --exclude-logs <filename-prefixes>, --include-logs <filename-prefixes> and --additional-logs the user is able to specify log files to take or not take. By default only Alluxio-relevant files under ${ALLUXIO_HOME}/logs are included and unrecognized files are ignored.\n\nFor example, alluxio collectInfo --additional-logs alluxio_gc --exclude-logs master collectLog <tmp-dir> will include all alluxio_gc* files (supposedly for GC logs) and exclude all master* files like master.log.* and master.out.\nalluxio collectInfo --include-logs master collectLog <tmp-dir> will, however, take only the master* files like master.log and master.out.\n\n\nWith --start-time <datetime> and --end-time <datetime> the user can specify a certain time window to cover. This serves the need where only events in one window is of interest. The files that end before the start time or starts after the end time will be ignored. The end time of a file is the last modification time. The start time of a file is inferred by reading the first set of rows.\n\n\nalluxio-site.properties will not be collected as it can contain unmasked credentials. This is replaced with doing a local alluxio getConf.", "createdAt": "2020-07-20T02:54:25Z", "url": "https://github.com/Alluxio/alluxio/pull/11783", "merged": true, "mergeCommit": {"oid": "2aa7d4b65d08f3a58b2232a0f6eeadaeebd7fe6d"}, "closed": true, "closedAt": "2020-08-03T16:23:42Z", "author": {"login": "jiacheliu3"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3dYtOgBqjM1NzY1ODU0MDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7UiIqAFqTQ2MDE2NDQ0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85c13011c405a77ca134b79ff88dcbb9821dcb4f", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/85c13011c405a77ca134b79ff88dcbb9821dcb4f", "committedDate": "2020-07-22T15:53:45Z", "message": "checkstyle"}, "afterCommit": {"oid": "27639c948dfd375ca569f054bf4c6c7f6a0ba85e", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/27639c948dfd375ca569f054bf4c6c7f6a0ba85e", "committedDate": "2020-07-22T16:23:20Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e341ce0c966a2f8ff68f86be88aca6fd869db74a", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/e341ce0c966a2f8ff68f86be88aca6fd869db74a", "committedDate": "2020-07-23T02:19:59Z", "message": "add filename and timestamp selectors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bff88fb9f89054a25104709d902c8eeace03383", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/8bff88fb9f89054a25104709d902c8eeace03383", "committedDate": "2020-07-23T02:19:59Z", "message": "add datetime format inferrence unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43f057f08f7d21c54a0c01d747ee3ab147001b9f", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/43f057f08f7d21c54a0c01d747ee3ab147001b9f", "committedDate": "2020-07-23T02:19:59Z", "message": "do not copy alluxio-site.properties and do a local getConf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f14273a982293866ba0f42682ea660b41f828d3", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/9f14273a982293866ba0f42682ea660b41f828d3", "committedDate": "2020-07-23T02:21:32Z", "message": "include/exclude files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "661c3906050bfec65b3cd6b87338748adcc6562e", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/661c3906050bfec65b3cd6b87338748adcc6562e", "committedDate": "2020-07-23T02:21:32Z", "message": "verified time interval selection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fb012c8a6b0941e9b5856de264d9a92b57ddd1f", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/3fb012c8a6b0941e9b5856de264d9a92b57ddd1f", "committedDate": "2020-07-23T02:21:32Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44eadf4e8bce68574cb00124d95fc260ea872481", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/44eadf4e8bce68574cb00124d95fc260ea872481", "committedDate": "2020-07-23T02:21:32Z", "message": "checkstyl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5817ed43ada0be247949cfd3f41d2b627a77de85", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/5817ed43ada0be247949cfd3f41d2b627a77de85", "committedDate": "2020-07-23T02:21:32Z", "message": "small changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c5dbd5213734691355c34de9138b58ac21845d1", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/3c5dbd5213734691355c34de9138b58ac21845d1", "committedDate": "2020-07-23T03:19:44Z", "message": "smallfixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ed47e695cdee3e915a152242a0b9dabc1271fe0", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/8ed47e695cdee3e915a152242a0b9dabc1271fe0", "committedDate": "2020-07-22T16:38:04Z", "message": "checkstyl"}, "afterCommit": {"oid": "3c5dbd5213734691355c34de9138b58ac21845d1", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/3c5dbd5213734691355c34de9138b58ac21845d1", "committedDate": "2020-07-23T03:19:44Z", "message": "smallfixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d8e058355367addd575f70928c1c0dd942b1e17", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/2d8e058355367addd575f70928c1c0dd942b1e17", "committedDate": "2020-07-23T03:39:20Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b899a7047b7e73ee144b6f6bb9ef0663b17b5ab", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/3b899a7047b7e73ee144b6f6bb9ef0663b17b5ab", "committedDate": "2020-07-23T05:10:49Z", "message": "findbugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2565428f0481809f8fffe7cfb85dbeb950ff7a80", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/2565428f0481809f8fffe7cfb85dbeb950ff7a80", "committedDate": "2020-07-23T07:19:34Z", "message": "smallfixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "committedDate": "2020-07-23T10:40:02Z", "message": "verified"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDQ0ODAw", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-454044800", "createdAt": "2020-07-23T11:32:24Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozMjoyNFrOG2Gjow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozMjoyNFrOG2Gjow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4MzcxNQ==", "bodyText": "The parsed options will propagate to subcommands.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459383715", "createdAt": "2020-07-23T11:32:24Z", "author": {"login": "jiacheliu3"}, "path": "shell/src/main/java/alluxio/cli/bundler/CollectInfo.java", "diffHunk": "@@ -404,7 +466,7 @@ private int executeAndAddFile(String[] argv, List<File> filesToCollect) throws I\n       printHelp(String.format(\"%s is an unknown command.%n\", subCommand));\n       return 1;\n     }\n-    int ret = run(argv);\n+    int ret = cmd.run(cmdLine);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 227}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDQ1MjU0", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-454045254", "createdAt": "2020-07-23T11:33:14Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozMzoxNFrOG2GlCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozMzoxNFrOG2GlCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDA3Mw==", "bodyText": "The index changed cuz the invocation method changed.\n-    int ret = run(argv);\n+    int ret = cmd.run(cmdLine);", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459384073", "createdAt": "2020-07-23T11:33:14Z", "author": {"login": "jiacheliu3"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/AbstractCollectInfoCommand.java", "diffHunk": "@@ -56,12 +56,15 @@ public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n    * */\n   public String getWorkingDirectory(CommandLine cl) {\n     String[] args = cl.getArgs();\n-    String baseDirPath = args[0];\n+    String baseDirPath = args[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDQ1OTAx", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-454045901", "createdAt": "2020-07-23T11:34:23Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozNDoyM1rOG2Gm6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozNDoyM1rOG2Gm6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDU1NQ==", "bodyText": "This will create parent directories if not existent.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459384555", "createdAt": "2020-07-23T11:34:23Z", "author": {"login": "jiacheliu3"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +156,149 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDQ3OTMx", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-454047931", "createdAt": "2020-07-23T11:37:53Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozNzo1M1rOG2GtIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozNzo1M1rOG2GtIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NjE0NA==", "bodyText": "This invokes Set#equals which compares the size and checks existence of all elements.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459386144", "createdAt": "2020-07-23T11:37:53Z", "author": {"login": "jiacheliu3"}, "path": "shell/src/test/java/alluxio/cli/bundler/InfoCollectorTestUtils.java", "diffHunk": "@@ -37,12 +44,37 @@ public static File createTemporaryDirectory() {\n   }\n \n   public static File createFileInDir(File dir, String fileName) throws IOException {\n-    File newFile = new File(Paths.get(dir.getAbsolutePath(), fileName).toString());\n+    File newFile = new File(Paths.get(dir.getCanonicalPath(), fileName).toUri());\n     newFile.createNewFile();\n     return newFile;\n   }\n \n+  public static File createDirInDir(File dir, String dirName) throws IOException {\n+    File newDir = new File(Paths.get(dir.getCanonicalPath(), dirName).toUri());\n+    newDir.mkdir();\n+    return newDir;\n+  }\n+\n   public static void create() {\n     Files.createTempDir();\n   }\n+\n+  public static void verifyAllFiles(File targetDir, Set<String> expectedFiles) throws IOException {\n+    Set<String> copiedFiles = getAllFileNamesRelative(targetDir, targetDir);\n+    assertEquals(expectedFiles, copiedFiles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDQ4NjYx", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-454048661", "createdAt": "2020-07-23T11:39:09Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozOTowOVrOG2Gvaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozOTowOVrOG2Gvaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NjczMQ==", "bodyText": "It might be controversial whether we use real content or abstractions here. I would argue real logs capture more.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459386731", "createdAt": "2020-07-23T11:39:09Z", "author": {"login": "jiacheliu3"}, "path": "shell/src/test/java/alluxio/cli/bundler/command/CollectLogCommandTest.java", "diffHunk": "@@ -19,56 +22,500 @@\n import alluxio.conf.InstancedConfiguration;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n import org.apache.commons.cli.CommandLine;\n-import org.junit.Assert;\n-import org.junit.BeforeClass;\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n \n import java.io.File;\n+import java.io.FileWriter;\n import java.io.IOException;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n \n public class CollectLogCommandTest {\n-  private static InstancedConfiguration sConf;\n-  private static File sTestDir;\n-\n-  @BeforeClass\n-  public static void initConf() throws IOException {\n-    sTestDir = prepareLogDir(\"testLog\");\n-    sConf = InstancedConfiguration.defaults();\n-    sConf.set(PropertyKey.LOGS_DIR, sTestDir.getAbsolutePath());\n+  private static final int MILLISEC_TO_NANOSEC = 1_000_000;\n+\n+  private InstancedConfiguration mConf;\n+  private File mTestDir;\n+  private Set<String> mExpectedFiles;\n+\n+  @Before\n+  public void initLogDirAndConf() throws IOException {\n+    mTestDir = prepareLogDir();\n+    mConf = InstancedConfiguration.defaults();\n+    mConf.set(PropertyKey.LOGS_DIR, mTestDir.getAbsolutePath());\n+  }\n+\n+  @After\n+  public void emptyLogDir() {\n+    mConf.unset(PropertyKey.LOGS_DIR);\n+    mTestDir.delete();\n   }\n \n   // Prepare a temp dir with some log files\n-  private static File prepareLogDir(String prefix) throws IOException {\n+  private File prepareLogDir() throws IOException {\n     // The dir path will contain randomness so will be different every time\n-    File testConfDir = InfoCollectorTestUtils.createTemporaryDirectory();\n-    InfoCollectorTestUtils.createFileInDir(testConfDir, \"master.log\");\n-    InfoCollectorTestUtils.createFileInDir(testConfDir, \"worker.log\");\n-    return testConfDir;\n+    File testLogDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    // Prepare the normal log files that normal users will have\n+    for (String s : CollectLogCommand.FILE_NAMES) {\n+      InfoCollectorTestUtils.createFileInDir(testLogDir, s);\n+    }\n+    // Create some extra log files\n+    InfoCollectorTestUtils.createFileInDir(testLogDir, \"master.log.1\");\n+    InfoCollectorTestUtils.createFileInDir(testLogDir, \"master.log.2\");\n+    InfoCollectorTestUtils.createFileInDir(testLogDir, \"worker.log.backup\");\n+    // Remove the user file and create a directory\n+    File userDir = new File(testLogDir, \"user\");\n+    if (userDir.exists()) {\n+      userDir.delete();\n+    }\n+    // Put logs in the user log dir\n+    File userLogDir = InfoCollectorTestUtils.createDirInDir(testLogDir, \"user\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_hadoop.log\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_hadoop.out\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_root.log\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_root.out\");\n+\n+    // Set up expectation\n+    Set<String> createdFiles = InfoCollectorTestUtils\n+            .getAllFileNamesRelative(testLogDir, testLogDir);\n+    mExpectedFiles = createdFiles;\n+\n+    return testLogDir;\n+  }\n+\n+  @Test\n+  public void logFilesCopied() throws IOException, AlluxioException {\n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n+\n+    File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    CommandLine mockCommandLine = mock(CommandLine.class);\n+    String[] mockArgs = new String[]{cmd.getCommandName(), targetDir.getAbsolutePath()};\n+    when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    int ret = cmd.run(mockCommandLine);\n+    assertEquals(0, ret);\n+\n+    // Files will be copied to sub-dir of target dir\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n+  }\n+\n+  @Test\n+  public void irrelevantFileIgnored() throws Exception {\n+    // This file will not be copied\n+    // Not included in the expected set\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"irrelevant\");\n+\n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n+    File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    CommandLine mockCommandLine = mock(CommandLine.class);\n+    String[] mockArgs = new String[]{cmd.getCommandName(), targetDir.getAbsolutePath()};\n+    when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    int ret = cmd.run(mockCommandLine);\n+    assertEquals(0, ret);\n+\n+    // Files will be copied to sub-dir of target dir\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n+  }\n+\n+  @Test\n+  public void fileNameExcluded() throws Exception {\n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n+    File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    CommandLine mockCommandLine = mock(CommandLine.class);\n+    String[] mockArgs = new String[]{\n+            cmd.getCommandName(),\n+            targetDir.getAbsolutePath()\n+    };\n+    when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    when(mockCommandLine.hasOption(eq(\"exclude-logs\"))).thenReturn(true);\n+    when(mockCommandLine.getOptionValue(eq(\"exclude-logs\"))).thenReturn(\"master.log.1, worker\");\n+    int ret = cmd.run(mockCommandLine);\n+    assertEquals(0, ret);\n+\n+    // Files will be copied to sub-dir of target dir\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+    mExpectedFiles.remove(\"master.log.1\");\n+    mExpectedFiles.remove(\"worker.log\");\n+    mExpectedFiles.remove(\"worker.out\");\n+    mExpectedFiles.remove(\"worker.log.backup\");\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n   }\n \n   @Test\n-  public void logDirCopied() throws IOException, AlluxioException {\n-    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(sConf));\n+  public void fileNameIncluded() throws Exception {\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"alluxio_gc.log\");\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"alluxio_gc.log.1\");\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"alluxio_gc.log.2\");\n \n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n     File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n     CommandLine mockCommandLine = mock(CommandLine.class);\n-    String[] mockArgs = new String[]{targetDir.getAbsolutePath()};\n+    String[] mockArgs = new String[]{\n+            cmd.getCommandName(),\n+            targetDir.getAbsolutePath()\n+    };\n     when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    when(mockCommandLine.hasOption(eq(\"include-logs\"))).thenReturn(true);\n+    when(mockCommandLine.getOptionValue(eq(\"include-logs\"))).thenReturn(\"alluxio_gc\");\n     int ret = cmd.run(mockCommandLine);\n-    Assert.assertEquals(0, ret);\n+    assertEquals(0, ret);\n \n     // Files will be copied to sub-dir of target dir\n-    File subDir = new File(Paths.get(targetDir.getAbsolutePath(), cmd.getCommandName()).toString());\n-\n-    // Check the dir copied\n-    String[] files = subDir.list();\n-    Arrays.sort(files);\n-    String[] expectedFiles = sTestDir.list();\n-    Arrays.sort(expectedFiles);\n-    Assert.assertEquals(expectedFiles, files);\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+    mExpectedFiles.add(\"alluxio_gc.log\");\n+    mExpectedFiles.add(\"alluxio_gc.log.1\");\n+    mExpectedFiles.add(\"alluxio_gc.log.2\");\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n+  }\n+\n+  @Test\n+  public void endTimeFilter() throws Exception {\n+    // Define an issue end datetime\n+    // We ignore logs that are created after this\n+    LocalDateTime issueEnd = LocalDateTime.of(2020, 7, 8, 18, 0, 0);\n+    DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n+\n+    // Other logs all end before this issue\n+    LocalDateTime logEnd = issueEnd.minusHours(1);\n+    long logEndTimestamp = logEnd.toEpochSecond(ZoneOffset.UTC);\n+    for (File f : CommonUtils.recursiveListDir(mTestDir)) {\n+      f.setLastModified(logEndTimestamp);\n+    }\n+\n+    // Some logs are created after this time, should be ignored\n+    File masterLog = new File(mTestDir, \"master.log\");\n+    String log = \"2020-07-08 18:53:45,129 INFO  CopycatServer - Server started successfully!\\n\"\n+            + \"2020-07-08 18:53:59,129 INFO  RaftJournalSystem - Started Raft Journal System..\\n\"\n+            + \"2020-07-09 00:01:59,135 INFO  DefaultMetaMaster - Standby master with address...\\n\"\n+            + \"2020-07-09 00:03:59,135 INFO  AlluxioMasterProcess - All masters started\\n\"\n+            + \"2020-07-09 01:12:59,138 INFO  AbstractPrimarySelector - Primary selector..\\n\"\n+            + \"2020-07-09 01:53:59,139 INFO  AbstractMaster - TableMaster: Stopped secondary..\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 227}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzMxNDgx", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-454331481", "createdAt": "2020-07-23T17:05:52Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNTo1MlrOG2TrRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxODo0NVrOG2UI3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODY2MA==", "bodyText": "Can we add a unittest for this method?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459598660", "createdAt": "2020-07-23T17:05:52Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a dir and all its subdirs and return all the files.\n+   *\n+   * @param dir the directory\n+   * @return a list of all the files\n+   * */\n+  public static List<File> recursiveListDir(File dir) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTA1OA==", "bodyText": "Use Collections.emptyList() to avoid a new instance.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459599058", "createdAt": "2020-07-23T17:06:35Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a dir and all its subdirs and return all the files.\n+   *\n+   * @param dir the directory\n+   * @return a list of all the files\n+   * */\n+  public static List<File> recursiveListDir(File dir) {\n+    File[] files = dir.listFiles();\n+    // File#listFiles can return null when the path is invalid\n+    if (files == null) {\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMDAwNg==", "bodyText": "This lists a local dir, right? I think we should mention that in the javadoc and the name of the method.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459600006", "createdAt": "2020-07-23T17:08:17Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a dir and all its subdirs and return all the files.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjIzOQ==", "bodyText": "Somewhere in this usage message, we need to show how include and exclude work (relative order of them), and how start, end time work", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459606239", "createdAt": "2020-07-23T17:18:45Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/CollectInfo.java", "diffHunk": "@@ -61,7 +64,9 @@\n public class CollectInfo extends AbstractShell {\n   private static final Logger LOG = LoggerFactory.getLogger(CollectInfo.class);\n   private static final String USAGE =\n-      \"USAGE: collectInfo [--max-threads <threadNum>] [--local] [--help] COMMAND <outputPath>\\n\\n\"\n+      \"USAGE: collectInfo [--max-threads <threadNum>] [--local] [--help] \"\n+          + \"[--exclude-logs <filename-prefixes>] [--include-logs <filename-prefixes>] \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd63cf8efc3d129f85b38c0e27890bfca434eb84", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/bd63cf8efc3d129f85b38c0e27890bfca434eb84", "committedDate": "2020-07-24T08:42:27Z", "message": "resolve comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42964e5bde55199b2616dda9d09f856175a70c22", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/42964e5bde55199b2616dda9d09f856175a70c22", "committedDate": "2020-07-24T08:44:25Z", "message": "checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MjE5NjY1", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-456219665", "createdAt": "2020-07-28T00:17:42Z", "commit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwMDoxNzo0M1rOG34EOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwMDozNzoyOVrOG34a1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0MzQ1MQ==", "bodyText": "ahhh, ok. Now, I see the sub-command help. Then, why does this top level usage help mention start-time and include-logs, etc, when it is only a sub command option?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461243451", "createdAt": "2020-07-28T00:17:43Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/CollectInfo.java", "diffHunk": "@@ -61,7 +64,9 @@\n public class CollectInfo extends AbstractShell {\n   private static final Logger LOG = LoggerFactory.getLogger(CollectInfo.class);\n   private static final String USAGE =\n-      \"USAGE: collectInfo [--max-threads <threadNum>] [--local] [--help] COMMAND <outputPath>\\n\\n\"\n+      \"USAGE: collectInfo [--max-threads <threadNum>] [--local] [--help] \"\n+          + \"[--exclude-logs <filename-prefixes>] [--include-logs <filename-prefixes>] \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjIzOQ=="}, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NDE5Nw==", "bodyText": "This message makes it sound like the user should run mkdir. Instead, this could say:\n\"Creating working directory: %s %n\"\nSo it sounds like the command is creating the directory.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461244197", "createdAt": "2020-07-28T00:20:16Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/AbstractCollectInfoCommand.java", "diffHunk": "@@ -56,12 +56,15 @@ public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n    * */\n   public String getWorkingDirectory(CommandLine cl) {\n     String[] args = cl.getArgs();\n-    String baseDirPath = args[0];\n+    String baseDirPath = args[1];\n     String workingDirPath =  Paths.get(baseDirPath, this.getCommandName()).toString();\n     LOG.debug(\"Command %s works in %s\", this.getCommandName(), workingDirPath);\n     // mkdirs checks existence of the path\n     File workingDir = new File(workingDirPath);\n-    workingDir.mkdirs();\n+    if (!workingDir.exists()) {\n+      System.out.format(\"Working path %s does not exist. mkdir first%n\", workingDirPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NTg3Mw==", "bodyText": "is this to avoid copying credentials?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461245873", "createdAt": "2020-07-28T00:25:52Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -30,6 +36,10 @@\n   public static final String COMMAND_NAME = \"collectConfig\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectConfigCommand.class);\n \n+  private static final Set<String> EXCLUDED_FILES = Stream.of(\n+          Constants.SITE_PROPERTIES", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NTk3Ng==", "bodyText": "Would ImmutableSet.of(...) work?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461245976", "createdAt": "2020-07-28T00:26:12Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -30,6 +36,10 @@\n   public static final String COMMAND_NAME = \"collectConfig\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectConfigCommand.class);\n \n+  private static final Set<String> EXCLUDED_FILES = Stream.of(\n+          Constants.SITE_PROPERTIES\n+  ).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NjQ2NA==", "bodyText": "If these are supposed to prefixes, the variable name should be something like EXCLUDED_FILE_PREFIXES or something.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461246464", "createdAt": "2020-07-28T00:28:00Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +62,21 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListDir(confDir);\n+    for (File f : allFiles) {\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILES) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NjgwOQ==", "bodyText": "Is relativePath just the filename part?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461246809", "createdAt": "2020-07-28T00:29:05Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +62,21 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListDir(confDir);\n+    for (File f : allFiles) {\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILES) {\n+        if (relativePath.startsWith(prefix)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODU0Ng==", "bodyText": "Is String.length() slow?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461248546", "createdAt": "2020-07-28T00:34:56Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -71,4 +308,34 @@ public String getUsage() {\n   public String getDescription() {\n     return \"Collect Alluxio log files\";\n   }\n+\n+  /**\n+   * Identifies the datetime from a certain piece of log by trying various known patterns.\n+   * Returns null if unable to identify a datetime.\n+   *\n+   * @param s a log entry\n+   * @return identified datetime\n+   * */\n+  @Nullable\n+  public static LocalDateTime parseDateTime(String s) {\n+    for (Map.Entry<String, Integer> entry : FORMAT_TO_LEN.entrySet()) {\n+      String f = entry.getKey();\n+      int len = entry.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODc3Mg==", "bodyText": "Why can't this just be a list? Why do we need to cache the length?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461248772", "createdAt": "2020-07-28T00:35:43Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,121 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<String, Integer> FORMAT_TO_LEN = new LinkedHashMap<String, Integer>(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0OTIzOQ==", "bodyText": "why can't we just have an ordered list of formatters? Why do we need the string representation?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461249239", "createdAt": "2020-07-28T00:37:29Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,121 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<String, Integer> FORMAT_TO_LEN = new LinkedHashMap<String, Integer>(){\n+    {\n+      put(\"yyyy-MM-dd HH:mm:ss,SSS\", 23);\n+      put(\"yyyy-MM-dd HH:mm:ss\", 19);\n+      put(\"yyyy-MM-dd HH:mm\", 16);\n+      put(\"yy/MM/dd HH:mm:ss\", 17);\n+      put(\"yy/MM/dd HH:mm\", 14);\n+      put(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\", 28);\n+      put(\"yyyy-MM-dd'T'HH:mm:ss\", 19);\n+      put(\"yyyy-MM-dd'T'HH:mm\", 16);\n+    }\n+  };\n+  private static final Map<String, DateTimeFormatter> STRING_TO_FORMATTER = initFormatters();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85dd3eade62b25445f98d681325d9e337c3ce7cd", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/85dd3eade62b25445f98d681325d9e337c3ce7cd", "committedDate": "2020-07-28T05:42:09Z", "message": "resolve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "committedDate": "2020-07-28T16:55:43Z", "message": "subcommand option messages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDE4NTkx", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-457018591", "createdAt": "2020-07-28T21:15:25Z", "commit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToxNToyNVrOG4fKtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTozNTowOFrOG4fwAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDA4NQ==", "bodyText": "I think Collections.emptyList() will work better with type safety?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461884085", "createdAt": "2020-07-28T21:15:25Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a local dir and all its subdirs and return all the files.\n+   *\n+   * @param dir the directory\n+   * @return a list of all the files\n+   * */\n+  public static List<File> recursiveListLocalDir(File dir) {\n+    File[] files = dir.listFiles();\n+    // File#listFiles can return null when the path is invalid\n+    if (files == null) {\n+      return Collections.EMPTY_LIST;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NTEyOQ==", "bodyText": "Doesn't this continue just move to the next entry in EXCLUDED_FILE_PREFIXES? Don't we want to go to the next entry in allFiles instead?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461885129", "createdAt": "2020-07-28T21:17:36Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +60,22 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(confDir);\n+    for (File f : allFiles) {\n+      String filename = f.getName();\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILE_PREFIXES) {\n+        if (filename.startsWith(prefix)) {\n+          continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NTY4OQ==", "bodyText": "I think this block needs to be outside the iteration over all EXCLUDED_FILE_PREFIXES.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461885689", "createdAt": "2020-07-28T21:18:45Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +60,22 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(confDir);\n+    for (File f : allFiles) {\n+      String filename = f.getName();\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILE_PREFIXES) {\n+        if (filename.startsWith(prefix)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjU2NQ==", "bodyText": "These are prefixes, in order to handle master.log.1, right? Should we include \"prefix\" in the name of the variable?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461886565", "createdAt": "2020-07-28T21:20:29Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4Njk0Nw==", "bodyText": "I wonder if we need to make this larger, in order to ignore any long stack trace at the beginning of the file or something?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461886947", "createdAt": "2020-07-28T21:21:16Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NzU2Nw==", "bodyText": "comment on what the second field is (what that length represents)", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461887567", "createdAt": "2020-07-28T21:22:32Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4OTg5Nw==", "bodyText": "what is the order of operation between include and exclude? For example, if master.log is in both include and exclude, what happens?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461889897", "createdAt": "2020-07-28T21:27:16Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(INCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to include in ${ALLUXIO_HOME}/logs. \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDE3OA==", "bodyText": "Does start time require end time?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461890178", "createdAt": "2020-07-28T21:27:53Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(INCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to include in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be included.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  public static final String EXCLUDE_OPTION_NAME = \"exclude-logs\";\n+  private static final Option EXCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(EXCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to exclude in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be excluded.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  private static final String START_OPTION_NAME = \"start-time\";\n+  private static final Option START_OPTION =\n+          Option.builder().required(false).argName(\"datetime\")\n+                  .longOpt(START_OPTION_NAME).hasArg(true)\n+                  .desc(\"logs that do not contain entries after this time will be ignored\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDI2NA==", "bodyText": "Does end time require start time?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461890264", "createdAt": "2020-07-28T21:28:05Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(INCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to include in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be included.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  public static final String EXCLUDE_OPTION_NAME = \"exclude-logs\";\n+  private static final Option EXCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(EXCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to exclude in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be excluded.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  private static final String START_OPTION_NAME = \"start-time\";\n+  private static final Option START_OPTION =\n+          Option.builder().required(false).argName(\"datetime\")\n+                  .longOpt(START_OPTION_NAME).hasArg(true)\n+                  .desc(\"logs that do not contain entries after this time will be ignored\\n\"\n+                          + \"<datetime> a datetime string like 2020-06-27T11:58:53\").build();\n+  private static final String END_OPTION_NAME = \"end-time\";\n+  private static final Option END_OPTION =\n+          Option.builder().required(false).argName(\"datetime\")\n+                  .longOpt(END_OPTION_NAME).hasArg(true)\n+                  .desc(\"logs that do not contain entries before this time will be ignored\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTMyMA==", "bodyText": "mIncludedPrefix starts off with the entire list. Does that mean it can never be reduced? For example, if I use the option --include master.log this will still retrieve all logs because mIncludedPrefix = new HashSet<>(FILE_NAMES)?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461891320", "createdAt": "2020-07-28T21:30:10Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzI1Ng==", "bodyText": "We should guard this with if (mEndTime != null) and in the block, return false if it fails.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461893256", "createdAt": "2020-07-28T21:34:23Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzMzNg==", "bodyText": "We should guard this with if (mStartTime != null) and in the block, return false if it fails.", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461893336", "createdAt": "2020-07-28T21:34:34Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();\n+    LocalDateTime fileEndTime =\n+            LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());\n+\n+    // Infer file start time by parsing the first bunch of rows", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzYzNQ==", "bodyText": "will this skip empty strings?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461893635", "createdAt": "2020-07-28T21:35:08Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();\n+    LocalDateTime fileEndTime =\n+            LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());\n+\n+    // Infer file start time by parsing the first bunch of rows\n+    LocalDateTime fileStartTime = inferFileStartTime(f);\n+    if (fileStartTime == null) {\n+      fileStartTime = LocalDateTime.MIN;\n+    }\n+\n+    // The file is earlier than the desired interval\n+    if (mStartTime != null && mStartTime.isAfter(fileEndTime)) {\n+      return false;\n+    }\n+    // The file is later than the desired interval\n+    if (mEndTime != null && mEndTime.isBefore(fileStartTime)) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Infer the starting time of a log file by parsing the log entries from the beginning.\n+   * It will try the first certain lines with various known datetime patterns.\n+   *\n+   * @param f log file\n+   * @return the parsed datetime\n+   * */\n+  public static LocalDateTime inferFileStartTime(File f) throws FileNotFoundException {\n+    int r = 0;\n+    try (Scanner scanner = new Scanner(f)) {\n+      while (scanner.hasNextLine() && r < TRY_PARSE_LOG_ROWS) {\n+        String line = scanner.nextLine();\n+        LocalDateTime datetime = parseDateTime(line);\n+        if (datetime != null) {\n+          return datetime;\n+        }\n+        r++;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Set<String> parseFileNames(String input) {\n+    Set<String> names = new HashSet<>();\n+    names.addAll(Stream.of(input.split(\",\")).map(String::trim).collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 274}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9188422dc22fe4826f4745568ecf3783b68776cd", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/9188422dc22fe4826f4745568ecf3783b68776cd", "committedDate": "2020-07-29T14:58:45Z", "message": "resolved part of comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67620a2fd8138edecd6cc7c10975770baf406041", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/67620a2fd8138edecd6cc7c10975770baf406041", "committedDate": "2020-07-30T04:30:47Z", "message": "add --additional-logs option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de03e19048bdcd5a822c82145b6835bcaadeadb4", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/de03e19048bdcd5a822c82145b6835bcaadeadb4", "committedDate": "2020-07-30T05:30:24Z", "message": "Merge remote-tracking branch 'upstream/master' into collectinfo2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjI2MjQ0", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-458626244", "createdAt": "2020-07-30T17:50:03Z", "commit": {"oid": "de03e19048bdcd5a822c82145b6835bcaadeadb4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1MDowNFrOG5tlSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxMjo0N1rOG5uYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2ODg0Mw==", "bodyText": "I was saying we have to do some \"work\" to determine if the end time is satisfied. However in the current code, I think we do all the \"work\" for determining each files' end and start times, but later, we only use the results of that work if the end and start times are specified (end != null or start != null).\nTherefore, my suggestion was to only do the \"work\" if the end or start times are specified (!= null). If both are null, then we would not check file end time, or file start time at all, and just return true.\nWhat do you think?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463168843", "createdAt": "2020-07-30T17:50:04Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzI1Ng=="}, "originalCommit": {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTg0Mw==", "bodyText": "I think maybe we can achieve everything with only the --include flag, but that flag simply specifies the files to get. We can set the default for this flag as the list of FILE_NAMES_PREFIXES.\nHowever, if a user wants to exclude or include files, then they would have to add a --include with the full list they want.\nIf that is too unfriendly, then can't we just assume we download everything under logs/, and only have an --exclude flag, so any additional logs will automatically get retrieved, and the exclude is a simple way to not download some.\nI just thought having 3 flags was too much. Ideally we only need one. What do you think?", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463181843", "createdAt": "2020-07-30T18:12:47Z", "author": {"login": "gpang"}, "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,148 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES_PREFIXES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // A YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 100;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one.\n+  // The 1st field is the DateTimeFormatter of a specific pattern.\n+  // The 2nd field is the length to take from the beginning of the log entry.\n+  // The length of the format string can be different from the datetime string it parses to.\n+  // For example, \"yyyy-MM-dd'T'HH:mm:ss.SSSXX\" has length of 27 but parses to\n+  // \"2020-10-12T12:11:10.055+0800\".\n+  // Note that the single quotes around 'T' are not in the real string,\n+  // and \"XX\" parses to the timezone, which is \"+0800\".\n+  // The datetime parsing works only when the string matches exactly to the format.\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  public static final String EXCLUDE_OPTION_NAME = \"exclude-logs\";\n+  public static final String ADDITIONAL_OPTION_NAME = \"additional-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de03e19048bdcd5a822c82145b6835bcaadeadb4"}, "originalPosition": 103}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab3ab9d708e778c43085eab92355de2f17c726d7", "author": {"user": {"login": "jiacheliu3", "name": "Jiacheng Liu"}}, "url": "https://github.com/Alluxio/alluxio/commit/ab3ab9d708e778c43085eab92355de2f17c726d7", "committedDate": "2020-07-31T03:41:12Z", "message": "update check time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMTY0NDQ5", "url": "https://github.com/Alluxio/alluxio/pull/11783#pullrequestreview-460164449", "createdAt": "2020-08-03T16:23:00Z", "commit": {"oid": "ab3ab9d708e778c43085eab92355de2f17c726d7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4311, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}