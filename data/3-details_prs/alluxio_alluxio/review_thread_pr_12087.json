{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyNjgwNTc2", "number": 12087, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzo0NTozNFrOEhyc8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowNzozOFrOEkrvAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODY1MDczOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzo0NTozNFrOHPTIJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODozOToxMlrOHPU6vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwNDA2OQ==", "bodyText": "Will this part be performant enough if there are a large number of extra pages? Is there any way to parallelize or otherwise delete the rest of the stream at once after we detect the metastore is out of space?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r485804069", "createdAt": "2020-09-09T17:45:34Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -107,10 +107,13 @@ private static boolean restore(\n           LOG.error(\"Invalid page info\");\n           return false;\n         }\n-        metaStore.addPage(pageInfo.getPageId(), pageInfo);\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n         if (metaStore.bytes() > pageStore.getCacheSize()) {\n-          LOG.error(\"Loaded pages exceed cache capacity ({} bytes)\", pageStore.getCacheSize());\n-          return false;\n+          metaStore.removePage(pageId);\n+          pageStore.delete(pageId);\n+          LOG.warn(\"Abandon {} in restore: cache size is {} bytes and {} bytes used\",\n+              pageInfo, pageStore.getCacheSize(), metaStore.bytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39056b7ebb206a567b685d3f625dc3c84ff3fa5f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMzQwNA==", "bodyText": "removed the warning but show the aggregated result in the end.\nthere is no easy way to bulk-delete the files after metastore is filled", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r485833404", "createdAt": "2020-09-09T18:39:12Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -107,10 +107,13 @@ private static boolean restore(\n           LOG.error(\"Invalid page info\");\n           return false;\n         }\n-        metaStore.addPage(pageInfo.getPageId(), pageInfo);\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n         if (metaStore.bytes() > pageStore.getCacheSize()) {\n-          LOG.error(\"Loaded pages exceed cache capacity ({} bytes)\", pageStore.getCacheSize());\n-          return false;\n+          metaStore.removePage(pageId);\n+          pageStore.delete(pageId);\n+          LOG.warn(\"Abandon {} in restore: cache size is {} bytes and {} bytes used\",\n+              pageInfo, pageStore.getCacheSize(), metaStore.bytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwNDA2OQ=="}, "originalCommit": {"oid": "39056b7ebb206a567b685d3f625dc3c84ff3fa5f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTQ4OTk1OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjoyNDo0MFrOHRuIaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo0NDozNVrOHSf2jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0MzY1Nw==", "bodyText": "Should this be a write lock because we might delete the page if there is not enough space?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r488343657", "createdAt": "2020-09-15T02:24:40Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -424,9 +408,87 @@ public boolean delete(PageId pageId) {\n     }\n   }\n \n+  @Override\n+  public State state() {\n+    return mState.get();\n+  }\n+\n+  /**\n+   * Restores a page store a the configured location, updating meta store.\n+   */\n+  private void restoreOrInit(PageStoreOptions options) {\n+    Preconditions.checkState(mState.get() == READ_ONLY);\n+    if (!restore(options)) {\n+      try {\n+        mPageStore.close();\n+        try (LockResource r = new LockResource(mMetaLock.writeLock())) {\n+          mMetaStore.reset();\n+        }\n+        PageStore.initialize(options);\n+        mPageStore = PageStore.create(options);\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to clean up PageStore\", e);\n+        return;\n+      }\n+    }\n+    mState.set(READ_WRITE);\n+    Metrics.STATE.inc();\n+  }\n+\n+  private boolean restore(PageStoreOptions options) {\n+    LOG.info(\"Attempt to restore PageStore with {}\", options);\n+    Path rootDir = Paths.get(options.getRootDir());\n+    if (!Files.exists(rootDir)) {\n+      LOG.error(\"Failed to restore PageStore: Directory {} does not exist\", rootDir);\n+      return false;\n+    }\n+    long discardedPages = 0;\n+    long discardedBytes = 0;\n+    try (Stream<PageInfo> stream = mPageStore.getPages()) {\n+      Iterator<PageInfo> iterator = stream.iterator();\n+      while (iterator.hasNext()) {\n+        PageInfo pageInfo = iterator.next();\n+        if (pageInfo == null) {\n+          LOG.error(\"Invalid page info\");\n+          return false;\n+        }\n+        PageId pageId = pageInfo.getPageId();\n+        ReadWriteLock pageLock = getPageLock(pageId);\n+        try (LockResource r = new LockResource(pageLock.readLock())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1ODI4Nw==", "bodyText": "good catch. corrected", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489158287", "createdAt": "2020-09-16T04:44:35Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -424,9 +408,87 @@ public boolean delete(PageId pageId) {\n     }\n   }\n \n+  @Override\n+  public State state() {\n+    return mState.get();\n+  }\n+\n+  /**\n+   * Restores a page store a the configured location, updating meta store.\n+   */\n+  private void restoreOrInit(PageStoreOptions options) {\n+    Preconditions.checkState(mState.get() == READ_ONLY);\n+    if (!restore(options)) {\n+      try {\n+        mPageStore.close();\n+        try (LockResource r = new LockResource(mMetaLock.writeLock())) {\n+          mMetaStore.reset();\n+        }\n+        PageStore.initialize(options);\n+        mPageStore = PageStore.create(options);\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to clean up PageStore\", e);\n+        return;\n+      }\n+    }\n+    mState.set(READ_WRITE);\n+    Metrics.STATE.inc();\n+  }\n+\n+  private boolean restore(PageStoreOptions options) {\n+    LOG.info(\"Attempt to restore PageStore with {}\", options);\n+    Path rootDir = Paths.get(options.getRootDir());\n+    if (!Files.exists(rootDir)) {\n+      LOG.error(\"Failed to restore PageStore: Directory {} does not exist\", rootDir);\n+      return false;\n+    }\n+    long discardedPages = 0;\n+    long discardedBytes = 0;\n+    try (Stream<PageInfo> stream = mPageStore.getPages()) {\n+      Iterator<PageInfo> iterator = stream.iterator();\n+      while (iterator.hasNext()) {\n+        PageInfo pageInfo = iterator.next();\n+        if (pageInfo == null) {\n+          LOG.error(\"Invalid page info\");\n+          return false;\n+        }\n+        PageId pageId = pageInfo.getPageId();\n+        ReadWriteLock pageLock = getPageLock(pageId);\n+        try (LockResource r = new LockResource(pageLock.readLock())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0MzY1Nw=="}, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTQ5NDk5OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjoyNzoxM1rOHRuLaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjoyNzoxM1rOHRuLaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NDQyNA==", "bodyText": "Is this description accurate? It looks like we only have two states?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r488344424", "createdAt": "2020-09-15T02:27:13Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -938,6 +950,12 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(false)\n           .build();\n+  public static final MetricKey CLIENT_CACHE_STATE =\n+      new Builder(Name.CLIENT_CACHE_STATE)\n+          .setDescription(\"State of the cache: 0 (NOT_READY), 1 (READ_ONLY) and 2 (READ_WRITE)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTQ5ODcyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjoyOToyNFrOHRuNpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo0MzozN1rOHSf1uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NDk5Ng==", "bodyText": "One concern here is if multiple threads can go into restoreOrInit.", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r488344996", "createdAt": "2020-09-15T02:29:24Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -424,9 +408,87 @@ public boolean delete(PageId pageId) {\n     }\n   }\n \n+  @Override\n+  public State state() {\n+    return mState.get();\n+  }\n+\n+  /**\n+   * Restores a page store a the configured location, updating meta store.\n+   */\n+  private void restoreOrInit(PageStoreOptions options) {\n+    Preconditions.checkState(mState.get() == READ_ONLY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1ODA3NQ==", "bodyText": "synchronized", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489158075", "createdAt": "2020-09-16T04:43:37Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -424,9 +408,87 @@ public boolean delete(PageId pageId) {\n     }\n   }\n \n+  @Override\n+  public State state() {\n+    return mState.get();\n+  }\n+\n+  /**\n+   * Restores a page store a the configured location, updating meta store.\n+   */\n+  private void restoreOrInit(PageStoreOptions options) {\n+    Preconditions.checkState(mState.get() == READ_ONLY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NDk5Ng=="}, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTQ5OTU2OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjoyOTo1M1rOHRuOLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo0MzoyM1rOHSf1fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NTEzNQ==", "bodyText": "Are we guaranteed create is only called once? Otherwise we could queue up multiple restoreOrInit", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r488345135", "createdAt": "2020-09-15T02:29:53Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -69,99 +74,67 @@\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n   private static final int LOCK_SIZE = 1024;\n+\n   private final long mPageSize;\n   private final long mCacheSize;\n   private final boolean mAsyncWrite;\n+  private final boolean mAsyncRestore;\n   /** A readwrite lock pool to guard individual pages based on striping. */\n   private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n-  private final PageStore mPageStore;\n+  private PageStore mPageStore;\n   /** A readwrite lock to guard metadata operations. */\n   private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n   @GuardedBy(\"mMetaLock\")\n   private final MetaStore mMetaStore;\n+  /** Executor service for execute the init tasks. */\n+  private final ExecutorService mInitService;\n   /** Executor service for execute the async cache tasks. */\n   private final ExecutorService mAsyncCacheExecutor;\n   private final ConcurrentHashSet<PageId> mPendingRequests;\n+  /** State of this cache. */\n+  private final AtomicReference<CacheManager.State> mState = new AtomicReference<>(READ_ONLY);\n \n   /**\n-   * Restores a page store a the configured location, updating meta store and evictor.\n-   *\n-   * @param pageStore page store\n-   * @param options page store options\n-   * @param metaStore meta store\n-   * @return whether the restore succeeds or not\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n    */\n-  private static boolean restore(\n-      PageStore pageStore, PageStoreOptions options, MetaStore metaStore) {\n-    LOG.info(\"Attempt to restore PageStore with {}\", options);\n-    Path rootDir = Paths.get(options.getRootDir());\n-    if (!Files.exists(rootDir)) {\n-      LOG.error(\"Failed to restore PageStore: Directory {} does not exist\", rootDir);\n-      return false;\n-    }\n-    try (Stream<PageInfo> stream = pageStore.getPages()) {\n-      Iterator<PageInfo> iterator = stream.iterator();\n-      while (iterator.hasNext()) {\n-        PageInfo pageInfo = iterator.next();\n-        if (pageInfo == null) {\n-          LOG.error(\"Invalid page info\");\n-          return false;\n-        }\n-        metaStore.addPage(pageInfo.getPageId(), pageInfo);\n-        if (metaStore.bytes() > pageStore.getCacheSize()) {\n-          LOG.error(\"Loaded pages exceed cache capacity ({} bytes)\", pageStore.getCacheSize());\n-          return false;\n-        }\n-      }\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to restore PageStore\", e);\n-      return false;\n-    }\n-    LOG.info(\"Restored PageStore with {} existing pages and {} bytes\", metaStore.pages(),\n-        metaStore.bytes());\n-    return true;\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create(CacheEvictor.create(conf));\n+    PageStoreOptions options = PageStoreOptions.create(conf);\n+    PageStore pageStore = PageStore.create(options);\n+    return create(conf, metaStore, pageStore, options);\n   }\n \n   /**\n    * @param conf the Alluxio configuration\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   * @param options page store options\n    * @return an instance of {@link LocalCacheManager}\n    */\n-  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n-    MetaStore metaStore = MetaStore.create(CacheEvictor.create(conf));\n-    PageStoreOptions options = PageStoreOptions.create(conf);\n-    PageStore pageStore = null;\n-    boolean restored = false;\n-    try {\n-      pageStore = PageStore.create(options, false);\n-      restored = restore(pageStore, options, metaStore);\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to restore PageStore\", e);\n-    }\n-    if (!restored) {\n-      if (pageStore != null) {\n-        try {\n-          pageStore.close();\n-        } catch (Exception e) {\n-          LOG.error(\"Failed to close PageStore\", e);\n-        }\n-      }\n-      metaStore.reset();\n-      pageStore = PageStore.create(options, true);\n+  @VisibleForTesting\n+  static LocalCacheManager create(AlluxioConfiguration conf, MetaStore metaStore,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1NjQ1Mw==", "bodyText": "ensured by https://github.com/Alluxio/alluxio/pull/12087/files#diff-f604b8c2e5cc2efb92656285c2a61cbfR50", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489156453", "createdAt": "2020-09-16T04:36:58Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -69,99 +74,67 @@\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n   private static final int LOCK_SIZE = 1024;\n+\n   private final long mPageSize;\n   private final long mCacheSize;\n   private final boolean mAsyncWrite;\n+  private final boolean mAsyncRestore;\n   /** A readwrite lock pool to guard individual pages based on striping. */\n   private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n-  private final PageStore mPageStore;\n+  private PageStore mPageStore;\n   /** A readwrite lock to guard metadata operations. */\n   private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n   @GuardedBy(\"mMetaLock\")\n   private final MetaStore mMetaStore;\n+  /** Executor service for execute the init tasks. */\n+  private final ExecutorService mInitService;\n   /** Executor service for execute the async cache tasks. */\n   private final ExecutorService mAsyncCacheExecutor;\n   private final ConcurrentHashSet<PageId> mPendingRequests;\n+  /** State of this cache. */\n+  private final AtomicReference<CacheManager.State> mState = new AtomicReference<>(READ_ONLY);\n \n   /**\n-   * Restores a page store a the configured location, updating meta store and evictor.\n-   *\n-   * @param pageStore page store\n-   * @param options page store options\n-   * @param metaStore meta store\n-   * @return whether the restore succeeds or not\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n    */\n-  private static boolean restore(\n-      PageStore pageStore, PageStoreOptions options, MetaStore metaStore) {\n-    LOG.info(\"Attempt to restore PageStore with {}\", options);\n-    Path rootDir = Paths.get(options.getRootDir());\n-    if (!Files.exists(rootDir)) {\n-      LOG.error(\"Failed to restore PageStore: Directory {} does not exist\", rootDir);\n-      return false;\n-    }\n-    try (Stream<PageInfo> stream = pageStore.getPages()) {\n-      Iterator<PageInfo> iterator = stream.iterator();\n-      while (iterator.hasNext()) {\n-        PageInfo pageInfo = iterator.next();\n-        if (pageInfo == null) {\n-          LOG.error(\"Invalid page info\");\n-          return false;\n-        }\n-        metaStore.addPage(pageInfo.getPageId(), pageInfo);\n-        if (metaStore.bytes() > pageStore.getCacheSize()) {\n-          LOG.error(\"Loaded pages exceed cache capacity ({} bytes)\", pageStore.getCacheSize());\n-          return false;\n-        }\n-      }\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to restore PageStore\", e);\n-      return false;\n-    }\n-    LOG.info(\"Restored PageStore with {} existing pages and {} bytes\", metaStore.pages(),\n-        metaStore.bytes());\n-    return true;\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create(CacheEvictor.create(conf));\n+    PageStoreOptions options = PageStoreOptions.create(conf);\n+    PageStore pageStore = PageStore.create(options);\n+    return create(conf, metaStore, pageStore, options);\n   }\n \n   /**\n    * @param conf the Alluxio configuration\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   * @param options page store options\n    * @return an instance of {@link LocalCacheManager}\n    */\n-  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n-    MetaStore metaStore = MetaStore.create(CacheEvictor.create(conf));\n-    PageStoreOptions options = PageStoreOptions.create(conf);\n-    PageStore pageStore = null;\n-    boolean restored = false;\n-    try {\n-      pageStore = PageStore.create(options, false);\n-      restored = restore(pageStore, options, metaStore);\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to restore PageStore\", e);\n-    }\n-    if (!restored) {\n-      if (pageStore != null) {\n-        try {\n-          pageStore.close();\n-        } catch (Exception e) {\n-          LOG.error(\"Failed to close PageStore\", e);\n-        }\n-      }\n-      metaStore.reset();\n-      pageStore = PageStore.create(options, true);\n+  @VisibleForTesting\n+  static LocalCacheManager create(AlluxioConfiguration conf, MetaStore metaStore,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NTEzNQ=="}, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1ODAxMg==", "bodyText": "also made a few methods synchronized to further ensure this", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489158012", "createdAt": "2020-09-16T04:43:23Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -69,99 +74,67 @@\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n   private static final int LOCK_SIZE = 1024;\n+\n   private final long mPageSize;\n   private final long mCacheSize;\n   private final boolean mAsyncWrite;\n+  private final boolean mAsyncRestore;\n   /** A readwrite lock pool to guard individual pages based on striping. */\n   private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n-  private final PageStore mPageStore;\n+  private PageStore mPageStore;\n   /** A readwrite lock to guard metadata operations. */\n   private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n   @GuardedBy(\"mMetaLock\")\n   private final MetaStore mMetaStore;\n+  /** Executor service for execute the init tasks. */\n+  private final ExecutorService mInitService;\n   /** Executor service for execute the async cache tasks. */\n   private final ExecutorService mAsyncCacheExecutor;\n   private final ConcurrentHashSet<PageId> mPendingRequests;\n+  /** State of this cache. */\n+  private final AtomicReference<CacheManager.State> mState = new AtomicReference<>(READ_ONLY);\n \n   /**\n-   * Restores a page store a the configured location, updating meta store and evictor.\n-   *\n-   * @param pageStore page store\n-   * @param options page store options\n-   * @param metaStore meta store\n-   * @return whether the restore succeeds or not\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n    */\n-  private static boolean restore(\n-      PageStore pageStore, PageStoreOptions options, MetaStore metaStore) {\n-    LOG.info(\"Attempt to restore PageStore with {}\", options);\n-    Path rootDir = Paths.get(options.getRootDir());\n-    if (!Files.exists(rootDir)) {\n-      LOG.error(\"Failed to restore PageStore: Directory {} does not exist\", rootDir);\n-      return false;\n-    }\n-    try (Stream<PageInfo> stream = pageStore.getPages()) {\n-      Iterator<PageInfo> iterator = stream.iterator();\n-      while (iterator.hasNext()) {\n-        PageInfo pageInfo = iterator.next();\n-        if (pageInfo == null) {\n-          LOG.error(\"Invalid page info\");\n-          return false;\n-        }\n-        metaStore.addPage(pageInfo.getPageId(), pageInfo);\n-        if (metaStore.bytes() > pageStore.getCacheSize()) {\n-          LOG.error(\"Loaded pages exceed cache capacity ({} bytes)\", pageStore.getCacheSize());\n-          return false;\n-        }\n-      }\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to restore PageStore\", e);\n-      return false;\n-    }\n-    LOG.info(\"Restored PageStore with {} existing pages and {} bytes\", metaStore.pages(),\n-        metaStore.bytes());\n-    return true;\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create(CacheEvictor.create(conf));\n+    PageStoreOptions options = PageStoreOptions.create(conf);\n+    PageStore pageStore = PageStore.create(options);\n+    return create(conf, metaStore, pageStore, options);\n   }\n \n   /**\n    * @param conf the Alluxio configuration\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   * @param options page store options\n    * @return an instance of {@link LocalCacheManager}\n    */\n-  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n-    MetaStore metaStore = MetaStore.create(CacheEvictor.create(conf));\n-    PageStoreOptions options = PageStoreOptions.create(conf);\n-    PageStore pageStore = null;\n-    boolean restored = false;\n-    try {\n-      pageStore = PageStore.create(options, false);\n-      restored = restore(pageStore, options, metaStore);\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to restore PageStore\", e);\n-    }\n-    if (!restored) {\n-      if (pageStore != null) {\n-        try {\n-          pageStore.close();\n-        } catch (Exception e) {\n-          LOG.error(\"Failed to close PageStore\", e);\n-        }\n-      }\n-      metaStore.reset();\n-      pageStore = PageStore.create(options, true);\n+  @VisibleForTesting\n+  static LocalCacheManager create(AlluxioConfiguration conf, MetaStore metaStore,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NTEzNQ=="}, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTUwMzczOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjozMjowOFrOHRuQlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo0NjoyMFrOHSf4Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NTc0OQ==", "bodyText": "If restoreOrInit hasn't completed, is it safe for get calls? Will there be some objects which could be null?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r488345749", "createdAt": "2020-09-15T02:32:08Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -18,7 +18,35 @@\n /**\n  * Interface for managing cached pages.\n  */\n-public interface CacheManager extends AutoCloseable  {\n+public interface CacheManager extends AutoCloseable {\n+\n+  /**\n+   * State of a cache.\n+   */\n+  enum State {\n+    /**\n+     * this cache is read only.\n+     */\n+    READ_ONLY(0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1ODczOA==", "bodyText": "protected by locks", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489158738", "createdAt": "2020-09-16T04:46:20Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -18,7 +18,35 @@\n /**\n  * Interface for managing cached pages.\n  */\n-public interface CacheManager extends AutoCloseable  {\n+public interface CacheManager extends AutoCloseable {\n+\n+  /**\n+   * State of a cache.\n+   */\n+  enum State {\n+    /**\n+     * this cache is read only.\n+     */\n+    READ_ONLY(0),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0NTc0OQ=="}, "originalCommit": {"oid": "73d9ad510e0647bba18112f038baab9b03bd6f82"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDU3NjEyOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMjoyMzo1OFrOHTGPUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwNTo1MjozMlrOHTSaNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NzIxOA==", "bodyText": "Should this be -1, 0, and 1?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489787218", "createdAt": "2020-09-16T22:23:58Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -938,6 +956,12 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(false)\n           .build();\n+  public static final MetricKey CLIENT_CACHE_STATE =\n+      new Builder(Name.CLIENT_CACHE_STATE)\n+          .setDescription(\"State of the cache: 0 (NOT_IN_USE), 1 (READ_ONLY) and 2 (READ_WRITE)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d05cde3ad3652f40a7421c5a0637db9094f571c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5MDcxMw==", "bodyText": "I feel 0,1,2 is more friendly for monitoring? my would go with 0, 1, 2", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489790713", "createdAt": "2020-09-16T22:33:25Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -938,6 +956,12 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(false)\n           .build();\n+  public static final MetricKey CLIENT_CACHE_STATE =\n+      new Builder(Name.CLIENT_CACHE_STATE)\n+          .setDescription(\"State of the cache: 0 (NOT_IN_USE), 1 (READ_ONLY) and 2 (READ_WRITE)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NzIxOA=="}, "originalCommit": {"oid": "d05cde3ad3652f40a7421c5a0637db9094f571c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyMzc5NA==", "bodyText": "Yeah I agree, but is that how the value works in the code, doesn't the Metric.STATE counter initialize at 0?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489823794", "createdAt": "2020-09-17T00:22:35Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -938,6 +956,12 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(false)\n           .build();\n+  public static final MetricKey CLIENT_CACHE_STATE =\n+      new Builder(Name.CLIENT_CACHE_STATE)\n+          .setDescription(\"State of the cache: 0 (NOT_IN_USE), 1 (READ_ONLY) and 2 (READ_WRITE)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NzIxOA=="}, "originalCommit": {"oid": "d05cde3ad3652f40a7421c5a0637db9094f571c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk4NjYxNQ==", "bodyText": "ah you are right. Let me update the state transition.", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r489986615", "createdAt": "2020-09-17T05:52:32Z", "author": {"login": "apc999"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -938,6 +956,12 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(false)\n           .build();\n+  public static final MetricKey CLIENT_CACHE_STATE =\n+      new Builder(Name.CLIENT_CACHE_STATE)\n+          .setDescription(\"State of the cache: 0 (NOT_IN_USE), 1 (READ_ONLY) and 2 (READ_WRITE)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NzIxOA=="}, "originalCommit": {"oid": "d05cde3ad3652f40a7421c5a0637db9094f571c2"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTAwNzM3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowNzozOFrOHTxMYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOToxNDoyMFrOHTxaiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5MDk3OA==", "bodyText": "Should this be return -1 not sure if this counts as error or page not found?", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r490490978", "createdAt": "2020-09-17T19:07:38Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -371,6 +358,11 @@ public int get(PageId pageId, int pageOffset, int bytesToRead, byte[] buffer,\n         \"buffer does not have enough space: bufferLength=%s offsetInBuffer=%s bytesToRead=%s\",\n         buffer.length, offsetInBuffer, bytesToRead);\n     LOG.debug(\"get({},pageOffset={}) enters\", pageId, pageOffset);\n+    if (mState.get() == NOT_IN_USE) {\n+      Metrics.GET_NOT_READY_ERRORS.inc();\n+      Metrics.GET_ERRORS.inc();\n+      return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7ddd0c4e53fa2cbc541833ab3b4b9a85ac5370a"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5NDYwMA==", "bodyText": "updated", "url": "https://github.com/Alluxio/alluxio/pull/12087#discussion_r490494600", "createdAt": "2020-09-17T19:14:20Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -371,6 +358,11 @@ public int get(PageId pageId, int pageOffset, int bytesToRead, byte[] buffer,\n         \"buffer does not have enough space: bufferLength=%s offsetInBuffer=%s bytesToRead=%s\",\n         buffer.length, offsetInBuffer, bytesToRead);\n     LOG.debug(\"get({},pageOffset={}) enters\", pageId, pageOffset);\n+    if (mState.get() == NOT_IN_USE) {\n+      Metrics.GET_NOT_READY_ERRORS.inc();\n+      Metrics.GET_ERRORS.inc();\n+      return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5MDk3OA=="}, "originalCommit": {"oid": "b7ddd0c4e53fa2cbc541833ab3b4b9a85ac5370a"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1166, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}