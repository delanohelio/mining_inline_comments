{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0NTcyMTI3", "number": 11304, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1MzowNVrODyq7Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTo0OFrODzhSvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDU4Njk1OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1MzowNVrOGG2vFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1MzowNVrOGG2vFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0MTQyOQ==", "bodyText": "Property keys are part of the stable API, add an alias for the old ones.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409841429", "createdAt": "2020-04-16T20:53:05Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3419,113 +3412,178 @@ public String toString() {\n               + \"aggregated, so different applications must set their own ids or leave this value \"\n               + \"unset to use a randomly generated id.\")\n           .build();\n-  public static final PropertyKey USER_NETWORK_DATA_TIMEOUT_MS =\n-      new Builder(Name.USER_NETWORK_DATA_TIMEOUT_MS)\n+  public static final PropertyKey USER_STREAMING_DATA_TIMEOUT_MS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDU4OTI3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1Mzo0OFrOGG2wmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1Mzo0OFrOGG2wmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0MTgxOQ==", "bodyText": "Suffix with Rpc to be consistent?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409841819", "createdAt": "2020-04-16T20:53:48Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java", "diffHunk": "@@ -94,12 +88,18 @@ public DefaultBlockWorkerClient(UserState userState, GrpcServerAddress address,\n       try {\n         // Disables channel pooling for data streaming to achieve better throughput.\n         // Channel is still reused due to client pooling.\n-        mStreamingChannel = buildChannel(userState.getSubject(), address,\n-            GrpcChannelKey.MultiplexGroup.STREAMING, alluxioConf, workerGroup);\n+        mStreamingChannel = GrpcChannelBuilder.newBuilder(address, alluxioConf)\n+            .setSubject(userState.getSubject())\n+            .setNetworkGroup(GrpcChannelKey.NetworkGroup.STREAMING)\n+            .setClientType(\"DefaultBlockWorkerClient-Stream\")\n+            .build();\n         mStreamingChannel.intercept(new StreamSerializationClientInterceptor());\n         // Uses default pooling strategy for RPC calls for better scalability.\n-        mRpcChannel = buildChannel(userState.getSubject(), address,\n-            GrpcChannelKey.MultiplexGroup.DEFAULT, alluxioConf, workerGroup);\n+        mRpcChannel = GrpcChannelBuilder.newBuilder(address, alluxioConf)\n+            .setSubject(userState.getSubject())\n+            .setNetworkGroup(GrpcChannelKey.NetworkGroup.DEFAULT)\n+            .setClientType(\"DefaultBlockWorkerClient\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDYwMTc0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1NzozN1rOGG24Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMDo1NzozN1rOGG24Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0Mzc4Mw==", "bodyText": "We are moving away from explicit time units in the property key", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409843783", "createdAt": "2020-04-16T20:57:37Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java", "diffHunk": "@@ -118,7 +118,7 @@ public DefaultBlockWorkerClient(UserState userState, GrpcServerAddress address,\n     mRpcBlockingStub = BlockWorkerGrpc.newBlockingStub(mRpcChannel);\n     mRpcAsyncStub = BlockWorkerGrpc.newStub(mRpcChannel);\n     mAddress = address;\n-    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDYxMzY4OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTowMDo1OVrOGG2_Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMjo1MToyM1rOGG57eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0NTU4Nw==", "bodyText": "These two are always the same?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409845587", "createdAt": "2020-04-16T21:00:59Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnection.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+\n+import io.grpc.Channel;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ClientInterceptors;\n+import io.grpc.ManagedChannel;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Used to gather gRPC level resources and indexes together.\n+ */\n+public class GrpcConnection implements AutoCloseable {\n+\n+  private GrpcConnectionKey mKey;\n+  private ManagedChannel mManagedChannel;\n+  private Channel mChannel;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5Mzc1Mg==", "bodyText": "ManagedChannel is the original netty side channel.\nChannel is usually that channel wrapped with different interceptors. For example; each logical channel need to inject its own channel-id so they have their own interceptors. So we keep wrapping this channel until it has the final logical state we want.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409893752", "createdAt": "2020-04-16T22:51:23Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnection.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+\n+import io.grpc.Channel;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ClientInterceptors;\n+import io.grpc.ManagedChannel;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Used to gather gRPC level resources and indexes together.\n+ */\n+public class GrpcConnection implements AutoCloseable {\n+\n+  private GrpcConnectionKey mKey;\n+  private ManagedChannel mManagedChannel;\n+  private Channel mChannel;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0NTU4Nw=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDYyMDIzOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTowMzoxOFrOGG3DmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTowMzoxOFrOGG3DmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0NjY4MA==", "bodyText": "Can this be static final and initialized in line?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409846680", "createdAt": "2020-04-16T21:03:18Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDYyNTczOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTowNDo1NVrOGG3HCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1NToyMFrOGHXrCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0NzU2Mw==", "bodyText": "Instead of shutting down here, should we let other users of the channel eventually fail and only shutdown after the refcount is zero?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409847563", "createdAt": "2020-04-16T21:04:55Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5MjM1Nw==", "bodyText": "Though what would happen to the one that figured out the health issue?\n\nAssign a new group id and retry?\n\nWhat if max connection is 1, so we keep retrying on the same channel?\n\n\nBlock this one until other clients are failed released the connection?\n\nThis could never happen as they will be cached in pools and may not be used for a long time.\nSo this block could take at least as long as pool GC interval. (We can implement GrpcConnectionLister interface that is used to synchronously let them owners know)", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409892357", "createdAt": "2020-04-16T22:47:53Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0NzU2Mw=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MTA2NA==", "bodyText": "Oh I see, we cannot replace the value in the map because the other users don't have a direct reference to the channel.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r410381064", "createdAt": "2020-04-17T17:55:20Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0NzU2Mw=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDYzMTM3OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMTowNjo0NlrOGG3KiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMjo0MjowM1rOGG5tew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0ODQ1Nw==", "bodyText": "Is ref protected by the concurrency guarantees provided by the concurrenthashmap?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409848457", "createdAt": "2020-04-16T21:06:46Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);\n+          }\n+\n+          // Create a new managed channel.\n+          LOG.debug(\"Creating a new managed channel. ConnectionKey: {}. Ref-count:{}\", key,\n+              existingRefCount);\n+          ManagedChannel managedChannel = createManagedChannel(channelKey, conf);\n+          // Set map reference.\n+          return new CountingReference(managedChannel, existingRefCount).reference();\n+        });\n+\n+    // Wrap connection reference and the connection.\n+    return new GrpcConnection(connectionKey, connectionRef.get(), conf);\n+  }\n+\n+  /**\n+   * Decreases the ref-count of the {@link ManagedChannel} for the given address. It shuts down the\n+   * underlying channel if reference count reaches zero.\n+   *\n+   * @param connectionKey the connection key\n+   * @param conf the Alluxio configuration\n+   */\n+  public void releaseConnection(GrpcConnectionKey connectionKey, AlluxioConfiguration conf) {\n+    mChannels.compute(connectionKey, (key, ref) -> {\n+      Preconditions.checkNotNull(ref, \"Cannot release nonexistent connection\");\n+      LOG.debug(\"Releasing connection for: {}. Ref-count: {}\", key, ref.getRefCount());\n+      // Shutdown managed channel.\n+      if (ref.dereference() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5MDE3MQ==", "bodyText": "Correct.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409890171", "createdAt": "2020-04-16T22:42:03Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);\n+          }\n+\n+          // Create a new managed channel.\n+          LOG.debug(\"Creating a new managed channel. ConnectionKey: {}. Ref-count:{}\", key,\n+              existingRefCount);\n+          ManagedChannel managedChannel = createManagedChannel(channelKey, conf);\n+          // Set map reference.\n+          return new CountingReference(managedChannel, existingRefCount).reference();\n+        });\n+\n+    // Wrap connection reference and the connection.\n+    return new GrpcConnection(connectionKey, connectionRef.get(), conf);\n+  }\n+\n+  /**\n+   * Decreases the ref-count of the {@link ManagedChannel} for the given address. It shuts down the\n+   * underlying channel if reference count reaches zero.\n+   *\n+   * @param connectionKey the connection key\n+   * @param conf the Alluxio configuration\n+   */\n+  public void releaseConnection(GrpcConnectionKey connectionKey, AlluxioConfiguration conf) {\n+    mChannels.compute(connectionKey, (key, ref) -> {\n+      Preconditions.checkNotNull(ref, \"Cannot release nonexistent connection\");\n+      LOG.debug(\"Releasing connection for: {}. Ref-count: {}\", key, ref.getRefCount());\n+      // Shutdown managed channel.\n+      if (ref.dereference() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0ODQ1Nw=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY0NjQ4OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxMToxMFrOGG3Tuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxMToxMFrOGG3Tuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1MDgxMQ==", "bodyText": "Return the channel builder here?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409850811", "createdAt": "2020-04-16T21:11:10Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);\n+          }\n+\n+          // Create a new managed channel.\n+          LOG.debug(\"Creating a new managed channel. ConnectionKey: {}. Ref-count:{}\", key,\n+              existingRefCount);\n+          ManagedChannel managedChannel = createManagedChannel(channelKey, conf);\n+          // Set map reference.\n+          return new CountingReference(managedChannel, existingRefCount).reference();\n+        });\n+\n+    // Wrap connection reference and the connection.\n+    return new GrpcConnection(connectionKey, connectionRef.get(), conf);\n+  }\n+\n+  /**\n+   * Decreases the ref-count of the {@link ManagedChannel} for the given address. It shuts down the\n+   * underlying channel if reference count reaches zero.\n+   *\n+   * @param connectionKey the connection key\n+   * @param conf the Alluxio configuration\n+   */\n+  public void releaseConnection(GrpcConnectionKey connectionKey, AlluxioConfiguration conf) {\n+    mChannels.compute(connectionKey, (key, ref) -> {\n+      Preconditions.checkNotNull(ref, \"Cannot release nonexistent connection\");\n+      LOG.debug(\"Releasing connection for: {}. Ref-count: {}\", key, ref.getRefCount());\n+      // Shutdown managed channel.\n+      if (ref.dereference() == 0) {\n+        LOG.debug(\"Shutting down connection after: {}\", connectionKey);\n+        shutdownManagedChannel(ref.get(), conf);\n+        // Release the event-loop for the connection.\n+        releaseNetworkEventLoop(connectionKey.getChannelKey());\n+        return null;\n+      }\n+      return ref;\n+    });\n+  }\n+\n+  private GrpcConnectionKey getConnectionKey(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Assign index within the network group.\n+    long groupIndex = mNetworkGroupCounters.get(channelKey.getNetworkGroup()).incrementAndGet();\n+    switch (channelKey.getNetworkGroup()) {\n+      case DEFAULT:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_DEFAULT_MAX_CONNECTIONS);\n+        break;\n+      case STREAMING:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_STREAMING_DEFAULT_MAX_CONNECTIONS);\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            String.format(\"Unrecognized network group: %s\", channelKey.getNetworkGroup()));\n+    }\n+\n+    return new GrpcConnectionKey(channelKey, (int) groupIndex);\n+  }\n+\n+  /**\n+   * Creates a {@link ManagedChannel} by given pool key.\n+   */\n+  private ManagedChannel createManagedChannel(GrpcChannelKey channelKey,\n+      AlluxioConfiguration conf) {\n+    // Create netty channel builder with the address from channel key.\n+    NettyChannelBuilder channelBuilder;\n+    SocketAddress address = channelKey.getServerAddress().getSocketAddress();\n+    if (address instanceof InetSocketAddress) {\n+      InetSocketAddress inetServerAddress = (InetSocketAddress) address;\n+      // This constructor delays DNS lookup to detect changes\n+      channelBuilder = NettyChannelBuilder.forAddress(inetServerAddress.getHostName(),\n+          inetServerAddress.getPort());\n+    } else {\n+      channelBuilder = NettyChannelBuilder.forAddress(address);\n+    }\n+    // Apply default channel options for the multiplex group.\n+    applyGroupDefaults(channelKey, channelBuilder, conf);\n+    // Build netty managed channel.\n+    return channelBuilder.build();\n+  }\n+\n+  private void applyGroupDefaults(GrpcChannelKey key, NettyChannelBuilder channelBuilder,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDY0OTM3OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMToxMjoxMFrOGG3VkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMjo0NDoxMVrOGG5wlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1MTI4MA==", "bodyText": "Is there any additional action we can take here?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409851280", "createdAt": "2020-04-16T21:12:10Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);\n+          }\n+\n+          // Create a new managed channel.\n+          LOG.debug(\"Creating a new managed channel. ConnectionKey: {}. Ref-count:{}\", key,\n+              existingRefCount);\n+          ManagedChannel managedChannel = createManagedChannel(channelKey, conf);\n+          // Set map reference.\n+          return new CountingReference(managedChannel, existingRefCount).reference();\n+        });\n+\n+    // Wrap connection reference and the connection.\n+    return new GrpcConnection(connectionKey, connectionRef.get(), conf);\n+  }\n+\n+  /**\n+   * Decreases the ref-count of the {@link ManagedChannel} for the given address. It shuts down the\n+   * underlying channel if reference count reaches zero.\n+   *\n+   * @param connectionKey the connection key\n+   * @param conf the Alluxio configuration\n+   */\n+  public void releaseConnection(GrpcConnectionKey connectionKey, AlluxioConfiguration conf) {\n+    mChannels.compute(connectionKey, (key, ref) -> {\n+      Preconditions.checkNotNull(ref, \"Cannot release nonexistent connection\");\n+      LOG.debug(\"Releasing connection for: {}. Ref-count: {}\", key, ref.getRefCount());\n+      // Shutdown managed channel.\n+      if (ref.dereference() == 0) {\n+        LOG.debug(\"Shutting down connection after: {}\", connectionKey);\n+        shutdownManagedChannel(ref.get(), conf);\n+        // Release the event-loop for the connection.\n+        releaseNetworkEventLoop(connectionKey.getChannelKey());\n+        return null;\n+      }\n+      return ref;\n+    });\n+  }\n+\n+  private GrpcConnectionKey getConnectionKey(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Assign index within the network group.\n+    long groupIndex = mNetworkGroupCounters.get(channelKey.getNetworkGroup()).incrementAndGet();\n+    switch (channelKey.getNetworkGroup()) {\n+      case DEFAULT:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_DEFAULT_MAX_CONNECTIONS);\n+        break;\n+      case STREAMING:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_STREAMING_DEFAULT_MAX_CONNECTIONS);\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            String.format(\"Unrecognized network group: %s\", channelKey.getNetworkGroup()));\n+    }\n+\n+    return new GrpcConnectionKey(channelKey, (int) groupIndex);\n+  }\n+\n+  /**\n+   * Creates a {@link ManagedChannel} by given pool key.\n+   */\n+  private ManagedChannel createManagedChannel(GrpcChannelKey channelKey,\n+      AlluxioConfiguration conf) {\n+    // Create netty channel builder with the address from channel key.\n+    NettyChannelBuilder channelBuilder;\n+    SocketAddress address = channelKey.getServerAddress().getSocketAddress();\n+    if (address instanceof InetSocketAddress) {\n+      InetSocketAddress inetServerAddress = (InetSocketAddress) address;\n+      // This constructor delays DNS lookup to detect changes\n+      channelBuilder = NettyChannelBuilder.forAddress(inetServerAddress.getHostName(),\n+          inetServerAddress.getPort());\n+    } else {\n+      channelBuilder = NettyChannelBuilder.forAddress(address);\n+    }\n+    // Apply default channel options for the multiplex group.\n+    applyGroupDefaults(channelKey, channelBuilder, conf);\n+    // Build netty managed channel.\n+    return channelBuilder.build();\n+  }\n+\n+  private void applyGroupDefaults(GrpcChannelKey key, NettyChannelBuilder channelBuilder,\n+      AlluxioConfiguration conf) {\n+    long keepAliveTimeMs = conf.getMs(PropertyKey.Template.USER_NETWORK_KEEPALIVE_TIME_MS\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    long keepAliveTimeoutMs = conf.getMs(PropertyKey.Template.USER_NETWORK_KEEPALIVE_TIMEOUT_MS\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    long inboundMessageSizeBytes =\n+        conf.getBytes(PropertyKey.Template.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE\n+            .format(key.getNetworkGroup().getPropertyCode()));\n+    long flowControlWindow = conf.getBytes(PropertyKey.Template.USER_NETWORK_FLOWCONTROL_WINDOW\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    Class<? extends Channel> channelType = NettyUtils.getChannelClass(\n+        !(key.getServerAddress().getSocketAddress() instanceof InetSocketAddress),\n+        PropertyKey.Template.USER_NETWORK_NETTY_CHANNEL\n+            .format(key.getNetworkGroup().getPropertyCode()),\n+        conf);\n+    EventLoopGroup eventLoopGroup = acquireNetworkEventLoop(key, conf);\n+\n+    // Update the builder.\n+    channelBuilder.keepAliveTime(keepAliveTimeMs, TimeUnit.MILLISECONDS);\n+    channelBuilder.keepAliveTimeout(keepAliveTimeoutMs, TimeUnit.MILLISECONDS);\n+    channelBuilder.maxInboundMetadataSize((int) inboundMessageSizeBytes);\n+    channelBuilder.flowControlWindow((int) flowControlWindow);\n+    channelBuilder.channelType(channelType);\n+    channelBuilder.eventLoopGroup(eventLoopGroup);\n+    // Use plaintext\n+    channelBuilder.usePlaintext();\n+  }\n+\n+  /**\n+   * Returns {@code true} if given managed channel is ready.\n+   */\n+  private boolean waitForConnectionReady(ManagedChannel managedChannel, AlluxioConfiguration conf) {\n+    long healthCheckTimeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_HEALTH_CHECK_TIMEOUT);\n+    try {\n+      Boolean res = CommonUtils.waitForResult(\"channel to be ready\", () -> {\n+        ConnectivityState currentState = managedChannel.getState(true);\n+        switch (currentState) {\n+          case READY:\n+            return true;\n+          case TRANSIENT_FAILURE:\n+          case SHUTDOWN:\n+            return false;\n+          case IDLE:\n+          case CONNECTING:\n+            return null;\n+          default:\n+            return null;\n+        }\n+      }, (b) -> b != null, WaitForOptions.defaults().setTimeoutMs((int) healthCheckTimeoutMs));\n+      return res;\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    } catch (TimeoutException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Tries to gracefully shut down the managed channel. If falls back to forceful shutdown if\n+   * graceful shutdown times out.\n+   */\n+  private void shutdownManagedChannel(ManagedChannel managedChannel, AlluxioConfiguration conf) {\n+    // Close the gRPC managed-channel if not shut down already.\n+    if (!managedChannel.isShutdown()) {\n+      long gracefulTimeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_SHUTDOWN_GRACEFUL_TIMEOUT);\n+      managedChannel.shutdown();\n+      try {\n+        if (!managedChannel.awaitTermination(gracefulTimeoutMs, TimeUnit.MILLISECONDS)) {\n+          LOG.warn(\"Timed out gracefully shutting down connection: {}. \", managedChannel);\n+        }\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        // Allow thread to exit.\n+      }\n+    }\n+    // Forceful shut down if still not terminated.\n+    if (!managedChannel.isTerminated()) {\n+      long timeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_SHUTDOWN_TIMEOUT);\n+\n+      managedChannel.shutdownNow();\n+      try {\n+        if (!managedChannel.awaitTermination(timeoutMs, TimeUnit.MILLISECONDS)) {\n+          LOG.warn(\"Timed out forcefully shutting down connection: {}. \", managedChannel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5MDk2NQ==", "bodyText": "Not really.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409890965", "createdAt": "2020-04-16T22:44:11Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  private static GrpcConnectionPool sInstance;\n+\n+  static {\n+    sInstance = new GrpcConnectionPool();\n+  }\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * @return the singleton pool instance\n+   */\n+  public static GrpcConnectionPool INSTANCE() {\n+    return sInstance;\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);\n+          }\n+\n+          // Create a new managed channel.\n+          LOG.debug(\"Creating a new managed channel. ConnectionKey: {}. Ref-count:{}\", key,\n+              existingRefCount);\n+          ManagedChannel managedChannel = createManagedChannel(channelKey, conf);\n+          // Set map reference.\n+          return new CountingReference(managedChannel, existingRefCount).reference();\n+        });\n+\n+    // Wrap connection reference and the connection.\n+    return new GrpcConnection(connectionKey, connectionRef.get(), conf);\n+  }\n+\n+  /**\n+   * Decreases the ref-count of the {@link ManagedChannel} for the given address. It shuts down the\n+   * underlying channel if reference count reaches zero.\n+   *\n+   * @param connectionKey the connection key\n+   * @param conf the Alluxio configuration\n+   */\n+  public void releaseConnection(GrpcConnectionKey connectionKey, AlluxioConfiguration conf) {\n+    mChannels.compute(connectionKey, (key, ref) -> {\n+      Preconditions.checkNotNull(ref, \"Cannot release nonexistent connection\");\n+      LOG.debug(\"Releasing connection for: {}. Ref-count: {}\", key, ref.getRefCount());\n+      // Shutdown managed channel.\n+      if (ref.dereference() == 0) {\n+        LOG.debug(\"Shutting down connection after: {}\", connectionKey);\n+        shutdownManagedChannel(ref.get(), conf);\n+        // Release the event-loop for the connection.\n+        releaseNetworkEventLoop(connectionKey.getChannelKey());\n+        return null;\n+      }\n+      return ref;\n+    });\n+  }\n+\n+  private GrpcConnectionKey getConnectionKey(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Assign index within the network group.\n+    long groupIndex = mNetworkGroupCounters.get(channelKey.getNetworkGroup()).incrementAndGet();\n+    switch (channelKey.getNetworkGroup()) {\n+      case DEFAULT:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_DEFAULT_MAX_CONNECTIONS);\n+        break;\n+      case STREAMING:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_STREAMING_DEFAULT_MAX_CONNECTIONS);\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            String.format(\"Unrecognized network group: %s\", channelKey.getNetworkGroup()));\n+    }\n+\n+    return new GrpcConnectionKey(channelKey, (int) groupIndex);\n+  }\n+\n+  /**\n+   * Creates a {@link ManagedChannel} by given pool key.\n+   */\n+  private ManagedChannel createManagedChannel(GrpcChannelKey channelKey,\n+      AlluxioConfiguration conf) {\n+    // Create netty channel builder with the address from channel key.\n+    NettyChannelBuilder channelBuilder;\n+    SocketAddress address = channelKey.getServerAddress().getSocketAddress();\n+    if (address instanceof InetSocketAddress) {\n+      InetSocketAddress inetServerAddress = (InetSocketAddress) address;\n+      // This constructor delays DNS lookup to detect changes\n+      channelBuilder = NettyChannelBuilder.forAddress(inetServerAddress.getHostName(),\n+          inetServerAddress.getPort());\n+    } else {\n+      channelBuilder = NettyChannelBuilder.forAddress(address);\n+    }\n+    // Apply default channel options for the multiplex group.\n+    applyGroupDefaults(channelKey, channelBuilder, conf);\n+    // Build netty managed channel.\n+    return channelBuilder.build();\n+  }\n+\n+  private void applyGroupDefaults(GrpcChannelKey key, NettyChannelBuilder channelBuilder,\n+      AlluxioConfiguration conf) {\n+    long keepAliveTimeMs = conf.getMs(PropertyKey.Template.USER_NETWORK_KEEPALIVE_TIME_MS\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    long keepAliveTimeoutMs = conf.getMs(PropertyKey.Template.USER_NETWORK_KEEPALIVE_TIMEOUT_MS\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    long inboundMessageSizeBytes =\n+        conf.getBytes(PropertyKey.Template.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE\n+            .format(key.getNetworkGroup().getPropertyCode()));\n+    long flowControlWindow = conf.getBytes(PropertyKey.Template.USER_NETWORK_FLOWCONTROL_WINDOW\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    Class<? extends Channel> channelType = NettyUtils.getChannelClass(\n+        !(key.getServerAddress().getSocketAddress() instanceof InetSocketAddress),\n+        PropertyKey.Template.USER_NETWORK_NETTY_CHANNEL\n+            .format(key.getNetworkGroup().getPropertyCode()),\n+        conf);\n+    EventLoopGroup eventLoopGroup = acquireNetworkEventLoop(key, conf);\n+\n+    // Update the builder.\n+    channelBuilder.keepAliveTime(keepAliveTimeMs, TimeUnit.MILLISECONDS);\n+    channelBuilder.keepAliveTimeout(keepAliveTimeoutMs, TimeUnit.MILLISECONDS);\n+    channelBuilder.maxInboundMetadataSize((int) inboundMessageSizeBytes);\n+    channelBuilder.flowControlWindow((int) flowControlWindow);\n+    channelBuilder.channelType(channelType);\n+    channelBuilder.eventLoopGroup(eventLoopGroup);\n+    // Use plaintext\n+    channelBuilder.usePlaintext();\n+  }\n+\n+  /**\n+   * Returns {@code true} if given managed channel is ready.\n+   */\n+  private boolean waitForConnectionReady(ManagedChannel managedChannel, AlluxioConfiguration conf) {\n+    long healthCheckTimeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_HEALTH_CHECK_TIMEOUT);\n+    try {\n+      Boolean res = CommonUtils.waitForResult(\"channel to be ready\", () -> {\n+        ConnectivityState currentState = managedChannel.getState(true);\n+        switch (currentState) {\n+          case READY:\n+            return true;\n+          case TRANSIENT_FAILURE:\n+          case SHUTDOWN:\n+            return false;\n+          case IDLE:\n+          case CONNECTING:\n+            return null;\n+          default:\n+            return null;\n+        }\n+      }, (b) -> b != null, WaitForOptions.defaults().setTimeoutMs((int) healthCheckTimeoutMs));\n+      return res;\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    } catch (TimeoutException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Tries to gracefully shut down the managed channel. If falls back to forceful shutdown if\n+   * graceful shutdown times out.\n+   */\n+  private void shutdownManagedChannel(ManagedChannel managedChannel, AlluxioConfiguration conf) {\n+    // Close the gRPC managed-channel if not shut down already.\n+    if (!managedChannel.isShutdown()) {\n+      long gracefulTimeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_SHUTDOWN_GRACEFUL_TIMEOUT);\n+      managedChannel.shutdown();\n+      try {\n+        if (!managedChannel.awaitTermination(gracefulTimeoutMs, TimeUnit.MILLISECONDS)) {\n+          LOG.warn(\"Timed out gracefully shutting down connection: {}. \", managedChannel);\n+        }\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        // Allow thread to exit.\n+      }\n+    }\n+    // Forceful shut down if still not terminated.\n+    if (!managedChannel.isTerminated()) {\n+      long timeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_SHUTDOWN_TIMEOUT);\n+\n+      managedChannel.shutdownNow();\n+      try {\n+        if (!managedChannel.awaitTermination(timeoutMs, TimeUnit.MILLISECONDS)) {\n+          LOG.warn(\"Timed out forcefully shutting down connection: {}. \", managedChannel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg1MTI4MA=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDg3MjI2OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/RemovedKey.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMjozMDoyOFrOGG5ckQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzo0Nzo1N1rOGG7EDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4NTg0MQ==", "bodyText": "is this intended?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409885841", "createdAt": "2020-04-16T22:30:28Z", "author": {"login": "madanadit"}, "path": "core/common/src/main/java/alluxio/conf/RemovedKey.java", "diffHunk": "@@ -114,7 +114,7 @@ private static String replacedSince(String version, String newProperty) {\n       put(\"alluxio.user.network.netty.reader.buffer.size.packets\", removedSince(V2_0_0));\n       put(\"alluxio.user.network.netty.reader.packet.size.bytes\", removedSince(V2_0_0));\n       put(\"alluxio.user.network.netty.timeout\", replacedSince(V2_0_0,\n-          PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS.getName()));\n+          PropertyKey.USER_STREAMING_DATA_TIMEOUT_MS.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwMTQzMQ==", "bodyText": "Should I make it V2_2_3 ?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409901431", "createdAt": "2020-04-16T23:13:22Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/conf/RemovedKey.java", "diffHunk": "@@ -114,7 +114,7 @@ private static String replacedSince(String version, String newProperty) {\n       put(\"alluxio.user.network.netty.reader.buffer.size.packets\", removedSince(V2_0_0));\n       put(\"alluxio.user.network.netty.reader.packet.size.bytes\", removedSince(V2_0_0));\n       put(\"alluxio.user.network.netty.timeout\", replacedSince(V2_0_0,\n-          PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS.getName()));\n+          PropertyKey.USER_STREAMING_DATA_TIMEOUT_MS.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4NTg0MQ=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMjMzMg==", "bodyText": "V2_3_0, this changes seems big enough to not go into a patch", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409912332", "createdAt": "2020-04-16T23:47:57Z", "author": {"login": "madanadit"}, "path": "core/common/src/main/java/alluxio/conf/RemovedKey.java", "diffHunk": "@@ -114,7 +114,7 @@ private static String replacedSince(String version, String newProperty) {\n       put(\"alluxio.user.network.netty.reader.buffer.size.packets\", removedSince(V2_0_0));\n       put(\"alluxio.user.network.netty.reader.packet.size.bytes\", removedSince(V2_0_0));\n       put(\"alluxio.user.network.netty.timeout\", replacedSince(V2_0_0,\n-          PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS.getName()));\n+          PropertyKey.USER_STREAMING_DATA_TIMEOUT_MS.getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4NTg0MQ=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NDkwMTQxOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMjo0MjoyN1rOGG5uDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNTozNzo0OFrOGHAi8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5MDMxOQ==", "bodyText": "why is this conversion necessary? maybe add a comment", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409890319", "createdAt": "2020-04-16T22:42:27Z", "author": {"login": "madanadit"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannel.java", "diffHunk": "@@ -106,7 +97,11 @@ public synchronized void shutdown() {\n       mAuthDriver = null;\n     }\n     if (!mChannelReleased) {\n-      GrpcManagedChannelPool.INSTANCE().releaseManagedChannel(mChannelKey, mShutdownTimeoutMs);\n+      try {\n+        mConnection.close();\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwMDgxMw==", "bodyText": "which conversion?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409900813", "createdAt": "2020-04-16T23:11:26Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannel.java", "diffHunk": "@@ -106,7 +97,11 @@ public synchronized void shutdown() {\n       mAuthDriver = null;\n     }\n     if (!mChannelReleased) {\n-      GrpcManagedChannelPool.INSTANCE().releaseManagedChannel(mChannelKey, mShutdownTimeoutMs);\n+      try {\n+        mConnection.close();\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5MDMxOQ=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwMjE2MQ==", "bodyText": "It boils down to what do we want to do with failed release attempts.\nI believe It's good to have an exception with a stack-trace at least until stabilized.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r410002161", "createdAt": "2020-04-17T05:37:48Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannel.java", "diffHunk": "@@ -106,7 +97,11 @@ public synchronized void shutdown() {\n       mAuthDriver = null;\n     }\n     if (!mChannelReleased) {\n-      GrpcManagedChannelPool.INSTANCE().releaseManagedChannel(mChannelKey, mShutdownTimeoutMs);\n+      try {\n+        mConnection.close();\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg5MDMxOQ=="}, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTAyMDMzOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzozNDoyNVrOGG6zug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzozNDoyNVrOGG6zug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwODE1NA==", "bodyText": "unused now", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409908154", "createdAt": "2020-04-16T23:34:25Z", "author": {"login": "madanadit"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -11,66 +11,42 @@\n \n package alluxio.grpc;\n \n-import alluxio.collections.Pair;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n import alluxio.util.network.NetworkAddressUtils;\n \n import com.google.common.base.MoreObjects;\n \n-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n-import io.netty.channel.Channel;\n-import io.netty.channel.EventLoopGroup;\n import org.apache.commons.lang.builder.HashCodeBuilder;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n import java.lang.reflect.Field;\n-import java.util.Optional;\n import java.util.Random;\n import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n \n /**\n  * Used to identify a unique {@link GrpcChannel}.\n  */\n public class GrpcChannelKey {\n   private static final Random RANDOM = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTAzNjk4OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzo0MjozM1rOGG69tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQyMzo0MjozM1rOGG69tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMDcxMQ==", "bodyText": "nt: expand on the network group index usage", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r409910711", "createdAt": "2020-04-16T23:42:33Z", "author": {"login": "madanadit"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionKey.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Used to define a key for {@link GrpcConnectionPool}.\n+ */\n+public class GrpcConnectionKey {\n+  private GrpcChannelKey mChannelKey;\n+  private int mGroupIndex;\n+\n+  /**\n+   * Creates a new gRPC connection key.\n+   *\n+   * @param channelKey the gRPC channel key\n+   * @param groupIndex the group index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "002836e125e9dc60fd17eaa451744152c65b92b4"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MTMzMzAxOnYy", "diffSide": "LEFT", "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNDowNDo0NVrOGHxxwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNzowODozNVrOGH6R3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODc2OQ==", "bodyText": "Is there a reason we're not making this configurable anymore?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r410808769", "createdAt": "2020-04-19T04:04:45Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java", "diffHunk": "@@ -54,16 +46,10 @@ private GrpcChannelBuilder(GrpcServerAddress address, AlluxioConfiguration conf)\n     // Read constants.\n     mAuthType =\n         mConfiguration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);\n-    mShutdownTimeoutMs =\n-        mConfiguration.getMs(PropertyKey.NETWORK_CONNECTION_SHUTDOWN_TIMEOUT);\n-    mHealthCheckTimeoutMs =\n-        mConfiguration.getMs(PropertyKey.NETWORK_CONNECTION_HEALTH_CHECK_TIMEOUT);\n \n     // Set default overrides for the channel.\n     mChannelKey = GrpcChannelKey.create(conf);\n     mChannelKey.setServerAddress(address);\n-    mChannelKey.setMaxInboundMessageSize(\n-        (int) mConfiguration.getBytes(PropertyKey.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873ab84a2538ae9926d4d65215fac0c5caa5ad1b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0ODA2Mg==", "bodyText": "It is configurable. Just not per channel but per connection. You can set different defaults to connections for streaming vs rpc.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r410948062", "createdAt": "2020-04-19T17:08:35Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java", "diffHunk": "@@ -54,16 +46,10 @@ private GrpcChannelBuilder(GrpcServerAddress address, AlluxioConfiguration conf)\n     // Read constants.\n     mAuthType =\n         mConfiguration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);\n-    mShutdownTimeoutMs =\n-        mConfiguration.getMs(PropertyKey.NETWORK_CONNECTION_SHUTDOWN_TIMEOUT);\n-    mHealthCheckTimeoutMs =\n-        mConfiguration.getMs(PropertyKey.NETWORK_CONNECTION_HEALTH_CHECK_TIMEOUT);\n \n     // Set default overrides for the channel.\n     mChannelKey = GrpcChannelKey.create(conf);\n     mChannelKey.setServerAddress(address);\n-    mChannelKey.setMaxInboundMessageSize(\n-        (int) mConfiguration.getBytes(PropertyKey.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODc2OQ=="}, "originalCommit": {"oid": "873ab84a2538ae9926d4d65215fac0c5caa5ad1b"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzQ5MTYyOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MDoyMlrOGIBEcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MDoyMlrOGIBEcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1OTMxMg==", "bodyText": "We can remove the ms suffix here.", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r411059312", "createdAt": "2020-04-20T02:50:22Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4873,8 +5052,24 @@ private static String javadocLink(String fullyQualifiedClassname) {\n     public static final String USER_METRICS_HEARTBEAT_INTERVAL_MS =\n         \"alluxio.user.metrics.heartbeat.interval\";\n     public static final String USER_APP_ID = \"alluxio.user.app.id\";\n-    public static final String USER_STREAMING_DATA_TIMEOUT_MS =\n+    public static final String USER_NETWORK_DATA_TIMEOUT_MS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af4e40460056ddbcf529817c75f134fac3e5de86"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzQ5Mjg1OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTowMFrOGIBFGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTowMFrOGIBFGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1OTQ4Mg==", "bodyText": "We can remove the ms suffix in the variable name", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r411059482", "createdAt": "2020-04-20T02:51:00Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4873,8 +5052,24 @@ private static String javadocLink(String fullyQualifiedClassname) {\n     public static final String USER_METRICS_HEARTBEAT_INTERVAL_MS =\n         \"alluxio.user.metrics.heartbeat.interval\";\n     public static final String USER_APP_ID = \"alluxio.user.app.id\";\n-    public static final String USER_STREAMING_DATA_TIMEOUT_MS =\n+    public static final String USER_NETWORK_DATA_TIMEOUT_MS =\n         \"alluxio.user.network.data.timeout\";\n+    public static final String USER_NETWORK_READER_BUFFER_SIZE_MESSAGES =\n+        \"alluxio.user.network.reader.buffer.size.messages\";\n+    public static final String USER_NETWORK_READER_CHUNK_SIZE_BYTES =\n+        \"alluxio.user.network.reader.chunk.size.bytes\";\n+    public static final String USER_NETWORK_WRITER_BUFFER_SIZE_MESSAGES =\n+        \"alluxio.user.network.writer.buffer.size.messages\";\n+    public static final String USER_NETWORK_WRITER_CHUNK_SIZE_BYTES =\n+        \"alluxio.user.network.writer.chunk.size.bytes\";\n+    public static final String USER_NETWORK_WRITER_CLOSE_TIMEOUT_MS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af4e40460056ddbcf529817c75f134fac3e5de86"}, "originalPosition": 383}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzQ5NDA5OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTozOVrOGIBFyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTozOVrOGIBFyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1OTY1Ng==", "bodyText": "Does this alias need to be propagated to the new property?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r411059656", "createdAt": "2020-04-20T02:51:39Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3463,62 +3468,230 @@ public String toString() {\n           .build();\n   public static final PropertyKey USER_STREAMING_WRITER_FLUSH_TIMEOUT =\n       new Builder(Name.USER_STREAMING_WRITER_FLUSH_TIMEOUT)\n+          .setAlias(Name.USER_NETWORK_WRITER_FLUSH_TIMEOUT)\n           .setDefaultValue(\"30min\")\n           .setDescription(\"The timeout to wait for flush to finish in a data writer.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.CLIENT)\n           .build();\n   public static final PropertyKey USER_STREAMING_ZEROCOPY_ENABLED =\n       new Builder(Name.USER_STREAMING_ZEROCOPY_ENABLED)\n+          .setAlias(Name.USER_NETWORK_ZEROCOPY_ENABLED)\n           .setDefaultValue(true)\n           .setDescription(\"Whether zero copy is enabled on client when processing data streams.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.CLIENT)\n           .build();\n-  public static final PropertyKey USER_NETWORK_RPC_FLOWCONTROL_WINDOW =\n-      new Builder(Name.USER_NETWORK_RPC_FLOWCONTROL_WINDOW)\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_DATA_TIMEOUT} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_DATA_TIMEOUT_MS =\n+      new Builder(Name.USER_NETWORK_DATA_TIMEOUT_MS)\n+          .setAlias(\"alluxio.user.network.data.timeout.ms\")\n+          .setDefaultValue(\"30sec\")\n+          .setDescription(\"The maximum time for an Alluxio client to wait for a data response \"\n+              + \"(e.g. block reads and block writes) from Alluxio worker.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_READER_BUFFER_SIZE_MESSAGES} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_READER_BUFFER_SIZE_MESSAGES =\n+      new Builder(Name.USER_NETWORK_READER_BUFFER_SIZE_MESSAGES)\n+          .setDefaultValue(16)\n+          .setDescription(\"When a client reads from a remote worker, the maximum number of \"\n+              + \"messages to buffer by the client. A message can be either a command response, \"\n+              + \"a data chunk, or a gRPC stream event such as complete or error.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_READER_CHUNK_SIZE_BYTES} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_READER_CHUNK_SIZE_BYTES =\n+      new Builder(Name.USER_NETWORK_READER_CHUNK_SIZE_BYTES)\n+          .setDefaultValue(\"1MB\")\n+          .setDescription(\"When a client reads from a remote worker, the maximum chunk size.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_WRITER_BUFFER_SIZE_MESSAGES} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_WRITER_BUFFER_SIZE_MESSAGES =\n+      new Builder(Name.USER_NETWORK_WRITER_BUFFER_SIZE_MESSAGES)\n+          .setDefaultValue(16)\n+          .setDescription(\"When a client writes to a remote worker, the maximum number of messages \"\n+              + \"to buffer by the client. A message can be either a command response, a data \"\n+              + \"chunk, or a gRPC stream event such as complete or error.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_WRITER_CHUNK_SIZE_BYTES} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_WRITER_CHUNK_SIZE_BYTES =\n+      new Builder(Name.USER_NETWORK_WRITER_CHUNK_SIZE_BYTES)\n+          .setDefaultValue(\"1MB\")\n+          .setDescription(\"When a client writes to a remote worker, the maximum chunk size.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n+          .setScope(Scope.CLIENT)\n+          .build();\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_WRITER_CLOSE_TIMEOUT_MS} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_WRITER_CLOSE_TIMEOUT_MS =\n+      new Builder(Name.USER_NETWORK_WRITER_CLOSE_TIMEOUT_MS)\n+          .setAlias(\"alluxio.user.network.writer.close.timeout.ms\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af4e40460056ddbcf529817c75f134fac3e5de86"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzQ5NDM4OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTo0OFrOGIBF8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo1MTo0OFrOGIBF8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1OTY5Ng==", "bodyText": "Does this alias need to be propagated to the new property?", "url": "https://github.com/Alluxio/alluxio/pull/11304#discussion_r411059696", "createdAt": "2020-04-20T02:51:48Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -3463,62 +3468,230 @@ public String toString() {\n           .build();\n   public static final PropertyKey USER_STREAMING_WRITER_FLUSH_TIMEOUT =\n       new Builder(Name.USER_STREAMING_WRITER_FLUSH_TIMEOUT)\n+          .setAlias(Name.USER_NETWORK_WRITER_FLUSH_TIMEOUT)\n           .setDefaultValue(\"30min\")\n           .setDescription(\"The timeout to wait for flush to finish in a data writer.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.CLIENT)\n           .build();\n   public static final PropertyKey USER_STREAMING_ZEROCOPY_ENABLED =\n       new Builder(Name.USER_STREAMING_ZEROCOPY_ENABLED)\n+          .setAlias(Name.USER_NETWORK_ZEROCOPY_ENABLED)\n           .setDefaultValue(true)\n           .setDescription(\"Whether zero copy is enabled on client when processing data streams.\")\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.CLIENT)\n           .build();\n-  public static final PropertyKey USER_NETWORK_RPC_FLOWCONTROL_WINDOW =\n-      new Builder(Name.USER_NETWORK_RPC_FLOWCONTROL_WINDOW)\n+  /**\n+   * @deprecated use {@link #USER_STREAMING_DATA_TIMEOUT} instead\n+   */\n+  @Deprecated\n+  public static final PropertyKey USER_NETWORK_DATA_TIMEOUT_MS =\n+      new Builder(Name.USER_NETWORK_DATA_TIMEOUT_MS)\n+          .setAlias(\"alluxio.user.network.data.timeout.ms\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af4e40460056ddbcf529817c75f134fac3e5de86"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1851, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}