{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2MDE2NzQ5", "number": 11579, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxOTowNlrOEG3L8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowNzozNlrOEG7aGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjMxMDkxOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxOTowNlrOGl69nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToyMDozN1rOGmAnXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw==", "bodyText": "Why is this renamed? mount info sounds like it is the info for a single mount, but mount table sounds like the entire mapping?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442416543", "createdAt": "2020-06-18T18:19:06Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "diffHunk": "@@ -234,7 +234,7 @@ long getNewBlockIdForFile(AlluxioURI path) throws FileDoesNotExistException, Inv\n   /**\n    * @return a copy of the current mount table\n    */\n-  Map<String, MountPointInfo>  getMountTable();\n+  Map<String, MountPointInfo>  getMountInfo();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMzY3Mg==", "bodyText": "I renamed it because I added another method which actually returns the MountTable object. I felt it was more apt to call that getMountTable. This was used by a few other places and I couldn't think of a good name. Since it wasn't the actual MountTable object I just settled on getMountInfo. I'm open to other ideas", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442433672", "createdAt": "2020-06-18T18:51:00Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "diffHunk": "@@ -234,7 +234,7 @@ long getNewBlockIdForFile(AlluxioURI path) throws FileDoesNotExistException, Inv\n   /**\n    * @return a copy of the current mount table\n    */\n-  Map<String, MountPointInfo>  getMountTable();\n+  Map<String, MountPointInfo>  getMountInfo();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwOTE1MA==", "bodyText": "Ah, I see it now. maybe getMountTableMap? or getMountInfoMap? Yeah, since it is not the actual mount table, this should not simply be getMountTable.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442509150", "createdAt": "2020-06-18T21:20:37Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "diffHunk": "@@ -234,7 +234,7 @@ long getNewBlockIdForFile(AlluxioURI path) throws FileDoesNotExistException, Inv\n   /**\n    * @return a copy of the current mount table\n    */\n-  Map<String, MountPointInfo>  getMountTable();\n+  Map<String, MountPointInfo>  getMountInfo();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjMxMzU4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxOTo1NlrOGl6_SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozMTozOVrOGmCS1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA==", "bodyText": "What about this test?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442416968", "createdAt": "2020-06-18T18:19:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MDA4Mg==", "bodyText": "I was trying to write a test which reproduced the issue consistently, but this one only reproduced it every 1/25 times or so...I can try adding more to make sure that it does reproduce the issue and that this change fixes it, but it might take me a bit longer - or we can just go without this test.\nWhat do you think?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442440082", "createdAt": "2020-06-18T19:02:36Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzYyOQ==", "bodyText": "Even with a much longer path? How long could the test take if it \"passes\"?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442507629", "createdAt": "2020-06-18T21:17:06Z", "author": {"login": "gpang"}, "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNjY2MQ==", "bodyText": "even with a longer path it failed to reproduce. To writing the actual test that fails (deadlocks) in the earlier code and not in the current code might take me a while to write.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442536661", "createdAt": "2020-06-18T22:31:39Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjM4Mzc1OnYy", "diffSide": "LEFT", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MTowN1rOGl7ruA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo1MTowN1rOGl8Avw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODM0NA==", "bodyText": "is this no longer necessary because everything is unlocked?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442428344", "createdAt": "2020-06-18T18:41:07Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -257,21 +293,18 @@ public boolean sync() {\n \n       // process the sync result for the original path\n       try {\n-        mRootPath.traverse();\n+        path.traverse();\n       } catch (InvalidPathException e) {\n         throw new RuntimeException(e);\n       }\n-    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+    } catch (BlockInfoException | FileAlreadyCompletedException\n         | FileDoesNotExistException | InterruptedException | InvalidFileSizeException\n-        | InvalidPathException | IOException e) {\n+        | IOException e) {\n       LogUtils.warnWithException(LOG, \"Failed to sync metadata on root path {}\",\n           toString(), e);\n     } finally {\n       // regardless of the outcome, remove the UfsStatus for this path from the cache\n-      mStatusCache.remove(mRootPath.getUri());\n-      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n-      // concurrent operations\n-      mRootPath.downgradeToRead();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMzcyNw==", "bodyText": "yes", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442433727", "createdAt": "2020-06-18T18:51:07Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -257,21 +293,18 @@ public boolean sync() {\n \n       // process the sync result for the original path\n       try {\n-        mRootPath.traverse();\n+        path.traverse();\n       } catch (InvalidPathException e) {\n         throw new RuntimeException(e);\n       }\n-    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+    } catch (BlockInfoException | FileAlreadyCompletedException\n         | FileDoesNotExistException | InterruptedException | InvalidFileSizeException\n-        | InvalidPathException | IOException e) {\n+        | IOException e) {\n       LogUtils.warnWithException(LOG, \"Failed to sync metadata on root path {}\",\n           toString(), e);\n     } finally {\n       // regardless of the outcome, remove the UfsStatus for this path from the cache\n-      mStatusCache.remove(mRootPath.getUri());\n-      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n-      // concurrent operations\n-      mRootPath.downgradeToRead();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODM0NA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjM4NTM4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MTozN1rOGl7sxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo1NjoyN1rOGl8MZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODYxMg==", "bodyText": "This will relock and recheck permissions? Can we add that to the comments of this method or class?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442428612", "createdAt": "2020-06-18T18:41:37Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -245,9 +269,21 @@ public boolean sync() {\n     if (LOG.isDebugEnabled()) {\n       start = System.currentTimeMillis();\n     }\n-\n-    try {\n-      syncInodeMetadata(mRootPath);\n+    try (LockedInodePath path = mInodeTree.lockInodePath(mRootScheme)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzNjcwOA==", "bodyText": "This will relock and recheck permissions\n\nThe permission check and locking were all moved into this block. The syncMetadata function in DFSM no longer does the lock and permission check", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442436708", "createdAt": "2020-06-18T18:56:27Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -245,9 +269,21 @@ public boolean sync() {\n     if (LOG.isDebugEnabled()) {\n       start = System.currentTimeMillis();\n     }\n-\n-    try {\n-      syncInodeMetadata(mRootPath);\n+    try (LockedInodePath path = mInodeTree.lockInodePath(mRootScheme)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODYxMg=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg5MTU4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToyMzo1NVrOGmAtZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToyMzo1NVrOGmAtZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY5NQ==", "bodyText": "NIT: I would avoid calling this a two-phase locking scheme, since \"two-phase locking\" is already a well-defined term. Maybe this can be a two-step locking scheme?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442510695", "createdAt": "2020-06-18T21:23:55Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg5Nzg5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToyNjowOFrOGmAxTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozMzoxNFrOGmCUvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTY5NA==", "bodyText": "This is the same comment as in getFileIdInternal right? Can we just have a simple comment here to point to that method for more details about load metadata? (same comment for list status)", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442511694", "createdAt": "2020-06-18T21:26:08Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzE0OQ==", "bodyText": "Yeah, I can make it so there's only one comment. I just wanted to be extra clear in where I was using it.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442537149", "createdAt": "2020-06-18T22:33:14Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTY5NA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njk5MTQwOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowMjo1NlrOGmBsUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoyNzozNFrOGmauEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA==", "bodyText": "Is there any chance this could run for more than 2 iterations?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442526800", "createdAt": "2020-06-18T22:02:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMjMzNA==", "bodyText": "Do you see a case where it could?\nI stepped through the logic myself to iron out as many errors as possible when writing it and when doing the tests.\nFor each of the implementations there are two flags\n\nrun\nloadMetadata\n\nIn the main body of the loop run is always immediately set false after entering the loop and is only set again within a conditional that contains if (!loadMetadata)\nWithin the conditional of if (!loadMetadata) we set run to true, but also set the loadMetadata flag to true, which means that we shouldn't enter the same conditional the 2nd time around to be able to set run to true again - preventing more than 2 iterations.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442722334", "createdAt": "2020-06-19T09:07:10Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczOTgxNg==", "bodyText": "If you have a better idea of how you would implement this logic I'm all ears. I'm sure there are ways it can be improved. This was the simplest thing I came up with.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442739816", "createdAt": "2020-06-19T09:42:58Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkzNjg1MQ==", "bodyText": "Yeah, after looking at it, it should be fine. The important part is that we have to make sure run is set to false in the beginning, and setting run=true can only happen when loadMetadata == false.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442936851", "createdAt": "2020-06-19T16:27:34Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njk5NDc0OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowNDowOVrOGmBuRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToyMjoxN1rOGmOETw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNzMwMg==", "bodyText": "the rpcs use shouldLoadMetadataIfNotExists to check to load metadata, but this method also calls shouldLoadMetadataIfNotExists again. Is that intentional, and why do we need to check again?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442527302", "createdAt": "2020-06-18T22:04:09Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -2518,12 +2592,32 @@ public UfsInfo getUfsInfo(long mountId) {\n    * Loads metadata for the path if it is (non-existing || load direct children is set).\n    *\n    * @param rpcContext the rpc context\n-   * @param inodePath the {@link LockedInodePath} to load the metadata for\n    * @param context the load metadata context\n    */\n-  private void loadMetadataIfNotExist(RpcContext rpcContext, LockedInodePath inodePath,\n-      LoadMetadataContext context, boolean isGetFileInfo) {\n-    Preconditions.checkState(inodePath.getLockPattern() == LockPattern.READ);\n+  private void loadMetadataIfNotExist(RpcContext rpcContext, AlluxioURI path,\n+      LoadMetadataContext context, boolean isGetFileInfo)\n+      throws InvalidPathException, AccessControlException {\n+    LockingScheme scheme = new LockingScheme(path, LockPattern.READ, false);\n+    boolean lm;\n+    try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+      lm = shouldLoadMetadataIfNotExists(inodePath, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTU1MQ==", "bodyText": "It was originally intentional because I was trying to preserve the old behavior, and it's possible that in between the original check and running this function the tree changed, so this can prevent us from loading the metadata unnecessarily\nBut I am thinking more about it now; the cost of the lock to perform this check vs the probability of the path being loaded since the last check outside this function is likely low, and so the cost of performing this lock vs the amount of CPU time it could save is likely going to do more harm than good. I'll remove it.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442729551", "createdAt": "2020-06-19T09:22:17Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -2518,12 +2592,32 @@ public UfsInfo getUfsInfo(long mountId) {\n    * Loads metadata for the path if it is (non-existing || load direct children is set).\n    *\n    * @param rpcContext the rpc context\n-   * @param inodePath the {@link LockedInodePath} to load the metadata for\n    * @param context the load metadata context\n    */\n-  private void loadMetadataIfNotExist(RpcContext rpcContext, LockedInodePath inodePath,\n-      LoadMetadataContext context, boolean isGetFileInfo) {\n-    Preconditions.checkState(inodePath.getLockPattern() == LockPattern.READ);\n+  private void loadMetadataIfNotExist(RpcContext rpcContext, AlluxioURI path,\n+      LoadMetadataContext context, boolean isGetFileInfo)\n+      throws InvalidPathException, AccessControlException {\n+    LockingScheme scheme = new LockingScheme(path, LockPattern.READ, false);\n+    boolean lm;\n+    try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+      lm = shouldLoadMetadataIfNotExists(inodePath, context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNzMwMg=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzAwMjQ5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowNzozNlrOGmBzNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTozOToyN1rOGmOlkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODU2NA==", "bodyText": "Is there a better message we can use, to help us debug or fix?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442528564", "createdAt": "2020-06-18T22:07:36Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      FileInfo ret = null;\n+      while (run) {\n+        run = false;\n+        if (loadMetadata) {\n+          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), path);\n+          loadMetadataIfNotExist(rpcContext, path, lmCtx, true);\n         }\n-        // If the file already exists, then metadata does not need to be loaded,\n-        // otherwise load metadata.\n-        if (!inodePath.fullPathExists()) {\n-          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n-          loadMetadataIfNotExist(rpcContext, inodePath, LoadMetadataContext.mergeFrom(\n-              LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n-                  FileSystemMasterCommonPOptions.newBuilder()\n-                      .setTtl(context.getOptions().getCommonOptions().getTtl())\n-                      .setTtlAction(context.getOptions().getCommonOptions().getTtlAction()))),\n-              true);\n+\n+        LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n+        try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n+          auditContext.setSrcInode(inodePath.getInodeOrNull());\n+          try {\n+            mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+          } catch (AccessControlException e) {\n+            auditContext.setAllowed(false);\n+            throw e;\n+          }\n+\n+          if (!loadMetadata && shouldLoadMetadataIfNotExists(inodePath, lmCtx)) {\n+            loadMetadata = true;\n+            run = true;\n+            continue;\n+          }\n+\n           ensureFullPathAndUpdateCache(inodePath);\n+\n+          FileInfo fileInfo = getFileInfoInternal(inodePath);\n+          Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n+          if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode()\n+              && (accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n+            mAccessTimeUpdater.updateAccessTime(rpcContext.getJournalContext(),\n+                inodePath.getInode(), opTimeMs);\n+          }\n+          auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n+          ret = fileInfo;\n         }\n-        FileInfo fileInfo = getFileInfoInternal(inodePath);\n-        Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n-        if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode() && (\n-            accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n-          mAccessTimeUpdater\n-              .updateAccessTime(rpcContext.getJournalContext(), inodePath.getInode(), opTimeMs);\n-        }\n-        auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n-        return fileInfo;\n       }\n+      return Preconditions.checkNotNull(ret,\n+          \"fileInfo returned should not be null. This is a bug.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczODA2Ng==", "bodyText": "Oh so, I guess IntelliJ became smart again - after looking at this code the IDE is reporting to me that \"ret is always non-null\" at this point (it didn't before). I guess I can remove this Precondition check.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442738066", "createdAt": "2020-06-19T09:39:27Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      FileInfo ret = null;\n+      while (run) {\n+        run = false;\n+        if (loadMetadata) {\n+          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), path);\n+          loadMetadataIfNotExist(rpcContext, path, lmCtx, true);\n         }\n-        // If the file already exists, then metadata does not need to be loaded,\n-        // otherwise load metadata.\n-        if (!inodePath.fullPathExists()) {\n-          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n-          loadMetadataIfNotExist(rpcContext, inodePath, LoadMetadataContext.mergeFrom(\n-              LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n-                  FileSystemMasterCommonPOptions.newBuilder()\n-                      .setTtl(context.getOptions().getCommonOptions().getTtl())\n-                      .setTtlAction(context.getOptions().getCommonOptions().getTtlAction()))),\n-              true);\n+\n+        LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n+        try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n+          auditContext.setSrcInode(inodePath.getInodeOrNull());\n+          try {\n+            mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+          } catch (AccessControlException e) {\n+            auditContext.setAllowed(false);\n+            throw e;\n+          }\n+\n+          if (!loadMetadata && shouldLoadMetadataIfNotExists(inodePath, lmCtx)) {\n+            loadMetadata = true;\n+            run = true;\n+            continue;\n+          }\n+\n           ensureFullPathAndUpdateCache(inodePath);\n+\n+          FileInfo fileInfo = getFileInfoInternal(inodePath);\n+          Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n+          if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode()\n+              && (accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n+            mAccessTimeUpdater.updateAccessTime(rpcContext.getJournalContext(),\n+                inodePath.getInode(), opTimeMs);\n+          }\n+          auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n+          ret = fileInfo;\n         }\n-        FileInfo fileInfo = getFileInfoInternal(inodePath);\n-        Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n-        if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode() && (\n-            accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n-          mAccessTimeUpdater\n-              .updateAccessTime(rpcContext.getJournalContext(), inodePath.getInode(), opTimeMs);\n-        }\n-        auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n-        return fileInfo;\n       }\n+      return Preconditions.checkNotNull(ret,\n+          \"fileInfo returned should not be null. This is a bug.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODU2NA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 161}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1654, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}