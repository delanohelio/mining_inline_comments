{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2Nzk4MzQ3", "number": 10933, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMDoyMjo1NVrODg1yww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDozMDowMVrODhufeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzYyMzcxOnYy", "diffSide": "RIGHT", "path": "shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMDoyMjo1NVrOFrRKbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMDo0MDoxMFrOFrXddw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNDI4Ng==", "bodyText": "nit: is there a reason to make this all caps?", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r380914286", "createdAt": "2020-02-18T20:22:55Z", "author": {"login": "ZacBlanco"}, "path": "shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java", "diffHunk": "@@ -74,8 +74,7 @@ public int run() throws IOException {\n           // Bytes long can be transformed to human-readable format\n           strValue = FormatUtils.getSizeFromBytes((long) doubleValue);\n           if (name.contains(THROUGHPUT_METRIC_IDENTIFIER)) {\n-            // throughput is calculated as one-minute exponentially-weighted moving average rate\n-            strValue = strValue + \"/min\";\n+            strValue = strValue + \"/SEC\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4ef6f3f00b6d7aa522317e7daab53f1c6e213b9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkyODI5NQ==", "bodyText": "Because FormatUtils.getSizeFromBytes() will return size in caps like B, MB, GB", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r380928295", "createdAt": "2020-02-18T20:53:18Z", "author": {"login": "LuQQiu"}, "path": "shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java", "diffHunk": "@@ -74,8 +74,7 @@ public int run() throws IOException {\n           // Bytes long can be transformed to human-readable format\n           strValue = FormatUtils.getSizeFromBytes((long) doubleValue);\n           if (name.contains(THROUGHPUT_METRIC_IDENTIFIER)) {\n-            // throughput is calculated as one-minute exponentially-weighted moving average rate\n-            strValue = strValue + \"/min\";\n+            strValue = strValue + \"/SEC\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNDI4Ng=="}, "originalCommit": {"oid": "a4ef6f3f00b6d7aa522317e7daab53f1c6e213b9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxNDgwNA==", "bodyText": "also, is every throughput metric at the sec granularity? Is that something we even want?\nI feel like there will be times when a cluster is not under a high load and many of the gauges will report as 0 - especially for people who scrape metrics on a periodic basis, second-level granularity seems like it would cause lots of information to be missed.", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r381014804", "createdAt": "2020-02-19T00:29:59Z", "author": {"login": "ZacBlanco"}, "path": "shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java", "diffHunk": "@@ -74,8 +74,7 @@ public int run() throws IOException {\n           // Bytes long can be transformed to human-readable format\n           strValue = FormatUtils.getSizeFromBytes((long) doubleValue);\n           if (name.contains(THROUGHPUT_METRIC_IDENTIFIER)) {\n-            // throughput is calculated as one-minute exponentially-weighted moving average rate\n-            strValue = strValue + \"/min\";\n+            strValue = strValue + \"/SEC\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNDI4Ng=="}, "originalCommit": {"oid": "a4ef6f3f00b6d7aa522317e7daab53f1c6e213b9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxNzQ2Mw==", "bodyText": "All the cluster throughput is at sec now. Throughput can be of sec or minute. Yeah, maybe use MIN make more sense since alluxio is usually long-running cluster.", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r381017463", "createdAt": "2020-02-19T00:40:10Z", "author": {"login": "LuQQiu"}, "path": "shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java", "diffHunk": "@@ -74,8 +74,7 @@ public int run() throws IOException {\n           // Bytes long can be transformed to human-readable format\n           strValue = FormatUtils.getSizeFromBytes((long) doubleValue);\n           if (name.contains(THROUGHPUT_METRIC_IDENTIFIER)) {\n-            // throughput is calculated as one-minute exponentially-weighted moving average rate\n-            strValue = strValue + \"/min\";\n+            strValue = strValue + \"/SEC\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNDI4Ng=="}, "originalCommit": {"oid": "a4ef6f3f00b6d7aa522317e7daab53f1c6e213b9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Njg0NjI5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/metrics/MetricsStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo1MzozNlrOFsnTNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo1ODowNVrOFsnYrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTU1OA==", "bodyText": "what's the advantage to using mClock vs System.currentTimeMillis?", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382325558", "createdAt": "2020-02-20T23:53:36Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/MetricsStore.java", "diffHunk": "@@ -209,7 +223,7 @@ public void clear() {\n       for (Counter counter : mClusterCounters.values()) {\n         counter.dec(counter.getCount());\n       }\n-      mLastClearTime = System.currentTimeMillis();\n+      mLastClearTime = mClock.millis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a262f12f0337bca68ed9eab7a2e4636630a6c6e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjk1OA==", "bodyText": "They are nearly the same, but mClock is good for testing, I can manually modify the time in unit tests instead of waiting for time to passed.", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382326958", "createdAt": "2020-02-20T23:58:05Z", "author": {"login": "LuQQiu"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/MetricsStore.java", "diffHunk": "@@ -209,7 +223,7 @@ public void clear() {\n       for (Counter counter : mClusterCounters.values()) {\n         counter.dec(counter.getCount());\n       }\n-      mLastClearTime = System.currentTimeMillis();\n+      mLastClearTime = mClock.millis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTU1OA=="}, "originalCommit": {"oid": "7a262f12f0337bca68ed9eab7a2e4636630a6c6e"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Njg0ODU4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo1NDo0OVrOFsnUqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDowNDoxNlrOFsnf1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTkzMQ==", "bodyText": "hmm if uptime is 0 should we be returning value? or 0?\nIn the off chance of some kind of error, what if uptime is negative?", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382325931", "createdAt": "2020-02-20T23:54:49Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "diffHunk": "@@ -141,9 +141,11 @@ protected void registerThroughputGauge(String counterName, String throughputName\n         new Gauge<Object>() {\n           @Override\n           public Object getValue() {\n-            long uptime = (System.currentTimeMillis() - mMetricsStore.getLastClearTime())\n-                / Constants.SECOND_MS;\n-            return uptime == 0 ? 0 : MetricsSystem.counter(counterName).getCount() / uptime;\n+            long uptime = (mClock.millis() - mMetricsStore.getLastClearTime())\n+                / Constants.MINUTE_MS;\n+            long value = MetricsSystem.counter(counterName).getCount();\n+            // The value is bytes per minute\n+            return uptime == 0 ? value : value / uptime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a262f12f0337bca68ed9eab7a2e4636630a6c6e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzU4NQ==", "bodyText": "Oh, that should not happen. mClock.mills() should always be equal or bigger than the mMetricsStore.getLastClearTime()).\nI feel returning value in the first minute actually makes more sense. I am fine with both 0 or value just feeling that using value can even provide users information in the first minute so it's better.", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382327585", "createdAt": "2020-02-21T00:00:05Z", "author": {"login": "LuQQiu"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "diffHunk": "@@ -141,9 +141,11 @@ protected void registerThroughputGauge(String counterName, String throughputName\n         new Gauge<Object>() {\n           @Override\n           public Object getValue() {\n-            long uptime = (System.currentTimeMillis() - mMetricsStore.getLastClearTime())\n-                / Constants.SECOND_MS;\n-            return uptime == 0 ? 0 : MetricsSystem.counter(counterName).getCount() / uptime;\n+            long uptime = (mClock.millis() - mMetricsStore.getLastClearTime())\n+                / Constants.MINUTE_MS;\n+            long value = MetricsSystem.counter(counterName).getCount();\n+            // The value is bytes per minute\n+            return uptime == 0 ? value : value / uptime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTkzMQ=="}, "originalCommit": {"oid": "7a262f12f0337bca68ed9eab7a2e4636630a6c6e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzkwNw==", "bodyText": "wait, actually uptime can be negative.....\nLet me modify the code", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382327907", "createdAt": "2020-02-21T00:01:13Z", "author": {"login": "LuQQiu"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "diffHunk": "@@ -141,9 +141,11 @@ protected void registerThroughputGauge(String counterName, String throughputName\n         new Gauge<Object>() {\n           @Override\n           public Object getValue() {\n-            long uptime = (System.currentTimeMillis() - mMetricsStore.getLastClearTime())\n-                / Constants.SECOND_MS;\n-            return uptime == 0 ? 0 : MetricsSystem.counter(counterName).getCount() / uptime;\n+            long uptime = (mClock.millis() - mMetricsStore.getLastClearTime())\n+                / Constants.MINUTE_MS;\n+            long value = MetricsSystem.counter(counterName).getCount();\n+            // The value is bytes per minute\n+            return uptime == 0 ? value : value / uptime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTkzMQ=="}, "originalCommit": {"oid": "7a262f12f0337bca68ed9eab7a2e4636630a6c6e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyODc5MA==", "bodyText": "Changed the code to make sure uptime is positive. Thanks for finding out that!!", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382328790", "createdAt": "2020-02-21T00:04:16Z", "author": {"login": "LuQQiu"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "diffHunk": "@@ -141,9 +141,11 @@ protected void registerThroughputGauge(String counterName, String throughputName\n         new Gauge<Object>() {\n           @Override\n           public Object getValue() {\n-            long uptime = (System.currentTimeMillis() - mMetricsStore.getLastClearTime())\n-                / Constants.SECOND_MS;\n-            return uptime == 0 ? 0 : MetricsSystem.counter(counterName).getCount() / uptime;\n+            long uptime = (mClock.millis() - mMetricsStore.getLastClearTime())\n+                / Constants.MINUTE_MS;\n+            long value = MetricsSystem.counter(counterName).getCount();\n+            // The value is bytes per minute\n+            return uptime == 0 ? value : value / uptime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTkzMQ=="}, "originalCommit": {"oid": "7a262f12f0337bca68ed9eab7a2e4636630a6c6e"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NjkxMzIxOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDozMDowMVrOFsn7pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDo0MDo1NVrOFsoHXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNTkxMA==", "bodyText": "I'm not sure if this will still fix the issue?\nA java Clock object can have an offset added to it (See https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html). If the duration is negative it could cause this to return negative for an extended period of time.\nI don't think we use the offset method anywhere, but it would be good to guard against it. I think keeping the code on one line is fine.\nMaybe instead we can simply update the return uptime == 0 ?  to return uptime <= 0 ? value : value / uptime\nor actually - since we should simply return the value within the first minute, maybe it should be\nreturn uptime <= 60 * Constants.SECOND_MS ? value : value / uptime", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382335910", "createdAt": "2020-02-21T00:30:01Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "diffHunk": "@@ -141,9 +141,13 @@ protected void registerThroughputGauge(String counterName, String throughputName\n         new Gauge<Object>() {\n           @Override\n           public Object getValue() {\n-            long uptime = (System.currentTimeMillis() - mMetricsStore.getLastClearTime())\n-                / Constants.SECOND_MS;\n-            return uptime == 0 ? 0 : MetricsSystem.counter(counterName).getCount() / uptime;\n+            // Divide into two lines so uptime is always zero or positive\n+            long lastClearTime = mMetricsStore.getLastClearTime();\n+            long uptime = (mClock.millis() - lastClearTime)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30fd4170a5f36cb57e0a83ef1fa42413c79bee42"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzODkxMA==", "bodyText": "Clock.offset can be set, but usually it's in tests only.\nChanged to set uptime <= 0", "url": "https://github.com/Alluxio/alluxio/pull/10933#discussion_r382338910", "createdAt": "2020-02-21T00:40:55Z", "author": {"login": "LuQQiu"}, "path": "core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java", "diffHunk": "@@ -141,9 +141,13 @@ protected void registerThroughputGauge(String counterName, String throughputName\n         new Gauge<Object>() {\n           @Override\n           public Object getValue() {\n-            long uptime = (System.currentTimeMillis() - mMetricsStore.getLastClearTime())\n-                / Constants.SECOND_MS;\n-            return uptime == 0 ? 0 : MetricsSystem.counter(counterName).getCount() / uptime;\n+            // Divide into two lines so uptime is always zero or positive\n+            long lastClearTime = mMetricsStore.getLastClearTime();\n+            long uptime = (mClock.millis() - lastClearTime)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNTkxMA=="}, "originalCommit": {"oid": "30fd4170a5f36cb57e0a83ef1fa42413c79bee42"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2061, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}