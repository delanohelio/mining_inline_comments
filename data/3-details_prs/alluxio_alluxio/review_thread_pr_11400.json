{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MDQ0MDg0", "number": 11400, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzowNjowN1rOD6thrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzo1NDo0OFrOD7AYiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODg5OTAyOnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzowNjowN1rOGSssOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MjoxOFrOGSvmgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTc3MQ==", "bodyText": "If we seek backward should sequential count always be set to 0?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422259771", "createdAt": "2020-05-08T17:06:07Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzQ1OA==", "bodyText": "yeah i was undecided about this one, but probably rare to see someone jump forward and then jump back in the stream?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422307458", "createdAt": "2020-05-08T18:42:18Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTc3MQ=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODkwNTMxOnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzowODoyNVrOGSswWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MjoyNFrOGSvmpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDgyNQ==", "bodyText": "Should this only be incremented if bytesRead > 0?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422260825", "createdAt": "2020-05-08T17:08:25Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzQ5NA==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422307494", "createdAt": "2020-05-08T18:42:24Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDgyNQ=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODkxMDAxOnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzowOTo0NlrOGSszDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MDo0OVrOGSvjqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MTUxOQ==", "bodyText": "Is it guaranteed that in is positioned correctly?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422261519", "createdAt": "2020-05-08T17:09:46Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((FSDataInputStream) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n-    mPos += n;\n-    return n;\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+      mPos += n;\n+      return n;\n+    } else {\n+      long skipped = ((FSDataInputStream) in).skip(n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjczMQ==", "bodyText": "good catch, fixed", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422306731", "createdAt": "2020-05-08T18:40:49Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((FSDataInputStream) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n-    mPos += n;\n-    return n;\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+      mPos += n;\n+      return n;\n+    } else {\n+      long skipped = ((FSDataInputStream) in).skip(n);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MTUxOQ=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODkxMzc1OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzoxMTowNFrOGSs1fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNjoxMTo0NFrOGS4yMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA==", "bodyText": "Do these numbers require tuning or is the heuristic good enough?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422262140", "createdAt": "2020-05-08T17:11:04Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwODE3Nw==", "bodyText": "We could further tune these, but experimentally journal replays are as fast as before, will verify remote spark tpcds behavior soon.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422308177", "createdAt": "2020-05-08T18:43:41Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1ODU4MQ==", "bodyText": "nit: add a comment describing these as counts and not a bytes limit", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422358581", "createdAt": "2020-05-08T20:30:58Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MzYzMg==", "bodyText": "if they require tuning, i prefer and property. we can choose to make it hidden in case we don't want to add to the user's confusion.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422363632", "createdAt": "2020-05-08T20:42:13Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NzkwNQ==", "bodyText": "So I am actually leaning towards making these not tunable for now. A tunable parameter is only useful if there is some metric / log message that suggests these parameters need to be tuned. Right now we don't have any of that. These default values should work well out of the box.\nHow about we add a TODO here to make another PR with the appropriate diagnostic metrics and make it tunable in that PR?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422457905", "createdAt": "2020-05-09T06:11:44Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, "originalCommit": {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTc1MzI3OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMTo1NDozNFrOGS03nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNjowMjo1MVrOGS4vnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng==", "bodyText": "We still need to skip in the stream if we are in the sequential read mode and n is less than the movement limit?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422393756", "createdAt": "2020-05-08T21:54:34Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +71,46 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwMDA5Ng==", "bodyText": "it is not necessary, because our mPos is the ground truth. As long as we maintain mPos, we can delay any seek or skip until when we actually read.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422400096", "createdAt": "2020-05-08T22:15:01Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +71,46 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng=="}, "originalCommit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTExMA==", "bodyText": "In that case, a read pattern like read, read, read, skip(1), read, skip(1), read will cause us to lose the sequential read mode at the last read. Is this intended?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422405110", "createdAt": "2020-05-08T22:31:55Z", "author": {"login": "calvinjia"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +71,46 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng=="}, "originalCommit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NzI0NA==", "bodyText": "yes, fixed. it became obvious once i started writing the test.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422457244", "createdAt": "2020-05-09T06:02:51Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +71,46 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng=="}, "originalCommit": {"oid": "e334b0533d4903c77a479f31b967019518442096"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTkzMjY5OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNjo1Nzo0NFrOGTFyFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMToxOVrOGTHsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MDg3MA==", "bodyText": "nit: this seems to be a clone of FilterInputStream javadoc. I don't think we need a copy here.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422670870", "createdAt": "2020-05-10T16:57:44Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjExNQ==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702115", "createdAt": "2020-05-10T21:21:19Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MDg3MA=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTkzNzMxOnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzowMjozM1rOGTF0aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMToxM1rOGTHsGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MTQ2NA==", "bodyText": "nit: this doesn't need to be a nested class? separate file for readability", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422671464", "createdAt": "2020-05-10T17:02:33Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEwNg==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702106", "createdAt": "2020-05-10T21:21:13Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MTQ2NA=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk0OTQ5OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzoxNTozMVrOGTF6VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMTozM1rOGTHsNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Mjk4MA==", "bodyText": "nit: comment why pread is never called", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422672980", "createdAt": "2020-05-10T17:15:31Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEzNQ==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702135", "createdAt": "2020-05-10T21:21:33Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Mjk4MA=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk0OTk4OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzoxNTo1N1rOGTF6jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMTozN1rOGTHsQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzAzOQ==", "bodyText": "nit: comment that skip > MOVEMENT_LIMIT causes pread. maybe even mark MOVEMENT_LIMIT @VisibleForTesting and re-use 2*MOVEMENT_LIMIT to avoid changing the test if we tune the parameter.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422673039", "createdAt": "2020-05-10T17:15:57Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE0Ng==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702146", "createdAt": "2020-05-10T21:21:37Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzAzOQ=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk1NTAwOnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzoyMTowOVrOGTF87w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMTo0MlrOGTHsSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzY0Nw==", "bodyText": "nit: comment that read > SEQUENTIAL_READ_LIMIT causes . similar to above consider exposing SEQUENTIAL_READ_LIMIT for testing and using a for loop here to avoid changing the test after possible tuning", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422673647", "createdAt": "2020-05-10T17:21:09Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);\n+    in.read();\n+    in.read();\n+    in.read();\n+    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.read();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE1Mw==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702153", "createdAt": "2020-05-10T21:21:42Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);\n+    in.read();\n+    in.read();\n+    in.read();\n+    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.read();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzY0Nw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk1ODAwOnYy", "diffSide": "LEFT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzoyNDowNlrOGTF-aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzoyNDowNlrOGTF-aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDAyNQ==", "bodyText": "nit: the comment above is mis-placed?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422674025", "createdAt": "2020-05-10T17:24:06Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk1ODU0OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzoyNDo0NFrOGTF-rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMTowNlrOGTHsEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDA5Mg==", "bodyText": "nit: also this comment seems mis-placed as this method makes no decision about pread api", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422674092", "createdAt": "2020-05-10T17:24:44Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,\n-        options.getOffset(), options.getLength());\n-    for (BlockLocation loc : blockLocations) {\n-      if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n-        // Some blocks are remote only, use pread api to HDFS\n-        return false;\n+    BlockLocation[] blockLocations;\n+    try {\n+      blockLocations = fs.getFileBlockLocations(filePath,\n+          options.getOffset(), options.getLength());\n+      if (blockLocations == null) {\n+        // no blocks exist\n+        return true;\n       }\n+\n+      for (BlockLocation loc : blockLocations) {\n+        if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n+          // Some blocks are remote only, use pread api to HDFS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA5Ng==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702096", "createdAt": "2020-05-10T21:21:06Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,\n-        options.getOffset(), options.getLength());\n-    for (BlockLocation loc : blockLocations) {\n-      if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n-        // Some blocks are remote only, use pread api to HDFS\n-        return false;\n+    BlockLocation[] blockLocations;\n+    try {\n+      blockLocations = fs.getFileBlockLocations(filePath,\n+          options.getOffset(), options.getLength());\n+      if (blockLocations == null) {\n+        // no blocks exist\n+        return true;\n       }\n+\n+      for (BlockLocation loc : blockLocations) {\n+        if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n+          // Some blocks are remote only, use pread api to HDFS", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDA5Mg=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk2NjA3OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzozMjo0M1rOGTGCcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMToyNlrOGTHsKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTA1Nw==", "bodyText": "nit: in this test can we also check if the data read back is what we expect, in addition to the API used to read?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422675057", "createdAt": "2020-05-10T17:32:43Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEyMw==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702123", "createdAt": "2020-05-10T21:21:26Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTA1Nw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk3MDY2OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzozNjo1MFrOGTGEnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToxODo0M1rOGTHrDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTYxMw==", "bodyText": "is this seek necessary or guaranteed to be a no-op if say I have 10 continuous reads as we reset mSequentialReadCount and seek after every 3 reads?", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422675613", "createdAt": "2020-05-10T17:36:50Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTgzOA==", "bodyText": "I changed this part a bit so we don't do the noop seek. Basically we do the seek lazily if we are in sequential mode, and don't reset the counter until we seek or skip a large step.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422701838", "createdAt": "2020-05-10T21:18:43Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTYxMw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk4NjE2OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzo1MzowM1rOGTGMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMDo1MVrOGTHr6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NzU3MQ==", "bodyText": "what if\n\nstream is in random read mode and mPos=0\nHdfsPositionedUnderFileInputeStream.seek(MOVEMENT_LIMIT-1)\nwe end up calling seek on FSDataInputStream and that is undesired?\n\ninstead can we refactor this by creating an auxiliary method isSequentialReadMode=mSequentialReadCount> SEQUENTIAL_READ_LIMIT\n   if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n      mSequentialReadCount = 0;\n    }\n\n    if (isSequentialReadMode()) {\n      ((Seekable) in).seek(position);", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422677571", "createdAt": "2020-05-10T17:53:03Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA1Ng==", "bodyText": "see above, i now avoid this seek entirely by doing it lazily in the read.", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702056", "createdAt": "2020-05-10T21:20:51Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NzU3MQ=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTk4ODU2OnYy", "diffSide": "RIGHT", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxNzo1NDo0OFrOGTGNXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToyMDo1OFrOGTHsAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Nzg1Mw==", "bodyText": "nit: for readability i prefer a method called  isSequentialReadMode to determine whether to seek or not", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422677853", "createdAt": "2020-05-10T17:54:48Z", "author": {"login": "madanadit"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(mPos + n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA4MA==", "bodyText": "done", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702080", "createdAt": "2020-05-10T21:20:58Z", "author": {"login": "yuzhu"}, "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(mPos + n);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Nzg1Mw=="}, "originalCommit": {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1724, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}