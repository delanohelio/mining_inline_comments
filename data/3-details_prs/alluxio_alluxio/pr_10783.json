{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2MTE2Mzg3", "number": 10783, "title": "Refactor gRPC authentication", "bodyText": "A major overhaul of gRPC authentication code that targets:\n\nSimplification of authentication driver code\nSimplifications of interfaces and reducing boilerplate code\nSilent and uniformed tracing format", "createdAt": "2020-01-22T23:40:07Z", "url": "https://github.com/Alluxio/alluxio/pull/10783", "merged": true, "mergeCommit": {"oid": "d8e5166a13f5d6524c56277c4d1c20510d6259fd"}, "closed": true, "closedAt": "2020-01-29T19:46:12Z", "author": {"login": "ggezer"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8_dsJAH2gAyMzY2MTE2Mzg3OjY2MWU2Nzc1NDY5ZDc0ZDhlM2JiZDg0ZGZkMzU4ZDQ0MjMxODRjNDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_IfOJAFqTM1MDI0MzI3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/661e6775469d74d8e3bbd84dfd358d4423184c43", "committedDate": "2020-01-23T00:46:50Z", "message": "Refactor gRPC authentication"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2093158f68be55b13284583a906925090fff8aa2", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2093158f68be55b13284583a906925090fff8aa2", "committedDate": "2020-01-22T23:37:53Z", "message": "Refactor gRPC authentication"}, "afterCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/661e6775469d74d8e3bbd84dfd358d4423184c43", "committedDate": "2020-01-23T00:46:50Z", "message": "Refactor gRPC authentication"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjA4MTcy", "url": "https://github.com/Alluxio/alluxio/pull/10783#pullrequestreview-348208172", "createdAt": "2020-01-24T20:32:45Z", "commit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMDozMjo0NVrOFhpqHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMzowMzozMlrOFhss1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgyOTg1NQ==", "bodyText": "why was this removed?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370829855", "createdAt": "2020-01-24T20:32:45Z", "author": {"login": "gpang"}, "path": "core/common/src/test/java/alluxio/security/authentication/SaslHandlersTest.java", "diffHunk": "@@ -69,12 +65,4 @@ public void testCreateClientSimpleNullPasword() throws UnauthenticatedException\n     mThrown.expectMessage(\"PLAIN: authorization ID and password must be specified\");\n     SaslClientHandler client = new SaslClientHandlerPlain(\"test\", null, null);\n   }\n-\n-  @Test\n-  public void testCreateServerSimple() throws UnauthenticatedException, SaslException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3NzczOQ==", "bodyText": "should this be a constant?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370877739", "createdAt": "2020-01-24T22:55:38Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -57,8 +60,18 @@\n   private Optional<String> mClientType = Optional.empty();\n   /** Unique channel identifier. */\n   private UUID mChannelId = UUID.randomUUID();\n-\n-  private GrpcChannelKey() {}\n+  /** Hostname to send to server for identification. */\n+  private String mLocalHostName;\n+\n+  private GrpcChannelKey(AlluxioConfiguration conf) {\n+    // Try to get local host name.\n+    try {\n+      mLocalHostName = NetworkAddressUtils\n+          .getLocalHostName((int) conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n+    } catch (Exception e) {\n+      mLocalHostName = \"<UNKNOWN>\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3Nzg3MQ==", "bodyText": "can this be final?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370877871", "createdAt": "2020-01-24T22:56:06Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -57,8 +60,18 @@\n   private Optional<String> mClientType = Optional.empty();\n   /** Unique channel identifier. */\n   private UUID mChannelId = UUID.randomUUID();\n-\n-  private GrpcChannelKey() {}\n+  /** Hostname to send to server for identification. */\n+  private String mLocalHostName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODAyOA==", "bodyText": "why is client hostname not part of this?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370878028", "createdAt": "2020-01-24T22:56:49Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -288,14 +301,25 @@ public String toString() {\n    * @return short representation of this channel key\n    */\n   public String toStringShort() {\n-    return MoreObjects.toStringHelper(this)\n+    return MoreObjects.toStringHelper(\"Channel\")\n         .add(\"ClientType\", getStringFromOptional(mClientType))\n         .add(\"ServerAddress\", mServerAddress)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODE2NA==", "bodyText": "I'm not sure what the differences are between these 2 toString methods.", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370878164", "createdAt": "2020-01-24T22:57:19Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/grpc/GrpcChannelKey.java", "diffHunk": "@@ -288,14 +301,25 @@ public String toString() {\n    * @return short representation of this channel key\n    */\n   public String toStringShort() {\n-    return MoreObjects.toStringHelper(this)\n+    return MoreObjects.toStringHelper(\"Channel\")\n         .add(\"ClientType\", getStringFromOptional(mClientType))\n         .add(\"ServerAddress\", mServerAddress)\n         .add(\"ChannelId\", mChannelId)\n         .omitNullValues()\n         .toString();\n   }\n \n+  /**\n+   * @return server-side representation of this channel key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODQwMA==", "bodyText": "is this allowed to be final?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370878400", "createdAt": "2020-01-24T22:58:15Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/security/authentication/AbstractSaslClientHandler.java", "diffHunk": "@@ -23,12 +29,59 @@\n public abstract class AbstractSaslClientHandler implements SaslClientHandler {\n   private static final Logger LOG = LoggerFactory.getLogger(AbstractSaslClientHandler.class);\n \n+  /** Initial challenge for client to start Sasl session. */\n+  private static final byte[] S_INITIATE_CHALLENGE = new byte[0];\n+\n+  private ChannelAuthenticationScheme mAuthScheme;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3OTcwMQ==", "bodyText": "why does this not use unregisterChannel?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r370879701", "createdAt": "2020-01-24T23:03:32Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/security/authentication/DefaultAuthenticationServer.java", "diffHunk": "@@ -178,7 +163,7 @@ private void cleanupStaleClients() {\n     // Unregister stale clients.\n     LOG.debug(\"Found {} stale channels for cleanup.\", staleChannels.size());\n     for (UUID clientId : staleChannels) {\n-      unregisterChannel(clientId);\n+      mChannels.remove(clientId).getSaslServerDriver().close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "661e6775469d74d8e3bbd84dfd358d4423184c43"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "447ee1d30bf6850da1df49ef95c17fa246a8f281", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/447ee1d30bf6850da1df49ef95c17fa246a8f281", "committedDate": "2020-01-24T23:24:18Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9e3d4597f27c40f1663d7916c993ae602c9ca52", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/f9e3d4597f27c40f1663d7916c993ae602c9ca52", "committedDate": "2020-01-24T23:32:50Z", "message": "Merge toString variations of GrpcChannelKey"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4OTE0OTkz", "url": "https://github.com/Alluxio/alluxio/pull/10783#pullrequestreview-348914993", "createdAt": "2020-01-27T19:25:03Z", "commit": {"oid": "f9e3d4597f27c40f1663d7916c993ae602c9ca52"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToyNTowM1rOFiOlPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToyNzowNFrOFiOpYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNDgxNA==", "bodyText": "This will invoke toStringShort even if it is not debug level, right? Instead, should we have a if (debug()) gating this? (same with other LOG.debug statements here)", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r371434814", "createdAt": "2020-01-27T19:25:03Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/security/authentication/AuthenticatedChannelClientDriver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.security.authentication;\n+\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.DeadlineExceededException;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.grpc.GrpcChannelKey;\n+import alluxio.grpc.SaslMessage;\n+import alluxio.util.LogUtils;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * Responsible for driving authentication traffic from client-side.\n+ *\n+ * An authentication between client and server is managed by\n+ * {@link AuthenticatedChannelClientDriver} and {@link AuthenticatedChannelServerDriver}\n+ * respectively.\n+ *\n+ * These drivers are wrappers over gRPC {@link StreamObserver}s that manages the stream\n+ * traffic destined for the other participant. They make sure messages are exchanged between client\n+ * and server synchronously.\n+ *\n+ * Authentication is initiated by the client. Following the initiate call, depending on the scheme,\n+ * one or more messages are exchanged to establish authenticated session between client and server.\n+ *\n+ * After the authentication is established, client and server streams are not closed in order to use\n+ * them as long polling on authentication state changes.\n+ *  -> Client closing the stream means that it doesn't want to be authenticated anymore.\n+ *  -> Server closing the stream means the client is not authenticated at the server anymore.\n+ *\n+ */\n+public class AuthenticatedChannelClientDriver implements StreamObserver<SaslMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(AuthenticatedChannelClientDriver.class);\n+  /** Channel key. */\n+  private GrpcChannelKey mChannelKey;\n+  /** Server's sasl stream. */\n+  private StreamObserver<SaslMessage> mRequestObserver;\n+  /** Handshake handler for client. */\n+  private SaslClientHandler mSaslClientHandler;\n+  /** Whether channel is authenticated. */\n+  private volatile boolean mChannelAuthenticated;\n+  /** Used to wait during authentication handshake. */\n+  private SettableFuture<Void> mChannelAuthenticatedFuture;\n+\n+  /**\n+   * Creates client driver with given handshake handler.\n+   *\n+   * @param saslClientHandler sasl client handler\n+   * @param channelKey channel key\n+   */\n+  public AuthenticatedChannelClientDriver(SaslClientHandler saslClientHandler,\n+      GrpcChannelKey channelKey) {\n+    mSaslClientHandler = saslClientHandler;\n+    mChannelKey = channelKey;\n+    mChannelAuthenticated = false;\n+    mChannelAuthenticatedFuture = SettableFuture.create();\n+  }\n+\n+  /**\n+   * Sets the server's Sasl stream.\n+   *\n+   * @param requestObserver server Sasl stream\n+   */\n+  public void setServerObserver(StreamObserver<SaslMessage> requestObserver) {\n+    mRequestObserver = requestObserver;\n+  }\n+\n+  @Override\n+  public void onNext(SaslMessage saslMessage) {\n+    try {\n+      LOG.debug(\"Received message for {}. Message: {}\", mChannelKey.toStringShort(), saslMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9e3d4597f27c40f1663d7916c993ae602c9ca52"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNTc0MQ==", "bodyText": "should we include the channel info in the message?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r371435741", "createdAt": "2020-01-27T19:26:47Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/security/authentication/AuthenticatedChannelClientDriver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.security.authentication;\n+\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.DeadlineExceededException;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.grpc.GrpcChannelKey;\n+import alluxio.grpc.SaslMessage;\n+import alluxio.util.LogUtils;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * Responsible for driving authentication traffic from client-side.\n+ *\n+ * An authentication between client and server is managed by\n+ * {@link AuthenticatedChannelClientDriver} and {@link AuthenticatedChannelServerDriver}\n+ * respectively.\n+ *\n+ * These drivers are wrappers over gRPC {@link StreamObserver}s that manages the stream\n+ * traffic destined for the other participant. They make sure messages are exchanged between client\n+ * and server synchronously.\n+ *\n+ * Authentication is initiated by the client. Following the initiate call, depending on the scheme,\n+ * one or more messages are exchanged to establish authenticated session between client and server.\n+ *\n+ * After the authentication is established, client and server streams are not closed in order to use\n+ * them as long polling on authentication state changes.\n+ *  -> Client closing the stream means that it doesn't want to be authenticated anymore.\n+ *  -> Server closing the stream means the client is not authenticated at the server anymore.\n+ *\n+ */\n+public class AuthenticatedChannelClientDriver implements StreamObserver<SaslMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(AuthenticatedChannelClientDriver.class);\n+  /** Channel key. */\n+  private GrpcChannelKey mChannelKey;\n+  /** Server's sasl stream. */\n+  private StreamObserver<SaslMessage> mRequestObserver;\n+  /** Handshake handler for client. */\n+  private SaslClientHandler mSaslClientHandler;\n+  /** Whether channel is authenticated. */\n+  private volatile boolean mChannelAuthenticated;\n+  /** Used to wait during authentication handshake. */\n+  private SettableFuture<Void> mChannelAuthenticatedFuture;\n+\n+  /**\n+   * Creates client driver with given handshake handler.\n+   *\n+   * @param saslClientHandler sasl client handler\n+   * @param channelKey channel key\n+   */\n+  public AuthenticatedChannelClientDriver(SaslClientHandler saslClientHandler,\n+      GrpcChannelKey channelKey) {\n+    mSaslClientHandler = saslClientHandler;\n+    mChannelKey = channelKey;\n+    mChannelAuthenticated = false;\n+    mChannelAuthenticatedFuture = SettableFuture.create();\n+  }\n+\n+  /**\n+   * Sets the server's Sasl stream.\n+   *\n+   * @param requestObserver server Sasl stream\n+   */\n+  public void setServerObserver(StreamObserver<SaslMessage> requestObserver) {\n+    mRequestObserver = requestObserver;\n+  }\n+\n+  @Override\n+  public void onNext(SaslMessage saslMessage) {\n+    try {\n+      LOG.debug(\"Received message for {}. Message: {}\", mChannelKey.toStringShort(), saslMessage);\n+      SaslMessage response = mSaslClientHandler.handleMessage(saslMessage);\n+      if (response != null) {\n+        mRequestObserver.onNext(response);\n+      } else {\n+        // {@code null} response means server message was a success.\n+        // Release blocked waiters.\n+        LOG.debug(\"Authentication established for {}\", mChannelKey.toStringShort());\n+        mChannelAuthenticatedFuture.set(null);\n+      }\n+    } catch (Throwable t) {\n+      LOG.debug(\"Exception while handling message for {}. Message: {}. Error: {}\",\n+          mChannelKey.toStringShort(), saslMessage, t);\n+      // Fail blocked waiters.\n+      mChannelAuthenticatedFuture.setException(t);\n+      mRequestObserver.onError(AlluxioStatusException.fromThrowable(t).toGrpcStatusException());\n+    }\n+  }\n+\n+  @Override\n+  public void onError(Throwable throwable) {\n+    LOG.debug(\"Received error for {}. Error: {}\", mChannelKey.toStringShort(), throwable);\n+    closeAuthenticatedChannel(false);\n+\n+    // Fail blocked waiters.\n+    mChannelAuthenticatedFuture.setException(throwable);\n+  }\n+\n+  @Override\n+  public void onCompleted() {\n+    LOG.debug(\"Authenticated channel revoked by server for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(false);\n+  }\n+\n+  /**\n+   * Stops authenticated session with the server by releasing the long poll.\n+   */\n+  public void close() {\n+    LOG.debug(\"Closing authentication for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(true);\n+  }\n+\n+  /**\n+   * @return {@code true} if the channel is still authenticated\n+   */\n+  public boolean isAuthenticated() {\n+    return mChannelAuthenticated;\n+  }\n+\n+  /**\n+   * Starts authentication with the server and wait until completion.\n+   *\n+   * @param timeoutMs time to wait for authentication\n+   * @throws UnauthenticatedException\n+   */\n+  public void startAuthenticatedChannel(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      LOG.debug(\"Initiating authentication for {}\", mChannelKey.toStringShort());\n+      // Send the server initial message.\n+      SaslMessage.Builder initialMsg = mSaslClientHandler.handleMessage(null).toBuilder();\n+      initialMsg.setClientId(mChannelKey.getChannelId().toString());\n+      initialMsg.setChannelRef(mChannelKey.toStringShort());\n+      mRequestObserver.onNext(initialMsg.build());\n+\n+      // Utility to return from start when channel is secured.\n+      waitUntilChannelAuthenticated(timeoutMs);\n+    } catch (Throwable t) {\n+      closeAuthenticatedChannel(true);\n+      throw AlluxioStatusException.fromThrowable(t);\n+    }\n+  }\n+\n+  private void waitUntilChannelAuthenticated(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      // Wait until authentication status changes.\n+      mChannelAuthenticatedFuture.get(timeoutMs, TimeUnit.MILLISECONDS);\n+      mChannelAuthenticated = true;\n+    } catch (InterruptedException ie) {\n+      Thread.currentThread().interrupt();\n+      throw AlluxioStatusException.fromThrowable(ie);\n+    } catch (ExecutionException e) {\n+      AlluxioStatusException statExc = AlluxioStatusException.fromThrowable(e.getCause());\n+      // Unimplemented is returned if server doesn't provide authentication service.\n+      if (statExc.getStatusCode() == Status.Code.UNIMPLEMENTED) {\n+        throw new UnauthenticatedException(\"Authentication is disabled on target server.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9e3d4597f27c40f1663d7916c993ae602c9ca52"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzNTg3Mw==", "bodyText": "should we include the channel info in the message?", "url": "https://github.com/Alluxio/alluxio/pull/10783#discussion_r371435873", "createdAt": "2020-01-27T19:27:04Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/security/authentication/AuthenticatedChannelClientDriver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.security.authentication;\n+\n+import alluxio.exception.status.AlluxioStatusException;\n+import alluxio.exception.status.DeadlineExceededException;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.grpc.GrpcChannelKey;\n+import alluxio.grpc.SaslMessage;\n+import alluxio.util.LogUtils;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import io.grpc.stub.StreamObserver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * Responsible for driving authentication traffic from client-side.\n+ *\n+ * An authentication between client and server is managed by\n+ * {@link AuthenticatedChannelClientDriver} and {@link AuthenticatedChannelServerDriver}\n+ * respectively.\n+ *\n+ * These drivers are wrappers over gRPC {@link StreamObserver}s that manages the stream\n+ * traffic destined for the other participant. They make sure messages are exchanged between client\n+ * and server synchronously.\n+ *\n+ * Authentication is initiated by the client. Following the initiate call, depending on the scheme,\n+ * one or more messages are exchanged to establish authenticated session between client and server.\n+ *\n+ * After the authentication is established, client and server streams are not closed in order to use\n+ * them as long polling on authentication state changes.\n+ *  -> Client closing the stream means that it doesn't want to be authenticated anymore.\n+ *  -> Server closing the stream means the client is not authenticated at the server anymore.\n+ *\n+ */\n+public class AuthenticatedChannelClientDriver implements StreamObserver<SaslMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(AuthenticatedChannelClientDriver.class);\n+  /** Channel key. */\n+  private GrpcChannelKey mChannelKey;\n+  /** Server's sasl stream. */\n+  private StreamObserver<SaslMessage> mRequestObserver;\n+  /** Handshake handler for client. */\n+  private SaslClientHandler mSaslClientHandler;\n+  /** Whether channel is authenticated. */\n+  private volatile boolean mChannelAuthenticated;\n+  /** Used to wait during authentication handshake. */\n+  private SettableFuture<Void> mChannelAuthenticatedFuture;\n+\n+  /**\n+   * Creates client driver with given handshake handler.\n+   *\n+   * @param saslClientHandler sasl client handler\n+   * @param channelKey channel key\n+   */\n+  public AuthenticatedChannelClientDriver(SaslClientHandler saslClientHandler,\n+      GrpcChannelKey channelKey) {\n+    mSaslClientHandler = saslClientHandler;\n+    mChannelKey = channelKey;\n+    mChannelAuthenticated = false;\n+    mChannelAuthenticatedFuture = SettableFuture.create();\n+  }\n+\n+  /**\n+   * Sets the server's Sasl stream.\n+   *\n+   * @param requestObserver server Sasl stream\n+   */\n+  public void setServerObserver(StreamObserver<SaslMessage> requestObserver) {\n+    mRequestObserver = requestObserver;\n+  }\n+\n+  @Override\n+  public void onNext(SaslMessage saslMessage) {\n+    try {\n+      LOG.debug(\"Received message for {}. Message: {}\", mChannelKey.toStringShort(), saslMessage);\n+      SaslMessage response = mSaslClientHandler.handleMessage(saslMessage);\n+      if (response != null) {\n+        mRequestObserver.onNext(response);\n+      } else {\n+        // {@code null} response means server message was a success.\n+        // Release blocked waiters.\n+        LOG.debug(\"Authentication established for {}\", mChannelKey.toStringShort());\n+        mChannelAuthenticatedFuture.set(null);\n+      }\n+    } catch (Throwable t) {\n+      LOG.debug(\"Exception while handling message for {}. Message: {}. Error: {}\",\n+          mChannelKey.toStringShort(), saslMessage, t);\n+      // Fail blocked waiters.\n+      mChannelAuthenticatedFuture.setException(t);\n+      mRequestObserver.onError(AlluxioStatusException.fromThrowable(t).toGrpcStatusException());\n+    }\n+  }\n+\n+  @Override\n+  public void onError(Throwable throwable) {\n+    LOG.debug(\"Received error for {}. Error: {}\", mChannelKey.toStringShort(), throwable);\n+    closeAuthenticatedChannel(false);\n+\n+    // Fail blocked waiters.\n+    mChannelAuthenticatedFuture.setException(throwable);\n+  }\n+\n+  @Override\n+  public void onCompleted() {\n+    LOG.debug(\"Authenticated channel revoked by server for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(false);\n+  }\n+\n+  /**\n+   * Stops authenticated session with the server by releasing the long poll.\n+   */\n+  public void close() {\n+    LOG.debug(\"Closing authentication for {}\", mChannelKey.toStringShort());\n+    closeAuthenticatedChannel(true);\n+  }\n+\n+  /**\n+   * @return {@code true} if the channel is still authenticated\n+   */\n+  public boolean isAuthenticated() {\n+    return mChannelAuthenticated;\n+  }\n+\n+  /**\n+   * Starts authentication with the server and wait until completion.\n+   *\n+   * @param timeoutMs time to wait for authentication\n+   * @throws UnauthenticatedException\n+   */\n+  public void startAuthenticatedChannel(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      LOG.debug(\"Initiating authentication for {}\", mChannelKey.toStringShort());\n+      // Send the server initial message.\n+      SaslMessage.Builder initialMsg = mSaslClientHandler.handleMessage(null).toBuilder();\n+      initialMsg.setClientId(mChannelKey.getChannelId().toString());\n+      initialMsg.setChannelRef(mChannelKey.toStringShort());\n+      mRequestObserver.onNext(initialMsg.build());\n+\n+      // Utility to return from start when channel is secured.\n+      waitUntilChannelAuthenticated(timeoutMs);\n+    } catch (Throwable t) {\n+      closeAuthenticatedChannel(true);\n+      throw AlluxioStatusException.fromThrowable(t);\n+    }\n+  }\n+\n+  private void waitUntilChannelAuthenticated(long timeoutMs) throws AlluxioStatusException {\n+    try {\n+      // Wait until authentication status changes.\n+      mChannelAuthenticatedFuture.get(timeoutMs, TimeUnit.MILLISECONDS);\n+      mChannelAuthenticated = true;\n+    } catch (InterruptedException ie) {\n+      Thread.currentThread().interrupt();\n+      throw AlluxioStatusException.fromThrowable(ie);\n+    } catch (ExecutionException e) {\n+      AlluxioStatusException statExc = AlluxioStatusException.fromThrowable(e.getCause());\n+      // Unimplemented is returned if server doesn't provide authentication service.\n+      if (statExc.getStatusCode() == Status.Code.UNIMPLEMENTED) {\n+        throw new UnauthenticatedException(\"Authentication is disabled on target server.\");\n+      }\n+      throw statExc;\n+    } catch (TimeoutException e) {\n+      throw new DeadlineExceededException(e);\n+    }\n+  }\n+\n+  private void closeAuthenticatedChannel(boolean signalServer) {\n+    mSaslClientHandler.close();\n+    // Authentication failed either during or after handshake.\n+    mChannelAuthenticated = false;\n+\n+    if (signalServer) {\n+      try {\n+        mRequestObserver.onCompleted();\n+      } catch (Exception e) {\n+        LogUtils.warnWithException(LOG, \"Failed signaling server for stream completion.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9e3d4597f27c40f1663d7916c993ae602c9ca52"}, "originalPosition": 191}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac4f9e327a958f625a3615400a9fc183a7558e5e", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/ac4f9e327a958f625a3615400a9fc183a7558e5e", "committedDate": "2020-01-28T20:09:34Z", "message": "Trace fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMjQzMjcz", "url": "https://github.com/Alluxio/alluxio/pull/10783#pullrequestreview-350243273", "createdAt": "2020-01-29T16:25:30Z", "commit": {"oid": "ac4f9e327a958f625a3615400a9fc183a7558e5e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3133, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}