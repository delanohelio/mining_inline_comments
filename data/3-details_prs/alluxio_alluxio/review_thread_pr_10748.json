{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyODgyMTk5", "number": 10748, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDowMTozNFrODYBsCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMjoxNFrODgBDRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTIwMDc0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDowMTozNFrOFdproQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDowMTozNFrOFdproQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNTkzNw==", "bodyText": "@apc999 This needs to be public or reflection will not work", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366635937", "createdAt": "2020-01-15T00:01:34Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java", "diffHunk": "@@ -101,7 +101,7 @@\n    *\n    * @param fsContext file system context\n    */\n-  public BaseFileSystem(FileSystemContext fsContext) {\n+  protected BaseFileSystem(FileSystemContext fsContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74932edcb60ca7b63130e42438849da125af761d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTk2Mzg0OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo0OTo0M1rOFdw1eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo0OTo0M1rOFdw1eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzE0NA==", "bodyText": "is this already a lazy init or just a TODO, @calvinjia ?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753144", "createdAt": "2020-01-15T08:49:43Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTk2NzA4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTowOFrOFdw3iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTowOFrOFdw3iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzY3Mg==", "bodyText": "how shall we handle IOException here when reading cache? Assume we shall fallback to external stream? Currently the IOE will be escalated.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753672", "createdAt": "2020-01-15T08:51:08Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTk2ODYxOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTo0NVrOFdw4fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTo0NVrOFdw4fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzkxOQ==", "bodyText": "how shall we handle IOException here when reading cache? Assume we shall fallback to external stream? Currently the IOE will be escalated. Are we supposed to make the failure transparent for the application?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753919", "createdAt": "2020-01-15T08:51:45Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTk3MDk3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MjozN1rOFdw57w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MjozN1rOFdw57w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NDI4Nw==", "bodyText": "how shall we handle failed put with IOE? shall we silently swallow the exception (w/ warning)?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366754287", "createdAt": "2020-01-15T08:52:37Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTk3MjY5OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MzoxNlrOFdw65g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MzoxNlrOFdw65g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NDUzNA==", "bodyText": "handle IOException?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366754534", "createdAt": "2020-01-15T08:53:16Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTk3NzA4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1NDo0OVrOFdw9cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1NDo0OVrOFdw9cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NTE4Ng==", "bodyText": "what's the invariant when access evictor in terms of locking?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366755186", "createdAt": "2020-01-15T08:54:49Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjExMjAzOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1NTozMVrOFpBhOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTozOTo1M1rOFphEOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDgyNg==", "bodyText": "should this be done through getClusterConf()?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378560826", "createdAt": "2020-02-12T22:55:31Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3NzY4OQ==", "bodyText": "We previously were trying to decouple filesystem creation from the file system context, but I don't think that is necessary anymore, I've reverted the changes. See: #10907", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379077689", "createdAt": "2020-02-13T19:39:53Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDgyNg=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjExMjYwOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1NTo0MlrOFpBhiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1NTo0MlrOFpBhiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDkwNw==", "bodyText": "same question", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378560907", "createdAt": "2020-02-12T22:55:42Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n       Class[] ctorArgClasses = new Class[] {FileSystemContext.class};\n       Object[] ctorArgs = new Object[] {context};\n       FileSystem fs =\n           (FileSystem) CommonUtils.createNewClassInstance(fsClass, ctorArgClasses, ctorArgs);\n-      if (context.getClusterConf().getBoolean(PropertyKey.USER_LOCAL_CACHE_ENABLED)) {\n-        return new LocalCacheFileSystem(fs);\n+      if (conf.getBoolean(PropertyKey.USER_LOCAL_CACHE_ENABLED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDkxMjUxOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/wire/FileInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzowOTo1OVrOFpcQ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTo0MDowMVrOFphEcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTAzMQ==", "bodyText": "how is this different from the fileId? Can we add some info in the javadoc?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378999031", "createdAt": "2020-02-13T17:09:59Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/wire/FileInfo.java", "diffHunk": "@@ -89,6 +90,13 @@ public long getFileId() {\n     return mFileId;\n   }\n \n+  /**\n+   * @return the file identifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3Nzc0NA==", "bodyText": "Added: #10907", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379077744", "createdAt": "2020-02-13T19:40:01Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/wire/FileInfo.java", "diffHunk": "@@ -89,6 +90,13 @@ public long getFileId() {\n     return mFileId;\n   }\n \n+  /**\n+   * @return the file identifier", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTAzMQ=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTUzMzgyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNjo1NFrOFpib1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowMTo1MFrOFqAlfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMDExNg==", "bodyText": "I am concerned about how this could affect the client jar. Many people will not be using the rocskdb-based page store and this jar is ~13MB in size. How do you feel about excluding it for now?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379100116", "createdAt": "2020-02-13T20:26:54Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/pom.xml", "diffHunk": "@@ -55,6 +55,10 @@\n       <groupId>io.grpc</groupId>\n       <artifactId>grpc-stub</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.rocksdb</groupId>\n+      <artifactId>rocksdbjni</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NDczNg==", "bodyText": "That makes sense to me.\n@bf8086 @apc999 WDYT?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379164736", "createdAt": "2020-02-13T22:53:21Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/pom.xml", "diffHunk": "@@ -55,6 +55,10 @@\n       <groupId>io.grpc</groupId>\n       <artifactId>grpc-stub</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.rocksdb</groupId>\n+      <artifactId>rocksdbjni</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMDExNg=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NDEwOA==", "bodyText": "marked as provided in shaded client module. so we can keep the original jar size", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379594108", "createdAt": "2020-02-14T19:01:50Z", "author": {"login": "apc999"}, "path": "core/client/fs/pom.xml", "diffHunk": "@@ -55,6 +55,10 @@\n       <groupId>io.grpc</groupId>\n       <artifactId>grpc-stub</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.rocksdb</groupId>\n+      <artifactId>rocksdbjni</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMDExNg=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTU0ODg4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDozMTozM1rOFpik2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDozMTozM1rOFpik2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMjQyNw==", "bodyText": "we can get rid of lots of powermock usages throughout the codebase with this :)", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379102427", "createdAt": "2020-02-13T20:31:33Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "diffHunk": "@@ -85,7 +85,7 @@\n  * so, because thread A holds the lock on {@link FileSystemContext}.\n  */\n @ThreadSafe\n-public final class FileSystemContext implements Closeable {\n+public class FileSystemContext implements Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTY1MDA4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/evictor/LRUCacheEvictor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowNzoyOVrOFpjkfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjo1NDo1NVrOFpmabg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODcxOA==", "bodyText": "is it simpler to just make this method synchronized?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379118718", "createdAt": "2020-02-13T21:07:29Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/evictor/LRUCacheEvictor.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.evictor;\n+\n+import alluxio.client.file.cache.CacheEvictor;\n+import alluxio.client.file.cache.PageId;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * LRU client-side cache eviction policy.\n+ */\n+@ThreadSafe\n+public class LRUCacheEvictor implements CacheEvictor {\n+  private static final int LINKED_HASH_MAP_INIT_CAPACITY = 200;\n+  private static final float LINKED_HASH_MAP_INIT_LOAD_FACTOR = 0.75f;\n+  private static final boolean LINKED_HASH_MAP_ACCESS_ORDERED = true;\n+  private static final boolean UNUSED_MAP_VALUE = true;\n+\n+  // TODO(feng): unify with worker side evictor\n+  private final Map<PageId, Boolean> mLRUCache =\n+      Collections.synchronizedMap(new LinkedHashMap<>(LINKED_HASH_MAP_INIT_CAPACITY,\n+          LINKED_HASH_MAP_INIT_LOAD_FACTOR, LINKED_HASH_MAP_ACCESS_ORDERED));\n+\n+  @Override\n+  public void updateOnGet(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnPut(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnDelete(PageId pageId) {\n+    mLRUCache.remove(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public PageId evict() {\n+    synchronized (mLRUCache) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTI5NA==", "bodyText": "IMO finer grained synchronization is cleaner", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379165294", "createdAt": "2020-02-13T22:54:55Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/evictor/LRUCacheEvictor.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.evictor;\n+\n+import alluxio.client.file.cache.CacheEvictor;\n+import alluxio.client.file.cache.PageId;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * LRU client-side cache eviction policy.\n+ */\n+@ThreadSafe\n+public class LRUCacheEvictor implements CacheEvictor {\n+  private static final int LINKED_HASH_MAP_INIT_CAPACITY = 200;\n+  private static final float LINKED_HASH_MAP_INIT_LOAD_FACTOR = 0.75f;\n+  private static final boolean LINKED_HASH_MAP_ACCESS_ORDERED = true;\n+  private static final boolean UNUSED_MAP_VALUE = true;\n+\n+  // TODO(feng): unify with worker side evictor\n+  private final Map<PageId, Boolean> mLRUCache =\n+      Collections.synchronizedMap(new LinkedHashMap<>(LINKED_HASH_MAP_INIT_CAPACITY,\n+          LINKED_HASH_MAP_INIT_LOAD_FACTOR, LINKED_HASH_MAP_ACCESS_ORDERED));\n+\n+  @Override\n+  public void updateOnGet(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnPut(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnDelete(PageId pageId) {\n+    mLRUCache.remove(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public PageId evict() {\n+    synchronized (mLRUCache) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODcxOA=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTY5MDkwOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMToyMToxNFrOFpj9pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMToyMToxNFrOFpj9pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNTE1Ng==", "bodyText": "RocksDB is better-optimized for smaller values. Since pages are on the order of MB, there is probably some tuning in the default values for RocksPageStoreOptions that we can do to improve performance OOTB for many users. I am fine saving the work for a later PR\nReference discussion: https://github.com/facebook/rocksdb/issues/513", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379125156", "createdAt": "2020-02-13T21:21:14Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;\n+  private static final byte[] CONF_KEY = \"CONF\".getBytes();\n+\n+  private final String mRoot;\n+  private final RocksDB mDb;\n+  private final AtomicLong mSize = new AtomicLong(0);\n+  private final AtomicLong mBytes = new AtomicLong(0);\n+  private final double mOverheadRatio;\n+\n+  /**\n+   * Creates a new instance of {@link PageStore} backed by RocksDB.\n+   *\n+   * @param options options for the rocks page store\n+   * @throws IOException when fails to create a {@link RocksPageStore}\n+   */\n+  public RocksPageStore(RocksPageStoreOptions options) throws IOException {\n+    Preconditions.checkArgument(options.getMaxPageSize() > 0);\n+    mRoot = options.getRootDir();\n+    // TODO(feng): consider making the overhead ratio configurable\n+    mOverheadRatio = (double) KEY_LEN / options.getMaxPageSize();\n+    Cache.PRocksPageStoreOptions pOptions = options.toProto();\n+    RocksDB.loadLibrary();\n+    RocksDB db = null;\n+    Options rocksOptions = new Options();\n+    rocksOptions.setCreateIfMissing(true);\n+    rocksOptions.setWriteBufferSize(options.getWriteBufferSize());\n+    rocksOptions.setCompressionType(options.getCompressionType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTc2ODkwOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/DefaultMetaStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTo0ODo1N1rOFpkvDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzoxNToyM1rOFpm08w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg==", "bodyText": "HashMap is not thread-safe. Is that ok?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379137806", "createdAt": "2020-02-13T21:48:57Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/DefaultMetaStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The default implementation of a metadata store for pages stored in cache.\n+ */\n+public class DefaultMetaStore implements MetaStore {\n+  /** A map from PageId to page info. */\n+  private final Map<PageId, PageInfo> mPageMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NjQwOA==", "bodyText": "I think we are handling locking in LocalCacheManager, @bf8086", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379166408", "createdAt": "2020-02-13T22:58:06Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/DefaultMetaStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The default implementation of a metadata store for pages stored in cache.\n+ */\n+public class DefaultMetaStore implements MetaStore {\n+  /** A map from PageId to page info. */\n+  private final Map<PageId, PageInfo> mPageMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3MjA4Mw==", "bodyText": "Yeah the LocalCacheManager manages the locks for metadata operations.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379172083", "createdAt": "2020-02-13T23:15:23Z", "author": {"login": "bf8086"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/DefaultMetaStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The default implementation of a metadata store for pages stored in cache.\n+ */\n+public class DefaultMetaStore implements MetaStore {\n+  /** A map from PageId to page info. */\n+  private final Map<PageId, PageInfo> mPageMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTgxMTEzOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowMzowMlrOFplJlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzowMToxN1rOFpmi_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDU5OA==", "bodyText": "This looks like it shares a lot of code with read(). Can it be refactored/reused?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379144598", "createdAt": "2020-02-13T22:03:02Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NzQ4NA==", "bodyText": "We weren't able to refactor much of it, it comes down to updating the instance variable mPosition vs a local variable. Do you have any suggestions? FWIW the other implementations of read/positionedread are also duplicated.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379167484", "createdAt": "2020-02-13T23:01:17Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDU5OA=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTgxMjkzOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowMzo0M1rOFplKxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzowMjo1MVrOFpmk7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDkwMA==", "bodyText": "this looks like the same exact error message as read(). Can we make them distinct?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379144900", "createdAt": "2020-02-13T22:03:43Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);\n+          System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+        }\n+      }\n+    }\n+    Preconditions.checkState(\n+        bytesRead == len || (bytesRead < len && currentPosition == mStatus.getLength()),\n+        \"Invalid number of bytes read - \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2Nzk4Mw==", "bodyText": "Updated: #10907", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379167983", "createdAt": "2020-02-13T23:02:51Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);\n+          System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+        }\n+      }\n+    }\n+    Preconditions.checkState(\n+        bytesRead == len || (bytesRead < len && currentPosition == mStatus.getLength()),\n+        \"Invalid number of bytes read - \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDkwMA=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTgxNjg0OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowNToyM1rOFplNWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjo1NTo0NlrOFpmbkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTU2MA==", "bodyText": "nit: should Local Cache be capitalized?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379145560", "createdAt": "2020-02-13T22:05:23Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTU4NQ==", "bodyText": "Updated: #10907", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379165585", "createdAt": "2020-02-13T22:55:46Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTU2MA=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTgxODU0OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowNTo1NFrOFplOXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjo1Njo1NlrOFpmdOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTgyMA==", "bodyText": "what is CacheBytesReadExternal? Should we reference the variable instead?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379145820", "createdAt": "2020-02-13T22:05:54Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_EXTERNAL)\n+          .setDescription(\"Total number of bytes read from external storage due to a cache miss \"\n+              + \"on the local cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL)\n+          .setDescription(\"Total number of bytes the user requested to read which resulted in a \"\n+              + \"cache miss. This number may be smaller than CacheBytesReadExternal due to chunk \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NjAxMQ==", "bodyText": "Updated: #10907", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379166011", "createdAt": "2020-02-13T22:56:56Z", "author": {"login": "calvinjia"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_EXTERNAL)\n+          .setDescription(\"Total number of bytes read from external storage due to a cache miss \"\n+              + \"on the local cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL)\n+          .setDescription(\"Total number of bytes the user requested to read which resulted in a \"\n+              + \"cache miss. This number may be smaller than CacheBytesReadExternal due to chunk \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTgyMA=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTgzMDk1OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxMDo0OFrOFplWfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzowODoxM1rOFpmrsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzkwMw==", "bodyText": "Would this be easier if using something like AtomicReference?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379147903", "createdAt": "2020-02-13T22:10:48Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.DelegatingFileSystem;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * A FileSystem implementation with a local cache.\n+ */\n+public class LocalCacheFileSystem extends DelegatingFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheFileSystem.class);\n+  private static Optional<CacheManager> sCacheManager;\n+\n+  private final AlluxioConfiguration mConf;\n+\n+  /**\n+   * @param fs a FileSystem instance to query on local cache miss\n+   * @param conf the configuration, only respected for the first call\n+   */\n+  @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+      value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\",\n+      justification = \"write to static is made threadsafe\")\n+  public LocalCacheFileSystem(FileSystem fs, AlluxioConfiguration conf) {\n+    super(fs);\n+    // TODO(feng): support multiple cache managers\n+    if (sCacheManager == null) {\n+      synchronized (LocalCacheFileSystem.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2OTcxNA==", "bodyText": "Are you suggesting to use getAndSet, that requires creating a new instance of cachemanager each time?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379169714", "createdAt": "2020-02-13T23:08:13Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.DelegatingFileSystem;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * A FileSystem implementation with a local cache.\n+ */\n+public class LocalCacheFileSystem extends DelegatingFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheFileSystem.class);\n+  private static Optional<CacheManager> sCacheManager;\n+\n+  private final AlluxioConfiguration mConf;\n+\n+  /**\n+   * @param fs a FileSystem instance to query on local cache miss\n+   * @param conf the configuration, only respected for the first call\n+   */\n+  @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+      value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\",\n+      justification = \"write to static is made threadsafe\")\n+  public LocalCacheFileSystem(FileSystem fs, AlluxioConfiguration conf) {\n+    super(fs);\n+    // TODO(feng): support multiple cache managers\n+    if (sCacheManager == null) {\n+      synchronized (LocalCacheFileSystem.class) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzkwMw=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTgzNzU1OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxMzoyMlrOFplavw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxMzoyMlrOFplavw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0ODk5MQ==", "bodyText": "Could this use com.google.common.util.concurrent.Striped?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379148991", "createdAt": "2020-02-13T22:13:22Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTg0MTczOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNDo1NlrOFpldXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNDo1NlrOFpldXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTY2Mg==", "bodyText": "what are the locking rules for locking both a meta lock and a page lock?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379149662", "createdAt": "2020-02-13T22:14:56Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTg0MjQyOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNTowN1rOFpldtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNTowN1rOFpldtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTc0OQ==", "bodyText": "Is anything allowed to lock more than 1 page lock?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379149749", "createdAt": "2020-02-13T22:15:07Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTg0NjI4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNjozNVrOFplgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNjozNVrOFplgGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDM2MA==", "bodyText": "Can you make this a more descriptive debug message?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379150360", "createdAt": "2020-02-13T22:16:35Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTg0Njg4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNjo0N1rOFplgcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNjo0N1rOFplgcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDQ1MQ==", "bodyText": "Can you improve this message?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379150451", "createdAt": "2020-02-13T22:16:47Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;\n+        if (enoughSpace) {\n+          mMetaStore.addPage(pageId, new PageInfo(pageId, page.length));\n+        } else {\n+          victim = mEvictor.evict();\n+          victimPageInfo = mMetaStore.getPageInfo(victim);\n+        }\n+      } catch (PageNotFoundException e) {\n+        throw new IllegalStateException(\"we shall not reach here\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTg2MTQzOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageId.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoyMjozNFrOFplpdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzowNToxNlrOFpmn9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1Mjc1OQ==", "bodyText": "what is a file id, and why is it a string?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379152759", "createdAt": "2020-02-13T22:22:34Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageId.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class identifies a single cached page.\n+ */\n+@ThreadSafe\n+public class PageId {\n+  private final String mFileId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2ODc1Ng==", "bodyText": "fileID will be used to key the pages, any unique identifier will be ok", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379168756", "createdAt": "2020-02-13T23:05:16Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageId.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class identifies a single cached page.\n+ */\n+@ThreadSafe\n+public class PageId {\n+  private final String mFileId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1Mjc1OQ=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTg4MzQxOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjozMDo0OVrOFpl3Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMzoxNzo0N1rOFpm4Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NjI3MA==", "bodyText": "What is the format of the key?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379156270", "createdAt": "2020-02-13T22:30:49Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3Mjg4Mw==", "bodyText": "It is PageIndex(long) + FileIdentifier(String). This constant here is only used for estimation of the overhead.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379172883", "createdAt": "2020-02-13T23:17:47Z", "author": {"login": "bf8086"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NjI3MA=="}, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODk2MjUxOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMDo1Mzo0MFrOFqDX2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMDo1NDo1MVrOFqDZgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTc3MA==", "bodyText": "@bf8086 From what I understand, mPageStore.bytes() is not protected by mMetaLock, so if enoughSpace is true here, there is no guarantee that it will continue to hold true.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379639770", "createdAt": "2020-02-14T20:53:40Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MDE5NQ==", "bodyText": "Instead of mPageStore.bytes() I think we need to use something like mMetastore.bytes()? Since we can guarantee that is not changing and we will reserve the required space while still holding the metalock", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379640195", "createdAt": "2020-02-14T20:54:51Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTc3MA=="}, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODk4MTAzOnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMTozNlrOFqDi6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMTozNlrOFqDi6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MjYwMQ==", "bodyText": "Since this is best effort, could make this API not throw exception, even on write failure?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379642601", "createdAt": "2020-02-14T21:01:36Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager extends AutoCloseable  {\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(AlluxioConfiguration conf) throws IOException {\n+    // TODO(feng): make cache manager type configurable when we introduce more implementations.\n+    return LocalCacheManager.create(conf);\n+  }\n+\n+  /**\n+   * Writes a new page from a source channel with best effort. It is possible that this put\n+   * operation returns without page written due to transient behavior not due to failures writing\n+   * to disks.\n+   *\n+   * @param pageId page identifier\n+   * @param page page data\n+   * @throws IOException if error happens when writing the page to disk\n+   * @return true on a successful put or false due to transient\n+   */\n+  boolean put(PageId pageId, byte[] page) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODk4MjQ3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMjoxNFrOFqDjzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMjoxNFrOFqDjzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MjgzMA==", "bodyText": "Could we default to returning null from this API instead of throwing an exception, since cache hit is best effort?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379642830", "createdAt": "2020-02-14T21:02:14Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager extends AutoCloseable  {\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(AlluxioConfiguration conf) throws IOException {\n+    // TODO(feng): make cache manager type configurable when we introduce more implementations.\n+    return LocalCacheManager.create(conf);\n+  }\n+\n+  /**\n+   * Writes a new page from a source channel with best effort. It is possible that this put\n+   * operation returns without page written due to transient behavior not due to failures writing\n+   * to disks.\n+   *\n+   * @param pageId page identifier\n+   * @param page page data\n+   * @throws IOException if error happens when writing the page to disk\n+   * @return true on a successful put or false due to transient\n+   */\n+  boolean put(PageId pageId, byte[] page) throws IOException;\n+\n+  /**\n+   * Wraps the page in a channel or null if the queried page is not found in the cache.\n+   *\n+   * @param pageId page identifier\n+   * @return a channel to read the page\n+   * @throws IOException if error happens when reading the page\n+   */\n+  @Nullable\n+  ReadableByteChannel get(PageId pageId) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2241, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}