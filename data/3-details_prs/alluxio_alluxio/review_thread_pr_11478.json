{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDY5NzEz", "number": 11478, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMTo0OTo1NlrOD_2-iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToxODoxNlrOEAR1EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Mjg3NjI0OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMTo0OTo1NlrOGaxhjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMjoyNzo1MlrOGayaFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyNzU2Nw==", "bodyText": "If this times out, will the backup not be scheduled until the next time, or will there be some sort of retry?", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r430727567", "createdAt": "2020-05-26T21:49:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -250,16 +253,15 @@ private void activateWorkerConnection(Connection workerConnection) {\n    */\n   private void scheduleLocalBackup(BackupPRequest request) {\n     mLocalBackupFuture = mExecutorService.submit(() -> {\n-      try (LockResource lr = new LockResource(mStatePauseLock)) {\n-        try {\n-          mBackupTracker.updateState(BackupState.Running);\n-          AlluxioURI backupUri = takeBackup(request, mBackupTracker.getEntryCounter());\n-          mBackupTracker.updateBackupUri(backupUri);\n-          mBackupTracker.updateState(BackupState.Completed);\n-        } catch (IOException e) {\n-          mBackupTracker.updateError(\n-              new BackupException(String.format(\"Local backup failed: %s\", e.getMessage()), e));\n-        }\n+      try (LockResource stateLockResource =\n+          new LockResource(mStatePauseLock, mStateLockTimeout, TimeUnit.MILLISECONDS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cfe2a93bb7453e501362d2cb2ebfc9263a1af23"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNjYwNw==", "bodyText": "It's already scheduled during this call. However, the backup-tracker will be completed in the catch statement if it times out.", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r430736607", "createdAt": "2020-05-26T22:13:02Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -250,16 +253,15 @@ private void activateWorkerConnection(Connection workerConnection) {\n    */\n   private void scheduleLocalBackup(BackupPRequest request) {\n     mLocalBackupFuture = mExecutorService.submit(() -> {\n-      try (LockResource lr = new LockResource(mStatePauseLock)) {\n-        try {\n-          mBackupTracker.updateState(BackupState.Running);\n-          AlluxioURI backupUri = takeBackup(request, mBackupTracker.getEntryCounter());\n-          mBackupTracker.updateBackupUri(backupUri);\n-          mBackupTracker.updateState(BackupState.Completed);\n-        } catch (IOException e) {\n-          mBackupTracker.updateError(\n-              new BackupException(String.format(\"Local backup failed: %s\", e.getMessage()), e));\n-        }\n+      try (LockResource stateLockResource =\n+          new LockResource(mStatePauseLock, mStateLockTimeout, TimeUnit.MILLISECONDS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyNzU2Nw=="}, "originalCommit": {"oid": "6cfe2a93bb7453e501362d2cb2ebfc9263a1af23"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0MDkyNg==", "bodyText": "Is there a retry outside of this? If the backup fails to lock, I feel like there should be retries.", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r430740926", "createdAt": "2020-05-26T22:24:50Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -250,16 +253,15 @@ private void activateWorkerConnection(Connection workerConnection) {\n    */\n   private void scheduleLocalBackup(BackupPRequest request) {\n     mLocalBackupFuture = mExecutorService.submit(() -> {\n-      try (LockResource lr = new LockResource(mStatePauseLock)) {\n-        try {\n-          mBackupTracker.updateState(BackupState.Running);\n-          AlluxioURI backupUri = takeBackup(request, mBackupTracker.getEntryCounter());\n-          mBackupTracker.updateBackupUri(backupUri);\n-          mBackupTracker.updateState(BackupState.Completed);\n-        } catch (IOException e) {\n-          mBackupTracker.updateError(\n-              new BackupException(String.format(\"Local backup failed: %s\", e.getMessage()), e));\n-        }\n+      try (LockResource stateLockResource =\n+          new LockResource(mStatePauseLock, mStateLockTimeout, TimeUnit.MILLISECONDS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyNzU2Nw=="}, "originalCommit": {"oid": "6cfe2a93bb7453e501362d2cb2ebfc9263a1af23"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0MjAzNw==", "bodyText": "No retries before, and didn't need to add more retries, because tryLock had the exact call implemented.", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r430742037", "createdAt": "2020-05-26T22:27:52Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -250,16 +253,15 @@ private void activateWorkerConnection(Connection workerConnection) {\n    */\n   private void scheduleLocalBackup(BackupPRequest request) {\n     mLocalBackupFuture = mExecutorService.submit(() -> {\n-      try (LockResource lr = new LockResource(mStatePauseLock)) {\n-        try {\n-          mBackupTracker.updateState(BackupState.Running);\n-          AlluxioURI backupUri = takeBackup(request, mBackupTracker.getEntryCounter());\n-          mBackupTracker.updateBackupUri(backupUri);\n-          mBackupTracker.updateState(BackupState.Completed);\n-        } catch (IOException e) {\n-          mBackupTracker.updateError(\n-              new BackupException(String.format(\"Local backup failed: %s\", e.getMessage()), e));\n-        }\n+      try (LockResource stateLockResource =\n+          new LockResource(mStatePauseLock, mStateLockTimeout, TimeUnit.MILLISECONDS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyNzU2Nw=="}, "originalCommit": {"oid": "6cfe2a93bb7453e501362d2cb2ebfc9263a1af23"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzIwODg3OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDo1NjozOFrOGbc1Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMTozMDozMFrOGbd3KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNzE1MA==", "bodyText": "are alluxio.master.backup.state.lock.timeout and alluxio.master.daily.backup.state.lock.timeout equivalent, but for CLI vs daily backup?", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r431437150", "createdAt": "2020-05-27T20:56:38Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4776,12 +4805,20 @@ private static String javadocLink(String fullyQualifiedClassname) {\n         \"alluxio.master.backup.connect.interval.max\";\n     public static final String MASTER_BACKUP_ABANDON_TIMEOUT =\n         \"alluxio.master.backup.abandon.timeout\";\n+    public static final String MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n+        \"alluxio.master.backup.state.lock.timeout\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2696924c2897af3d664e294a430e83a3993f19f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1Mzk5Mg==", "bodyText": "Yes.\nFor CLI only 1 configuration is exposed. Because other fine tunes are not required for interactive use.", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r431453992", "createdAt": "2020-05-27T21:30:30Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -4776,12 +4805,20 @@ private static String javadocLink(String fullyQualifiedClassname) {\n         \"alluxio.master.backup.connect.interval.max\";\n     public static final String MASTER_BACKUP_ABANDON_TIMEOUT =\n         \"alluxio.master.backup.abandon.timeout\";\n+    public static final String MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n+        \"alluxio.master.backup.state.lock.timeout\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNzE1MA=="}, "originalCommit": {"oid": "c2696924c2897af3d664e294a430e83a3993f19f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzI3NTY4OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToxODoxN1rOGbdgDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMTozNDoyM1rOGbd-UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODA3OA==", "bodyText": "is this supposed to be deadlineMs - System.currentTimeMillis()?", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r431448078", "createdAt": "2020-05-27T21:18:17Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "diffHunk": "@@ -70,6 +72,41 @@ public LockResource(Lock lock, boolean acquireLock, boolean useTryLock) {\n     }\n   }\n \n+  /**\n+   * Creates a new instance of {@link LockResource} using the given lock.\n+   *\n+   * This method will use the {@link Lock#tryLock(long, TimeUnit)} internally in a loop\n+   * for trying to grab the lock without causing total blockage of other waiters of the lock.\n+   *\n+   * @param lock  the lock to acquire\n+   * @param tryMs the duration to attempt acquiring the lock\n+   * @param sleepMs the wait duration after failed attempt to acquire the lock\n+   * @param timeoutMs the total duration to try acquiring the lock in a loop\n+   * @throws InterruptedException if interrupted while acquiring the lock\n+   * @throws TimeoutException if the lock was not acquired after given timeout\n+   */\n+  public LockResource(Lock lock, long tryMs, long sleepMs, long timeoutMs)\n+      throws InterruptedException, TimeoutException {\n+    mLock = lock;\n+    long deadlineMs = System.currentTimeMillis() + timeoutMs;\n+    boolean lockAcquired = false;\n+    while (System.currentTimeMillis() < deadlineMs) {\n+      if (mLock.tryLock(tryMs, TimeUnit.MILLISECONDS)) {\n+        lockAcquired = true;\n+        break;\n+      } else {\n+        long remainingWaitMs = deadlineMs = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2696924c2897af3d664e294a430e83a3993f19f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1NTgyNQ==", "bodyText": "nice catch! otherwise, it would always wait at the end and we'd never know.", "url": "https://github.com/Alluxio/alluxio/pull/11478#discussion_r431455825", "createdAt": "2020-05-27T21:34:23Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "diffHunk": "@@ -70,6 +72,41 @@ public LockResource(Lock lock, boolean acquireLock, boolean useTryLock) {\n     }\n   }\n \n+  /**\n+   * Creates a new instance of {@link LockResource} using the given lock.\n+   *\n+   * This method will use the {@link Lock#tryLock(long, TimeUnit)} internally in a loop\n+   * for trying to grab the lock without causing total blockage of other waiters of the lock.\n+   *\n+   * @param lock  the lock to acquire\n+   * @param tryMs the duration to attempt acquiring the lock\n+   * @param sleepMs the wait duration after failed attempt to acquire the lock\n+   * @param timeoutMs the total duration to try acquiring the lock in a loop\n+   * @throws InterruptedException if interrupted while acquiring the lock\n+   * @throws TimeoutException if the lock was not acquired after given timeout\n+   */\n+  public LockResource(Lock lock, long tryMs, long sleepMs, long timeoutMs)\n+      throws InterruptedException, TimeoutException {\n+    mLock = lock;\n+    long deadlineMs = System.currentTimeMillis() + timeoutMs;\n+    boolean lockAcquired = false;\n+    while (System.currentTimeMillis() < deadlineMs) {\n+      if (mLock.tryLock(tryMs, TimeUnit.MILLISECONDS)) {\n+        lockAcquired = true;\n+        break;\n+      } else {\n+        long remainingWaitMs = deadlineMs = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODA3OA=="}, "originalCommit": {"oid": "c2696924c2897af3d664e294a430e83a3993f19f"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1564, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}