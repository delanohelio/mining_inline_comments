{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4Nzk2NDg3", "number": 3970, "title": "memoize: Change CloseableMemoize to not serialize accepts", "bodyText": "Lots of javadoc improvements and other doc updates. Some more tests.", "createdAt": "2020-04-24T22:43:36Z", "url": "https://github.com/bndtools/bnd/pull/3970", "merged": true, "mergeCommit": {"oid": "f71ede287b197203e5860aaf33a2d30cd8726924"}, "closed": true, "closedAt": "2020-04-25T03:48:34Z", "author": {"login": "bjhargrave"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABca9y9ZgH2gAyNDA4Nzk2NDg3OjZkNDAxODdmYmMwYmYxNGVkMWNhMzM0YmEwZTc5ODMwNzUxMjgyYWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbDN5gAFqTQwMDM3ODEwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae", "author": {"user": {"login": "bjhargrave", "name": "BJ Hargrave"}}, "url": "https://github.com/bndtools/bnd/commit/6d40187fbc0bf14ed1ca334ba0e79830751282ae", "committedDate": "2020-04-25T03:47:59Z", "message": "memoize: Improve CloseableMemoize to not serialize accepts\n\nLots of javadoc improvements and other doc updates. Some more tests.\n\nSigned-off-by: BJ Hargrave <bj@bjhargrave.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzc4MTAy", "url": "https://github.com/bndtools/bnd/pull/3970#pullrequestreview-400378102", "createdAt": "2020-04-25T09:52:40Z", "commit": {"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTo1Mjo0MFrOGLzRjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTo1ODo1M1rOGLzVmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzU5OA==", "bodyText": "can elaborate why you're not directly writing it? It looks so strange so I assume you have reason for this?", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415027598", "createdAt": "2020-04-25T09:52:40Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNzg1Ng==", "bodyText": "this violates the contract that you call the supplier at most once ... if it throws an exception, the next get will call it again", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415027856", "createdAt": "2020-04-25T09:54:03Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());\n+\t\t\t\t\tmemoized = result;\n+\t\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\t\tinitial = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODMxOA==", "bodyText": "what is the reason memoized is not volatile? Makes things smaller and a lot more readable?", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415028318", "createdAt": "2020-04-25T09:56:40Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());\n+\t\t\t\t\tmemoized = result;\n+\t\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\t\tinitial = false;\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tlock.unlockWrite(stamp);\n \t\t\t}\n \t\t}\n-\t\treturn memoized;\n-\t}\n-\n-\tprivate T get0() {\n-\t\tif (memoized == null) {\n-\t\t\tmemoized = supplier.get();\n-\t\t\tassert memoized != null;\n+\t\tT result = memoized;\n+\t\tif (result == null) {\n+\t\t\tthrow new IllegalStateException(\"closed\");\n \t\t}\n-\t\treturn memoized;\n+\t\treturn result;\n \t}\n \n \t@Override\n \tpublic T peek() {\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyODYzNQ==", "bodyText": "making memoizd volatile saves a lot of this hard to read code, why doing it so complicated?", "url": "https://github.com/bndtools/bnd/pull/3970#discussion_r415028635", "createdAt": "2020-04-25T09:58:53Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -2,74 +2,109 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import java.util.concurrent.locks.StampedLock;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n+/**\n+ * The object can exist in one of three states:\n+ * <ul>\n+ * <li>initial which means neither {@code get} or {@code close} has been called.\n+ * From this state, the object can transition directly to either open or\n+ * closed.</li>\n+ * <li>open which means memoized is non-null with the value from the wrapped\n+ * supplier. From this state, the object can transition to closed.</li>\n+ * <li>closed which means memoized is null and any value it may have held was\n+ * closed. This is a terminal state.</li>\n+ * </ul>\n+ */\n class CloseableMemoizingSupplier<T extends AutoCloseable> implements CloseableMemoize<T> {\n \tprivate final Supplier<? extends T>\tsupplier;\n-\t// @GuardedBy(\"this\")\n-\tprivate boolean\t\t\t\t\t\tclosed\t= false;\n-\tprivate volatile T\t\t\t\t\tmemoized;\n+\tprivate final StampedLock\t\t\tlock;\n+\tprivate volatile boolean\t\t\tinitial;\n+\t// @GuardedBy(\"initial\")\n+\tprivate T\t\t\t\t\t\t\tmemoized;\n \n \tCloseableMemoizingSupplier(Supplier<? extends T> supplier) {\n \t\tthis.supplier = requireNonNull(supplier);\n+\t\tlock = new StampedLock();\n+\t\tinitial = true;\n \t}\n \n \t@Override\n \tpublic T get() {\n-\t\tif (memoized == null) {\n-\t\t\tsynchronized (this) {\n-\t\t\t\tif (closed)\n-\t\t\t\t\tthrow new IllegalStateException(\"Already closed\");\n-\t\t\t\treturn get0();\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tT result = requireNonNull(supplier.get());\n+\t\t\t\t\tmemoized = result;\n+\t\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\t\tinitial = false;\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tlock.unlockWrite(stamp);\n \t\t\t}\n \t\t}\n-\t\treturn memoized;\n-\t}\n-\n-\tprivate T get0() {\n-\t\tif (memoized == null) {\n-\t\t\tmemoized = supplier.get();\n-\t\t\tassert memoized != null;\n+\t\tT result = memoized;\n+\t\tif (result == null) {\n+\t\t\tthrow new IllegalStateException(\"closed\");\n \t\t}\n-\t\treturn memoized;\n+\t\treturn result;\n \t}\n \n \t@Override\n \tpublic T peek() {\n+\t\t// read initial _before_ read memoized\n+\t\tif (initial) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn memoized;\n \t}\n \n \t@Override\n-\tpublic synchronized boolean isClosed() {\n-\t\treturn closed;\n+\tpublic boolean isClosed() {\n+\t\t// read initial _before_ read memoized\n+\t\treturn !initial && (memoized == null);\n \t}\n \n \t@Override\n \tpublic void close() throws Exception {\n-\t\tT current;\n-\t\tsynchronized (this) {\n-\t\t\tif (closed)\n-\t\t\t\treturn;\n-\n-\t\t\tclosed = true;\n-\n-\t\t\tif (memoized == null)\n-\t\t\t\treturn;\n-\n-\t\t\tcurrent = memoized;\n-\t\t\tmemoized = null;\n+\t\tif (!isClosed()) {\n+\t\t\tAutoCloseable closeable;\n+\t\t\t// critical section: only one at a time\n+\t\t\tfinal long stamp = lock.writeLock();\n+\t\t\ttry {\n+\t\t\t\tif (initial) {\n+\t\t\t\t\tinitial = false;\n+\t\t\t\t\treturn; // no value to close\n+\t\t\t\t}\n+\t\t\t\tcloseable = memoized;\n+\t\t\t\tmemoized = null; // mark closed\n+\t\t\t\t// write initial _after_ write memoized\n+\t\t\t\tinitial = false; // even though it is already false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d40187fbc0bf14ed1ca334ba0e79830751282ae"}, "originalPosition": 117}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3048, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}