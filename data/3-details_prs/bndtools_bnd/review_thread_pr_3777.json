{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MzE1ODk0", "number": 3777, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzoyNDo1NFrODf400w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzoyNDo1NFrODf400w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzYzNDc1OnYy", "diffSide": "RIGHT", "path": "docs/_chapters/230-manifest-annotations.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMzoyNDo1NFrOFp2a9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNDoxOToyOFrOFp4AzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyNzU3Mw==", "bodyText": "This is not entirely true. See https://bnd.bndtools.org/chapters/235-accessor-properties.html.", "url": "https://github.com/bndtools/bnd/pull/3777#discussion_r379427573", "createdAt": "2020-02-14T13:24:54Z", "author": {"login": "bjhargrave"}, "path": "docs/_chapters/230-manifest-annotations.md", "diffHunk": "@@ -72,6 +71,26 @@ Require-Capability: \\\n \n The invisible link created between user code and the indirect requirement is a powerful mechanism that enables automatic validation of a bundle closure.\n \n+The actual requirement `filter:` directive is constructed from an `AND` of the `filter()`, `name()`, and `version()` annotation methods. All fields are optional. The name field will create an assertion that the given namespace equals the value of the `name()` annotation method. For example, if the namespace is `com.example.foo` and the `name()` method has the value `bar` then the filter is `(com.example.foo=bar)`. If a version is specified, it will be expanded to a filtered version-range expression.  The convention of using the namespace name as the property key is commonly used in OSGi specification. For example, the filter `(osgi.wiring.package=com.example.foo)` is the filter for an Import-Package `com.example.foo` while `osgi.wiring.package` is the namespace for the packages.\n+\n+The filter will **not** be processed for macros like the `@Header` annotation is. The filter can therefore not refer to any annotation methods in meta-annotated classes. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a1908ed95bb266dbb7abb3ec88381a16d8a494"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTUwMA==", "bodyText": "I spent half an hour going over the getFilter() method and I fail to see where -any- macro processing takes place on the filter. Am I missing something?", "url": "https://github.com/bndtools/bnd/pull/3777#discussion_r379439500", "createdAt": "2020-02-14T13:51:31Z", "author": {"login": "pkriens"}, "path": "docs/_chapters/230-manifest-annotations.md", "diffHunk": "@@ -72,6 +71,26 @@ Require-Capability: \\\n \n The invisible link created between user code and the indirect requirement is a powerful mechanism that enables automatic validation of a bundle closure.\n \n+The actual requirement `filter:` directive is constructed from an `AND` of the `filter()`, `name()`, and `version()` annotation methods. All fields are optional. The name field will create an assertion that the given namespace equals the value of the `name()` annotation method. For example, if the namespace is `com.example.foo` and the `name()` method has the value `bar` then the filter is `(com.example.foo=bar)`. If a version is specified, it will be expanded to a filtered version-range expression.  The convention of using the namespace name as the property key is commonly used in OSGi specification. For example, the filter `(osgi.wiring.package=com.example.foo)` is the filter for an Import-Package `com.example.foo` while `osgi.wiring.package` is the namespace for the packages.\n+\n+The filter will **not** be processed for macros like the `@Header` annotation is. The filter can therefore not refer to any annotation methods in meta-annotated classes. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyNzU3Mw=="}, "originalCommit": {"oid": "32a1908ed95bb266dbb7abb3ec88381a16d8a494"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NzcwMw==", "bodyText": "All results of AnnotationsHeaders are parsed by macros. It's not that the filter itself is processed, but the entire end result is processed here https://github.com/bndtools/bnd/blob/master/biz.aQute.bndlib/src/aQute/bnd/osgi/AnnotationHeaders.java#L979\nIn this way, any string contents of any attribute or value can contain macros.", "url": "https://github.com/bndtools/bnd/pull/3777#discussion_r379447703", "createdAt": "2020-02-14T14:07:57Z", "author": {"login": "rotty3000"}, "path": "docs/_chapters/230-manifest-annotations.md", "diffHunk": "@@ -72,6 +71,26 @@ Require-Capability: \\\n \n The invisible link created between user code and the indirect requirement is a powerful mechanism that enables automatic validation of a bundle closure.\n \n+The actual requirement `filter:` directive is constructed from an `AND` of the `filter()`, `name()`, and `version()` annotation methods. All fields are optional. The name field will create an assertion that the given namespace equals the value of the `name()` annotation method. For example, if the namespace is `com.example.foo` and the `name()` method has the value `bar` then the filter is `(com.example.foo=bar)`. If a version is specified, it will be expanded to a filtered version-range expression.  The convention of using the namespace name as the property key is commonly used in OSGi specification. For example, the filter `(osgi.wiring.package=com.example.foo)` is the filter for an Import-Package `com.example.foo` while `osgi.wiring.package` is the namespace for the packages.\n+\n+The filter will **not** be processed for macros like the `@Header` annotation is. The filter can therefore not refer to any annotation methods in meta-annotated classes. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyNzU3Mw=="}, "originalCommit": {"oid": "32a1908ed95bb266dbb7abb3ec88381a16d8a494"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTAyMQ==", "bodyText": "As @bjhargrave referenced, we have an entire feature built around this behaviour (which is tested) :) Furthermore, additional bnd features beyond bundle annotations use this such as SPI Annotations.", "url": "https://github.com/bndtools/bnd/pull/3777#discussion_r379451021", "createdAt": "2020-02-14T14:14:18Z", "author": {"login": "rotty3000"}, "path": "docs/_chapters/230-manifest-annotations.md", "diffHunk": "@@ -72,6 +71,26 @@ Require-Capability: \\\n \n The invisible link created between user code and the indirect requirement is a powerful mechanism that enables automatic validation of a bundle closure.\n \n+The actual requirement `filter:` directive is constructed from an `AND` of the `filter()`, `name()`, and `version()` annotation methods. All fields are optional. The name field will create an assertion that the given namespace equals the value of the `name()` annotation method. For example, if the namespace is `com.example.foo` and the `name()` method has the value `bar` then the filter is `(com.example.foo=bar)`. If a version is specified, it will be expanded to a filtered version-range expression.  The convention of using the namespace name as the property key is commonly used in OSGi specification. For example, the filter `(osgi.wiring.package=com.example.foo)` is the filter for an Import-Package `com.example.foo` while `osgi.wiring.package` is the namespace for the packages.\n+\n+The filter will **not** be processed for macros like the `@Header` annotation is. The filter can therefore not refer to any annotation methods in meta-annotated classes. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyNzU3Mw=="}, "originalCommit": {"oid": "32a1908ed95bb266dbb7abb3ec88381a16d8a494"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MzY0NQ==", "bodyText": "You are right, they are processed properly. But looking at Tim I was not the only one confused.", "url": "https://github.com/bndtools/bnd/pull/3777#discussion_r379453645", "createdAt": "2020-02-14T14:19:28Z", "author": {"login": "pkriens"}, "path": "docs/_chapters/230-manifest-annotations.md", "diffHunk": "@@ -72,6 +71,26 @@ Require-Capability: \\\n \n The invisible link created between user code and the indirect requirement is a powerful mechanism that enables automatic validation of a bundle closure.\n \n+The actual requirement `filter:` directive is constructed from an `AND` of the `filter()`, `name()`, and `version()` annotation methods. All fields are optional. The name field will create an assertion that the given namespace equals the value of the `name()` annotation method. For example, if the namespace is `com.example.foo` and the `name()` method has the value `bar` then the filter is `(com.example.foo=bar)`. If a version is specified, it will be expanded to a filtered version-range expression.  The convention of using the namespace name as the property key is commonly used in OSGi specification. For example, the filter `(osgi.wiring.package=com.example.foo)` is the filter for an Import-Package `com.example.foo` while `osgi.wiring.package` is the namespace for the packages.\n+\n+The filter will **not** be processed for macros like the `@Header` annotation is. The filter can therefore not refer to any annotation methods in meta-annotated classes. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyNzU3Mw=="}, "originalCommit": {"oid": "32a1908ed95bb266dbb7abb3ec88381a16d8a494"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1488, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}