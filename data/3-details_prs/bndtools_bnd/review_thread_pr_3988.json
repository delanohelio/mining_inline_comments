{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNjgwNDg1", "number": 3988, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzo0Mjo1MFrOD3ofYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzo0Mjo1MFrOD3ofYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjYxNjY3OnYy", "diffSide": "RIGHT", "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzo0Mjo1MFrOGN_cCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDowNToxOFrOGOAfRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNDA0Mw==", "bodyText": "Why not just return?\nWe should be nice in accepting nulls but rather strict in never returning nulls. Now you might force some to have to check.", "url": "https://github.com/bndtools/bnd/pull/3988#discussion_r417324043", "createdAt": "2020-04-29T13:42:50Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -107,6 +107,7 @@ public void close() throws Exception {\n \n \t@Override\n \tpublic CloseableMemoize<T> accept(Consumer<? super T> consumer) {\n+\t\trequireNonNull(consumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a77d1291cfd12d9a60037e9df1248cbad65cb51"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNTgxMw==", "bodyText": "I think it is a programming error to pass a null consumer. It may be ok to accept null for a collection argument as if it were an empty collection. But a consumer is code to execute.", "url": "https://github.com/bndtools/bnd/pull/3988#discussion_r417325813", "createdAt": "2020-04-29T13:45:06Z", "author": {"login": "bjhargrave"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -107,6 +107,7 @@ public void close() throws Exception {\n \n \t@Override\n \tpublic CloseableMemoize<T> accept(Consumer<? super T> consumer) {\n+\t\trequireNonNull(consumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNDA0Mw=="}, "originalCommit": {"oid": "4a77d1291cfd12d9a60037e9df1248cbad65cb51"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyODA4Mg==", "bodyText": "What is the rationale? Someone needs to check you or any of your N callers. There is a perfect case to make that null means 'do not call me'. By having such a default you just significantly reduce the error space of this function, i.e. you make it a complete function, without any cost on your side and potential savings on the caller side.", "url": "https://github.com/bndtools/bnd/pull/3988#discussion_r417328082", "createdAt": "2020-04-29T13:48:14Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -107,6 +107,7 @@ public void close() throws Exception {\n \n \t@Override\n \tpublic CloseableMemoize<T> accept(Consumer<? super T> consumer) {\n+\t\trequireNonNull(consumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNDA0Mw=="}, "originalCommit": {"oid": "4a77d1291cfd12d9a60037e9df1248cbad65cb51"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMzNTg0Nw==", "bodyText": "It is the general contract of methods taking a Consumer, that the Consumer be non-null.\nFor example from java.util.function.Consumer itself:\nhttps://github.com/openjdk/jdk/blob/478773c10278d86a4b81d2ad5382f7314cee4c17/src/java.base/share/classes/java/util/function/Consumer.java#L63-L66\nThis code already required that. I just move the check earlier to avoid memoizing when you would NPE anyway later in the code.\nBy allowing null to mean no-op you avoid catching programming errors early.\nI think it is a bad idea to allow null here as it hides programming errors.", "url": "https://github.com/bndtools/bnd/pull/3988#discussion_r417335847", "createdAt": "2020-04-29T13:58:20Z", "author": {"login": "bjhargrave"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -107,6 +107,7 @@ public void close() throws Exception {\n \n \t@Override\n \tpublic CloseableMemoize<T> accept(Consumer<? super T> consumer) {\n+\t\trequireNonNull(consumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNDA0Mw=="}, "originalCommit": {"oid": "4a77d1291cfd12d9a60037e9df1248cbad65cb51"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0MTI1Mw==", "bodyText": "I know it is a common pattern in Java, but sadly so are checked exceptions. I just do not like the extra error space you allow by having incomplete functions. The idea that you catch programming errors this way is a bit like hitting your head hard against a wall and then when you stop saying that it feels so good. You just force the error handling on the N callers.\nBut it is a matter of style and we do not have a style book.", "url": "https://github.com/bndtools/bnd/pull/3988#discussion_r417341253", "createdAt": "2020-04-29T14:05:18Z", "author": {"login": "pkriens"}, "path": "aQute.libg/src/aQute/lib/memoize/CloseableMemoizingSupplier.java", "diffHunk": "@@ -107,6 +107,7 @@ public void close() throws Exception {\n \n \t@Override\n \tpublic CloseableMemoize<T> accept(Consumer<? super T> consumer) {\n+\t\trequireNonNull(consumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyNDA0Mw=="}, "originalCommit": {"oid": "4a77d1291cfd12d9a60037e9df1248cbad65cb51"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1400, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}