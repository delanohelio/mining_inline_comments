{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3OTc3Njg0", "number": 59376, "title": "Cache API key doc to reduce traffic to the security index", "bodyText": "Getting the API key document form the security index is the most time consuing part of the authentication flow (>60% if index is local and >90% if index is remote). This traffic can be avoided with cache. Initially we also plan to avoid deserialising source of GetApiKeyDocument response if \"primary term\" and \"sequence number\" are unchanged. However, given the document fetching itself is dominant in execution time, it does not seem to be worthwhile to optimise for deserialisation. Hence, for uncached document, the cache will fetch the document and also simply deserialise it without further checking.\nWhen a large number of API keys are in use, we expect most of them are created with exactly the same role-descriptors and limited-by-role-descriptors. It is wasteful to cache these identical role descriptors repeatitively for different API keys. Hence a two layer caches are put in place:\n\nThe first cache is keyed by docId and values are content of the API key document, except that the role-descriptors and limited-by-role-descriptors are replacecd by their sha256 hashes respectively.\nThe second cache is keyed by the above sha256 hashes and values are the corresponding role-descriptors.\n\nThe lifecyces of the above two caches are mostly tied together and they need work together in a way to ensure least possibility of stale results. Hence a new SecurityCaches class is added and it implements all necessary handlings as discussed in #55836.\n@tvernum This is a quick attempt to implement a cache for API key document. It intentionally omits some parts, e.g. tests, configuration, to get a quick turnaround for proving the idea. It is easier to discuss when we have something concrete. We could try formalise it for v7.9 if feasible. But I am also OK to delay it if more careful evaluation is needed. Thanks!\nResolves: #53940", "createdAt": "2020-07-13T00:30:16Z", "url": "https://github.com/elastic/elasticsearch/pull/59376", "merged": true, "mergeCommit": {"oid": "9e1f912cccfbc1aac79352b17902077e0815e68b"}, "closed": true, "closedAt": "2020-10-06T10:41:26Z", "author": {"login": "ywangd"}, "timelineItems": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1AVJbABqjM1NDY0OTQ0MzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP0UIUgFqTUwMjcxMzM1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8fa3869d10878442598957bf31fb1082e642de92", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/8fa3869d10878442598957bf31fb1082e642de92", "committedDate": "2020-07-13T00:25:25Z", "message": "WIP: add cache for API Key document."}, "afterCommit": {"oid": "32a7a3195ceb4bdce7d8c50d9ed0a94171144b7e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/32a7a3195ceb4bdce7d8c50d9ed0a94171144b7e", "committedDate": "2020-07-15T01:25:26Z", "message": "WIP: add cache for API Key document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7501b0502006ea5cc566d3cbadfe7fff1a014e95", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/7501b0502006ea5cc566d3cbadfe7fff1a014e95", "committedDate": "2020-07-20T06:09:23Z", "message": "WIP: add cache for API Key document."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32a7a3195ceb4bdce7d8c50d9ed0a94171144b7e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/32a7a3195ceb4bdce7d8c50d9ed0a94171144b7e", "committedDate": "2020-07-15T01:25:26Z", "message": "WIP: add cache for API Key document."}, "afterCommit": {"oid": "7501b0502006ea5cc566d3cbadfe7fff1a014e95", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/7501b0502006ea5cc566d3cbadfe7fff1a014e95", "committedDate": "2020-07-20T06:09:23Z", "message": "WIP: add cache for API Key document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97e1318e5092940c4efc1ab4c1cb63c541cde4aa", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/97e1318e5092940c4efc1ab4c1cb63c541cde4aa", "committedDate": "2020-08-03T05:48:15Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c166c13a97effe3d01bcd31f6206cefdb0787af0", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/c166c13a97effe3d01bcd31f6206cefdb0787af0", "committedDate": "2020-08-10T02:15:02Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df2a1d8614a9ac1631e1183ea265fdc7c48d8651", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/df2a1d8614a9ac1631e1183ea265fdc7c48d8651", "committedDate": "2020-08-11T06:51:53Z", "message": "WIP: Have one cache for API key doc and auth result."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e20dad8b78a364ce653aea638b33d3e6de5d7ef4", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/e20dad8b78a364ce653aea638b33d3e6de5d7ef4", "committedDate": "2020-08-12T04:17:09Z", "message": "Revert \"WIP: Have one cache for API key doc and auth result.\"\n\nThis reverts commit df2a1d8614a9ac1631e1183ea265fdc7c48d8651."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f425470e8d3aa8117320f593bbd50f2984d2f527", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/f425470e8d3aa8117320f593bbd50f2984d2f527", "committedDate": "2020-08-13T06:34:04Z", "message": "Add security cache common behaviours and handlers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5536b88112c7039a0fff7b3fd3f6e9dbac7e771f", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5536b88112c7039a0fff7b3fd3f6e9dbac7e771f", "committedDate": "2020-08-13T06:44:29Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05dc6aeab88099dd9a1b3720d43e05d9e1062614", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/05dc6aeab88099dd9a1b3720d43e05d9e1062614", "committedDate": "2020-08-13T08:05:50Z", "message": "Fix for no cache scenario"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5c690b5e45da3ea518b4fad358cf71e3797e6a2", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5c690b5e45da3ea518b4fad358cf71e3797e6a2", "committedDate": "2020-08-13T08:06:06Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzQzNzI2", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-466743726", "createdAt": "2020-08-13T13:08:51Z", "commit": {"oid": "c5c690b5e45da3ea518b4fad358cf71e3797e6a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowODo1MVrOHAKumQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowODo1MVrOHAKumQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNzgxNw==", "bodyText": "I think we probably prefer to have a singleton instance for this class similar to all other components. If so, I can make it so and have it injected into the Transport action.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r469937817", "createdAt": "2020-08-13T13:08:51Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/SecurityCacheRegistry.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+public class SecurityCacheRegistry {\n+\n+    private static final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5c690b5e45da3ea518b4fad358cf71e3797e6a2"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e62e81021a6c7a8d01bd506103985a90be22532", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9e62e81021a6c7a8d01bd506103985a90be22532", "committedDate": "2020-09-04T03:04:52Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0b3bd0911ce7cea7d2d03fa3d8996362cf828fd", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/a0b3bd0911ce7cea7d2d03fa3d8996362cf828fd", "committedDate": "2020-09-07T03:34:19Z", "message": "Simplify security cache based on feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33a75532fd10928f71d9264beb2b5abef0650fa4", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/33a75532fd10928f71d9264beb2b5abef0650fa4", "committedDate": "2020-09-07T03:45:14Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzg0OTMx", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-483784931", "createdAt": "2020-09-08T04:20:03Z", "commit": {"oid": "33a75532fd10928f71d9264beb2b5abef0650fa4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNDoyMDowNFrOHOMKXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNDoyNTowNVrOHOMOxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MTM3NQ==", "bodyText": "I wonder about this.\nIt defaults to 24h, and we don 't have much in place to clean it up.\nShould it really cache for that long? It's expiry after access, so 1h feels like it would be sufficient.\nFrom my brief reading, once the doc cache expires (5m after last write) there will be no incoming references to these entries. They may get revived, but I don't think holding onto that memory for 24h is justified.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484641375", "createdAt": "2020-09-08T04:20:04Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -192,14 +199,42 @@ public ApiKeyService(Settings settings, Clock clock, Client client, XPackLicense\n         this.threadPool = threadPool;\n         this.cacheHasher = Hasher.resolve(CACHE_HASH_ALGO_SETTING.get(settings));\n         final TimeValue ttl = CACHE_TTL_SETTING.get(settings);\n+        final Integer maximumWeight = CACHE_MAX_KEYS_SETTING.get(settings);\n         if (ttl.getNanos() > 0) {\n             this.apiKeyAuthCache = CacheBuilder.<String, ListenableFuture<CachedApiKeyHashResult>>builder()\n                 .setExpireAfterWrite(ttl)\n-                .setMaximumWeight(CACHE_MAX_KEYS_SETTING.get(settings))\n+                .setMaximumWeight(maximumWeight)\n                 .build();\n+            this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()\n+                .setExpireAfterAccess(ttl)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a75532fd10928f71d9264beb2b5abef0650fa4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MjM0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void invalidate(String name, Collection<String> keys) {\n          \n          \n            \n                public static void invalidateByKey(String cacheName, Collection<String> keys) {", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484642342", "createdAt": "2020-09-08T04:24:26Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistry.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+/**\n+ * A registry that provides common cache invalidation services for caches that relies on the security index.\n+ */\n+public class CacheInvalidatorRegistry {\n+\n+    private static final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();\n+\n+    public static void registerCacheInvalidator(String name, CacheInvalidator cacheInvalidator) {\n+        // TODO: check no overriding entries\n+        cacheInvalidators.put(name, cacheInvalidator);\n+    }\n+\n+    public static void onSecurityIndexStageChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState)\n+            || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            cacheInvalidators.values().forEach(CacheInvalidator::invalidateAll);\n+        }\n+    }\n+\n+    public static void invalidate(String name, Collection<String> keys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a75532fd10928f71d9264beb2b5abef0650fa4"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY0MjUwMQ==", "bodyText": "This name implies invalidating all caches, not all entries in 1 cache.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void invalidateAll(String name) {\n          \n          \n            \n                public static void invalidateCache(String cacheName) {", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r484642501", "createdAt": "2020-09-08T04:25:05Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistry.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+/**\n+ * A registry that provides common cache invalidation services for caches that relies on the security index.\n+ */\n+public class CacheInvalidatorRegistry {\n+\n+    private static final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();\n+\n+    public static void registerCacheInvalidator(String name, CacheInvalidator cacheInvalidator) {\n+        // TODO: check no overriding entries\n+        cacheInvalidators.put(name, cacheInvalidator);\n+    }\n+\n+    public static void onSecurityIndexStageChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState)\n+            || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            cacheInvalidators.values().forEach(CacheInvalidator::invalidateAll);\n+        }\n+    }\n+\n+    public static void invalidate(String name, Collection<String> keys) {\n+        final CacheInvalidator cacheInvalidator = cacheInvalidators.get(name);\n+        if (cacheInvalidator != null) {\n+            cacheInvalidator.invalidate(keys);\n+        }\n+    }\n+\n+    public static void invalidateAll(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a75532fd10928f71d9264beb2b5abef0650fa4"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aafed3f0ae978c6788dcfe7236831d0ee65ef407", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/aafed3f0ae978c6788dcfe7236831d0ee65ef407", "committedDate": "2020-09-08T14:25:38Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "283d1f5628ef575e7daa82934760c126aaaa2fe3", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/283d1f5628ef575e7daa82934760c126aaaa2fe3", "committedDate": "2020-09-08T14:29:15Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d23ce6c1c3554fe88d11375b6788f2c30f29ed", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/57d23ce6c1c3554fe88d11375b6788f2c30f29ed", "committedDate": "2020-09-08T14:41:51Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fc0a0215f202af77c48a821c201bec555ac1654", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/0fc0a0215f202af77c48a821c201bec555ac1654", "committedDate": "2020-09-11T02:00:14Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c94e0037979e057cc4a3f5c8d37a9bd3bb7d2318", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/c94e0037979e057cc4a3f5c8d37a9bd3bb7d2318", "committedDate": "2020-09-18T06:38:41Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a7b0a78dac4997aa2f1e93575538208b62a3d13", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a7b0a78dac4997aa2f1e93575538208b62a3d13", "committedDate": "2020-09-21T03:55:05Z", "message": "Add tests for api key doc caches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17c6f3a58ed120e56bab0dd5b11d9c5adb875f65", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/17c6f3a58ed120e56bab0dd5b11d9c5adb875f65", "committedDate": "2020-09-21T04:07:28Z", "message": "One more scenario for cache miss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32fcccfc84910059ff18e21f7a605507cd8b2c3f", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/32fcccfc84910059ff18e21f7a605507cd8b2c3f", "committedDate": "2020-09-21T04:37:59Z", "message": "Replace static class with the existing component pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fda220bce75bce69549965d4330691b6c46cc3bd", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/fda220bce75bce69549965d4330691b6c46cc3bd", "committedDate": "2020-09-21T05:02:26Z", "message": "Add tests for consistent cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abfb40c14f662b627faa11f344f7778c0ecaa1fb", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/abfb40c14f662b627faa11f344f7778c0ecaa1fb", "committedDate": "2020-09-21T05:20:31Z", "message": "Add tests for cache invalidator registry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f7a586e48d3e68e0f511e50a4ddf5d622cd31f3", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/3f7a586e48d3e68e0f511e50a4ddf5d622cd31f3", "committedDate": "2020-09-21T06:37:53Z", "message": "Add tests for integration tests for cache invalidation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41cc5957e313b4eeafe2255469b63a4aac5781f5", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/41cc5957e313b4eeafe2255469b63a4aac5781f5", "committedDate": "2020-09-21T06:48:20Z", "message": "Minor test tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36ae9c85acefcf0525f1acd2c6fca5cee150791f", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/36ae9c85acefcf0525f1acd2c6fca5cee150791f", "committedDate": "2020-09-21T08:29:25Z", "message": "Add client code, yaml tests and documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "066dbb8aeb0d0edac1836aa1f16f25ab253859d6", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/066dbb8aeb0d0edac1836aa1f16f25ab253859d6", "committedDate": "2020-09-21T08:36:11Z", "message": "Fix json spec file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b78eeec1955f2cf36d69b96e39d564aea73c8e7e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/b78eeec1955f2cf36d69b96e39d564aea73c8e7e", "committedDate": "2020-09-21T08:53:57Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/26741a405a2e1eb931068ee1d8951a0c241e42fe", "committedDate": "2020-09-21T11:05:35Z", "message": "update doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTE3MTYz", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-500517163", "createdAt": "2020-10-01T16:22:44Z", "commit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjoyMjo0NFrOHbSDIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjoyMjo0NFrOHbSDIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2OTMxMg==", "bodyText": "do we really need a lock to protect an atomic variable? What does this achieve.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r498369312", "createdAt": "2020-10-01T16:22:44Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/ConsistentCache.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * A wrapper of {@link Cache} that minimizes the possibility of caching stale results.\n+ */\n+public class ConsistentCache<K, V> {\n+\n+    private static final Logger logger = LogManager.getLogger(ConsistentCache.class);\n+\n+    private final Cache<K, V> delegate;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n+    private final ReadWriteLock invalidationLock = new ReentrantReadWriteLock();\n+    private final ReleasableLock invalidationReadLock = new ReleasableLock(invalidationLock.readLock());\n+    private final ReleasableLock invalidationWriteLock = new ReleasableLock(invalidationLock.writeLock());\n+\n+    public ConsistentCache(Cache<K, V> delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    public Checkpoint<K, V> checkpoint() {\n+        final long invalidationCounter = numInvalidation.get();\n+        return (key, value) -> {\n+            try (ReleasableLock ignored = invalidationReadLock.acquire()) {\n+                if (invalidationCounter == numInvalidation.get()) {\n+                    logger.debug(\"Caching for key [{}], value [{}]\", key, value);\n+                    delegate.put(key, value);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+    }\n+\n+    public V get(K key) {\n+        return delegate.get(key);\n+    }\n+\n+    // If there are secondary caches that must be invalidated when the main\n+    // entry is invalidated, they can be registered via the removalListener\n+    public void invalidate(Collection<K> keys) {\n+        try (ReleasableLock ignored = invalidationWriteLock.acquire()) {\n+            numInvalidation.incrementAndGet();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTYyNzU2", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-500562756", "createdAt": "2020-10-01T17:21:30Z", "commit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoyMTozMVrOHbUDBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoyMTozMVrOHbUDBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjA1NQ==", "bodyText": "It's a bit hard to understand the reasoning for the \"consistent cache\" here.\nMy understanding is that you're trying to guard against a doc update (a call to invalidate a key), followed by a cache clear call (they are currently separate endpoints), after the doc has been retrieved by the get, but before the handler is called. IMO, this is a narrow time window for this big of a complication (the ConsistentCache complication).\nAlternatively, what do you say you make the current invalidation counter part of the cached value (the CachedApiKeyDoc instance). In this case, you always populate the cache values with the current invalidation counter, but you never use a cache entry with an older invalidation counter compared to the current (you remove the entry and try the get).", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r498402055", "createdAt": "2020-10-01T17:21:31Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -364,13 +425,16 @@ private void loadApiKeyAndValidateCredentials(ThreadContext ctx, ApiKeyCredentia\n                         response.getSourceAsBytesRef(), XContentType.JSON)) {\n                         apiKeyDoc = ApiKeyDoc.fromXContent(parser);\n                     }\n-                    validateApiKeyCredentials(docId, apiKeyDoc, credentials, clock, ActionListener.delegateResponse(listener, (l, e) -> {\n-                        if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n-                            listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n-                        } else {\n-                            listener.onFailure(e);\n+                    if (checkpoint != null) {\n+                        final CachedApiKeyDoc cachedApiKeyDoc = apiKeyDoc.toCachedApiKeyDoc();\n+                        if (checkpoint.put(docId, cachedApiKeyDoc)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTMzMjQy", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-501533242", "createdAt": "2020-10-03T09:21:08Z", "commit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwOToyMTowOFrOHcAlrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxNToxOTo0NVrOHcCGOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTgyMw==", "bodyText": "I would suggest there be an enum for the cache names. But this to me shows that it's not quite suitable as a request param.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499131823", "createdAt": "2020-10-03T09:21:08Z", "author": {"login": "albertzaharovits"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/ClearSecurityCacheRequest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+/**\n+ * The request used to clear the specified cache.\n+ */\n+public final class ClearSecurityCacheRequest implements Validatable {\n+\n+    private final String cacheName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMzMwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            security.\n          \n          \n            \n            privilege.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499133307", "createdAt": "2020-10-03T09:43:28Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/docs/en/rest-api/security/clear-security-cache.asciidoc", "diffHunk": "@@ -0,0 +1,54 @@\n+[role=\"xpack\"]\n+[[security-api-clear-security-cache]]\n+=== Clear security cache API\n+++++\n+<titleabbrev>Clear security cache</titleabbrev>\n+++++\n+\n+Evicts a subset of all entries from the specified security cache.\n+The cache is also automatically cleared on state changes of the security index.\n+\n+NOTE: The intention for the clear security cache API is to have a single endpoint\n+for clearing all security related caches. Currently, it only covers API key\n+caches. For clearing user cache, see the <<security-api-clear-cache,Clear user cache API>>.\n+For clearing role cache, see the <<security-api-clear-role-cache,Clear roles cache API>>.\n+For clearing privileges, see <<security-api-clear-privilege-cache,Clear privileges cache API>>.\n+These separate APIs will be migrated over time.\n+\n+\n+[[security-api-clear-security-cache-request]]\n+==== {api-request-title}\n+\n+`POST /_security/<cache_name>/<keys>/_clear_cache`\n+\n+[[security-api-clear-security-cache-prereqs]]\n+==== {api-prereq-title}\n+\n+* To use this API, you must have at least the `manage_security` cluster\n+security.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0MDA0Mw==", "bodyText": "Thank you @ywangd for the detailed explanation!\nI understand it fully now, both the invalidation counter and the locking. You are right.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499140043", "createdAt": "2020-10-03T11:29:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -364,13 +425,16 @@ private void loadApiKeyAndValidateCredentials(ThreadContext ctx, ApiKeyCredentia\n                         response.getSourceAsBytesRef(), XContentType.JSON)) {\n                         apiKeyDoc = ApiKeyDoc.fromXContent(parser);\n                     }\n-                    validateApiKeyCredentials(docId, apiKeyDoc, credentials, clock, ActionListener.delegateResponse(listener, (l, e) -> {\n-                        if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n-                            listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n-                        } else {\n-                            listener.onFailure(e);\n+                    if (checkpoint != null) {\n+                        final CachedApiKeyDoc cachedApiKeyDoc = apiKeyDoc.toCachedApiKeyDoc();\n+                        if (checkpoint.put(docId, cachedApiKeyDoc)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjA1NQ=="}, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0OTI1MA==", "bodyText": "Personally, putting myself in the shoes of the user, I don't think a general API like this is an improvement over what there is already:\n\n/_security/realm/{realms}/_clear_cache\n/_security/role/{name}/_clear_cache\n/_security/privilege/{application}/_clear_cache\n\nI think it is good that we're combining the transport actions under a single one, like a function with parameters which is called from the REST handler.\nBut the cache_name, and especially the keys parameters, are not easy to figure out by the caller and they require reading the javadocs (eg when you clear the api key cache are the keys the API key ids or the API key names). For the existing APIs, it is easy to tell what the value of the parameter should be from the name of the parameter itself. The value of the parameters is also something that the calling user created (e.g. a role), not the name of an internal object (e.g. the caller modified some entity (e.g. role/application privilege), and it should clear the cache for that entity, almost the same URL path).\nIf you still think that the cache name should be a parameter that the caller fills, then I would suggest:\nPOST _security/caches/{name}/_clear with optional URL parameters for the keys parameter.\nMy suggestion for the clear cache for API keys is\nPOST _security/api_key/_clear_cache, given the existing structure of API key APIs, and I wouldn't worry about parameters (but if we must, then they'd be in the request body, again to jibe with the other APIs).", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499149250", "createdAt": "2020-10-03T13:46:45Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/RestClearSecurityCacheAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestActions.NodesResponseRestListener;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheAction;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheRequest;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+\n+public class RestClearSecurityCacheAction extends SecurityBaseRestHandler {\n+\n+    public RestClearSecurityCacheAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"security_clear_cache_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return Collections.singletonList(new Route(POST, \"/_security/{cache_name}/{keys}/_clear_cache\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDIxNA==", "bodyText": "I don't think that the class name or the documentation help in understanding when all this is needed, i.e. what is consistency in this case? Is the regular Cache inconsistent?\nSimilarly with the checkpoint caller. I need to read the code to have any clue of what a checkpoint.put does.\nMy feeling is that you're trying too hard to hide the lock and the counter.\nWhat do you say of something like:\npublic class CacheInvalidationHelper<K, V> {\n\n    private final Cache<K, V> cache;\n    private final AtomicLong currentInvalidationCounter = new AtomicLong();\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final ReleasableLock putLock = new ReleasableLock(lock.readLock());\n    private final ReleasableLock invalidateLock = new ReleasableLock(lock.writeLock());\n\n    public CacheInvalidationHelper(Cache<K, V> cache) {\n        this.cache = cache;\n    }\n\n    public Long getCurrentInvalidationCount() {\n        return this.currentInvalidationCounter.get();\n    }\n\n    public void putIfNoInvalidationSince(K key, V value, Long previousInvalidationCounter) {\n        try (ReleasableLock ignored = putLock.acquire()) {\n            if (previousInvalidationCounter == currentInvalidationCounter.get()) {\n                cache.put(key, value);\n            }\n        }\n    }\n\n    public void invalidate(K key) {\n        try (ReleasableLock ignored = invalidateLock.acquire()) {\n            currentInvalidationCounter.incrementAndGet();\n        }\n        cache.invalidate(key);\n    }\n\n    public void invalidateAll() {\n        try (ReleasableLock ignored = invalidateLock.acquire()) {\n            currentInvalidationCounter.incrementAndGet();\n        }\n        cache.invalidateAll();\n    }\n}", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499154214", "createdAt": "2020-10-03T14:49:50Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/ConsistentCache.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.util.concurrent.ReleasableLock;\n+\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * A wrapper of {@link Cache} that minimizes the possibility of caching stale results.\n+ */\n+public class ConsistentCache<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NDU0NQ==", "bodyText": "I think \"expire after use\" is more suitable here. There's no reason to evict an in-use cached credential. What do you think?", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499154545", "createdAt": "2020-10-03T14:53:48Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -192,14 +199,42 @@ public ApiKeyService(Settings settings, Clock clock, Client client, XPackLicense\n         this.threadPool = threadPool;\n         this.cacheHasher = Hasher.resolve(CACHE_HASH_ALGO_SETTING.get(settings));\n         final TimeValue ttl = CACHE_TTL_SETTING.get(settings);\n+        final Integer maximumWeight = CACHE_MAX_KEYS_SETTING.get(settings);\n         if (ttl.getNanos() > 0) {\n             this.apiKeyAuthCache = CacheBuilder.<String, ListenableFuture<CachedApiKeyHashResult>>builder()\n                 .setExpireAfterWrite(ttl)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NTg2Mg==", "bodyText": "This note here doesn't sound too \"professional\".\nWe have APIs and deprecated APIs , but no APIs that should do the job of others but not yet.\nWe can create an API now that we foresee will be deprecated. There is no rush, people can sit on a version for a long time.\nNot a big deal, just my thoughts.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499155862", "createdAt": "2020-10-03T15:11:41Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/docs/en/rest-api/security/clear-security-cache.asciidoc", "diffHunk": "@@ -0,0 +1,54 @@\n+[role=\"xpack\"]\n+[[security-api-clear-security-cache]]\n+=== Clear security cache API\n+++++\n+<titleabbrev>Clear security cache</titleabbrev>\n+++++\n+\n+Evicts a subset of all entries from the specified security cache.\n+The cache is also automatically cleared on state changes of the security index.\n+\n+NOTE: The intention for the clear security cache API is to have a single endpoint\n+for clearing all security related caches. Currently, it only covers API key\n+caches. For clearing user cache, see the <<security-api-clear-cache,Clear user cache API>>.\n+For clearing role cache, see the <<security-api-clear-role-cache,Clear roles cache API>>.\n+For clearing privileges, see <<security-api-clear-privilege-cache,Clear privileges cache API>>.\n+These separate APIs will be migrated over time.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NTk1OQ==", "bodyText": "Too bad this doesn't return the failed nodes. Not something to tackle atm.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499155959", "createdAt": "2020-10-03T15:12:59Z", "author": {"login": "albertzaharovits"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/ClearSecurityCacheResponse.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.NodesResponseHeader;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * The response object that will be returned when clearing a security cache\n+ */\n+public final class ClearSecurityCacheResponse extends SecurityNodesResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NjUzNg==", "bodyText": "As a possible refactoring in the future, the logic that puts and gets an API key doc into the cache, which uses a secondary cache for the role descriptors is a nice thing to encapsulate.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499156536", "createdAt": "2020-10-03T15:19:45Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -364,13 +425,16 @@ private void loadApiKeyAndValidateCredentials(ThreadContext ctx, ApiKeyCredentia\n                         response.getSourceAsBytesRef(), XContentType.JSON)) {\n                         apiKeyDoc = ApiKeyDoc.fromXContent(parser);\n                     }\n-                    validateApiKeyCredentials(docId, apiKeyDoc, credentials, clock, ActionListener.delegateResponse(listener, (l, e) -> {\n-                        if (ExceptionsHelper.unwrapCause(e) instanceof EsRejectedExecutionException) {\n-                            listener.onResponse(AuthenticationResult.terminate(\"server is too busy to respond\", e));\n-                        } else {\n-                            listener.onFailure(e);\n+                    if (checkpoint != null) {\n+                        final CachedApiKeyDoc cachedApiKeyDoc = apiKeyDoc.toCachedApiKeyDoc();\n+                        if (checkpoint.put(docId, cachedApiKeyDoc)) {\n+                            roleDescriptorsBytesCache.computeIfAbsent(\n+                                cachedApiKeyDoc.roleDescriptorsHash, k -> apiKeyDoc.roleDescriptorsBytes);\n+                            roleDescriptorsBytesCache.computeIfAbsent(\n+                                cachedApiKeyDoc.limitedByRoleDescriptorsHash, k -> apiKeyDoc.limitedByRoleDescriptorsBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26741a405a2e1eb931068ee1d8951a0c241e42fe"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e828b476405524c0b26c2675440152e9f5114da", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/7e828b476405524c0b26c2675440152e9f5114da", "committedDate": "2020-10-04T11:33:12Z", "message": "Address feedback: simplify consistent cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d24f0a92fd917dd248e023873d3514b85dcb326", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d24f0a92fd917dd248e023873d3514b85dcb326", "committedDate": "2020-10-04T12:05:45Z", "message": "Address feedback: only expose clear api key cache API. Client side dedicate clear api key cache request class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "748ddbb9efcbb369bb2e7050c8fb505b3f71aef4", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/748ddbb9efcbb369bb2e7050c8fb505b3f71aef4", "committedDate": "2020-10-04T12:58:11Z", "message": "Add cache clear call after key invalidation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52d793a3ce6dd9dec22cb88675d4232035761ec4", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/52d793a3ce6dd9dec22cb88675d4232035761ec4", "committedDate": "2020-10-04T13:07:17Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3b683e5f699994628d1dfa10851bcd2da004c5e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/f3b683e5f699994628d1dfa10851bcd2da004c5e", "committedDate": "2020-10-04T13:08:42Z", "message": "More check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "720ee2aa174c758540989eb66572fc64933ef182", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/720ee2aa174c758540989eb66572fc64933ef182", "committedDate": "2020-10-04T22:39:48Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52e4d6b42d14e0c356d2560daa67040642a69d38", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/52e4d6b42d14e0c356d2560daa67040642a69d38", "committedDate": "2020-10-04T23:29:02Z", "message": "Refactor to better manage the secondary role descriptor cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "901e85f4f011e33c45a0a851c0f4ed223102c539", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/901e85f4f011e33c45a0a851c0f4ed223102c539", "committedDate": "2020-10-04T23:37:05Z", "message": "null check optimize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70ab17bb566320da7a23e81676e309438705ed5b", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/70ab17bb566320da7a23e81676e309438705ed5b", "committedDate": "2020-10-04T23:47:11Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cbffa3eb2df1010ceffe7124650b1c02ac4f1b8", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/4cbffa3eb2df1010ceffe7124650b1c02ac4f1b8", "committedDate": "2020-10-05T00:28:39Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac8ca3591b4d593eab8b1f53752f5a1d5bec5bda", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac8ca3591b4d593eab8b1f53752f5a1d5bec5bda", "committedDate": "2020-10-05T02:20:16Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11e591babca2733bc1ce37c692989e38c9586350", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/11e591babca2733bc1ce37c692989e38c9586350", "committedDate": "2020-10-05T09:17:40Z", "message": "Address feedback - add dedicated rest action for clear api key cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe0922581dad62fb59a72dd4dbb55f80bfbc5866", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe0922581dad62fb59a72dd4dbb55f80bfbc5866", "committedDate": "2020-10-06T00:00:11Z", "message": "Merge remote-tracking branch 'origin/master' into es-53940-apikey-getdoc-avoidance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/fb29d5256825db9a4afcb0e7445eb0d50f2c7393", "committedDate": "2020-10-06T00:29:06Z", "message": "Remove clear security request base class from client code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNTQyOTY2", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-502542966", "createdAt": "2020-10-06T02:31:49Z", "commit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMjozMTo0OVrOHcz5UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMzozNzo0NlrOHc01mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MjQzMw==", "bodyText": "Nit: There's no reason to use addPathPartAsIs for one and addPathPart for the other part.\nSeeing different methods being called here, makes the reader try and work out why they're different, but as far as I can tell, there is no reason, and it could just be any one of these:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .addPathPartAsIs(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n          \n            \n                        .addPathPart(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .addPathPartAsIs(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n          \n            \n                        .addPathPart(\"_security\", \"api_key\")\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .addPathPartAsIs(\"_security\")\n          \n          \n            \n                        .addPathPart(\"api_key\")\n          \n          \n            \n                        .addPathPartAsIs(\"_security/api_key\")", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499972433", "createdAt": "2020-10-06T02:31:49Z", "author": {"login": "tvernum"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SecurityRequestConverters.java", "diffHunk": "@@ -184,10 +185,20 @@ static Request clearRolesCache(ClearRolesCacheRequest disableCacheRequest) {\n         return new Request(HttpPost.METHOD_NAME, endpoint);\n     }\n \n-    static Request clearPrivilegesCache(ClearPrivilegesCacheRequest disableCacheRequest) {\n+    static Request clearPrivilegesCache(ClearPrivilegesCacheRequest clearPrivilegesCacheRequest) {\n         String endpoint = new RequestConverters.EndpointBuilder()\n             .addPathPartAsIs(\"_security/privilege\")\n-            .addCommaSeparatedPathParts(disableCacheRequest.applications())\n+            .addCommaSeparatedPathParts(clearPrivilegesCacheRequest.applications())\n+            .addPathPart(\"_clear_cache\")\n+            .build();\n+        return new Request(HttpPost.METHOD_NAME, endpoint);\n+    }\n+\n+    static Request clearApiKeyCache(ClearApiKeyCacheRequest clearApiKeyCacheRequest) {\n+        String endpoint = new RequestConverters.EndpointBuilder()\n+            .addPathPartAsIs(\"_security\")\n+            .addPathPart(\"api_key\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzY2NA==", "bodyText": "Nit: Having an empty array mean clear-all is a dangerous Java API.\nIt means this:\nString[] ids = {};\nnew ClearApiKeyCacheRequest(ids);\n\nclears the whole cache, despite reading as though it clears an explicit list.\nI would prefer something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ClearApiKeyCacheRequest(String... ids) {\n          \n          \n            \n                    this.ids = ids;\n          \n          \n            \n                }\n          \n          \n            \n                private ClearApiKeyCacheRequest(String... ids) {\n          \n          \n            \n                    this.ids = ids;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                public static ClearApiKeyCacheRequest clearAll() {\n          \n          \n            \n                    return new ClearApiKeyCacheRequest();\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                public static ClearApiKeyCacheRequest clearById(String ... ids) { \n          \n          \n            \n                    if (ids.length == 0) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Ids cannot be empty\");\n          \n          \n            \n                    }  \n          \n          \n            \n                    return new ClearApiKeyCacheRequest(ids);\n          \n          \n            \n                 }\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ClearApiKeyCacheRequest(String... ids) {\n          \n          \n            \n                    this.ids = ids;\n          \n          \n            \n                }\n          \n          \n            \n                public ClearApiKeyCacheRequest() {\n          \n          \n            \n                    this.ids = new String[0];\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public ClearApiKeyCacheRequest(String id1, String... otherIds) {\n          \n          \n            \n                    this.ids = ArrayUtils.concat(new String[] { id1 }, otherIds);\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                public ClearApiKeyCacheRequest(List<String> ids) {\n          \n          \n            \n                    if (ids.isEmpty()) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Ids cannot be empty\");\n          \n          \n            \n                    }\n          \n          \n            \n                    this.ids = ids.toArray(String[]::new);\n          \n          \n            \n                }", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499973664", "createdAt": "2020-10-06T02:37:21Z", "author": {"login": "tvernum"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/ClearApiKeyCacheRequest.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * The request used to clear the API key cache.\n+ */\n+public final class ClearApiKeyCacheRequest implements Validatable {\n+\n+    private final String[] ids;\n+\n+    /**\n+     * @param ids      An array of API Key ids to be cleared from the specified cache.\n+     *                 If not specified, all entries will be cleared.\n+     */\n+    public ClearApiKeyCacheRequest(String... ids) {\n+        this.ids = ids;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MTcxNw==", "bodyText": "Why is the max 5min? Are we sure we don't ever want to let someone increase that TTL?\nIt seems like something we'd like to have available if we need to boost performance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(0), TimeValue.timeValueMinutes(5), Property.NodeScope);\n          \n          \n            \n                    TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(0), TimeValue.timeValueMinutes(15), Property.NodeScope);", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499981717", "createdAt": "2020-10-06T03:11:08Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -160,6 +168,8 @@\n         TimeValue.timeValueHours(24L), Property.NodeScope);\n     public static final Setting<Integer> CACHE_MAX_KEYS_SETTING = Setting.intSetting(\"xpack.security.authc.api_key.cache.max_keys\",\n         10000, Property.NodeScope);\n+    public static final Setting<TimeValue> DOC_CACHE_TTL_SETTING = Setting.timeSetting(\"xpack.security.authc.api_key.doc_cache.ttl\",\n+        TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(0), TimeValue.timeValueMinutes(5), Property.NodeScope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MzQ1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"clearing the API key cache failed. \" + \"please clear the caches manually\", e));\n          \n          \n            \n                                    \"clearing the API key cache failed; please clear the caches manually\", e));", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499983453", "createdAt": "2020-10-06T03:18:25Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -904,6 +965,25 @@ private void indexInvalidation(Collection<String> apiKeyIds, ActionListener<Inva\n         }\n     }\n \n+    private void clearCache(InvalidateApiKeyResponse result, ActionListener<InvalidateApiKeyResponse> listener) {\n+        final ClearSecurityCacheRequest clearApiKeyCacheRequest =\n+            new ClearSecurityCacheRequest().cacheName(\"api_key\").keys(result.getInvalidatedApiKeys().toArray(String[]::new));\n+        executeAsyncWithOrigin(client, SECURITY_ORIGIN, ClearSecurityCacheAction.INSTANCE, clearApiKeyCacheRequest,\n+            new ActionListener<>() {\n+                @Override\n+                public void onResponse(ClearSecurityCacheResponse nodes) {\n+                    listener.onResponse(result);\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.error(\"unable to clear API key cache\", e);\n+                    listener.onFailure(new ElasticsearchException(\n+                        \"clearing the API key cache failed. \" + \"please clear the caches manually\", e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NDI1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * are replaced by their hashes. The actual values are stored in a separate role descriptor cache.\n          \n          \n            \n                 * are replaced by their hashes. The actual values are stored in a separate role descriptor cache,\n          \n          \n            \n                 * so that duplicate role descriptors are cached only once (and therefore consume less memory).", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499984256", "createdAt": "2020-10-06T03:21:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -1088,8 +1168,128 @@ public ApiKeyDoc(\n             this.creator = creator;\n         }\n \n+        public CachedApiKeyDoc toCachedApiKeyDoc() {\n+            final MessageDigest digest = MessageDigests.sha256();\n+            digest.update(BytesReference.toBytes(roleDescriptorsBytes));\n+            final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            digest.reset();\n+            digest.update(BytesReference.toBytes(limitedByRoleDescriptorsBytes));\n+            final String limitedByRoleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            return new CachedApiKeyDoc(\n+                creationTime,\n+                expirationTime,\n+                invalidated,\n+                hash,\n+                name,\n+                version,\n+                creator,\n+                roleDescriptorsHash,\n+                limitedByRoleDescriptorsHash);\n+        }\n+\n         static ApiKeyDoc fromXContent(XContentParser parser) {\n             return PARSER.apply(parser, null);\n         }\n     }\n+\n+    /**\n+     * A cached version of the {@link ApiKeyDoc}. The main difference is that the role descriptors\n+     * are replaced by their hashes. The actual values are stored in a separate role descriptor cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NTI3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()\n          \n          \n            \n                        // We don't use the doc TTL because that TTL is very low to avoid the risk of\n          \n          \n            \n                        // caching an invalidated API key. But role descriptors are immutable and may be shared between\n          \n          \n            \n                        // multiple API keys, so we cache for longer and rely on the weight to manage the cache size.\n          \n          \n            \n                        this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499985275", "createdAt": "2020-10-06T03:26:34Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -1088,8 +1168,128 @@ public ApiKeyDoc(\n             this.creator = creator;\n         }\n \n+        public CachedApiKeyDoc toCachedApiKeyDoc() {\n+            final MessageDigest digest = MessageDigests.sha256();\n+            digest.update(BytesReference.toBytes(roleDescriptorsBytes));\n+            final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            digest.reset();\n+            digest.update(BytesReference.toBytes(limitedByRoleDescriptorsBytes));\n+            final String limitedByRoleDescriptorsHash = MessageDigests.toHexString(digest.digest());\n+            return new CachedApiKeyDoc(\n+                creationTime,\n+                expirationTime,\n+                invalidated,\n+                hash,\n+                name,\n+                version,\n+                creator,\n+                roleDescriptorsHash,\n+                limitedByRoleDescriptorsHash);\n+        }\n+\n         static ApiKeyDoc fromXContent(XContentParser parser) {\n             return PARSER.apply(parser, null);\n         }\n     }\n+\n+    /**\n+     * A cached version of the {@link ApiKeyDoc}. The main difference is that the role descriptors\n+     * are replaced by their hashes. The actual values are stored in a separate role descriptor cache.\n+     */\n+    public static final class CachedApiKeyDoc {\n+        final long creationTime;\n+        final long expirationTime;\n+        final Boolean invalidated;\n+        final String hash;\n+        final String name;\n+        final int version;\n+        final Map<String, Object> creator;\n+        final String roleDescriptorsHash;\n+        final String limitedByRoleDescriptorsHash;\n+\n+        public CachedApiKeyDoc(\n+            long creationTime, long expirationTime,\n+            Boolean invalidated,\n+            String hash,\n+            String name, int version, Map<String, Object> creator,\n+            String roleDescriptorsHash,\n+            String limitedByRoleDescriptorsHash) {\n+            this.creationTime = creationTime;\n+            this.expirationTime = expirationTime;\n+            this.invalidated = invalidated;\n+            this.hash = hash;\n+            this.name = name;\n+            this.version = version;\n+            this.creator = creator;\n+            this.roleDescriptorsHash = roleDescriptorsHash;\n+            this.limitedByRoleDescriptorsHash = limitedByRoleDescriptorsHash;\n+        }\n+\n+        public ApiKeyDoc toApiKeyDoc(BytesReference roleDescriptorsBytes, BytesReference limitedByRoleDescriptorsBytes) {\n+            return new ApiKeyDoc(\n+                \"api_key\",\n+                creationTime,\n+                expirationTime,\n+                invalidated,\n+                hash,\n+                name,\n+                version,\n+                roleDescriptorsBytes,\n+                limitedByRoleDescriptorsBytes,\n+                creator);\n+        }\n+    }\n+\n+    private static final class ApiKeyDocCache {\n+        private final InvalidationCountingCacheWrapper<String, ApiKeyService.CachedApiKeyDoc> docCache;\n+        private final Cache<String, BytesReference> roleDescriptorsBytesCache;\n+\n+        ApiKeyDocCache(TimeValue ttl, int maximumWeight) {\n+            this.docCache = new InvalidationCountingCacheWrapper<>(\n+                CacheBuilder.<String, ApiKeyService.CachedApiKeyDoc>builder()\n+                    .setMaximumWeight(maximumWeight)\n+                    .setExpireAfterWrite(ttl)\n+                    .build()\n+            );\n+            this.roleDescriptorsBytesCache = CacheBuilder.<String, BytesReference>builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NTg4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class TransportClearSecurityCacheAction extends TransportNodesAction<ClearSecurityCacheRequest, ClearSecurityCacheResponse,\n          \n          \n            \n            /**\n          \n          \n            \n             * Clears a security cache by name (with optional keys).\n          \n          \n            \n             * @see CacheInvalidatorRegistry\n          \n          \n            \n             */\n          \n          \n            \n            public class TransportClearSecurityCacheAction extends TransportNodesAction<ClearSecurityCacheRequest, ClearSecurityCacheResponse,", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499985889", "createdAt": "2020-10-06T03:29:30Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportClearSecurityCacheAction.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheAction;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.ClearSecurityCacheResponse;\n+import org.elasticsearch.xpack.security.support.CacheInvalidatorRegistry;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class TransportClearSecurityCacheAction extends TransportNodesAction<ClearSecurityCacheRequest, ClearSecurityCacheResponse,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NjEyMw==", "bodyText": "Ideally we would have serialization tests for every class that has a writeTo method.", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499986123", "createdAt": "2020-10-06T03:30:27Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/ClearSecurityCacheRequest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.support.nodes.BaseNodesRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.io.IOException;\n+\n+public class ClearSecurityCacheRequest extends BaseNodesRequest<ClearSecurityCacheRequest> {\n+\n+    private String cacheName;\n+    private String[] keys;\n+\n+    public ClearSecurityCacheRequest() {\n+        super((String[]) null);\n+    }\n+\n+    public ClearSecurityCacheRequest(StreamInput in) throws IOException {\n+        super(in);\n+        cacheName = in.readString();\n+        keys = in.readOptionalStringArray();\n+    }\n+\n+    public ClearSecurityCacheRequest cacheName(String cacheName) {\n+        this.cacheName = cacheName;\n+        return this;\n+    }\n+\n+    public String cacheName() {\n+        return cacheName;\n+    }\n+\n+    public ClearSecurityCacheRequest keys(String... keys) {\n+        this.keys = keys;\n+        return this;\n+    }\n+\n+    public String[] keys() {\n+        return keys;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(cacheName);\n+        out.writeOptionalStringArray(keys);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NzQ5Mg==", "bodyText": "A Nit, with a real implication.\nThis test name just refers to the method that it tests. It doesn't actually say what behaviour it's testing, just the method it calls. A name like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testInvalidateByKey() {\n          \n          \n            \n                public void testInvalidateByKeyCallsCorrectInvalidatorObject() {\n          \n      \n    \n    \n  \n\nwould be more descriptive.\nAnd the implication is that because we have a method named test{SomeMethod} it leads to thinking that we just need to call some stuff on that method and we're done, and skips the thinking step of What cases do I need to test?.\nAnd in this case, there's no tests for invalidating a cache that hasn't been registered. Should that be a no-op? Or a failure?", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499987492", "createdAt": "2020-10-06T03:35:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistryTests.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.security.support.CacheInvalidatorRegistry.CacheInvalidator;\n+import org.junit.Before;\n+\n+import java.time.Instant;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+public class CacheInvalidatorRegistryTests extends ESTestCase {\n+\n+    private CacheInvalidatorRegistry cacheInvalidatorRegistry;\n+\n+    @Before\n+    public void setup() {\n+        cacheInvalidatorRegistry = new CacheInvalidatorRegistry();\n+    }\n+\n+    public void testRegistryWillNotAllowInvalidatorsWithDuplicatedName() {\n+        cacheInvalidatorRegistry.registerCacheInvalidator(\"service1\", mock(CacheInvalidator.class));\n+        final IllegalArgumentException e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> cacheInvalidatorRegistry.registerCacheInvalidator(\"service1\", mock(CacheInvalidator.class)));\n+        assertThat(e.getMessage(), containsString(\"already has an entry with name: [service1]\"));\n+    }\n+\n+    public void testSecurityIndexStateChangeWillInvalidateAllRegisteredInvalidators() {\n+        final CacheInvalidator invalidator1 = mock(CacheInvalidator.class);\n+        cacheInvalidatorRegistry.registerCacheInvalidator(\"service1\", invalidator1);\n+        final CacheInvalidator invalidator2 = mock(CacheInvalidator.class);\n+        cacheInvalidatorRegistry.registerCacheInvalidator(\"service2\", invalidator2);\n+\n+        final SecurityIndexManager.State previousState = SecurityIndexManager.State.UNRECOVERED_STATE;\n+        final SecurityIndexManager.State currentState = new SecurityIndexManager.State(\n+            Instant.now(), true, true, true, Version.CURRENT,\n+            \".security\", ClusterHealthStatus.GREEN, IndexMetadata.State.OPEN);\n+\n+        cacheInvalidatorRegistry.onSecurityIndexStageChange(previousState, currentState);\n+        verify(invalidator1).invalidateAll();\n+        verify(invalidator2).invalidateAll();\n+    }\n+\n+    public void testInvalidateByKey() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4NzY0NQ==", "bodyText": "The lack of an else seems like dangerous leniency. Why do we silently pretend to invalidate a cache that doesn't exist?", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499987645", "createdAt": "2020-10-06T03:36:40Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/CacheInvalidatorRegistry.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isIndexDeleted;\n+import static org.elasticsearch.xpack.security.support.SecurityIndexManager.isMoveFromRedToNonRed;\n+\n+/**\n+ * A registry that provides common cache invalidation services for caches that relies on the security index.\n+ */\n+public class CacheInvalidatorRegistry {\n+\n+    private final Map<String, CacheInvalidator> cacheInvalidators = new ConcurrentHashMap<>();\n+\n+    public CacheInvalidatorRegistry() {\n+    }\n+\n+    public void registerCacheInvalidator(String name, CacheInvalidator cacheInvalidator) {\n+        if (cacheInvalidators.containsKey(name)) {\n+            throw new IllegalArgumentException(\"Cache invalidator registry already has an entry with name: [\" + name + \"]\");\n+        }\n+        cacheInvalidators.put(name, cacheInvalidator);\n+    }\n+\n+    public void onSecurityIndexStageChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState)\n+            || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            cacheInvalidators.values().forEach(CacheInvalidator::invalidateAll);\n+        }\n+    }\n+\n+    public void invalidateByKey(String cacheName, Collection<String> keys) {\n+        final CacheInvalidator cacheInvalidator = cacheInvalidators.get(cacheName);\n+        if (cacheInvalidator != null) {\n+            cacheInvalidator.invalidate(keys);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4Nzg2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testItemWillNotBeCachedWhenInvalidationHappensBetweenCheckpointAndItsUsage() throws InterruptedException {\n          \n          \n            \n                public void testItemWillNotBeCachedIfInvalidationCounterHasChanged() throws InterruptedException {", "url": "https://github.com/elastic/elasticsearch/pull/59376#discussion_r499987865", "createdAt": "2020-10-06T03:37:46Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/support/InvalidationCountingCacheWrapperTests.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.support;\n+\n+import org.elasticsearch.common.cache.CacheBuilder;\n+import org.elasticsearch.test.ESTestCase;\n+import org.junit.Before;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class InvalidationCountingCacheWrapperTests extends ESTestCase {\n+\n+    private InvalidationCountingCacheWrapper<String, String> invalidationCountingCacheWrapper;\n+\n+    @Before\n+    public void setup() {\n+        invalidationCountingCacheWrapper = new InvalidationCountingCacheWrapper<>(CacheBuilder.<String, String>builder().build());\n+    }\n+\n+    public void testItemWillCached() {\n+        final long invalidationCount = invalidationCountingCacheWrapper.getInvalidationCount();\n+        assertTrue(invalidationCountingCacheWrapper.putIfNoInvalidationSince(\"foo\", \"bar\", invalidationCount));\n+        assertEquals(\"bar\", invalidationCountingCacheWrapper.get(\"foo\"));\n+    }\n+\n+    public void testItemWillNotBeCachedWhenInvalidationHappensBetweenCheckpointAndItsUsage() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb29d5256825db9a4afcb0e7445eb0d50f2c7393"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1a3b40e1b6d098a9e1930558cfd85025e5402f4", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/e1a3b40e1b6d098a9e1930558cfd85025e5402f4", "committedDate": "2020-10-06T03:47:47Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cefed1a4c7dcd0232120a52824a5e5a69771ff61", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/cefed1a4c7dcd0232120a52824a5e5a69771ff61", "committedDate": "2020-10-06T03:49:49Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef95a1dd11410530bccba9d0ddbbb46d50ea4e82", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ef95a1dd11410530bccba9d0ddbbb46d50ea4e82", "committedDate": "2020-10-06T04:12:15Z", "message": "Address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNzEzMzUz", "url": "https://github.com/elastic/elasticsearch/pull/59376#pullrequestreview-502713353", "createdAt": "2020-10-06T08:43:09Z", "commit": {"oid": "ef95a1dd11410530bccba9d0ddbbb46d50ea4e82"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4508, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}