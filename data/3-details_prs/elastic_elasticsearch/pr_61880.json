{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4MTMyODQ3", "number": 61880, "title": "Fix ILM history index settings", "bodyText": "This change fixed settings accidentally changed in #61457, this fixes ability of ILM history index to rollover.\nIt also adds test to make sure we can't hit this kind of bug in the future.\nCloses #61863", "createdAt": "2020-09-02T19:58:50Z", "url": "https://github.com/elastic/elasticsearch/pull/61880", "merged": true, "mergeCommit": {"oid": "969fa535fd31cbd6f8c6f643ccf730b4bc07f9cc"}, "closed": true, "closedAt": "2020-09-03T18:49:14Z", "author": {"login": "probakowski"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFBh6OAH2gAyNDc4MTMyODQ3OjE1ZGVlODFiYzc3MWQ4YjA3ZDc2ODk0OTYxZTZjODYxMTM2YjcwZjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFTDYogFqTQ4MjAwMjYxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "15dee81bc771d8b07d76894961e6c861136b70f8", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/15dee81bc771d8b07d76894961e6c861136b70f8", "committedDate": "2020-09-02T19:53:48Z", "message": "fix ilm history settings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjkzMDEz", "url": "https://github.com/elastic/elasticsearch/pull/61880#pullrequestreview-481693013", "createdAt": "2020-09-03T10:08:55Z", "commit": {"oid": "15dee81bc771d8b07d76894961e6c861136b70f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowODo1NVrOHMfuZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowODo1NVrOHMfuZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NDc0Mw==", "bodyText": "why would beforeBulk timeout? would removing the policy from the test index and/or stopping ILM solve the issue of outstanding ilm-history entries? (we're manually rolling over the ilm-history alias so ILM is only needed to trigger the creation of the first history index)", "url": "https://github.com/elastic/elasticsearch/pull/61880#discussion_r482864743", "createdAt": "2020-09-03T10:08:55Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/internalClusterTest/java/org/elasticsearch/xpack/ilm/ILMHistoryTests.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.admin.indices.get.GetIndexResponse;\n+import org.elasticsearch.action.admin.indices.rollover.RolloverResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;\n+import org.elasticsearch.xpack.ilm.history.ILMHistoryStore;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.xpack.core.ilm.LifecyclePolicyTestsUtils.randomTimeseriesLifecyclePolicy;\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 1)\n+public class ILMHistoryTests extends ESIntegTestCase {\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        Settings.Builder settings = Settings.builder().put(super.nodeSettings(nodeOrdinal));\n+        settings.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.SECURITY_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.WATCHER_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.GRAPH_ENABLED.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, \"1s\");\n+        settings.put(LifecycleSettings.SLM_HISTORY_INDEX_ENABLED_SETTING.getKey(), false);\n+        return settings.build();\n+    }\n+\n+    @Override\n+    protected boolean ignoreExternalCluster() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(LocalStateCompositeXPackPlugin.class, IndexLifecycle.class);\n+    }\n+\n+    private void putTestPolicy() throws InterruptedException, java.util.concurrent.ExecutionException {\n+        LifecyclePolicy lifecyclePolicy = randomTimeseriesLifecyclePolicy(\"test\");\n+        PutLifecycleAction.Request putLifecycleRequest = new PutLifecycleAction.Request(lifecyclePolicy);\n+        PutLifecycleAction.Response putLifecycleResponse = client().execute(PutLifecycleAction.INSTANCE, putLifecycleRequest).get();\n+        assertAcked(putLifecycleResponse);\n+    }\n+\n+    public void testIlmHistoryIndexCanRollover() throws Exception {\n+        putTestPolicy();\n+        Settings settings = Settings.builder().put(indexSettings()).put(SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(SETTING_NUMBER_OF_REPLICAS, 0).put(LifecycleSettings.LIFECYCLE_NAME, \"test\").build();\n+        CreateIndexResponse res = client().admin().indices().prepareCreate(\"test\").setSettings(settings).get();\n+        assertTrue(res.isAcknowledged());\n+\n+        assertBusy(() -> {\n+            String firstIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000001\";\n+            try {\n+                GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(firstIndex).get();\n+                assertThat(getIndexResponse.getIndices(), arrayContaining(firstIndex));\n+            } catch (Exception e) {\n+                fail(e.getMessage());\n+            }\n+        });\n+\n+        RolloverResponse rolloverResponse = client().admin().indices().prepareRolloverIndex(ILMHistoryStore.ILM_HISTORY_ALIAS).get();\n+        String secondIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000002\";\n+        assertTrue(rolloverResponse.isAcknowledged());\n+        assertThat(rolloverResponse.getNewIndex(), is(secondIndex));\n+\n+        GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(secondIndex).get();\n+        assertThat(getIndexResponse.getIndices(), arrayContaining(secondIndex));\n+\n+        //wait for all history items to index to avoid waiting for timeout in ILMHistoryStore beforeBulk\n+        Thread.sleep(6000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15dee81bc771d8b07d76894961e6c861136b70f8"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7914c593f441785efb0ab8778a7b8bc824d8a671", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/7914c593f441785efb0ab8778a7b8bc824d8a671", "committedDate": "2020-09-03T11:34:40Z", "message": "change waiting condition"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxODUyOTkw", "url": "https://github.com/elastic/elasticsearch/pull/61880#pullrequestreview-481852990", "createdAt": "2020-09-03T13:44:09Z", "commit": {"oid": "7914c593f441785efb0ab8778a7b8bc824d8a671"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0NDowOVrOHMnQ5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0NDowOVrOHMnQ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4ODI2MQ==", "bodyText": "should we avoid the randomisation of the ILM policy and use an empty hot phase only ILM policy? that way we can assert exactly how many items must be inserted before moving on with the test tear down. I think there might be another race condition possible otherwise as the stop ILM call is not a hard stop but has to be detected and depending on what step we're in we might execute more steps (see https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleService.java#L133 )", "url": "https://github.com/elastic/elasticsearch/pull/61880#discussion_r482988261", "createdAt": "2020-09-03T13:44:09Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/internalClusterTest/java/org/elasticsearch/xpack/ilm/ILMHistoryTests.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.admin.indices.get.GetIndexResponse;\n+import org.elasticsearch.action.admin.indices.rollover.RolloverResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.StopILMRequest;\n+import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;\n+import org.elasticsearch.xpack.core.ilm.action.StopILMAction;\n+import org.elasticsearch.xpack.ilm.history.ILMHistoryStore;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.index.query.QueryBuilders.matchQuery;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.xpack.core.ilm.LifecyclePolicyTestsUtils.randomTimeseriesLifecyclePolicy;\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 1)\n+public class ILMHistoryTests extends ESIntegTestCase {\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        Settings.Builder settings = Settings.builder().put(super.nodeSettings(nodeOrdinal));\n+        settings.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.SECURITY_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.WATCHER_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.GRAPH_ENABLED.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, \"1s\");\n+        settings.put(LifecycleSettings.SLM_HISTORY_INDEX_ENABLED_SETTING.getKey(), false);\n+        return settings.build();\n+    }\n+\n+    @Override\n+    protected boolean ignoreExternalCluster() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(LocalStateCompositeXPackPlugin.class, IndexLifecycle.class);\n+    }\n+\n+    private void putTestPolicy() throws InterruptedException, java.util.concurrent.ExecutionException {\n+        LifecyclePolicy lifecyclePolicy = randomTimeseriesLifecyclePolicy(\"test\");\n+        PutLifecycleAction.Request putLifecycleRequest = new PutLifecycleAction.Request(lifecyclePolicy);\n+        PutLifecycleAction.Response putLifecycleResponse = client().execute(PutLifecycleAction.INSTANCE, putLifecycleRequest).get();\n+        assertAcked(putLifecycleResponse);\n+    }\n+\n+    public void testIlmHistoryIndexCanRollover() throws Exception {\n+        putTestPolicy();\n+        Settings settings = Settings.builder().put(indexSettings()).put(SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(SETTING_NUMBER_OF_REPLICAS, 0).put(LifecycleSettings.LIFECYCLE_NAME, \"test\").build();\n+        CreateIndexResponse res = client().admin().indices().prepareCreate(\"test\").setSettings(settings).get();\n+        assertTrue(res.isAcknowledged());\n+\n+        String firstIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000001\";\n+        String secondIndex = ILMHistoryStore.ILM_HISTORY_INDEX_PREFIX + \"000002\";\n+\n+        assertBusy(() -> {\n+            try {\n+                GetIndexResponse getIndexResponse = client().admin().indices().prepareGetIndex().setIndices(firstIndex).get();\n+                assertThat(getIndexResponse.getIndices(), arrayContaining(firstIndex));\n+            } catch (Exception e) {\n+                fail(e.getMessage());\n+            }\n+        });\n+\n+        assertTrue(client().execute(StopILMAction.INSTANCE, new StopILMRequest()).actionGet().isAcknowledged());\n+\n+        //wait for all history items to index to avoid waiting for timeout in ILMHistoryStore beforeBulk\n+        assertBusy(() -> {\n+            SearchResponse search = client().prepareSearch(firstIndex).setQuery(matchQuery(\"index\", firstIndex)).setSize(0).get();\n+            assertThat(search.getHits().getTotalHits().value, greaterThan(0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7914c593f441785efb0ab8778a7b8bc824d8a671"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "582d05f1a77350ab9d69999fbd978027750ff198", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/582d05f1a77350ab9d69999fbd978027750ff198", "committedDate": "2020-09-03T15:27:37Z", "message": "derandomize policy + stopped ILM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a5d3c79c8eab925abea9fda446ffb553d6d0420", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a5d3c79c8eab925abea9fda446ffb553d6d0420", "committedDate": "2020-09-03T15:38:30Z", "message": "Merge branch 'master' into ilm-history-settings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDAyNjEy", "url": "https://github.com/elastic/elasticsearch/pull/61880#pullrequestreview-482002612", "createdAt": "2020-09-03T16:18:45Z", "commit": {"oid": "7a5d3c79c8eab925abea9fda446ffb553d6d0420"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 23, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}