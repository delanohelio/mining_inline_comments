{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNjA4ODM4", "number": 58608, "title": "Add microbenchmark for LongKeyedBucketOrds", "bodyText": "I've always been confused by the strange behavior that I saw when\nworking on #57304. Specifically, I saw switching from a bimorphic\ninvocation to a monomorphic invocation to give us a 7%-15% performance\nbump. This felt bonkers to me. And, it also made me wonder whether\nit'd be worth looking into doing it everywhere.\nIt turns out that, no, it isn't needed everywhere. This benchmark shows\nthat a bimorphic invocation like:\nLongKeyedBucketOrds ords = new LongKeyedBucketOrds.ForSingle();\nords.add(0, 0); <------ this line\n\nis 19% slower than a monomorphic invocation like:\nLongKeyedBucketOrds.ForSingle ords = new LongKeyedBucketOrds.ForSingle();\nords.add(0, 0); <------ this line\n\nBut only when the reference is mutable. In the example above, if\nords is never changed then both perform the same. But if the ords\nreference is assigned twice then we start to see the difference:\nimmutable bimorphic    avgt   10   6.468 \u00b1 0.045  ns/op\nimmutable monomorphic  avgt   10   6.756 \u00b1 0.026  ns/op\nmutable   bimorphic    avgt   10   9.741 \u00b1 0.073  ns/op\nmutable   monomorphic  avgt   10   8.190 \u00b1 0.016  ns/op\n\nSo the conclusion from all this is that we've done the right thing:\nauto_date_histogram is the only aggregation in which ords isn't final\nand it is the only aggregation that forces monomorphic invocations. All\nother aggregations use an immutable bimorphic invocation. Which is fine.\nRelates to #56487", "createdAt": "2020-06-26T14:11:31Z", "url": "https://github.com/elastic/elasticsearch/pull/58608", "merged": true, "mergeCommit": {"oid": "e84a501f00314c42097b7b5ef1bb5b1498e8da33"}, "closed": true, "closedAt": "2020-07-13T20:01:21Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvD327gH2gAyNDQwNjA4ODM4OjdlMTM3MWUzNDIwMmQ0Y2JhOTgxZDY4OWVmZjc5MTE3NTc5MDdhMTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0l4jQAH2gAyNDQwNjA4ODM4OmY0MjZiNTU3NTg2OGJjNmMwYjkwNTkxYmQzMjU1ZTI1M2FiMjZkM2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7e1371e34202d4cba981d689eff7911757907a16", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/7e1371e34202d4cba981d689eff7911757907a16", "committedDate": "2020-06-26T14:11:15Z", "message": "Add microbenchmark for LongKeyedBucketOrds\n\nI've always been confused by the strange behavior that I saw when\nworking on #57304. Specifically, I saw switching from a bimorphic\ninvocation to a monomorphic invocation to give us a 7%-15% performance\nbump. This felt *bonkers* to me. And, it also made me wonder whether\nit'd be worth looking into doing it everywhere.\n\nIt turns out that, no, it isn't needed everywhere. This benchmark shows\nthat a bimorphic invocation like:\n```\nLongKeyedBucketOrds ords = new LongKeyedBucketOrds.ForSingle();\nords.add(0, 0); <------ this line\n```\n\nis 19% slower than a monomorphic invocation like:\n```\nLongKeyedBucketOrds.ForSingle ords = new LongKeyedBucketOrds.ForSingle();\nords.add(0, 0); <------ this line\n```\n\nBut *only* when the reference is mutable. In the example above, if\n`ords` is never changed then both perform the same. But if the `ords`\nreference is assigned twice then we start to see the difference:\n```\nimmutable bimorphic    avgt   10   6.468 \u00b1 0.045  ns/op\nimmutable monomorphic  avgt   10   6.756 \u00b1 0.026  ns/op\nmutable   bimorphic    avgt   10   9.741 \u00b1 0.073  ns/op\nmutable   monomorphic  avgt   10   8.190 \u00b1 0.016  ns/op\n```\n\nSo the conclusion from all this is that we've done the right thing:\n`auto_date_histogram` is the only aggregation in which `ords` isn't final\nand it is the only aggregation that forces monomorphic invocations. All\nother aggregations use an immutable bimorphic invocation. Which is fine.\n\nRelates to #56487"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c20cd414437c4cf262c5cbc8a9fbbd658ce7464", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/7c20cd414437c4cf262c5cbc8a9fbbd658ce7464", "committedDate": "2020-06-30T21:08:45Z", "message": "Merge branch 'master' into long_keyed_bucket_ords"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9075f23de1c10551ef1df79cb9b25d041e372800", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/9075f23de1c10551ef1df79cb9b25d041e372800", "committedDate": "2020-06-30T22:42:30Z", "message": "Merge branch 'master' into long_keyed_bucket_ords"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjYwNzAz", "url": "https://github.com/elastic/elasticsearch/pull/58608#pullrequestreview-441260703", "createdAt": "2020-07-01T23:41:03Z", "commit": {"oid": "7e1371e34202d4cba981d689eff7911757907a16"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e4fb47c82260222be946d9fad401d1b0d1479a6", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/2e4fb47c82260222be946d9fad401d1b0d1479a6", "committedDate": "2020-07-06T14:01:10Z", "message": "Merge branch 'master' into long_keyed_bucket_ords"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/80ba140322035157349bb2a694c1a78301210a4d", "committedDate": "2020-07-06T14:05:04Z", "message": "Move benchmark to proper package"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDUxNzE3", "url": "https://github.com/elastic/elasticsearch/pull/58608#pullrequestreview-444451717", "createdAt": "2020-07-08T06:40:35Z", "commit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDozNVrOGuaJDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MTowMlrOGuaJtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNTk4Mw==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451315983", "createdAt": "2020-07-08T06:40:35Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjAxMQ==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316011", "createdAt": "2020-07-08T06:40:40Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjA1OQ==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316059", "createdAt": "2020-07-08T06:40:45Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjA5NQ==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316095", "createdAt": "2020-07-08T06:40:53Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjEyNg==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316126", "createdAt": "2020-07-08T06:40:58Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {\n+        LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = LongKeyedBucketOrds.build(bigArrays, true);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from a single bucket \"by accident\".\n+     * This can happen if an aggregation is under, say, a {@code terms}\n+     * aggregation and there is only a single value for that term in the index.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoMulti() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjE1MA==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316150", "createdAt": "2020-07-08T06:41:02Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {\n+        LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = LongKeyedBucketOrds.build(bigArrays, true);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from a single bucket \"by accident\".\n+     * This can happen if an aggregation is under, say, a {@code terms}\n+     * aggregation and there is only a single value for that term in the index.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoMulti() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, false)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from many buckets.\n+     */\n+    @Benchmark\n+    public void multiBucket() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d26ed4cb5d3bcd684e353d380d3b2fd4406d2ce", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d26ed4cb5d3bcd684e353d380d3b2fd4406d2ce", "committedDate": "2020-07-08T19:33:30Z", "message": "Merge branch 'master' into long_keyed_bucket_ords"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f46086db0c66023ebd6a4394fc7705259203582", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/0f46086db0c66023ebd6a4394fc7705259203582", "committedDate": "2020-07-08T19:36:36Z", "message": "Blackhole"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dde47b2c8c112bcac6d389715fe6bc22e91a5891", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/dde47b2c8c112bcac6d389715fe6bc22e91a5891", "committedDate": "2020-07-08T19:38:52Z", "message": "Handle merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ab3390daa6a68a7a788fe86a56518230d2df0f9", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/7ab3390daa6a68a7a788fe86a56518230d2df0f9", "committedDate": "2020-07-08T19:41:50Z", "message": "javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d31dd304434fb3e2175a6be44d130c5c31460b14", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/d31dd304434fb3e2175a6be44d130c5c31460b14", "committedDate": "2020-07-08T19:47:59Z", "message": "Force init"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67b57dba147bc70ff40c5b0c0ccd794247f45164", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/67b57dba147bc70ff40c5b0c0ccd794247f45164", "committedDate": "2020-07-08T19:49:28Z", "message": "Force loading classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MDU1MjIx", "url": "https://github.com/elastic/elasticsearch/pull/58608#pullrequestreview-447055221", "createdAt": "2020-07-13T08:53:48Z", "commit": {"oid": "67b57dba147bc70ff40c5b0c0ccd794247f45164"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo1Mzo0OFrOGwfLjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo1Mzo0OFrOGwfLjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ5NTY5Mw==", "bodyText": "I assume you're not interested in measuring class loading so you can move this code out of the measurement loop and into a separate setup method:\n    @Setup\n    public void setUp(Blackhole bh) {\n        // you can also inline this method now that there is only one call site\n        forceLoadClasses(bh);\n    }", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r453495693", "createdAt": "2020-07-13T08:53:48Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh) {\n+        forceLoadClasses(bh);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67b57dba147bc70ff40c5b0c0ccd794247f45164"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "308c982972050429f5f4be4a2729411fda54cc0f", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/308c982972050429f5f4be4a2729411fda54cc0f", "committedDate": "2020-07-13T18:33:24Z", "message": "Merge branch 'master' into long_keyed_bucket_ords"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f426b5575868bc6c0b90591bd3255e253ab26d3e", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/f426b5575868bc6c0b90591bd3255e253ab26d3e", "committedDate": "2020-07-13T18:38:24Z", "message": "Move force loading classes to setup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2665, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}