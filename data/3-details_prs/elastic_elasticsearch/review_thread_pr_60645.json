{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNjk3Nzgx", "number": 60645, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMToxMzoxMFrOEU8_yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzoxNToyOFrOEXNGlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDA2MzQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/RootObjectMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMToxMzoxMFrOG7b1MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMToxMzoxMFrOG7b1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk3NTE1Mg==", "bodyText": "This yields better error messages for dynamic mappings, including the name of the dynamic mapping itself and the type of the dynamically created field.", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r464975152", "createdAt": "2020-08-04T11:13:10Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/RootObjectMapper.java", "diffHunk": "@@ -388,10 +388,11 @@ private static void validateDynamicTemplate(Mapper.TypeParser.ParserContext pars\n                 continue;\n             }\n \n-            Map<String, Object> fieldTypeConfig = dynamicTemplate.mappingForName(\"__dummy__\", defaultDynamicType);\n-            fieldTypeConfig.remove(\"type\");\n+            String templateName = \"__dynamic__\" + dynamicTemplate.name();\n+            Map<String, Object> fieldTypeConfig = dynamicTemplate.mappingForName(templateName, defaultDynamicType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f929d922a0f9e38863ebed771fb7349226b01957"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDA3MzU3OnYy", "diffSide": "LEFT", "path": "server/src/test/java/org/elasticsearch/index/mapper/TypeParsersTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMToxNjoyOFrOG7b7SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMToxNjoyOFrOG7b7SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk3NjcxMw==", "bodyText": "KeywordFieldMapper.Builder doesn't match the signature of parseField anymore (because we don't actually use it in parsing), so I've adjusted these to directly test the parseMeta method.", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r464976713", "createdAt": "2020-08-04T11:16:28Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/TypeParsersTests.java", "diffHunk": "@@ -232,55 +235,49 @@ public TokenStream create(TokenStream tokenStream) {\n     }\n \n     public void testParseMeta() {\n-        FieldMapper.Builder<?> builder = new KeywordFieldMapper.Builder(\"foo\");\n-        Mapper.TypeParser.ParserContext parserContext = new Mapper.TypeParser.ParserContext(null, null, null, null, null, null);\n-\n         {\n-            Map<String, Object> mapping = new HashMap<>(Map.of(\"meta\", 3));\n             MapperParsingException e = expectThrows(MapperParsingException.class,\n-                    () -> TypeParsers.parseField(builder, builder.name, mapping, parserContext));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f929d922a0f9e38863ebed771fb7349226b01957"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU1MTAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo0NDoyMFrOG-2Dyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MTowNVrOG-4Tpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDYwMw==", "bodyText": "Are we using anywhere this method?", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468550603", "createdAt": "2020-08-11T12:44:20Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzQzMA==", "bodyText": "This is used in tests", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468587430", "createdAt": "2020-08-11T13:41:05Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDYwMw=="}, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU1MTYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo0NDoyOFrOG-2EHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNToxMDo1MVrOG-8iAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDY4NQ==", "bodyText": "Are we using anywhere this method?", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468550685", "createdAt": "2020-08-11T12:44:28Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {\n+            this.normalizer.setValue(normalizerName);\n+            return this;\n         }\n \n-        public Builder eagerGlobalOrdinals(boolean eagerGlobalOrdinals) {\n-            this.eagerGlobalOrdinals = eagerGlobalOrdinals;\n-            return builder;\n+        Builder nullValue(String nullValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzU5NQ==", "bodyText": "This was being used in tests, but possibly isn't... let me check", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468587595", "createdAt": "2020-08-11T13:41:19Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {\n+            this.normalizer.setValue(normalizerName);\n+            return this;\n         }\n \n-        public Builder eagerGlobalOrdinals(boolean eagerGlobalOrdinals) {\n-            this.eagerGlobalOrdinals = eagerGlobalOrdinals;\n-            return builder;\n+        Builder nullValue(String nullValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDY4NQ=="}, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NjY0Mw==", "bodyText": "nullValue and normalizer are both used in KeywordFieldMapperTests", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468656643", "createdAt": "2020-08-11T15:10:51Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {\n+        return (KeywordFieldMapper) in;\n+    }\n \n-        protected String nullValue = Defaults.NULL_VALUE;\n-        protected int ignoreAbove = Defaults.IGNORE_ABOVE;\n-        private IndexAnalyzers indexAnalyzers;\n-        private String normalizerName = \"default\";\n-        private boolean eagerGlobalOrdinals = Defaults.EAGER_GLOBAL_ORDINALS;\n-        private boolean splitQueriesOnWhitespace = Defaults.SPLIT_QUERIES_ON_WHITESPACE;\n-        private SimilarityProvider similarity;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-            builder = this;\n-        }\n+        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n+        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n+        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n \n-        @Override\n-        public Builder omitNorms(boolean omitNorms) {\n-            fieldType.setOmitNorms(omitNorms);\n-            return builder;\n+        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).nullValue, null);\n+\n+        private final Parameter<Boolean> eagerGlobalOrdinals\n+            = Parameter.boolParam(\"eager_global_ordinals\", true, m -> toType(m).eagerGlobalOrdinals, false);\n+        private final Parameter<Integer> ignoreAbove\n+            = Parameter.intParam(\"ignore_above\", true, m -> toType(m).ignoreAbove, Integer.MAX_VALUE);\n+\n+        private final Parameter<String> indexOptions\n+            = Parameter.restrictedStringParam(\"index_options\", false, m -> toType(m).indexOptions, \"docs\", \"freqs\");\n+        private final Parameter<Boolean> hasNorms\n+            = Parameter.boolParam(\"norms\", false, m -> toType(m).fieldType.omitNorms() == false, false);\n+        private final Parameter<SimilarityProvider> similarity = new Parameter<>(\"similarity\", false, () -> null,\n+            (n, c, o) -> TypeParsers.resolveSimilarity(c, n, o.toString()), m -> toType(m).similarity);\n+\n+        private final Parameter<String> normalizer\n+            = Parameter.stringParam(\"normalizer\", false, m -> toType(m).normalizerName, \"default\");\n+\n+        private final Parameter<Boolean> splitQueriesOnWhitespace\n+            = Parameter.boolParam(\"split_queries_on_whitespace\", true, m -> toType(m).splitQueriesOnWhitespace, false);\n+\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<Float> boost = Parameter.boostParam();\n+\n+        private final IndexAnalyzers indexAnalyzers;\n+\n+        public Builder(String name, IndexAnalyzers indexAnalyzers) {\n+            super(name);\n+            this.indexAnalyzers = indexAnalyzers;\n         }\n \n-        public void similarity(SimilarityProvider similarity) {\n-            this.similarity = similarity;\n+        public Builder(String name) {\n+            this(name, null);\n         }\n \n         public Builder ignoreAbove(int ignoreAbove) {\n-            if (ignoreAbove < 0) {\n-                throw new IllegalArgumentException(\"[ignore_above] must be positive, got \" + ignoreAbove);\n-            }\n-            this.ignoreAbove = ignoreAbove;\n+            this.ignoreAbove.setValue(ignoreAbove);\n             return this;\n         }\n \n-        @Override\n-        public Builder indexOptions(IndexOptions indexOptions) {\n-            if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {\n-                throw new IllegalArgumentException(\"The [keyword] field does not support positions, got [index_options]=\"\n-                        + indexOptionToString(indexOptions));\n-            }\n-            return super.indexOptions(indexOptions);\n+        Builder normalizer(String normalizerName) {\n+            this.normalizer.setValue(normalizerName);\n+            return this;\n         }\n \n-        public Builder eagerGlobalOrdinals(boolean eagerGlobalOrdinals) {\n-            this.eagerGlobalOrdinals = eagerGlobalOrdinals;\n-            return builder;\n+        Builder nullValue(String nullValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDY4NQ=="}, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzY2MTA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzoxMjoyM1rOG-3HHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0Mjo1MVrOG-4Yqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NzgzNg==", "bodyText": "Are we planning to use all these parameters later instead of accessing them through fieldType() as below:\ne.g.  =>\nfieldType().hasDocValues() => hasDocValues?\nDo we still need a fieldType here, if all values can be retrieved through builder?", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468567836", "createdAt": "2020-08-11T13:12:23Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -314,18 +290,35 @@ protected BytesRef indexedValueForSearch(Object value) {\n         }\n     }\n \n-    private int ignoreAbove;\n-    private boolean splitQueriesOnWhitespace;\n-    private String nullValue;\n+    private final boolean indexed;\n+    private final boolean hasDocValues;\n+    private final String nullValue;\n+    private final boolean eagerGlobalOrdinals;\n+    private final int ignoreAbove;\n+    private final String indexOptions;\n+    private final FieldType fieldType;\n+    private final SimilarityProvider similarity;\n+    private final String normalizerName;\n+    private final boolean splitQueriesOnWhitespace;\n+\n+    private final IndexAnalyzers indexAnalyzers;\n \n     protected KeywordFieldMapper(String simpleName, FieldType fieldType, MappedFieldType mappedFieldType,\n-                                 int ignoreAbove, boolean splitQueriesOnWhitespace, String nullValue,\n-                                 MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, fieldType, mappedFieldType, multiFields, copyTo);\n+                                 MultiFields multiFields, CopyTo copyTo, Builder builder) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n         assert fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) <= 0;\n-        this.ignoreAbove = ignoreAbove;\n-        this.splitQueriesOnWhitespace = splitQueriesOnWhitespace;\n-        this.nullValue = nullValue;\n+        this.indexed = builder.indexed.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4ODcxNQ==", "bodyText": "We still need fieldType because it needs to be passed to the super constructor, although I would like to make it unnecessary in future.  The fields themselves are used in the Parameter definitions further up, to initialize the merge builder from the existing mapping.", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468588715", "createdAt": "2020-08-11T13:42:51Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -314,18 +290,35 @@ protected BytesRef indexedValueForSearch(Object value) {\n         }\n     }\n \n-    private int ignoreAbove;\n-    private boolean splitQueriesOnWhitespace;\n-    private String nullValue;\n+    private final boolean indexed;\n+    private final boolean hasDocValues;\n+    private final String nullValue;\n+    private final boolean eagerGlobalOrdinals;\n+    private final int ignoreAbove;\n+    private final String indexOptions;\n+    private final FieldType fieldType;\n+    private final SimilarityProvider similarity;\n+    private final String normalizerName;\n+    private final boolean splitQueriesOnWhitespace;\n+\n+    private final IndexAnalyzers indexAnalyzers;\n \n     protected KeywordFieldMapper(String simpleName, FieldType fieldType, MappedFieldType mappedFieldType,\n-                                 int ignoreAbove, boolean splitQueriesOnWhitespace, String nullValue,\n-                                 MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, fieldType, mappedFieldType, multiFields, copyTo);\n+                                 MultiFields multiFields, CopyTo copyTo, Builder builder) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n         assert fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) <= 0;\n-        this.ignoreAbove = ignoreAbove;\n-        this.splitQueriesOnWhitespace = splitQueriesOnWhitespace;\n-        this.nullValue = nullValue;\n+        this.indexed = builder.indexed.getValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2NzgzNg=="}, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 314}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzY3MzgwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzoxNToyOFrOG-3O8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MzoyOVrOG-4aTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2OTg0Mg==", "bodyText": "Lines 69-71 and 80-82 seem to be unused", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468569842", "createdAt": "2020-08-11T13:15:28Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4OTEzMg==", "bodyText": "++ they are, will remove", "url": "https://github.com/elastic/elasticsearch/pull/60645#discussion_r468589132", "createdAt": "2020-08-11T13:43:29Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -92,149 +83,134 @@ public KeywordField(String field, BytesRef term) {\n \n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n+    private static KeywordFieldMapper toType(FieldMapper in) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2OTg0Mg=="}, "originalCommit": {"oid": "76116517d0927dcb01d3d8cccc765614c4043b8f"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2631, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}