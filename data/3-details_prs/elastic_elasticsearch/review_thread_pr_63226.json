{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3NTc0MTQ1", "number": 63226, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo0Mjo0NFrOEqLckg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzoxNDo0NlrOEqL9VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjYzMTg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo0Mjo0NFrOHcPTKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo0Mjo0NFrOHcPTKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3Mjg0MQ==", "bodyText": "nit: the ordering of fields is a bit odd, I would prefer this went either before or after the buffer related fields.", "url": "https://github.com/elastic/elasticsearch/pull/63226#discussion_r499372841", "createdAt": "2020-10-05T06:42:44Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java", "diffHunk": "@@ -72,10 +80,15 @@\n     private final LongConsumer persistedSequenceNumberConsumer;\n \n     protected final AtomicBoolean closed = new AtomicBoolean(false);\n-    // lock order synchronized(syncLock) -> synchronized(this)\n+    // lock order try(Releasable lock = writeLock.acquire()) -> synchronized(this)\n+    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n+    // lock order synchronized(syncLock) -> try(Releasable lock = writeLock.acquire()) -> synchronized(this)\n     private final Object syncLock = new Object();\n \n-    private LongArrayList nonFsyncedSequenceNumbers;\n+    private final int forceWriteThreshold;\n+    private final ArrayList<ReleasableBytesReference> bufferedOps = new ArrayList<>();\n+    private LongArrayList nonFsyncedSequenceNumbers = new LongArrayList(64);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af27c3fcbbc8f1661e99cf07e2761d8dcf2c37a4"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjcxNTcyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzoxNDo0NlrOHcQEPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzoxNDo0NlrOHcQEPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM4NTQwNQ==", "bodyText": "Would be good to also include testing that the readBytes path works, for instance by randomly choosing to do readBytes here instead.", "url": "https://github.com/elastic/elasticsearch/pull/63226#discussion_r499385405", "createdAt": "2020-10-05T07:14:46Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/translog/TranslogTests.java", "diffHunk": "@@ -1315,15 +1315,185 @@ public void testTranslogWriter() throws IOException {\n         IOUtils.close(writer);\n     }\n \n+    public void testTranslogWriterFlushesOnWriteWhenBufferFull() throws IOException {\n+        Path tempDir = createTempDir();\n+        final TranslogConfig temp = getTranslogConfig(tempDir);\n+        final TranslogConfig config = new TranslogConfig(temp.getShardId(), temp.getTranslogPath(), temp.getIndexSettings(),\n+            temp.getBigArrays(), new ByteSizeValue(1, ByteSizeUnit.KB));\n+\n+        final Set<Long> persistedSeqNos = new HashSet<>();\n+        final AtomicInteger writeCalls = new AtomicInteger();\n+\n+        final ChannelFactory channelFactory = (file, openOption) -> {\n+            FileChannel delegate = FileChannel.open(file, openOption);\n+            boolean success = false;\n+            try {\n+                // don't do partial writes for checkpoints we rely on the fact that the bytes are written as an atomic operation\n+                final boolean isCkpFile = file.getFileName().toString().endsWith(\".ckp\");\n+\n+                final FileChannel channel;\n+                if (isCkpFile) {\n+                    channel = delegate;\n+                } else {\n+                    channel = new FilterFileChannel(delegate) {\n+\n+                        @Override\n+                        public int write(ByteBuffer src) throws IOException {\n+                            writeCalls.incrementAndGet();\n+                            return super.write(src);\n+                        }\n+                    };\n+                }\n+                success = true;\n+                return channel;\n+            } finally {\n+                if (success == false) {\n+                    IOUtils.closeWhileHandlingException(delegate);\n+                }\n+            }\n+        };\n+\n+        String translogUUID = Translog.createEmptyTranslog(\n+            config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, channelFactory, primaryTerm.get());\n+\n+        try (Translog translog = new Translog(config, translogUUID, new TranslogDeletionPolicy(),\n+            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get, persistedSeqNos::add) {\n+            @Override\n+            ChannelFactory getChannelFactory() {\n+                return channelFactory;\n+            }\n+        }) {\n+            try (TranslogWriter writer = translog.createWriter(translog.currentFileGeneration() + 1)) {\n+                int initialWriteCalls = writeCalls.get();\n+                byte[] bytes = new byte[256];\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 1);\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 2);\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 3);\n+                assertThat(persistedSeqNos, empty());\n+                assertEquals(initialWriteCalls, writeCalls.get());\n+\n+                // This will fill the buffer and force a flush\n+                writer.add(ReleasableBytesReference.wrap(new BytesArray(bytes)), 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af27c3fcbbc8f1661e99cf07e2761d8dcf2c37a4"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3175, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}