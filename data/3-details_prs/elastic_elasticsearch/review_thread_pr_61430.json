{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxNzIwMzU1", "number": 61430, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoxMDozOFrOEbBnXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNTo0MFrOEbq91A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzczNDY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/IndexSortConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoxMDozOFrOHEzE0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoxMDozOFrOHEzE0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MzE3MQ==", "bodyText": "This was not strictly required in this PR, though it came natural as I added isRuntimeField to MappedFieldType. and configuring index sorting on runtime fields looked like a bad idea to me.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r474793171", "createdAt": "2020-08-21T16:10:38Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/IndexSortConfig.java", "diffHunk": "@@ -192,7 +195,7 @@ public Sort buildIndexSort(Function<String, MappedFieldType> fieldTypeLookup,\n             try {\n                 fieldData = fieldDataLookup.apply(ft);\n             } catch (Exception e) {\n-                throw new IllegalArgumentException(\"docvalues not found for index sort field:[\" + sortSpec.field + \"]\");\n+                throw new IllegalArgumentException(\"docvalues not found for index sort field:[\" + sortSpec.field + \"]\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzczNzczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoxMTo0NFrOHEzG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNToyNzoyMFrOHHRjOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MzY4NA==", "bodyText": "this is the main reason why I introduced isRuntimeField as part of this PR. I want to enforce that this method is never called for runtime fields. That is the case today, this is only used for index warmers and index sorting, but we need to make sure that that is still the case in the future.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r474793684", "createdAt": "2020-08-21T16:11:44Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java", "diffHunk": "@@ -106,14 +108,27 @@ public synchronized void clearField(final String fieldName) {\n         ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);\n     }\n \n+    /**\n+     * Returns fielddata for the provided field type. Same as {@link #getForField(MappedFieldType, String, Supplier)} but does not take\n+     * the index name and the search lookup supplier as arguments. Does not support runtime fields.\n+     */\n     public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {\n-        return getForField(fieldType, index().getName());\n+        assert fieldType.isRuntimeField() == false : \"runtime fields are not supported\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNDc3Mw==", "bodyText": "I am not sure this is needed, index sort will check that the field has doc values so it will fail at the Lucene level. I am not saying we shouldn't check at the ES level but this assert  is confusing IMO. Can we remove this function entirely and replace it with the one below ?", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475704773", "createdAt": "2020-08-24T15:34:27Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java", "diffHunk": "@@ -106,14 +108,27 @@ public synchronized void clearField(final String fieldName) {\n         ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);\n     }\n \n+    /**\n+     * Returns fielddata for the provided field type. Same as {@link #getForField(MappedFieldType, String, Supplier)} but does not take\n+     * the index name and the search lookup supplier as arguments. Does not support runtime fields.\n+     */\n     public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {\n-        return getForField(fieldType, index().getName());\n+        assert fieldType.isRuntimeField() == false : \"runtime fields are not supported\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MzY4NA=="}, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzMTM2Mw==", "bodyText": "correct, this is to have a proper error message. But what I am after here is to protect from this method being a second getForField which though can't support runtime fields (we have no search lookup!). It is so easy to use this one instead of the other one. Maybe renaming both would also help.\n\nCan we remove this function entirely and replace it with the one below?\n\nyou mean having a single getForField method I assume? That would be great but I am not sure where to get search lookup for this usecase that does not need it and it's only used for index warmers and index sorting.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475831363", "createdAt": "2020-08-24T19:03:07Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java", "diffHunk": "@@ -106,14 +108,27 @@ public synchronized void clearField(final String fieldName) {\n         ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);\n     }\n \n+    /**\n+     * Returns fielddata for the provided field type. Same as {@link #getForField(MappedFieldType, String, Supplier)} but does not take\n+     * the index name and the search lookup supplier as arguments. Does not support runtime fields.\n+     */\n     public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {\n-        return getForField(fieldType, index().getName());\n+        assert fieldType.isRuntimeField() == false : \"runtime fields are not supported\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MzY4NA=="}, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM4OTYyNg==", "bodyText": "I removed the getForField(MappedFieldType). Callers now call the other getForField and provide their own search lookup supplier and index name. That removed the need for the isRuntimeField flag too. index sorting already throws a decent error when it is configured with a runtime field (doc values not found for field etc.). I am happier with this as it simplifies things.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r477389626", "createdAt": "2020-08-26T15:27:20Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java", "diffHunk": "@@ -106,14 +108,27 @@ public synchronized void clearField(final String fieldName) {\n         ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);\n     }\n \n+    /**\n+     * Returns fielddata for the provided field type. Same as {@link #getForField(MappedFieldType, String, Supplier)} but does not take\n+     * the index name and the search lookup supplier as arguments. Does not support runtime fields.\n+     */\n     public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {\n-        return getForField(fieldType, index().getName());\n+        assert fieldType.isRuntimeField() == false : \"runtime fields are not supported\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MzY4NA=="}, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzc0ODIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoxNDo1OFrOHEzNWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzowMjoyNFrOHHK_iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NTM1Mg==", "bodyText": "@nik9000 this is very similar to what you had in #60318 ( I will give you credit in the final commit). The main difference is that I don't recreate a SearchLookup and DocLookup every time a new field is referenced. I rather fork SearchLookup once a field is looked up and keep on reusing the same and adding field names to that same list. I find it more intuitive this way. I guess you may have a different opinion. I also tried to enclose the tracking in the lookup function. All of the other changes turned out the same as what you made, although I started from scratch to see where I ended up :)", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r474795352", "createdAt": "2020-08-21T16:14:58Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -54,4 +94,20 @@ public DocLookup doc() {\n     public SourceLookup source() {\n         return sourceLookup;\n     }\n+\n+    private static Function<MappedFieldType, IndexFieldData<?>> wrapAndTrackFieldReferences(String field,\n+            Function<MappedFieldType, IndexFieldData<?>> fieldDataLookup) {\n+        final Set<String> fields = new LinkedHashSet<>();\n+        fields.add(field);\n+        return fieldType -> {\n+            if (fields.add(fieldType.name()) == false) {\n+                String message = String.join(\" -> \", fields) + \" -> \" + fieldType.name();\n+                throw new IllegalArgumentException(\"Cyclic dependency detected while resolving runtime fields: \" + message);\n+            }\n+            if (fields.size() > MAX_FIELD_CHAIN) {\n+                throw new IllegalArgumentException(\"Field requires resolving too many dependent fields: \" + String.join(\" -> \", fields));\n+            }\n+            return fieldDataLookup.apply(fieldType);\n+        };\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDM5MQ==", "bodyText": "If a field depends on many fields but doesn't have a \"chain\" of dependencies will this trigger? Is that what we want? Maybe it is, but I think a limit of 5 is pretty low in that case. Maybe fine, but I dunno.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475780391", "createdAt": "2020-08-24T17:30:29Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -54,4 +94,20 @@ public DocLookup doc() {\n     public SourceLookup source() {\n         return sourceLookup;\n     }\n+\n+    private static Function<MappedFieldType, IndexFieldData<?>> wrapAndTrackFieldReferences(String field,\n+            Function<MappedFieldType, IndexFieldData<?>> fieldDataLookup) {\n+        final Set<String> fields = new LinkedHashSet<>();\n+        fields.add(field);\n+        return fieldType -> {\n+            if (fields.add(fieldType.name()) == false) {\n+                String message = String.join(\" -> \", fields) + \" -> \" + fieldType.name();\n+                throw new IllegalArgumentException(\"Cyclic dependency detected while resolving runtime fields: \" + message);\n+            }\n+            if (fields.size() > MAX_FIELD_CHAIN) {\n+                throw new IllegalArgumentException(\"Field requires resolving too many dependent fields: \" + String.join(\" -> \", fields));\n+            }\n+            return fieldDataLookup.apply(fieldType);\n+        };\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NTM1Mg=="}, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4MjE4NQ==", "bodyText": "great point, it was a bug in my implementation, I don't think it should trigger without a chain. We may want to have a limit later also on number of direct dependencies for a single field, but not now. That should also make the 5 limit reasonable, as it is applied only as depth (also renamed the constant to clarify that).", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r477282185", "createdAt": "2020-08-26T13:02:24Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -54,4 +94,20 @@ public DocLookup doc() {\n     public SourceLookup source() {\n         return sourceLookup;\n     }\n+\n+    private static Function<MappedFieldType, IndexFieldData<?>> wrapAndTrackFieldReferences(String field,\n+            Function<MappedFieldType, IndexFieldData<?>> fieldDataLookup) {\n+        final Set<String> fields = new LinkedHashSet<>();\n+        fields.add(field);\n+        return fieldType -> {\n+            if (fields.add(fieldType.name()) == false) {\n+                String message = String.join(\" -> \", fields) + \" -> \" + fieldType.name();\n+                throw new IllegalArgumentException(\"Cyclic dependency detected while resolving runtime fields: \" + message);\n+            }\n+            if (fields.size() > MAX_FIELD_CHAIN) {\n+                throw new IllegalArgumentException(\"Field requires resolving too many dependent fields: \" + String.join(\" -> \", fields));\n+            }\n+            return fieldDataLookup.apply(fieldType);\n+        };\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NTM1Mg=="}, "originalCommit": {"oid": "09c2ed9130ae7f997ed6638ecafb1d8b7c5ff26f"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjQ0MjM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOToxMDozOFrOHFbKdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTo0NTo1NVrOHFc3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTk3Mw==", "bodyText": "32 feels big to me ;). I think we can be more aggressive here, something like 4-5 should be more than enough ?", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475449973", "createdAt": "2020-08-24T09:10:38Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -24,20 +24,60 @@\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.MapperService;\n \n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n \n public class SearchLookup {\n \n-    final DocLookup docMap;\n+    private static final int MAX_FIELD_CHAIN = 32;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NDE4Mw==", "bodyText": "fine with me, I totally expected some discussion on this limit. maybe 4-5 is a bit on the low side, shall we do 10? :)", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475454183", "createdAt": "2020-08-24T09:18:06Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -24,20 +24,60 @@\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.MapperService;\n \n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n \n public class SearchLookup {\n \n-    final DocLookup docMap;\n+    private static final int MAX_FIELD_CHAIN = 32;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTk3Mw=="}, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ2NzQ3OA==", "bodyText": "I am maybe be too cautious here but I cannot think of a good example of a chain that would require more than 2-3 indirections. Allowing for more looks like an anti-pattern to me.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475467478", "createdAt": "2020-08-24T09:32:23Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -24,20 +24,60 @@\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.MapperService;\n \n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n \n public class SearchLookup {\n \n-    final DocLookup docMap;\n+    private static final int MAX_FIELD_CHAIN = 32;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTk3Mw=="}, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NzgxNA==", "bodyText": "being cautious is not a bad idea, let's start with 5 then and see if users complain.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475477814", "createdAt": "2020-08-24T09:45:55Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/lookup/SearchLookup.java", "diffHunk": "@@ -24,20 +24,60 @@\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.MapperService;\n \n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n \n public class SearchLookup {\n \n-    final DocLookup docMap;\n+    private static final int MAX_FIELD_CHAIN = 32;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTk3Mw=="}, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjQ1Nzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOToxNDo1NlrOHFbT4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOToyMzo1NlrOHFbrGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MjM4NA==", "bodyText": "I wonder if this is the right way to do since we may forgot to override this function where needed ?\nCould we instead rely on some inheritance, runtime field type must extend a specific class to be considered runtime ?", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475452384", "createdAt": "2020-08-24T09:14:56Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -83,15 +85,22 @@ public MappedFieldType(String name, boolean isIndexed, boolean hasDocValues, Tex\n      * Return a fielddata builder for this field\n      *\n      * @param fullyQualifiedIndexName the name of the index this field-data is build for\n-     *\n+     * @param searchLookup a {@link SearchLookup} supplier to allow for accessing other fields values in the context of runtime fields\n      * @throws IllegalArgumentException if the fielddata is not supported on this type.\n      * An IllegalArgumentException is needed in order to return an http error 400\n      * when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}\n      */\n-    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName, Supplier<SearchLookup> searchLookup) {\n         throw new IllegalArgumentException(\"Fielddata is not supported on field [\" + name() + \"] of type [\" + typeName() + \"]\");\n     }\n \n+    /**\n+     * Return true for field types that are runtime fields implementation, false otherwise\n+     */\n+    public boolean isRuntimeField() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTA2NA==", "bodyText": "The idea is that runtime fields will have a common base class that overrides this method. This method is basically here to prevent having to perform instanceof checks to figure out whether something is a runtime field.", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475455064", "createdAt": "2020-08-24T09:19:40Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -83,15 +85,22 @@ public MappedFieldType(String name, boolean isIndexed, boolean hasDocValues, Tex\n      * Return a fielddata builder for this field\n      *\n      * @param fullyQualifiedIndexName the name of the index this field-data is build for\n-     *\n+     * @param searchLookup a {@link SearchLookup} supplier to allow for accessing other fields values in the context of runtime fields\n      * @throws IllegalArgumentException if the fielddata is not supported on this type.\n      * An IllegalArgumentException is needed in order to return an http error 400\n      * when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}\n      */\n-    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName, Supplier<SearchLookup> searchLookup) {\n         throw new IllegalArgumentException(\"Fielddata is not supported on field [\" + name() + \"] of type [\" + typeName() + \"]\");\n     }\n \n+    /**\n+     * Return true for field types that are runtime fields implementation, false otherwise\n+     */\n+    public boolean isRuntimeField() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MjM4NA=="}, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1ODMyOQ==", "bodyText": "ok fine with me if we have a long-term solution in the main PR", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475458329", "createdAt": "2020-08-24T09:23:56Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -83,15 +85,22 @@ public MappedFieldType(String name, boolean isIndexed, boolean hasDocValues, Tex\n      * Return a fielddata builder for this field\n      *\n      * @param fullyQualifiedIndexName the name of the index this field-data is build for\n-     *\n+     * @param searchLookup a {@link SearchLookup} supplier to allow for accessing other fields values in the context of runtime fields\n      * @throws IllegalArgumentException if the fielddata is not supported on this type.\n      * An IllegalArgumentException is needed in order to return an http error 400\n      * when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}\n      */\n-    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName, Supplier<SearchLookup> searchLookup) {\n         throw new IllegalArgumentException(\"Fielddata is not supported on field [\" + name() + \"] of type [\" + typeName() + \"]\");\n     }\n \n+    /**\n+     * Return true for field types that are runtime fields implementation, false otherwise\n+     */\n+    public boolean isRuntimeField() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MjM4NA=="}, "originalCommit": {"oid": "437e6f00c0ac6398367c618c35c78dfe3d3d63ee"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUwOTY0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNTo0MFrOHFvKtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowNzo0N1rOHFylwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzcxNg==", "bodyText": "Shadowing the lookup name here makes this harder to read. I probably had this on my version of the PR too, but could you rename lookup to l or something?", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475777716", "createdAt": "2020-08-24T17:25:40Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -290,8 +292,9 @@ MappedFieldType failIfFieldMappingNotFound(String name, MappedFieldType fieldMap\n \n     public SearchLookup lookup() {\n         if (lookup == null) {\n-            lookup = new SearchLookup(getMapperService(),\n-                    mappedFieldType -> indexFieldDataService.apply(mappedFieldType, fullyQualifiedIndex.getName()));\n+            lookup = new SearchLookup(\n+                getMapperService(),\n+                (fieldType, lookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), lookup));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "063fe1ac17e8deb1f34ae277f48af4ae743955fa"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzMzc5NA==", "bodyText": "makes sense", "url": "https://github.com/elastic/elasticsearch/pull/61430#discussion_r475833794", "createdAt": "2020-08-24T19:07:47Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -290,8 +292,9 @@ MappedFieldType failIfFieldMappingNotFound(String name, MappedFieldType fieldMap\n \n     public SearchLookup lookup() {\n         if (lookup == null) {\n-            lookup = new SearchLookup(getMapperService(),\n-                    mappedFieldType -> indexFieldDataService.apply(mappedFieldType, fullyQualifiedIndex.getName()));\n+            lookup = new SearchLookup(\n+                getMapperService(),\n+                (fieldType, lookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), lookup));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3NzcxNg=="}, "originalCommit": {"oid": "063fe1ac17e8deb1f34ae277f48af4ae743955fa"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 784, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}