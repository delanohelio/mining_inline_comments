{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNjY3ODg4", "number": 55223, "title": "SQL: Implement TIME_PARSE function for parsing strings into TIME values", "bodyText": "Implement TIME_PARSE(<time_str>, <pattern_str>) function\nwhich allows to parse a time string according to the specified\npattern into a time object. The patterns allowed are those of\njava.time.format.DateTimeFormatter.\nSupersedes: #55095\nCloses #54963", "createdAt": "2020-04-15T10:14:05Z", "url": "https://github.com/elastic/elasticsearch/pull/55223", "merged": true, "mergeCommit": {"oid": "1fe1188d449cad7d0782a202372edc52a4014135"}, "closed": true, "closedAt": "2020-05-29T08:43:50Z", "author": {"login": "Patrick0308"}, "timelineItems": {"totalCount": 90, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABaEH3iMAH2gAyNDAzNjY3ODg4OjBjMzVhMTc1NmIzYTAzMGU4NjdjNzkyYTQyODgxMTUwNGFkMDViN2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclxJgsgH2gAyNDAzNjY3ODg4OjZhYWZiMzZhMGY3NWE4MjQxM2ZlNjVjYmZlNDRjNWRlYjgyZDY4ODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0c35a1756b3a030e867c792a428811504ad05b7d", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/0c35a1756b3a030e867c792a428811504ad05b7d", "committedDate": "2019-01-12T12:09:28Z", "message": "Issue #37303 - Invalid variance fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36c886273da56cfb7872c65437b37af534da608a", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/36c886273da56cfb7872c65437b37af534da608a", "committedDate": "2019-01-14T19:04:38Z", "message": "Testcase added for #37303"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "966c46c51edffa3ba4e75aeab9de5b73a45e29dd", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/966c46c51edffa3ba4e75aeab9de5b73a45e29dd", "committedDate": "2019-01-23T17:25:34Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9b0ec9582bc2fc62473cb72e2bfe693a5db335d", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/f9b0ec9582bc2fc62473cb72e2bfe693a5db335d", "committedDate": "2019-01-24T19:55:36Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f65c03a0ba584b9964c7828ce9fcf2116968535f", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/f65c03a0ba584b9964c7828ce9fcf2116968535f", "committedDate": "2019-02-25T08:09:15Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28a493719af0963d5ba6978b14bcb3f5da5d2c0b", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/28a493719af0963d5ba6978b14bcb3f5da5d2c0b", "committedDate": "2019-12-24T07:30:41Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "617d6969a814c5b2bc21f8389dd106846d3bb8b4", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/617d6969a814c5b2bc21f8389dd106846d3bb8b4", "committedDate": "2020-01-04T17:58:30Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18b6cbbd36e12d1877d36f8d1534490dfc861470", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/18b6cbbd36e12d1877d36f8d1534490dfc861470", "committedDate": "2020-04-10T19:13:13Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "734e75bf0764be61153d2460f943261c9203f957", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/734e75bf0764be61153d2460f943261c9203f957", "committedDate": "2020-04-11T10:37:42Z", "message": "SQL: Implementing TIME_PARSE function for parsing strings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7033b27aabb886ae8e3ccb8ac81dddfbae5906b3", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/7033b27aabb886ae8e3ccb8ac81dddfbae5906b3", "committedDate": "2020-04-11T17:40:15Z", "message": "review comments fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc2e46b87da72c79de990cc66fc0096e4bf68ef8", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/fc2e46b87da72c79de990cc66fc0096e4bf68ef8", "committedDate": "2020-04-11T18:52:02Z", "message": "LocalTime To OffsetTime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8694b1159e231e42f287c80098c21c847402210a", "author": {"user": {"login": "vishnugt", "name": "Vishnu Gt"}}, "url": "https://github.com/elastic/elasticsearch/commit/8694b1159e231e42f287c80098c21c847402210a", "committedDate": "2020-04-11T19:01:05Z", "message": "Added docs for time_parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e496c212c328a335252b4256a1502105076c6559", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e496c212c328a335252b4256a1502105076c6559", "committedDate": "2020-04-15T16:08:45Z", "message": "Modify license and remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "274f461d4ce2171bb9c1527a4ca70b3727629bd8", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/274f461d4ce2171bb9c1527a4ca70b3727629bd8", "committedDate": "2020-04-15T16:35:58Z", "message": "\u201cre-ci\u201d"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6164e6be1c12e7166d07f991fc968108486eb1d0", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/6164e6be1c12e7166d07f991fc968108486eb1d0", "committedDate": "2020-04-26T06:44:39Z", "message": "modify processor and pip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7fdf0de0d5c29af3aa8574bcfb36f3d9ef6939e", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7fdf0de0d5c29af3aa8574bcfb36f3d9ef6939e", "committedDate": "2020-04-26T07:06:33Z", "message": "remove TimeParseProcessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/403b773da5362d4c8e790e5e4b55768e0a8f1799", "committedDate": "2020-04-27T08:37:49Z", "message": "modify some tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODExNjE5", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-400811619", "createdAt": "2020-04-27T10:11:51Z", "commit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMTo1MVrOGMbbxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMTo1MVrOGMbbxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NTU3Mg==", "bodyText": "Unnecessary extra new line", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415685572", "createdAt": "2020-04-27T10:11:51Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -487,6 +487,49 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse1]\n include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse2]\n --------------------------------------------------\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: datetime\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]\n+If timezone is not specified in the time string expression and the parsing pattern, the resulting `time` will\n+be in `UTC` timezone.\n+\n+[NOTE]\n+If the parsing pattern contains date units (e.g. 'dd/MM/uuuu', 'dd-MM HH:mm:ss', etc.) an error is returned\n+as the function needs to return a value of `time` type which will contain only time.\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse1]\n+--------------------------------------------------\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse2]\n+--------------------------------------------------\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODEyODIw", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-400812820", "createdAt": "2020-04-27T10:13:33Z", "commit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMzozNFrOGMbf3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMzo1MFrOGMb47g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NjYyMQ==", "bodyText": "Please revert all the formatting changes to untouched lines, it can cause confusion when looking at git history.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415686621", "createdAt": "2020-04-27T10:13:34Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -14,7 +14,7 @@ describeTable\n // tag::describeTable\n DESCRIBE emp;\n \n-       column       |     type      |    mapping    \n+       column       |     type      |    mapping", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ==", "bodyText": "I don't think that's necessary, did it cause any problems?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415687531", "createdAt": "2020-04-27T10:14:55Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODk5OA==", "bodyText": "You should override hashCode() and equals() and include the new attribute.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415688998", "createdAt": "2020-04-27T10:17:19Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "diffHunk": "@@ -8,29 +8,33 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.DateTimeParseExtractor;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n+    \n+    private final DateTimeParseExtractor dateTimeParseExtractor;\n \n-    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right) {\n+    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, DateTimeParseExtractor dateTimeParseExtractor) {\n         super(source, expression, left, right, null);\n+        this.dateTimeParseExtractor = dateTimeParseExtractor;\n     }\n \n     @Override\n     protected NodeInfo<DateTimeParsePipe> info() {\n-        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right());\n+        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), dateTimeParseExtractor);\n     }\n \n     @Override\n     protected DateTimeParsePipe replaceChildren(Pipe left, Pipe right) {\n-        return new DateTimeParsePipe(source(), expression(), left, right);\n+        return new DateTimeParsePipe(source(), expression(), left, right, dateTimeParseExtractor);\n     }\n \n     @Override\n     protected Processor makeProcessor(Processor left, Processor right, ZoneId zoneId) {\n-        return new DateTimeParseProcessor(left, right);\n+        return new DateTimeParseProcessor(left, right, dateTimeParseExtractor);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4OTg3MQ==", "bodyText": "wrong identation.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415689871", "createdAt": "2020-04-27T10:18:44Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n             }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n         }\n     }\n+    \n+    private final DateTimeParseExtractor extractor;\n+\n+    public static final String NAME = \"dtparse\";\n+\n+    public DateTimeParseProcessor(Processor source1, Processor source2, DateTimeParseExtractor extractor) {\n+        super(source1, source2, null);\n+        this.extractor = extractor;\n+    }\n \n+    public DateTimeParseProcessor(StreamInput in) throws IOException {\n+        super(in);\n+        this.extractor = in.readEnum(DateTimeParseExtractor.class);\n+    }\n+    \n+    @Override\n+    public void doWrite(StreamOutput out) throws IOException {\n+        out.writeEnum(extractor);\n+    }\n+    \n     @Override\n     public String getWriteableName() {\n         return NAME;\n     }\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern);\n+            return this.extractor.extract(timestamp, pattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MDkzNw==", "bodyText": "I would rename it to DateTimeParser or plain Parser since it's already under a class so it would be: DateTimeParseProcessor.Parser.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415690937", "createdAt": "2020-04-27T10:20:28Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MTU3Ng==", "bodyText": "Please rename it apply -> parser.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415691576", "createdAt": "2020-04-27T10:21:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjA3MQ==", "bodyText": "Please rename extactor -> parser.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692071", "createdAt": "2020-04-27T10:22:13Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n             }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n         }\n     }\n+    \n+    private final DateTimeParseExtractor extractor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjI3NA==", "bodyText": "Please rename to parse()", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692274", "createdAt": "2020-04-27T10:22:35Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjkzOQ==", "bodyText": "date shouldn't be there, should be added with DATE_PARSE function.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692939", "createdAt": "2020-04-27T10:23:42Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MzAzOA==", "bodyText": "date shouldn't be there, should be added with DATE_PARSE function.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415693038", "createdAt": "2020-04-27T10:23:50Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37703deaf11e7130097fd9f18e79556d8a200d1f", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/37703deaf11e7130097fd9f18e79556d8a200d1f", "committedDate": "2020-04-28T06:38:56Z", "message": "revert strip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ee4b0c3eaaed9a87701ed9fd94e026b887942b", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/87ee4b0c3eaaed9a87701ed9fd94e026b887942b", "committedDate": "2020-04-28T06:42:36Z", "message": "remove unnecessary extra new line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe8f9dba3a9c778de54c491004d8fe063b1e511b", "committedDate": "2020-04-28T07:33:10Z", "message": "Modify DateTimeParseExtractor to Parser."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffbb897297290880700e314597ac83714ba48b69", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/ffbb897297290880700e314597ac83714ba48b69", "committedDate": "2020-04-28T07:35:35Z", "message": "Remove date from message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfbb7c7df2e4401e3fce591e78796eec2a23cc1f", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/dfbb7c7df2e4401e3fce591e78796eec2a23cc1f", "committedDate": "2020-04-28T14:25:41Z", "message": "Merge branch 'master' into sql-time-parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c495eb9b49ac3057be8a21e23b53442234fc830", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/7c495eb9b49ac3057be8a21e23b53442234fc830", "committedDate": "2020-04-29T02:59:52Z", "message": "unset default time zone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/d55e0e393aa01a065f6b3608a3396a42c711329f", "committedDate": "2020-04-29T03:00:18Z", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNTAwMTI1", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-402500125", "createdAt": "2020-04-29T09:25:46Z", "commit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNTo0N1rOGN2uyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTo0MjoxOFrOGN3Sog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MTM4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *Output*: datetime\n          \n          \n            \n            *Output*: time", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417181386", "createdAt": "2020-04-29T09:25:47Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -487,6 +487,47 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse1]\n include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse2]\n --------------------------------------------------\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: datetime", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MTg3Mg==", "bodyText": "Please revert changes to this file.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417181872", "createdAt": "2020-04-29T09:26:39Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -18,6 +18,7 @@\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.util.List;\n+import java.util.TimeZone;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MjUzOA==", "bodyText": "Please keep the alphabetical ordering here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417182538", "createdAt": "2020-04-29T09:27:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java", "diffHunk": "@@ -77,17 +77,17 @@ private Processors() {}\n         entries.add(new Entry(Processor.class, NullIfProcessor.NAME, NullIfProcessor::new));\n \n         // datetime\n-        entries.add(new Entry(Processor.class, DateTimeProcessor.NAME, DateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, TimeProcessor.NAME, TimeProcessor::new));\n-        entries.add(new Entry(Processor.class, NamedDateTimeProcessor.NAME, NamedDateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, NonIsoDateTimeProcessor.NAME, NonIsoDateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, QuarterProcessor.NAME, QuarterProcessor::new));\n         entries.add(new Entry(Processor.class, DateAddProcessor.NAME, DateAddProcessor::new));\n         entries.add(new Entry(Processor.class, DateDiffProcessor.NAME, DateDiffProcessor::new));\n         entries.add(new Entry(Processor.class, DatePartProcessor.NAME, DatePartProcessor::new));\n-        entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));\n         entries.add(new Entry(Processor.class, DateTimeParseProcessor.NAME, DateTimeParseProcessor::new));\n+        entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NDgyMg==", "bodyText": "You should distinguish based on the enum value, this way you can have a specialized message for each and not a generic one that refers to both datetime and time.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417184822", "createdAt": "2020-04-29T09:31:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTA5OA==", "bodyText": "Minor: empty line", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185098", "createdAt": "2020-04-29T09:32:16Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+\n+    private final Parser parser;\n+\n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+        parser = Parser.TIME;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTIzNw==", "bodyText": "Minor: extra empty line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185237", "createdAt": "2020-04-29T09:32:33Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -294,9 +294,14 @@ public static String dateTimeFormat(Object dateTime, String pattern, String tzId\n     }\n \n     public static Object dateTimeParse(String dateField, String pattern, String tzId) {\n-        return DateTimeParseProcessor.process(dateField, pattern);\n+        return Parser.DATE_TIME.parse(dateField, pattern);\n     }\n \n+    public static Object timeParse(String dateField, String pattern, String tzId) {\n+        return Parser.TIME.parse(dateField, pattern);\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTUyNA==", "bodyText": "Minor: whitespaces.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185524", "createdAt": "2020-04-29T09:33:05Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -25,10 +26,11 @@\n     public static DateTimeParseProcessor randomDateTimeParseProcessor() {\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128))\n+            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n+                randomFrom(Parser.values())\n         );\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4OTc4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n          \n          \n            \n                    DATE_TIME(ZonedDateTime::from),\n          \n          \n            \n                    TIME(OffsetTime::from);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417189782", "createdAt": "2020-04-29T09:40:53Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5MDU2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Parser(BiFunction<String, String, TemporalAccessor> parser) {\n          \n          \n            \n                    Parser(TemporalQuery<?> query) {\n          \n          \n            \n                        this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n          \n          \n            \n                            .parseBest(timestampStr, query, LocalTime::from));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417190562", "createdAt": "2020-04-29T09:42:18Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7107639003808a9651e5190cefe1c3f731fae7a", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/a7107639003808a9651e5190cefe1c3f731fae7a", "committedDate": "2020-05-01T04:52:49Z", "message": "optimize some codes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e8e42744a6c6a29bbbbfe3ee0bf8c8a44c92ef8", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/5e8e42744a6c6a29bbbbfe3ee0bf8c8a44c92ef8", "committedDate": "2020-05-01T04:54:36Z", "message": "modify doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/b3635693998fcc4f4d04e95e7370b4003b67f257", "committedDate": "2020-05-01T04:59:57Z", "message": "format code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MDM2MDk5", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-404036099", "createdAt": "2020-05-01T06:17:51Z", "commit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxNzo1MVrOGPDC1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxOTo0NFrOGPDEhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTcwMA==", "bodyText": "Could be static and initialized here instead of the constructor.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431700", "createdAt": "2020-05-01T06:17:51Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+\n+    private final Parser parser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTc0Nw==", "bodyText": "same here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431747", "createdAt": "2020-05-01T06:18:05Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "diffHunk": "@@ -8,29 +8,54 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n+import java.util.Objects;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n+    \n+    private final Parser parser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTk0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n          \n          \n            \n                    Parser(String parseType,  TemporalQuery<?> queries...) {", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431948", "createdAt": "2020-05-01T06:18:54Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,115 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMjEzNA==", "bodyText": "whitespaces", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418432134", "createdAt": "2020-05-01T06:19:44Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,115 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, query, localQuery);\n+            this.parseType = parseType;\n+        }\n+        \n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {} \",\n+                    this.parseType,\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n+            }\n+        }\n+    }\n+    \n+    private final Parser parser;\n+\n     public static final String NAME = \"dtparse\";\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n+    public DateTimeParseProcessor(Processor source1, Processor source2, Parser parser) {\n         super(source1, source2, null);\n+        this.parser = parser;\n     }\n \n     public DateTimeParseProcessor(StreamInput in) throws IOException {\n         super(in);\n+        this.parser = in.readEnum(Parser.class);\n     }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n-        }\n-\n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n-\n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n-            }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n-            }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n-        }\n+    \n+    @Override\n+    public void doWrite(StreamOutput out) throws IOException {\n+        out.writeEnum(parser);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0ab4abf0a03c662d3aba02faff2808d7ecfeb27", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0ab4abf0a03c662d3aba02faff2808d7ecfeb27", "committedDate": "2020-05-01T09:09:47Z", "message": "change parser to static"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "committedDate": "2020-05-01T16:54:02Z", "message": "add tests and optimize codes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52424abfc36dacb842ed444dab906f53c603e25b", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/52424abfc36dacb842ed444dab906f53c603e25b", "committedDate": "2020-05-01T17:00:25Z", "message": "whitespaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c48208ca8c579e92e448b494ee81ad994d3b8a", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/64c48208ca8c579e92e448b494ee81ad994d3b8a", "committedDate": "2020-05-01T17:03:04Z", "message": "remove whitespaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTE5MzUy", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-404519352", "createdAt": "2020-05-02T11:05:54Z", "commit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNTo1NVrOGPiXHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNTo1NVrOGPiXHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDc5Nw==", "bodyText": "You can use a simple cast as String.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944797", "createdAt": "2020-05-02T11:05:55Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/time.csv-spec", "diffHunk": "@@ -104,3 +104,89 @@ SELECT MAX(salary) FROM test_emp GROUP BY CURRENT_TIME;\n ---------------\n 74999\n ;\n+\n+selectTimeParse\n+schema::dp_time1:time|dp_time2:time\n+SELECT TIME_PARSE('11:22:33', 'HH:mm:ss') AS dp_time1,\n+TIME_PARSE('11:22:33 -05:33', 'HH:mm:ss zz') AS dp_time2;\n+\n+       dp_time1             |    dp_time2\n+----------------------------+----------------------------\n+11:22:33.000Z               | 16:55:33.000Z\n+;\n+\n+selectTimeParseWithField\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH mm SSS ss'), 'HH mm SSS ss') AS dp_birth_time\n+FROM test_emp WHERE gender = 'M' AND emp_no BETWEEN 10037 AND 10052 ORDER BY emp_no;\n+\n+       birth_date        | dp_birth_time\n+-------------------------+-------------------------\n+1963-07-22 00:00:00.000Z | 00:00:00.000Z\n+1960-07-20 00:00:00.000Z | 00:00:00.000Z\n+1959-10-01 00:00:00.000Z | 00:00:00.000Z\n+null                     | null\n+null                     | null\n+null                     | null\n+null                     | null\n+null                     | null\n+1958-05-21 00:00:00.000Z | 00:00:00.000Z\n+1953-07-28 00:00:00.000Z | 00:00:00.000Z\n+1961-02-26 00:00:00.000Z | 00:00:00.000Z\n+;\n+\n+timeParseWhere\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH.mm.ss'), 'HH.mm.ss') AS dp_birth_time\n+FROM test_emp WHERE birth_date > '1963-10-20'::date and dp_birth_time = '00:00:00'::time ORDER BY emp_no;\n+\n+       birth_date        |     dp_birth_time\n+-------------------------+------------------------\n+1964-06-02 00:00:00.000Z | 00:00:00.000Z\n+1963-11-26 00:00:00.000Z | 00:00:00.000Z\n+1964-04-18 00:00:00.000Z | 00:00:00.000Z\n+1964-10-18 00:00:00.000Z | 00:00:00.000Z\n+1964-06-11 00:00:00.000Z | 00:00:00.000Z\n+1965-01-03 00:00:00.000Z | 00:00:00.000Z\n+;\n+\n+timeParseOrderBy\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH:mm:ss.SSS'), 'HH:mm:ss.SSS') AS dp_birth_time\n+FROM test_emp  ORDER BY 1 DESC NULLS LAST, 2 LIMIT 10;\n+\n+       birth_date        | dp_birth_time\n+-------------------------+-------------------------\n+1965-01-03 00:00:00.000Z | 00:00:00.000Z\n+1964-10-18 00:00:00.000Z | 00:00:00.000Z\n+1964-06-11 00:00:00.000Z | 00:00:00.000Z\n+1964-06-02 00:00:00.000Z | 00:00:00.000Z\n+1964-04-18 00:00:00.000Z | 00:00:00.000Z\n+1963-11-26 00:00:00.000Z | 00:00:00.000Z\n+1963-09-09 00:00:00.000Z | 00:00:00.000Z\n+1963-07-22 00:00:00.000Z | 00:00:00.000Z\n+1963-06-07 00:00:00.000Z | 00:00:00.000Z\n+1963-06-01 00:00:00.000Z | 00:00:00.000Z\n+;\n+\n+// Wait time format function implement\n+timeParseGroupBy-Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTE5Mzk3", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-404519397", "createdAt": "2020-05-02T11:06:33Z", "commit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNjozM1rOGPiXaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNjo0N1rOGPiXhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDg3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n          \n          \n            \n                                msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944875", "createdAt": "2020-05-02T11:06:33Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -70,10 +69,10 @@ public Object parse(Object timestamp, Object pattern) {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDkwMQ==", "bodyText": "I think it's better to keep the square brackets.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944901", "createdAt": "2020-05-02T11:06:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -70,10 +69,10 @@ public Object parse(Object timestamp, Object pattern) {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n                 }\n                 throw new SqlIllegalArgumentException(\n-                    \"Invalid [{}] string [{}] or pattern [{}] is received; {} \",\n+                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3a3c92a16fc2e97c271d3c69dcb30d0a4f44540", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/b3a3c92a16fc2e97c271d3c69dcb30d0a4f44540", "committedDate": "2020-05-02T11:32:01Z", "message": "Merge branch 'master' into sql-time-parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f2706d27066a1fcb62e70b8675cbb297f0ddff9", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f2706d27066a1fcb62e70b8675cbb297f0ddff9", "committedDate": "2020-05-02T14:48:09Z", "message": "add timeGroupBy tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bfa6d080888a62102ac8d4074ee740c7fb9b694", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bfa6d080888a62102ac8d4074ee740c7fb9b694", "committedDate": "2020-05-02T14:50:23Z", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd3dcbb0b6648b964878f4444eec7c5d23ca4576", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/fd3dcbb0b6648b964878f4444eec7c5d23ca4576", "committedDate": "2020-05-02T14:52:26Z", "message": "modify error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/e9148b5a3b303d6e1701edec186cd4d5796bc22b", "committedDate": "2020-05-02T16:19:28Z", "message": "Merge branch 'master' into sql-time-parse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTg3NDkz", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-404587493", "createdAt": "2020-05-03T06:53:58Z", "commit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MDM0MTQx", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-405034141", "createdAt": "2020-05-04T14:21:34Z", "commit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyMTozNFrOGQCoRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoyMDoyOVrOGQH17Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3MzQ3Nw==", "bodyText": "I don't understand this comment.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419473477", "createdAt": "2020-05-04T14:21:34Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java", "diffHunk": "@@ -62,6 +62,8 @@ public static Connection csvConnection(CsvTestCase csvTest) throws IOException,\n         csvProperties.setProperty(\"charset\", \"UTF-8\");\n         csvProperties.setProperty(\"separator\", \"|\");\n         csvProperties.setProperty(\"trimValues\", \"true\");\n+        // Converter when type is java.sql.Time use this property", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3OTc1MA==", "bodyText": "This package import I think it was ok where it was.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419479750", "createdAt": "2020-05-04T14:29:43Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -8,16 +8,17 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.type.DataTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NTg3Mw==", "bodyText": "I think we need to use a more useful set of test data. Have a look at the logs index - https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/qa/src/main/resources/logs.csv - and adjust the tests so that is uses that index instead. We need some real data for the time part, otherwise we just test a valid format, not that it's parsing that data properly.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419485873", "createdAt": "2020-05-04T14:37:53Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/src/main/resources/time.csv-spec", "diffHunk": "@@ -104,3 +104,88 @@ SELECT MAX(salary) FROM test_emp GROUP BY CURRENT_TIME;\n ---------------\n 74999\n ;\n+\n+selectTimeParse\n+schema::dp_time1:time|dp_time2:time\n+SELECT TIME_PARSE('11:22:33', 'HH:mm:ss') AS dp_time1,\n+TIME_PARSE('11:22:33 -05:33', 'HH:mm:ss zz') AS dp_time2;\n+\n+       dp_time1             |    dp_time2\n+----------------------------+----------------------------\n+11:22:33.000Z               | 16:55:33.000Z\n+;\n+\n+selectTimeParseWithField\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH mm SSS ss'), 'HH mm SSS ss') AS dp_birth_time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTI0OQ==", "bodyText": "Indentation issue.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515249", "createdAt": "2020-05-04T15:18:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -88,23 +90,26 @@ protected DateTimeParsePipe mutate(DateTimeParsePipe instance) {\n                 f.source(),\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n-                f.right()\n+                f.right(),\n+                    DATE_TIME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTM4OQ==", "bodyText": "Indentation issue.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515389", "createdAt": "2020-05-04T15:18:41Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -88,23 +90,26 @@ protected DateTimeParsePipe mutate(DateTimeParsePipe instance) {\n                 f.source(),\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n-                f.right()\n+                f.right(),\n+                    DATE_TIME\n             )\n         );\n         randoms.add(\n             f -> new DateTimeParsePipe(\n                 f.source(),\n                 f.expression(),\n                 f.left(),\n-                pipe(((Expression) randomValueOtherThan(f.right(), FunctionTestUtils::randomStringLiteral)))\n+                pipe(((Expression) randomValueOtherThan(f.right(), FunctionTestUtils::randomStringLiteral))),\n+                    DATE_TIME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTYzNA==", "bodyText": "Indentation issue.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515634", "createdAt": "2020-05-04T15:19:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -12,20 +12,24 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.sql.AbstractSqlWireSerializingTestCase;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n \n import static org.elasticsearch.xpack.ql.expression.Literal.NULL;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.time;\n \n public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestCase<DateTimeParseProcessor> {\n \n     public static DateTimeParseProcessor randomDateTimeParseProcessor() {\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128))\n+            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n+                randomFrom(Parser.values())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNzczMA==", "bodyText": "Extra white space after bracket.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419517730", "createdAt": "2020-05-04T15:21:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -126,5 +184,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time( 10, 20, 30, 123000000),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ==", "bodyText": "I don't think I like the square brackets for the first argument.\nThe original message in this class was \"Invalid date/time string [{}] or pattern [{}] is received; {}\". Notice date/time that now was replaced by [{}] which means it will generate an error message like Invalid [datetime] string [07/05/2020] or pattern [dd/MM/uuuu] is received. I think it's better without square brackets.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419540561", "createdAt": "2020-05-04T15:54:07Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NTMyMg==", "bodyText": "Do the assignments in the order received as parameters (ie this.parseType = parseType should come before this.parser=...).", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419545322", "createdAt": "2020-05-04T16:00:44Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1Nzg1MQ==", "bodyText": "TimeParse and DateTimeParse have common methods (for example resolveType). Maybe have a common class handle those and extend TimeParse and DateTimeParse from that.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419557851", "createdAt": "2020-05-04T16:18:57Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw==", "bodyText": "Shouldn't the pattern be isStringAndExact? What do you think, @matriv ? Same question for timestamp.\nOne concerning aspect, especially for pattern is that if the user provides a field as a pattern and that field is text (vs. keyword) any text in it will be analyzed. Think of capital letters being lowercased with a standard analyzer. Should we be concerned about this?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419558893", "createdAt": "2020-05-04T16:20:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/151042ac8c1ebd16368d0c632c23d88a576ecce1", "committedDate": "2020-05-06T05:26:33Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c2390a90f74727bbb02e82717943445f890f010", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/5c2390a90f74727bbb02e82717943445f890f010", "committedDate": "2020-05-06T06:17:13Z", "message": "Merge remote-tracking branch 'upstream/master' into sql-time-parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5813066992b78c306863af85f633585e52b9a518", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/5813066992b78c306863af85f633585e52b9a518", "committedDate": "2020-05-06T07:51:39Z", "message": "modify tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDA4NDg0", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-406408484", "createdAt": "2020-05-06T08:39:49Z", "commit": {"oid": "151042ac8c1ebd16368d0c632c23d88a576ecce1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozOTo0OVrOGRJQyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozOTo0OVrOGRJQyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMDcyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(time( 10, 20, 30, 123000000),\n          \n          \n            \n                    assertEquals(time(10, 20, 30, 123000000),", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r420630729", "createdAt": "2020-05-06T08:39:49Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -185,14 +185,12 @@ public void testParsing() {\n                 .process(null)\n         );\n         // TimeParse\n-        assertEquals(\n-                time( 10, 20, 30, 123000000),\n+        assertEquals(time( 10, 20, 30, 123000000),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "151042ac8c1ebd16368d0c632c23d88a576ecce1"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f674d01d573f0be79b02eae953c9f285c6f9b0c9", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/f674d01d573f0be79b02eae953c9f285c6f9b0c9", "committedDate": "2020-05-07T02:46:12Z", "message": "extract BaseDateTimeParseFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e4704af2ebf67c05c291bff25977492c8ba8615c", "committedDate": "2020-05-07T04:23:51Z", "message": "modify tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MzAzMjQx", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-407303241", "createdAt": "2020-05-07T09:30:40Z", "commit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMDo0MFrOGR2UBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0ODo1MFrOGR2_og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2ODgzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Parser extractor() {\n          \n          \n            \n                public Parser parser() {", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421368837", "createdAt": "2020-05-07T09:30:40Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){\n+        return parser.toString();\n+    }\n+    \n+    public Parser extractor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTAxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId , Parser parser) {\n          \n          \n            \n                public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId, Parser parser) {", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369019", "createdAt": "2020-05-07T09:31:01Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else if (ta instanceof ZonedDateTime){\n+                    return ((ZonedDateTime) ta).withZoneSameInstant(zoneId);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",\n+                    this.parseType,\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n+            }\n+        }\n+    }\n+    \n+    private final Parser parser;\n+\n     public static final String NAME = \"dtparse\";\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId) {\n+    public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId , Parser parser) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.hash(parser, left(), right());\n          \n          \n            \n                    return Objects.hash(left(), right(), parser);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369302", "createdAt": "2020-05-07T09:31:27Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -79,12 +111,12 @@ public String getWriteableName() {\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern, zoneId());\n+        return this.parser.parse(timestamp, pattern, zoneId());\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right());\n+        return Objects.hash(parser, left(), right());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTY3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.equals(parser, other.parser)\n          \n          \n            \n                    return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n          \n          \n            \n                        && Objects.equals(parser, other.parser);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369677", "createdAt": "2020-05-07T09:32:01Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MDE1Ng==", "bodyText": "Is this used? If so it shouldn't contain only the parser.toString() but also left & and right.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421370156", "createdAt": "2020-05-07T09:32:46Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MjEwNA==", "bodyText": "The zoneId should be passed and used, please check out the changes in #56158", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421372104", "createdAt": "2020-05-07T09:36:02Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BaseDateTimeParseFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzUzNw==", "bodyText": "The user session zoneId should be used.\nAn if for the OffsetTime should be added to apply the session zoneId also for times with a zone in the pattern.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421373537", "createdAt": "2020-05-07T09:38:26Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NDI3Mg==", "bodyText": "Parent class could hold a parser variable which is set accordingly in the constructors of the sub classes so this method and createPipe can be moved to the parent class.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421374272", "createdAt": "2020-05-07T09:39:36Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BaseDateTimeParseFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    @Override\n+    protected BinaryScalarFunction replaceChildren(Expression timestamp, Expression pattern) {\n+        return new TimeParse(source(), timestamp, pattern);\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, TimeParse::new, left(), right());\n+    }\n+\n+    @Override\n+    protected String scriptMethodName() {\n+        return \"timeParse\";\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return TIME.parse(left().fold(), right().fold(), zoneId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NTk5NQ==", "bodyText": "DATE_TIME should be randomized with randomFrom(Parser.values())", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421375995", "createdAt": "2020-05-07T09:42:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,12 +53,12 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId());\n+        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId(), DATE_TIME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NzU3MQ==", "bodyText": "Please change test tests similarly to https://github.com/elastic/elasticsearch/pull/55223/files#diff-4469bf63c6bd559fd4d04c24e52f23e4R172 where the session timezone is used for the resulting time.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421377571", "createdAt": "2020-05-07T09:44:50Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDAwMg==", "bodyText": "DateTimeParse shouldn't be then only function used in the creation of the pipe, since the pipe now doesn't \"belong\" to one function but it's more generic. Check this example https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/string/BinaryStringNumericPipeTests.java#L42 where you can randomize between the 2 functions DateTimeParse and TimeParse.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421380002", "createdAt": "2020-05-07T09:48:50Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -23,6 +23,8 @@\n import static org.elasticsearch.xpack.ql.expression.Expressions.pipe;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.ql.tree.SourceTests.randomSource;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+\n \n public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePipe, Pipe> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "committedDate": "2020-05-08T07:30:16Z", "message": "optimize code and offset time apply the session zoneId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8f808e52d241c69799659c9a92b4b3694b6792a", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/c8f808e52d241c69799659c9a92b4b3694b6792a", "committedDate": "2020-05-08T07:33:17Z", "message": "Revert: optimize code and offset time apply the session zoneId (ab81a18c)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d562e8c26767ddaef586d198b08c3f42c7c53ea", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d562e8c26767ddaef586d198b08c3f42c7c53ea", "committedDate": "2020-05-08T07:46:35Z", "message": "remove DateTimeParseProcessor.toString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e4ad4e3f7cabc2ecbfb650d7effffc48306c12b", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e4ad4e3f7cabc2ecbfb650d7effffc48306c12b", "committedDate": "2020-05-08T07:47:43Z", "message": "format DateTimeParsePipeTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4981fabd5aeea09ff4a26a59dabc1616ebde234", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4981fabd5aeea09ff4a26a59dabc1616ebde234", "committedDate": "2020-05-08T07:48:57Z", "message": "modify atTimeZone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b511e5420dea6f0eb47188f49978d50fd4db4ff", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b511e5420dea6f0eb47188f49978d50fd4db4ff", "committedDate": "2020-05-08T08:09:19Z", "message": "Modify DateTimeParseProcessorTests.testParsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "committedDate": "2020-05-08T08:11:08Z", "message": "Optimize code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDc5OTAy", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-408079902", "createdAt": "2020-05-08T08:17:55Z", "commit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoxNzo1NVrOGSdjvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMToyM1rOGSdptg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMTgzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));\n          \n          \n            \n                    return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(lt.atDate(LocalDate.EPOCH)).get(0));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422011836", "createdAt": "2020-05-08T08:17:55Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -209,4 +211,32 @@ public static int getNanoPrecision(Expression precisionExpression, int nano) {\n     public static ZonedDateTime atTimeZone(LocalDateTime ldt, ZoneId zoneId) {\n         return ZonedDateTime.ofInstant(ldt, zoneId.getRules().getValidOffsets(ldt).get(0), zoneId);\n     }\n+    \n+    public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n+    }\n+    \n+    public static OffsetTime atTimeZone(LocalTime lt, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMjgzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n          \n          \n            \n                    return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ot.atDate(LocalDate.EPOCH).toLocalDateTime()).get(0));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422012831", "createdAt": "2020-05-08T08:20:10Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -209,4 +211,32 @@ public static int getNanoPrecision(Expression precisionExpression, int nano) {\n     public static ZonedDateTime atTimeZone(LocalDateTime ldt, ZoneId zoneId) {\n         return ZonedDateTime.ofInstant(ldt, zoneId.getRules().getValidOffsets(ldt).get(0), zoneId);\n     }\n+    \n+    public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzI2NQ==", "bodyText": "Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013265", "createdAt": "2020-05-08T08:21:08Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DATETIME;\n+    protected Parser parser() {\n+        return DATE_TIME;\n     }\n-\n+    \n     @Override\n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        return TypeResolution.TYPE_RESOLVED;\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n+        return DateTimeParse::new;\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzMwNg==", "bodyText": "Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013306", "createdAt": "2020-05-08T08:21:14Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DATETIME;\n+    protected Parser parser() {\n+        return DATE_TIME;\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzM2Ng==", "bodyText": "Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013366", "createdAt": "2020-05-08T08:21:23Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a59795536910406852cc7703cedaef062ce8f2e", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a59795536910406852cc7703cedaef062ce8f2e", "committedDate": "2020-05-08T08:48:36Z", "message": "optimize code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "698ae838dcafda5a82c66f1dd1a44fac651191ae", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/698ae838dcafda5a82c66f1dd1a44fac651191ae", "committedDate": "2020-05-08T08:50:23Z", "message": "remove whitespaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9e7f955ebff15b548189508977093ecd2327415", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/d9e7f955ebff15b548189508977093ecd2327415", "committedDate": "2020-05-08T10:11:06Z", "message": "modify unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa", "committedDate": "2020-05-08T10:28:07Z", "message": "Modify csv tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTUzMTU1", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-408153155", "createdAt": "2020-05-08T10:40:59Z", "commit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MDo1OVrOGShUCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MDo1OVrOGShUCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            08:20:30.000Z\n          \n          \n            \n            10:20:30.000+03:00", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422073353", "createdAt": "2020-05-08T10:40:59Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTUzNTM5", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-408153539", "createdAt": "2020-05-08T10:41:52Z", "commit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MTo1MlrOGShVNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MTo1MlrOGShVNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzY1Mg==", "bodyText": "Please include it in a NOTE similarly to: https://github.com/elastic/elasticsearch/pull/56158/files#diff-b91ca24147aa7c0d4371fa129d3e51bdR487", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422073652", "createdAt": "2020-05-08T10:41:52Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -496,6 +496,53 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse3]\n --------------------------------------------------\n ====\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: time\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]\n+If timezone is not specified in the time string expression and the parsing pattern, the resulting `time` will\n+be in `UTC` timezone.\n+\n+[NOTE]\n+If the parsing pattern contains date units (e.g. 'dd/MM/uuuu', 'dd-MM HH:mm:ss', etc.) an error is returned\n+as the function needs to return a value of `time` type which will contain only time.\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse1]\n+--------------------------------------------------\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse2]\n+--------------------------------------------------\n+\n+[source, sql]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5b3345ed6a1f22859c8a9e58cea9d19ed8557ad", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e5b3345ed6a1f22859c8a9e58cea9d19ed8557ad", "committedDate": "2020-05-08T14:22:15Z", "message": "add note"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cbaf5ff63d4f94479cf8027d16d7380c7fead8b", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/9cbaf5ff63d4f94479cf8027d16d7380c7fead8b", "committedDate": "2020-05-08T14:23:28Z", "message": "modify unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74fb5ddf3c2cd233606cdf91c575b425b612f5bd", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/74fb5ddf3c2cd233606cdf91c575b425b612f5bd", "committedDate": "2020-05-08T14:28:43Z", "message": "modify docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ebd5f883f5fdc1808f6ab815c64c1d21c716eec", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/1ebd5f883f5fdc1808f6ab815c64c1d21c716eec", "committedDate": "2020-05-08T15:44:27Z", "message": "modify note"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MzA0NTE3", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-408304517", "createdAt": "2020-05-08T15:04:24Z", "commit": {"oid": "74fb5ddf3c2cd233606cdf91c575b425b612f5bd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNDoyNFrOGSozsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoyOTowNVrOGSrhww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NjE0Ng==", "bodyText": "Please remove the whole note.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422196146", "createdAt": "2020-05-08T15:04:24Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -496,6 +496,59 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse3]\n --------------------------------------------------\n ====\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: time\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74fb5ddf3c2cd233606cdf91c575b425b612f5bd"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MDcwNw==", "bodyText": "If timezone is not specified in the time string expression and the parsing pattern, \nthe resulting `time` will have the offset of the time zone specified by the user through the\n <<sql-rest-fields-timezone,`time_zone`>>/<<jdbc-cfg-timezone,`timezone`>> REST/driver \nparameters at the Unix epoch date (`1970-01-01`) with no conversion applied.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422240707", "createdAt": "2020-05-08T16:29:05Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -496,6 +496,59 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse3]\n --------------------------------------------------\n ====\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: time\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]\n+If timezone is not specified in the time string expression and the parsing pattern, the resulting `time` will\n+be in `UTC` timezone.\n+\n+[NOTE]\n+If the parsing pattern contains date units (e.g. 'dd/MM/uuuu', 'dd-MM HH:mm:ss', etc.) an error is returned\n+as the function needs to return a value of `time` type which will contain only time.\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse1]\n+--------------------------------------------------\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse2]\n+--------------------------------------------------\n+\n+[NOTE]\n+====\n+The resulting `time` will have the offset time of time zone in The Unix epoch which specified by the user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ebd5f883f5fdc1808f6ab815c64c1d21c716eec"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dcd01fac5478906983ea422589b736d1c23ec45", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/5dcd01fac5478906983ea422589b736d1c23ec45", "committedDate": "2020-05-08T16:51:58Z", "message": "Merge branch 'master' into sql-time-parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f20c85f7c0534b92c53d6be131cb6019faef965", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/7f20c85f7c0534b92c53d6be131cb6019faef965", "committedDate": "2020-05-09T00:32:40Z", "message": "modify docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f50cac49a64cd4f73aaed73c99024999a5029c", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/04f50cac49a64cd4f73aaed73c99024999a5029c", "committedDate": "2020-05-09T00:32:57Z", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NjIwNzU5", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-408620759", "createdAt": "2020-05-09T07:11:49Z", "commit": {"oid": "04f50cac49a64cd4f73aaed73c99024999a5029c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d06031745f00b2772cc3935365572826bc4226b3", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/d06031745f00b2772cc3935365572826bc4226b3", "committedDate": "2020-05-11T04:51:13Z", "message": "rename function name to randomDateTimeParsePipe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "committedDate": "2020-05-13T14:00:35Z", "message": "Merge branch 'master' into sql-time-parse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MjQyMDk4", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-414242098", "createdAt": "2020-05-19T08:58:39Z", "commit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODo1ODo0MFrOGXWsOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMjoxMVrOGXdFyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0MjIwMg==", "bodyText": "zoneId() should be part of equals and hashCode methods, through super method calls.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427142202", "createdAt": "2020-05-19T08:58:40Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -128,16 +121,11 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(parser, other.parser)\n-            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n-    }\n-\n-    @Override\n-    public String toString(){\n-        return parser.toString();\n+        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjU5OQ==", "bodyText": "Please, remove these whitespaces.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427146599", "createdAt": "2020-05-19T09:05:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -6,65 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class TimeParse extends BinaryDateTimeFunction {\n+public class TimeParse extends BaseDateTimeParseFunction {\n     \n-    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjY3NA==", "bodyText": "Please, remove these whitespaces.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427146674", "createdAt": "2020-05-19T09:05:25Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -6,65 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class TimeParse extends BinaryDateTimeFunction {\n+public class TimeParse extends BaseDateTimeParseFunction {\n     \n-    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return SqlDataTypes.TIME;\n+    protected Parser parser() {\n+        return TIME;\n     }\n-\n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        return TypeResolution.TYPE_RESOLVED;\n+    \n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n+        return TimeParse::new;\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjcxMQ==", "bodyText": "This should be new DateTimeParsePipe(b3.source().....). You change here the Parser not the Source. Source was changed and asserted before this.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427166711", "createdAt": "2020-05-19T09:37:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -53,21 +61,38 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), DATE_TIME);\n+        DateTimeParsePipe newB = new DateTimeParsePipe(\n+                b1.source(), \n+                newExpression, \n+                b1.left(), \n+                b1.right(), \n+                b1.zoneId(), \n+                b1.parser());\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), DATE_TIME);\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), b2.parser());\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n+    \n+        DateTimeParsePipe b3 = randomInstance();\n+        Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n+        newB = new DateTimeParsePipe(newLoc, b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNTU2NQ==", "bodyText": "In testTransform I think you need to test a new zoneId, as well.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427205565", "createdAt": "2020-05-19T10:45:03Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,21 +61,38 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTY3MA==", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245670", "createdAt": "2020-05-19T11:59:33Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -76,7 +82,8 @@ public void testInvalidInputs() {\n             () -> new DateTimeParse(Source.EMPTY, l(\"2020-04-07\"), l(\"MM/dd\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [2020-04-07] or pattern [MM/dd] is received; Text '2020-04-07' could not be parsed at index 2\",\n+            \"Invalid datetime string [2020-04-07] or pattern [MM/dd] is received; \" +\n+                    \"Text '2020-04-07' could not be parsed at index 2\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTczNg==", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245736", "createdAt": "2020-05-19T11:59:41Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -85,7 +92,8 @@ public void testInvalidInputs() {\n             () -> new DateTimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [07/05/2020] or pattern [dd/MM/uuuu] is received; Unable to convert parsed text into [datetime]\",\n+            \"Invalid datetime string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n+                    \"Unable to convert parsed text into [datetime]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTg3OA==", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245878", "createdAt": "2020-05-19T11:59:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -94,20 +102,70 @@ public void testInvalidInputs() {\n                 Source.EMPTY, l(\"10:20:30.123456789\"), l(\"HH:mm:ss.SSSSSSSSS\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [10:20:30.123456789] or pattern [HH:mm:ss.SSSSSSSSS] is received; \"\n+            \"Invalid datetime string [10:20:30.123456789] or pattern [HH:mm:ss.SSSSSSSSS] is received; \"\n                 + \"Unable to convert parsed text into [datetime]\",\n             siae.getMessage()\n         );\n     }\n+    \n+    public void testTimeInvalidInputs() {\n+        SqlIllegalArgumentException siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(10), randomStringLiteral(), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\"A string is required; received [10]\", siae.getMessage());\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, randomStringLiteral(), l(20), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\"A string is required; received [20]\", siae.getMessage());\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"11:04:07\"), l(\"invalid\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [11:04:07] or pattern [invalid] is received; Unknown pattern letter: i\",\n+                siae.getMessage()\n+        );\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"11:04:07\"), l(\"HH:mm\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [11:04:07] or pattern [HH:mm] is received; \" +\n+                        \"Text '11:04:07' could not be parsed, unparsed text found at index 5\",\n+                siae.getMessage()\n+        );\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n+                        \"Unable to convert parsed text into [time]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NjgzNw==", "bodyText": "These lines do not align with the previous tests in the same method. Please, use the same indentation rules.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427246837", "createdAt": "2020-05-19T12:01:45Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NzA0OA==", "bodyText": "These lines do not align with the previous tests in the same method. Please, use the same indentation rules.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427247048", "createdAt": "2020-05-19T12:02:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)\n+        );\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 162}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bf2a6410481e822740514c54370b3ef67b3fde7", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/5bf2a6410481e822740514c54370b3ef67b3fde7", "committedDate": "2020-05-20T08:05:34Z", "message": "code format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e", "committedDate": "2020-05-20T08:05:56Z", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MTEzOTk0", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-415113994", "createdAt": "2020-05-20T08:39:24Z", "commit": {"oid": "6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODozOToyNFrOGYBLig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODozOToyNFrOGYBLig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzODM0Ng==", "bodyText": "All these four lines do not align with the rest of the calls in the same method. Compare these with the ones above and, please, change them to have a consistent look and feel.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427838346", "createdAt": "2020-05-20T08:39:24Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -192,14 +189,14 @@ public void testParsing() {\n         assertEquals(\n                 time(10, 20, 30, 123000000, zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "590b1585608e862f9fba6532940ab2cc05b5dfeb", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/590b1585608e862f9fba6532940ab2cc05b5dfeb", "committedDate": "2020-05-21T04:26:12Z", "message": "add zone transform test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e76b1182ad651a7484fc8be95909e229be6f641d", "committedDate": "2020-05-21T04:27:05Z", "message": "hashcode and equals include zoneId"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTUyMzIx", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-415952321", "createdAt": "2020-05-21T08:00:24Z", "commit": {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODowMDoyNFrOGYp1_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODowMToxNlrOGYp3Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNDU3NA==", "bodyText": "Please use super.hashCode() and add only the parser here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r428504574", "createdAt": "2020-05-21T08:00:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -107,7 +107,7 @@ protected Object doProcess(Object timestamp, Object pattern) {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right(), parser);\n+        return Objects.hash(left(), right(), zoneId(), parser);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNDg5MA==", "bodyText": "Please use super.equals() and only check the equality on parser here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r428504890", "createdAt": "2020-05-21T08:01:16Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -122,7 +122,7 @@ public boolean equals(Object obj) {\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n         return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n-                && Objects.equals(parser, other.parser);\n+                && Objects.equals(zoneId(), other.zoneId()) && Objects.equals(parser, other.parser);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f1a0df813b0738c7ff450e72b43fe16c36fbc8d", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/1f1a0df813b0738c7ff450e72b43fe16c36fbc8d", "committedDate": "2020-05-23T09:22:07Z", "message": "use super's hashcode and equal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2f346a1f5705d0e63388eafd684e15460fbfed9", "committedDate": "2020-05-25T02:32:17Z", "message": "Merge remote-tracking branch 'upstream/master' into sql-time-parse"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDU4ODgy", "url": "https://github.com/elastic/elasticsearch/pull/55223#pullrequestreview-418458882", "createdAt": "2020-05-26T16:13:11Z", "commit": {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxMzoxMVrOGal08A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxODowN1rOGamCCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNTkyMA==", "bodyText": "This is wrong again. It should be\n        DateTimeParsePipe b4 = randomInstance();\n        ZoneId newZI = randomValueOtherThan(b4.zoneId(), ESTestCase::randomZone);\n        newB = new DateTimeParsePipe(b4.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n        assertEquals(newB, b4.transformPropertiesOnly(v -> Objects.equals(v, b4.zoneId()) ? newZI : v, ZoneId.class));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r430535920", "createdAt": "2020-05-26T16:13:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,21 +62,43 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId());\n+        DateTimeParsePipe newB = new DateTimeParsePipe(\n+                b1.source(), \n+                newExpression, \n+                b1.left(), \n+                b1.right(), \n+                b1.zoneId(), \n+                b1.parser());\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId());\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), b2.parser());\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n+    \n+        DateTimeParsePipe b3 = randomInstance();\n+        Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n+        newB = new DateTimeParsePipe(b3.source(), b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.parser()) ? newPr : v, Parser.class));\n+    \n+        DateTimeParsePipe b4 = randomInstance();\n+        ZoneId newZI = ESTestCase.randomZone();\n+        newB = new DateTimeParsePipe(b3.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.zoneId()) ? newZI : v, ZoneId.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzOTI3Mw==", "bodyText": "Again, indentation should be consistent. This method should look like below. As it is now, it is not like I commented in my review.\n    public void testParsing() {\n        // DateTimeParse\n        ZoneId zoneId = ZoneId.of(\"America/Sao_Paulo\");\n        assertEquals(\n            dateTime(2020, 4, 7, 10, 20, 30, 123000000, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123\"), l(\"dd/MM/uuuu HH:mm:ss.SSS\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            dateTime(2020, 4, 7, 5, 20, 30, 123456789, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 Europe/Berlin\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS VV\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            dateTime(2020, 4, 7, 1, 50, 30, 123456789, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 +05:30\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS zz\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        // TimeParse\n        assertEquals(\n            time(10, 20, 30, 123000000, zoneId),\n            new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n            new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n                .asProcessor()\n                .process(null)\n        );\n    }", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r430539273", "createdAt": "2020-05-26T16:18:07Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +185,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                    .asProcessor()\n+                    .process(null)\n+        );\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                    .asProcessor()\n+                    .process(null)\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9"}, "originalPosition": 160}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0290575d9bf90d6e3f102eda48b71316582a998d", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/0290575d9bf90d6e3f102eda48b71316582a998d", "committedDate": "2020-05-27T10:11:24Z", "message": "modify tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3a04ddc3e4472fb0c7d30f520327c3ffead34c2", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/e3a04ddc3e4472fb0c7d30f520327c3ffead34c2", "committedDate": "2020-05-28T01:44:04Z", "message": "Merge remote-tracking branch 'upstream/master' into sql-time-parse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "128c7ca95d70fde8b30d6135596de1496092964e", "author": {"user": {"login": "Patrick0308", "name": "\u767d\u6cfd"}}, "url": "https://github.com/elastic/elasticsearch/commit/128c7ca95d70fde8b30d6135596de1496092964e", "committedDate": "2020-05-28T03:25:24Z", "message": "override instanceZoneId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aafb36a0f75a82413fe65cbfe44c5deb82d6885", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/6aafb36a0f75a82413fe65cbfe44c5deb82d6885", "committedDate": "2020-05-28T17:17:01Z", "message": "Merge branch 'master' into sql-time-parse"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3363, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}