{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MTk3MjQ3", "number": 56292, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoyODozNFrOD55YqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMDo1OVrOD55cjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDM1NjI0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoyODozNVrOGRbSlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoyODozNVrOGRbSlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyNjEwMw==", "bodyText": "NIT: maybe use .get instead of .actionGet to get the full stacktrace logged on failure?", "url": "https://github.com/elastic/elasticsearch/pull/56292#discussion_r420926103", "createdAt": "2020-05-06T16:28:35Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java", "diffHunk": "@@ -86,37 +90,26 @@ public void testEnsureWeReconnect() throws Exception {\n                 .put(\"cluster.remote.test.seeds\",\n                     remoteNode.getAddress().getAddress() + \":\" + remoteNode.getAddress().getPort()).build();\n             try (MockTransportService service = MockTransportService.createNewService(localSettings, Version.CURRENT, threadPool, null)) {\n-                Semaphore semaphore = new Semaphore(1);\n                 service.start();\n-                service.getRemoteClusterService().getConnections().forEach(con -> {\n-                    con.getConnectionManager().addListener(new TransportConnectionListener() {\n-                        @Override\n-                        public void onNodeDisconnected(DiscoveryNode node, Transport.Connection connection) {\n-                            if (remoteNode.equals(node)) {\n-                                semaphore.release();\n-                            }\n-                        }\n-                    });\n-                });\n                 // this test is not perfect since we might reconnect concurrently but it will fail most of the time if we don't have\n                 // the right calls in place in the RemoteAwareClient\n                 service.acceptIncomingRequests();\n+                RemoteClusterService remoteClusterService = service.getRemoteClusterService();\n+                assertBusy(() -> assertTrue(remoteClusterService.isRemoteNodeConnected(\"test\", remoteNode)));\n                 for (int i = 0; i < 10; i++) {\n-                    semaphore.acquire();\n-                    try {\n-                        service.getRemoteClusterService().getConnections().forEach(con -> {\n-                            con.getConnectionManager().disconnectFromNode(remoteNode);\n-                        });\n-                        semaphore.acquire();\n-                        RemoteClusterService remoteClusterService = service.getRemoteClusterService();\n-                        Client client = remoteClusterService.getRemoteClusterClient(threadPool, \"test\");\n-                        ClusterStateResponse clusterStateResponse = client.admin().cluster().prepareState().execute().get();\n-                        assertNotNull(clusterStateResponse);\n-                        assertEquals(\"foo_bar_cluster\", clusterStateResponse.getState().getClusterName().value());\n-                        assertTrue(remoteClusterService.isRemoteNodeConnected(\"test\", remoteNode));\n-                    } finally {\n-                        semaphore.release();\n-                    }\n+                    RemoteClusterConnection remoteClusterConnection = remoteClusterService.getRemoteClusterConnection(\"test\");\n+                    ConnectionManager connectionManager = remoteClusterConnection.getConnectionManager();\n+                    Transport.Connection connection = connectionManager.getConnection(remoteNode);\n+                    PlainActionFuture<Void> closeFuture = PlainActionFuture.newFuture();\n+                    connection.addCloseListener(closeFuture);\n+                    connectionManager.disconnectFromNode(remoteNode);\n+                    closeFuture.actionGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77400cdfeead158a5835cac03cee07d5f3ddfbc4"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDM2NjIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMDo1OVrOGRbZGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMDo1OVrOGRbZGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyNzc2OA==", "bodyText": "NIT: probably doesn't matter much but maybe make it a message supplier now that it's debug level logging here? (same goes for the other debug that uses a new ParameterizedMessage  added below)", "url": "https://github.com/elastic/elasticsearch/pull/56292#discussion_r420927768", "createdAt": "2020-05-06T16:30:59Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java", "diffHunk": "@@ -255,17 +254,21 @@ private void collectRemoteNodes(Iterator<Supplier<DiscoveryNode>> seedNodes, Act\n \n             final StepListener<Void> fullConnectionStep = new StepListener<>();\n             handshakeStep.whenComplete(handshakeResponse -> {\n-                final DiscoveryNode handshakeNode = maybeAddProxyAddress(proxyAddress, handshakeResponse.getDiscoveryNode());\n+                final DiscoveryNode handshakeNode = handshakeResponse.getDiscoveryNode();\n \n                 if (nodePredicate.test(handshakeNode) && shouldOpenMoreConnections()) {\n-                    connectionManager.connectToNode(handshakeNode, null,\n-                        transportService.connectionValidator(handshakeNode), fullConnectionStep);\n+                    logger.trace(\"[{}] opening managed connection to seed node: [{}] proxy address: [{}]\", clusterAlias, handshakeNode,\n+                        proxyAddress);\n+                    final DiscoveryNode handshakeNodeWithProxy = maybeAddProxyAddress(proxyAddress, handshakeNode);\n+                    connectionManager.connectToNode(handshakeNodeWithProxy, null,\n+                        transportService.connectionValidator(handshakeNodeWithProxy), fullConnectionStep);\n                 } else {\n                     fullConnectionStep.onResponse(null);\n                 }\n             }, e -> {\n                 final Transport.Connection connection = openConnectionStep.result();\n-                logger.warn(new ParameterizedMessage(\"failed to connect to seed node [{}]\", connection.getNode()), e);\n+                final DiscoveryNode node = connection.getNode();\n+                logger.debug(new ParameterizedMessage(\"[{}] failed to handshake with seed node: [{}]\", clusterAlias, node), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77400cdfeead158a5835cac03cee07d5f3ddfbc4"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 684, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}