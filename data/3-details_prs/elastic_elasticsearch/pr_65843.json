{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxOTgyNDAx", "number": 65843, "title": "Move RestClusterStateAction Response Serialization to Management Pool", "bodyText": "Moving the cluster state response serialization to the management thread just like we did for the mappings response in #57937 since it's a potentially very large and slow to serialize response.", "createdAt": "2020-12-03T18:16:57Z", "url": "https://github.com/elastic/elasticsearch/pull/65843", "merged": true, "mergeCommit": {"oid": "2d336d12b9cdef9f4ca754771ebb8428f5650b75"}, "closed": true, "closedAt": "2020-12-04T11:56:48Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdinMz2gH2gAyNTMxOTgyNDAxOmIwNWNiYjdmYzNhYTZjMzAzNjU4ZDc4NTFmYWEwZTY4ODkyMDA5ZWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdi2XQQAFqTU0NDg5MDg3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b05cbb7fc3aa6c303658d7851faa0e68892009ec", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b05cbb7fc3aa6c303658d7851faa0e68892009ec", "committedDate": "2020-12-03T18:10:57Z", "message": "Move TransportClusterStateAction to Management Pool\n\nResponding with the full cluster state implies serializing the full cluster\nstate on the IO thread. In case of very large cluster states this serialization\nis not a trivial action and can take multiple seconds so it shouldn't be happening\non a transport thread."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6898eba67aa3dde49b5e7fe031f779f8ab28c43", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e6898eba67aa3dde49b5e7fe031f779f8ab28c43", "committedDate": "2020-12-03T22:24:56Z", "message": "Merge remote-tracking branch 'elastic/master' into cs-response-on-management-thread"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/3f0ea978a519531400b8df96c75fa21e91ed9761", "committedDate": "2020-12-03T22:33:04Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0Nzc3MDc0", "url": "https://github.com/elastic/elasticsearch/pull/65843#pullrequestreview-544777074", "createdAt": "2020-12-04T09:13:18Z", "commit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxMzoxOFrOH_HptA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxNjo1M1rOH_HywA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA==", "bodyText": "Are you sure that buildResponse() is the expensive bit? That's not where the serialisation happens, it's just reorganising some maps a bit.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535947700", "createdAt": "2020-12-04T09:13:18Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                ActionRunnable.supply(listener, () -> buildResponse(request, currentState)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA==", "bodyText": "If we build a response not on a transport thread, we still serialise it on the transport thread right? If it's just the outbound serialization bit that's slow, how is it logged? AIUI today we only log slowness when processing an inbound request.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535949378", "createdAt": "2020-12-04T09:15:55Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1MDAxNg==", "bodyText": "Nice \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535950016", "createdAt": "2020-12-04T09:16:53Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a326f797bfd8386e157e16426b62919536af68db", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a326f797bfd8386e157e16426b62919536af68db", "committedDate": "2020-12-04T10:55:21Z", "message": "Merge remote-tracking branch 'elastic/master' into cs-response-on-management-thread"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/02b7fb649528f6707a4e33b98a239e8786a8b3e9", "committedDate": "2020-12-04T11:00:14Z", "message": "revert transport action changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODYyNDA1", "url": "https://github.com/elastic/elasticsearch/pull/65843#pullrequestreview-544862405", "createdAt": "2020-12-04T11:06:08Z", "commit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowNjowOFrOH_MC7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowNjowOFrOH_MC7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxOTY5Mg==", "bodyText": "I kept this test cleanup even though it's not necessary now with the transport action changes reverted because busy asserting on futures was just weird ...", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536019692", "createdAt": "2020-12-04T11:06:08Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/state/ClusterStateApiTests.java", "diffHunk": "@@ -52,10 +53,7 @@ public void testWaitForMetadataVersion() throws Exception {\n         updateSettingsRequest.transientSettings(Settings.builder().put(\"cluster.max_shards_per_node\", 999));\n         assertAcked(client().admin().cluster().updateSettings(updateSettingsRequest).actionGet());\n \n-        assertBusy(() -> {\n-            assertThat(future2.isDone(), is(true));\n-        });\n-        ClusterStateResponse response = future2.actionGet();\n+        response = future2.get(10L, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODkwODc0", "url": "https://github.com/elastic/elasticsearch/pull/65843#pullrequestreview-544890874", "createdAt": "2020-12-04T11:49:35Z", "commit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo0OTozNVrOH_Nfog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo0OTozNVrOH_Nfog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0MzQyNg==", "bodyText": "Seems a bit weird to create the listener just to immediately complete it. Why not inline this?", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536043426", "createdAt": "2020-12-04T11:49:35Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");\n+                                        }\n+                                        builder.startObject();\n+                                        if (clusterStateRequest.waitForMetadataVersion() != null) {\n+                                            builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n+                                        }\n+                                        builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n+                                        ToXContent.Params params = new ToXContent.DelegatingMapParams(\n+                                                singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n+                                        response.getState().toXContent(builder, params);\n+                                        builder.endObject();\n+                                        return new BytesRestResponse(RestStatus.OK, builder);\n+                                    }\n+                                }.onResponse(response)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4168, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}