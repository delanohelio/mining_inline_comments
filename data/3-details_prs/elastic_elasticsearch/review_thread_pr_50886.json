{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNzQzMTk3", "number": 50886, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDoxODozNVrODXeOrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDozNTo0NVrODZyLkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTM5MTE4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDoxODozNVrOFcyPIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNTozNjoxNVrOFedo6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyNzUyMQ==", "bodyText": "I see the point in this change, but note that I added the .map shortcut back when I added it to dry up a bunch of ActionListener.wrap(..., listener::onFailure) spots.\nI think we'd basically have to audit every spot that we use .map in now and make sure that the listener/delegate will actually handle it's own onResponse failures (from a quick read over the spots we use map in this may already hold true).\nMaybe we should assert this and do something like:\ntry {\n   delegate.onResponse(mapped);\n} catch (Exception e) {\n   assert false: e;\n   throw e;\n}", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r365727521", "createdAt": "2020-01-13T10:18:35Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "diffHunk": "@@ -136,14 +136,27 @@ public void onFailure(Exception e) {\n      * Creates a listener that wraps another listener, mapping response values via the given mapping function and passing along\n      * exceptions to the delegate.\n      *\n+     * Notice that if the listener onResponse handler fails, the exception will bubble out, whereas if the function fails, the listeners\n+     * onFailure handler will be called. The principle is that the code using this is responsible for the function, whereas the listener\n+     * should do its own exception handling since it is a different component.\n+     *\n      * @param listener Listener to delegate to\n      * @param fn Function to apply to listener response\n      * @param <Response> Response type of the new listener\n      * @param <T> Response type of the wrapped listener\n      * @return a listener that maps the received response and then passes it to its delegate listener\n      */\n     static <T, Response> ActionListener<Response> map(ActionListener<T> listener, CheckedFunction<Response, T, Exception> fn) {\n-        return wrap(r -> listener.onResponse(fn.apply(r)), listener::onFailure);\n+        return delegateFailure(listener, (ActionListener<T> delegate, Response response) -> {\n+            T mapped;\n+            try {\n+                mapped = fn.apply(response);\n+            } catch (Exception e) {\n+                delegate.onFailure(e);\n+                return;\n+            }\n+            delegate.onResponse(mapped);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "308798111695b0d9004524aa63718108b0c169c3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ4NzIxMQ==", "bodyText": "I added the assert. Local CI seems happy about it.", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r367487211", "createdAt": "2020-01-16T15:36:15Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "diffHunk": "@@ -136,14 +136,27 @@ public void onFailure(Exception e) {\n      * Creates a listener that wraps another listener, mapping response values via the given mapping function and passing along\n      * exceptions to the delegate.\n      *\n+     * Notice that if the listener onResponse handler fails, the exception will bubble out, whereas if the function fails, the listeners\n+     * onFailure handler will be called. The principle is that the code using this is responsible for the function, whereas the listener\n+     * should do its own exception handling since it is a different component.\n+     *\n      * @param listener Listener to delegate to\n      * @param fn Function to apply to listener response\n      * @param <Response> Response type of the new listener\n      * @param <T> Response type of the wrapped listener\n      * @return a listener that maps the received response and then passes it to its delegate listener\n      */\n     static <T, Response> ActionListener<Response> map(ActionListener<T> listener, CheckedFunction<Response, T, Exception> fn) {\n-        return wrap(r -> listener.onResponse(fn.apply(r)), listener::onFailure);\n+        return delegateFailure(listener, (ActionListener<T> delegate, Response response) -> {\n+            T mapped;\n+            try {\n+                mapped = fn.apply(response);\n+            } catch (Exception e) {\n+                delegate.onFailure(e);\n+                return;\n+            }\n+            delegate.onResponse(mapped);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyNzUyMQ=="}, "originalCommit": {"oid": "308798111695b0d9004524aa63718108b0c169c3"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDEzMzQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1MzoxOFrOFe_JkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODowMjo1OFrOFhWH3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjI0MA==", "bodyText": "why assert here but not when calling delegate.onFailure(e);?", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r368036240", "createdAt": "2020-01-17T16:53:18Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "diffHunk": "@@ -136,14 +136,32 @@ public void onFailure(Exception e) {\n      * Creates a listener that wraps another listener, mapping response values via the given mapping function and passing along\n      * exceptions to the delegate.\n      *\n+     * Notice that if the listener onResponse handler fails, the exception will bubble out, whereas if the function fails, the listeners\n+     * onFailure handler will be called. The principle is that the code using this is responsible for the function, whereas the listener\n+     * should do its own exception handling since it is a different component.\n+     *\n      * @param listener Listener to delegate to\n      * @param fn Function to apply to listener response\n      * @param <Response> Response type of the new listener\n      * @param <T> Response type of the wrapped listener\n      * @return a listener that maps the received response and then passes it to its delegate listener\n      */\n     static <T, Response> ActionListener<Response> map(ActionListener<T> listener, CheckedFunction<Response, T, Exception> fn) {\n-        return wrap(r -> listener.onResponse(fn.apply(r)), listener::onFailure);\n+        return delegateFailure(listener, (ActionListener<T> delegate, Response response) -> {\n+            T mapped;\n+            try {\n+                mapped = fn.apply(response);\n+            } catch (Exception e) {\n+                delegate.onFailure(e);\n+                return;\n+            }\n+            try {\n+                delegate.onResponse(mapped);\n+            } catch (RuntimeException e) {\n+                assert false : new AssertionError(\"map: listener.onResponse failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ba493a87952ad4528f07592bf91a61df7b1abf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwOTc5MA==", "bodyText": "Thanks, added that in ca31964 and tests seems unaffected.", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r370509790", "createdAt": "2020-01-24T08:02:58Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "diffHunk": "@@ -136,14 +136,32 @@ public void onFailure(Exception e) {\n      * Creates a listener that wraps another listener, mapping response values via the given mapping function and passing along\n      * exceptions to the delegate.\n      *\n+     * Notice that if the listener onResponse handler fails, the exception will bubble out, whereas if the function fails, the listeners\n+     * onFailure handler will be called. The principle is that the code using this is responsible for the function, whereas the listener\n+     * should do its own exception handling since it is a different component.\n+     *\n      * @param listener Listener to delegate to\n      * @param fn Function to apply to listener response\n      * @param <Response> Response type of the new listener\n      * @param <T> Response type of the wrapped listener\n      * @return a listener that maps the received response and then passes it to its delegate listener\n      */\n     static <T, Response> ActionListener<Response> map(ActionListener<T> listener, CheckedFunction<Response, T, Exception> fn) {\n-        return wrap(r -> listener.onResponse(fn.apply(r)), listener::onFailure);\n+        return delegateFailure(listener, (ActionListener<T> delegate, Response response) -> {\n+            T mapped;\n+            try {\n+                mapped = fn.apply(response);\n+            } catch (Exception e) {\n+                delegate.onFailure(e);\n+                return;\n+            }\n+            try {\n+                delegate.onResponse(mapped);\n+            } catch (RuntimeException e) {\n+                assert false : new AssertionError(\"map: listener.onResponse failed\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjI0MA=="}, "originalCommit": {"oid": "65ba493a87952ad4528f07592bf91a61df7b1abf"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDEzNzU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchTransportService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1NDo0OFrOFe_MHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTo1ODoxOVrOFhYtbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg5NA==", "bodyText": "ChannelActionListener also has this weird double-sending logic.", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r368036894", "createdAt": "2020-01-17T16:54:48Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchTransportService.java", "diffHunk": "@@ -306,27 +305,11 @@ public static void registerRequestHandler(TransportService transportService, Sea\n             (in) -> TransportResponse.Empty.INSTANCE);\n \n         transportService.registerRequestHandler(DFS_ACTION_NAME, ThreadPool.Names.SAME, ShardSearchRequest::new,\n-            (request, channel, task) -> {\n-                searchService.executeDfsPhase(request, (SearchShardTask) task, new ActionListener<SearchPhaseResult>() {\n-                    @Override\n-                    public void onResponse(SearchPhaseResult searchPhaseResult) {\n-                        try {\n-                            channel.sendResponse(searchPhaseResult);\n-                        } catch (IOException e) {\n-                            throw new UncheckedIOException(e);\n-                        }\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        try {\n-                            channel.sendResponse(e);\n-                        } catch (IOException e1) {\n-                            throw new UncheckedIOException(e1);\n-                        }\n-                    }\n-                });\n-            });\n+            (request, channel, task) ->\n+                searchService.executeDfsPhase(request, (SearchShardTask) task,\n+                    new ChannelActionListener<>(channel, DFS_ACTION_NAME, request))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ba493a87952ad4528f07592bf91a61df7b1abf"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMjg5Mg==", "bodyText": "Yes, but the code used to propagate the exception out. This seemed to be a left-over from when the ChannelActionListener was introduced. The old map exception handling would ensure onFailure were called on exception. This means this change is effectively a no-op now (with the caveat that onFailure will be called on exceptions like for all other ChannelActionListener usages).\nWe should notice that DirectTransportChannel will not bubble out exceptions from invoking the TransportResponseHandler. So it seems likely that the primary exceptions bubbled out are related to communicating the response over a wire, in which case invoking onFailure might be desirable (for instance an NPE on serialization).\nSo I would like to keep using ChannelActionListener here and then deal with ChannelActionListener in a follow-up. WDYT?", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r370512892", "createdAt": "2020-01-24T08:14:13Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchTransportService.java", "diffHunk": "@@ -306,27 +305,11 @@ public static void registerRequestHandler(TransportService transportService, Sea\n             (in) -> TransportResponse.Empty.INSTANCE);\n \n         transportService.registerRequestHandler(DFS_ACTION_NAME, ThreadPool.Names.SAME, ShardSearchRequest::new,\n-            (request, channel, task) -> {\n-                searchService.executeDfsPhase(request, (SearchShardTask) task, new ActionListener<SearchPhaseResult>() {\n-                    @Override\n-                    public void onResponse(SearchPhaseResult searchPhaseResult) {\n-                        try {\n-                            channel.sendResponse(searchPhaseResult);\n-                        } catch (IOException e) {\n-                            throw new UncheckedIOException(e);\n-                        }\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        try {\n-                            channel.sendResponse(e);\n-                        } catch (IOException e1) {\n-                            throw new UncheckedIOException(e1);\n-                        }\n-                    }\n-                });\n-            });\n+            (request, channel, task) ->\n+                searchService.executeDfsPhase(request, (SearchShardTask) task,\n+                    new ChannelActionListener<>(channel, DFS_ACTION_NAME, request))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg5NA=="}, "originalCommit": {"oid": "65ba493a87952ad4528f07592bf91a61df7b1abf"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU1MjE3NA==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r370552174", "createdAt": "2020-01-24T09:58:19Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchTransportService.java", "diffHunk": "@@ -306,27 +305,11 @@ public static void registerRequestHandler(TransportService transportService, Sea\n             (in) -> TransportResponse.Empty.INSTANCE);\n \n         transportService.registerRequestHandler(DFS_ACTION_NAME, ThreadPool.Names.SAME, ShardSearchRequest::new,\n-            (request, channel, task) -> {\n-                searchService.executeDfsPhase(request, (SearchShardTask) task, new ActionListener<SearchPhaseResult>() {\n-                    @Override\n-                    public void onResponse(SearchPhaseResult searchPhaseResult) {\n-                        try {\n-                            channel.sendResponse(searchPhaseResult);\n-                        } catch (IOException e) {\n-                            throw new UncheckedIOException(e);\n-                        }\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        try {\n-                            channel.sendResponse(e);\n-                        } catch (IOException e1) {\n-                            throw new UncheckedIOException(e1);\n-                        }\n-                    }\n-                });\n-            });\n+            (request, channel, task) ->\n+                searchService.executeDfsPhase(request, (SearchShardTask) task,\n+                    new ChannelActionListener<>(channel, DFS_ACTION_NAME, request))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg5NA=="}, "originalCommit": {"oid": "65ba493a87952ad4528f07592bf91a61df7b1abf"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDE0NDYxOnYy", "diffSide": "LEFT", "path": "server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1NzoyMVrOFe_QuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1NzoyMVrOFe_QuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzODA3Mw==", "bodyText": "undo", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r368038073", "createdAt": "2020-01-17T16:57:21Z", "author": {"login": "ywelsch"}, "path": "server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java", "diffHunk": "@@ -378,5 +378,4 @@ public void testIndexNameInResponse() {\n \n         assertEquals(\"Should have index name in response\", \"foo\", response.index());\n     }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ba493a87952ad4528f07592bf91a61df7b1abf"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzYzMTU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDozNTo0NVrOFgXeYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMTo1Njo0N1rOFgZo2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MzM2Mw==", "bodyText": "Maybe word this a little differently, this reads somewhat confusing (IMO):\nThe principle is that the mapped listener will handle exceptions from the mapping function {@code fn} but it is the responsibility of {@code delegate} to handle its own exceptions inside `onResponse` and `onFailure`.\n\n?", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r369483363", "createdAt": "2020-01-22T10:35:45Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "diffHunk": "@@ -136,14 +136,49 @@ public void onFailure(Exception e) {\n      * Creates a listener that wraps another listener, mapping response values via the given mapping function and passing along\n      * exceptions to the delegate.\n      *\n-     * @param listener Listener to delegate to\n+     * Notice that it is considered a bug if the listener's onResponse or onFailure fails. onResponse failures will not call onFailure.\n+     *\n+     * If the function fails, the listener's onFailure handler will be called. The principle is that the code using this is responsible for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca31964870ea47b1391fa0cae78ee3c9272a7dcd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxODgwOQ==", "bodyText": "Thanks Armin, I used your improved comment here: 09b5576", "url": "https://github.com/elastic/elasticsearch/pull/50886#discussion_r369518809", "createdAt": "2020-01-22T11:56:47Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/ActionListener.java", "diffHunk": "@@ -136,14 +136,49 @@ public void onFailure(Exception e) {\n      * Creates a listener that wraps another listener, mapping response values via the given mapping function and passing along\n      * exceptions to the delegate.\n      *\n-     * @param listener Listener to delegate to\n+     * Notice that it is considered a bug if the listener's onResponse or onFailure fails. onResponse failures will not call onFailure.\n+     *\n+     * If the function fails, the listener's onFailure handler will be called. The principle is that the code using this is responsible for", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MzM2Mw=="}, "originalCommit": {"oid": "ca31964870ea47b1391fa0cae78ee3c9272a7dcd"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4641, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}