{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MTQzNzYz", "number": 53568, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNDowNzoyM1rODoB54Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjo0NjoyOFrODoUVww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMzAwODMzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNDowNzoyM1rOF2XosA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNDowNzoyM1rOF2XosA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NDY3Mg==", "bodyText": "These are because this class still extends AbstractNumericTestCase - the remainder of the tests will migrate in another pr", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r392554672", "createdAt": "2020-03-14T04:07:23Z", "author": {"login": "andyb-elastic"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumIT.java", "diffHunk": "@@ -111,20 +107,9 @@ public void testEmptyAggregation() throws Exception {\n         assertThat(sum.getValue(), equalTo(0.0));\n     }\n \n+    /** This test has been moved to {@link SumAggregatorTests#testUnmapped()} */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjAxNDU5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjo0MzozOFrOF2yiOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1MToxM1rOF2_dCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NTM4NA==", "bodyText": "Personally I don't think this is an improvement.", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r392995384", "createdAt": "2020-03-16T12:43:38Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -25,34 +25,62 @@\n import org.apache.lucene.document.StringField;\n import org.apache.lucene.index.DirectoryReader;\n import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.MultiReader;\n import org.apache.lucene.index.RandomIndexWriter;\n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.DocValuesFieldExistsQuery;\n import org.apache.lucene.search.IndexSearcher;\n-import org.apache.lucene.search.MatchAllDocsQuery;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.search.TermQuery;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.util.BytesRef;\n import org.apache.lucene.util.NumericUtils;\n import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.script.MockScriptEngine;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.LeafDocLookup;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n \n+import static java.util.Collections.emptyMap;\n import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static java.util.stream.Collectors.toList;\n+import static org.elasticsearch.common.lucene.search.Queries.newMatchAllQuery;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwNzA0OA==", "bodyText": "Yeah it's probably a net negative on readability", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r393207048", "createdAt": "2020-03-16T17:51:13Z", "author": {"login": "andyb-elastic"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -25,34 +25,62 @@\n import org.apache.lucene.document.StringField;\n import org.apache.lucene.index.DirectoryReader;\n import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.MultiReader;\n import org.apache.lucene.index.RandomIndexWriter;\n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.DocValuesFieldExistsQuery;\n import org.apache.lucene.search.IndexSearcher;\n-import org.apache.lucene.search.MatchAllDocsQuery;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.search.TermQuery;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.util.BytesRef;\n import org.apache.lucene.util.NumericUtils;\n import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.script.MockScriptEngine;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.search.lookup.LeafDocLookup;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n \n+import static java.util.Collections.emptyMap;\n import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static java.util.stream.Collectors.toList;\n+import static org.elasticsearch.common.lucene.search.Queries.newMatchAllQuery;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NTM4NA=="}, "originalCommit": {"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjAyODgzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjo0NjoyOFrOF2yrbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMDoyNjozNVrOF3Ejkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Nzc0MA==", "bodyText": "I don't think this name is right. It looks like it is just a generic \"does random stuff reduce right\" kind of thing.", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r392997740", "createdAt": "2020-03-16T12:46:28Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -165,27 +193,193 @@ public void testSummationAccuracy() throws IOException {\n     }\n \n     private void verifySummationOfDoubles(double[] values, double expected, double delta) throws IOException {\n-        testCase(new MatchAllDocsQuery(),\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(FIELD_NAME),\n             iw -> {\n                 for (double value : values) {\n                     iw.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, NumericUtils.doubleToSortableLong(value))));\n                 }\n             },\n             result -> assertEquals(expected, result.getValue(), delta),\n-            NumberFieldMapper.NumberType.DOUBLE\n+            singleton(defaultFieldType(NumberType.DOUBLE))\n+        );\n+    }\n+\n+    public void testUnmapped() throws IOException {\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(\"unknown_field\"),\n+            writer -> {\n+                final int numDocs = randomIntBetween(10, 100);\n+                for (int i = 0; i < numDocs; i++) {\n+                    writer.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, randomLong())));\n+                }\n+            },\n+            internalSum -> {\n+                assertEquals(0d, internalSum.getValue(), 0d);\n+                assertFalse(AggregationInspectionHelper.hasValue(internalSum));\n+            },\n+            singleton(defaultFieldType())\n+        );\n+    }\n+\n+    public void testPartiallyUnmapped() throws IOException {\n+        final MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberType.LONG);\n+        fieldType.setName(FIELD_NAME);\n+        fieldType.setHasDocValues(true);\n+\n+        final SumAggregationBuilder builder = sum(\"_name\")\n+            .field(fieldType.name());\n+\n+        final int numDocs = randomIntBetween(10, 100);\n+        final List<Set<IndexableField>> docs = new ArrayList<>(numDocs);\n+        int sum = 0;\n+        for (int i = 0; i < numDocs; i++) {\n+            final long value = randomLongBetween(0, 1000);\n+            sum += value;\n+            docs.add(singleton(new NumericDocValuesField(fieldType.name(), value)));\n+        }\n+\n+        try (Directory mappedDirectory = newDirectory(); Directory unmappedDirectory = newDirectory()) {\n+            try (RandomIndexWriter mappedWriter = new RandomIndexWriter(random(), mappedDirectory)) {\n+                mappedWriter.addDocuments(docs);\n+            }\n+\n+            new RandomIndexWriter(random(), unmappedDirectory).close();\n+\n+            try (IndexReader mappedReader = DirectoryReader.open(mappedDirectory);\n+                 IndexReader unmappedReader =  DirectoryReader.open(unmappedDirectory);\n+                 MultiReader multiReader = new MultiReader(mappedReader, unmappedReader)) {\n+\n+                final IndexSearcher searcher = newSearcher(multiReader, true, true);\n+\n+                final InternalSum internalSum = search(searcher, newMatchAllQuery(), builder, fieldType);\n+                assertEquals(sum, internalSum.getValue(), 0d);\n+                assertTrue(AggregationInspectionHelper.hasValue(internalSum));\n+            }\n+        }\n+    }\n+\n+    public void testValueScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testValueScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testFieldScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    public void testFieldScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    private void scriptTestCase(int numValuesPerField, SumAggregationBuilder builder) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwNzgyNg==", "bodyText": "Had the same thought after writing it - the script specific part is the expectedSum = sum + (numDocs * numValuesPerField); because it expects the script to increment all the fields by 1\nI'll see if I can make it less confusing", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r393207826", "createdAt": "2020-03-16T17:52:34Z", "author": {"login": "andyb-elastic"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -165,27 +193,193 @@ public void testSummationAccuracy() throws IOException {\n     }\n \n     private void verifySummationOfDoubles(double[] values, double expected, double delta) throws IOException {\n-        testCase(new MatchAllDocsQuery(),\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(FIELD_NAME),\n             iw -> {\n                 for (double value : values) {\n                     iw.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, NumericUtils.doubleToSortableLong(value))));\n                 }\n             },\n             result -> assertEquals(expected, result.getValue(), delta),\n-            NumberFieldMapper.NumberType.DOUBLE\n+            singleton(defaultFieldType(NumberType.DOUBLE))\n+        );\n+    }\n+\n+    public void testUnmapped() throws IOException {\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(\"unknown_field\"),\n+            writer -> {\n+                final int numDocs = randomIntBetween(10, 100);\n+                for (int i = 0; i < numDocs; i++) {\n+                    writer.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, randomLong())));\n+                }\n+            },\n+            internalSum -> {\n+                assertEquals(0d, internalSum.getValue(), 0d);\n+                assertFalse(AggregationInspectionHelper.hasValue(internalSum));\n+            },\n+            singleton(defaultFieldType())\n+        );\n+    }\n+\n+    public void testPartiallyUnmapped() throws IOException {\n+        final MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberType.LONG);\n+        fieldType.setName(FIELD_NAME);\n+        fieldType.setHasDocValues(true);\n+\n+        final SumAggregationBuilder builder = sum(\"_name\")\n+            .field(fieldType.name());\n+\n+        final int numDocs = randomIntBetween(10, 100);\n+        final List<Set<IndexableField>> docs = new ArrayList<>(numDocs);\n+        int sum = 0;\n+        for (int i = 0; i < numDocs; i++) {\n+            final long value = randomLongBetween(0, 1000);\n+            sum += value;\n+            docs.add(singleton(new NumericDocValuesField(fieldType.name(), value)));\n+        }\n+\n+        try (Directory mappedDirectory = newDirectory(); Directory unmappedDirectory = newDirectory()) {\n+            try (RandomIndexWriter mappedWriter = new RandomIndexWriter(random(), mappedDirectory)) {\n+                mappedWriter.addDocuments(docs);\n+            }\n+\n+            new RandomIndexWriter(random(), unmappedDirectory).close();\n+\n+            try (IndexReader mappedReader = DirectoryReader.open(mappedDirectory);\n+                 IndexReader unmappedReader =  DirectoryReader.open(unmappedDirectory);\n+                 MultiReader multiReader = new MultiReader(mappedReader, unmappedReader)) {\n+\n+                final IndexSearcher searcher = newSearcher(multiReader, true, true);\n+\n+                final InternalSum internalSum = search(searcher, newMatchAllQuery(), builder, fieldType);\n+                assertEquals(sum, internalSum.getValue(), 0d);\n+                assertTrue(AggregationInspectionHelper.hasValue(internalSum));\n+            }\n+        }\n+    }\n+\n+    public void testValueScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testValueScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testFieldScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    public void testFieldScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    private void scriptTestCase(int numValuesPerField, SumAggregationBuilder builder) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Nzc0MA=="}, "originalCommit": {"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDY0Mw==", "bodyText": "I made it a little more general and moved some other test cases to it too. Still not thrilled with its readability", "url": "https://github.com/elastic/elasticsearch/pull/53568#discussion_r393290643", "createdAt": "2020-03-16T20:26:35Z", "author": {"login": "andyb-elastic"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/SumAggregatorTests.java", "diffHunk": "@@ -165,27 +193,193 @@ public void testSummationAccuracy() throws IOException {\n     }\n \n     private void verifySummationOfDoubles(double[] values, double expected, double delta) throws IOException {\n-        testCase(new MatchAllDocsQuery(),\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(FIELD_NAME),\n             iw -> {\n                 for (double value : values) {\n                     iw.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, NumericUtils.doubleToSortableLong(value))));\n                 }\n             },\n             result -> assertEquals(expected, result.getValue(), delta),\n-            NumberFieldMapper.NumberType.DOUBLE\n+            singleton(defaultFieldType(NumberType.DOUBLE))\n+        );\n+    }\n+\n+    public void testUnmapped() throws IOException {\n+        testCase(newMatchAllQuery(),\n+            sum(\"_name\").field(\"unknown_field\"),\n+            writer -> {\n+                final int numDocs = randomIntBetween(10, 100);\n+                for (int i = 0; i < numDocs; i++) {\n+                    writer.addDocument(singleton(new NumericDocValuesField(FIELD_NAME, randomLong())));\n+                }\n+            },\n+            internalSum -> {\n+                assertEquals(0d, internalSum.getValue(), 0d);\n+                assertFalse(AggregationInspectionHelper.hasValue(internalSum));\n+            },\n+            singleton(defaultFieldType())\n+        );\n+    }\n+\n+    public void testPartiallyUnmapped() throws IOException {\n+        final MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberType.LONG);\n+        fieldType.setName(FIELD_NAME);\n+        fieldType.setHasDocValues(true);\n+\n+        final SumAggregationBuilder builder = sum(\"_name\")\n+            .field(fieldType.name());\n+\n+        final int numDocs = randomIntBetween(10, 100);\n+        final List<Set<IndexableField>> docs = new ArrayList<>(numDocs);\n+        int sum = 0;\n+        for (int i = 0; i < numDocs; i++) {\n+            final long value = randomLongBetween(0, 1000);\n+            sum += value;\n+            docs.add(singleton(new NumericDocValuesField(fieldType.name(), value)));\n+        }\n+\n+        try (Directory mappedDirectory = newDirectory(); Directory unmappedDirectory = newDirectory()) {\n+            try (RandomIndexWriter mappedWriter = new RandomIndexWriter(random(), mappedDirectory)) {\n+                mappedWriter.addDocuments(docs);\n+            }\n+\n+            new RandomIndexWriter(random(), unmappedDirectory).close();\n+\n+            try (IndexReader mappedReader = DirectoryReader.open(mappedDirectory);\n+                 IndexReader unmappedReader =  DirectoryReader.open(unmappedDirectory);\n+                 MultiReader multiReader = new MultiReader(mappedReader, unmappedReader)) {\n+\n+                final IndexSearcher searcher = newSearcher(multiReader, true, true);\n+\n+                final InternalSum internalSum = search(searcher, newMatchAllQuery(), builder, fieldType);\n+                assertEquals(sum, internalSum.getValue(), 0d);\n+                assertTrue(AggregationInspectionHelper.hasValue(internalSum));\n+            }\n+        }\n+    }\n+\n+    public void testValueScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testValueScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .field(FIELD_NAME)\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, VALUE_SCRIPT_NAME, emptyMap())));\n+    }\n+\n+    public void testFieldScriptSingleValuedField() throws IOException {\n+        scriptTestCase(1,\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    public void testFieldScriptMultiValuedField() throws IOException {\n+        scriptTestCase(randomIntBetween(2, 5),\n+            sum(\"_name\")\n+                .script(new Script(ScriptType.INLINE, MockScriptEngine.NAME, FIELD_SCRIPT_NAME, singletonMap(\"field\", FIELD_NAME))));\n+    }\n+\n+    private void scriptTestCase(int numValuesPerField, SumAggregationBuilder builder) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5Nzc0MA=="}, "originalCommit": {"oid": "431a7ef99e1220cfa30fb3eb38d8ba9e448ce3ae"}, "originalPosition": 190}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3247, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}