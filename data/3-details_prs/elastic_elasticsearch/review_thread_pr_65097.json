{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxODE0MTUw", "number": 65097, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo1NToxNFrOE7Hybw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo1NToxNFrOE7Hybw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDI5MDM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo1NToxNFrOH2laqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzoxNDowN1rOH2pGFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5ODE4NA==", "bodyText": "Any reason not to just early terminate the loop if we've hit the limit?", "url": "https://github.com/elastic/elasticsearch/pull/65097#discussion_r526998184", "createdAt": "2020-11-19T15:55:14Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregator.java", "diffHunk": "@@ -286,6 +299,57 @@ public InternalAggregation buildEmptyAggregation() {\n         ) throws IOException {\n             super(name, AggregatorFactories.EMPTY, keys, keyed, null, context, parent, cardinality, metadata);\n             this.filters = filters;\n+            this.profiling = context.getProfilers() != null;\n+        }\n+\n+        /**\n+         * Estimate the number of documents that this aggregation must visit. We'll\n+         * stop counting once we've passed {@code maxEstimatedCost} if we aren't profiling.\n+         */\n+        public long estimateCost(long maxCost) throws IOException {\n+            this.maxCost = maxCost;\n+            if (estimatedCost != -1) {\n+                return estimatedCost;\n+            }\n+            long limit = profiling ? Long.MAX_VALUE : maxCost;\n+            long start = profiling ? System.nanoTime() : 0;\n+            estimatedCost = 0;\n+            weights = buildWeights(topLevelQuery(), filters);\n+            List<LeafReaderContext> leaves = searcher().getIndexReader().leaves();\n+            /*\n+             * Its important that we save a copy of the BulkScorer because for\n+             * queries like PointInRangeQuery building the scorer can be a big\n+             * chunk of the run time.\n+             */\n+            scorers = new BulkScorer[leaves.size()][];\n+            for (LeafReaderContext ctx : leaves) {\n+                scorers[ctx.ord] = new BulkScorer[filters.length];\n+                for (int f = 0; f < filters.length; f++) {\n+                    scorers[ctx.ord][f] = weights[f].bulkScorer(ctx);\n+                    if (scorers[ctx.ord][f] == null) {\n+                        // Doesn't find anything in this leaf\n+                        continue;\n+                    }\n+                    if (estimatedCost >= 0 && estimatedCost <= limit) {\n+                        // If we've overflowed or are past the limit skip the cost\n+                        estimatedCost += scorers[ctx.ord][f].cost();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fe8d5204cc38bbeea6f3d661ba54895aa88c9ce"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1ODQ1NQ==", "bodyText": "Yeah! If build the scorers array we want to complete it so we don't NPE later. But, now that I think about it, I could avoid that and probably should because its expensive to build the scorer if we ain't gonna use it. I'll merge this as is and open up a follow up with that change.", "url": "https://github.com/elastic/elasticsearch/pull/65097#discussion_r527058455", "createdAt": "2020-11-19T17:14:07Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregator.java", "diffHunk": "@@ -286,6 +299,57 @@ public InternalAggregation buildEmptyAggregation() {\n         ) throws IOException {\n             super(name, AggregatorFactories.EMPTY, keys, keyed, null, context, parent, cardinality, metadata);\n             this.filters = filters;\n+            this.profiling = context.getProfilers() != null;\n+        }\n+\n+        /**\n+         * Estimate the number of documents that this aggregation must visit. We'll\n+         * stop counting once we've passed {@code maxEstimatedCost} if we aren't profiling.\n+         */\n+        public long estimateCost(long maxCost) throws IOException {\n+            this.maxCost = maxCost;\n+            if (estimatedCost != -1) {\n+                return estimatedCost;\n+            }\n+            long limit = profiling ? Long.MAX_VALUE : maxCost;\n+            long start = profiling ? System.nanoTime() : 0;\n+            estimatedCost = 0;\n+            weights = buildWeights(topLevelQuery(), filters);\n+            List<LeafReaderContext> leaves = searcher().getIndexReader().leaves();\n+            /*\n+             * Its important that we save a copy of the BulkScorer because for\n+             * queries like PointInRangeQuery building the scorer can be a big\n+             * chunk of the run time.\n+             */\n+            scorers = new BulkScorer[leaves.size()][];\n+            for (LeafReaderContext ctx : leaves) {\n+                scorers[ctx.ord] = new BulkScorer[filters.length];\n+                for (int f = 0; f < filters.length; f++) {\n+                    scorers[ctx.ord][f] = weights[f].bulkScorer(ctx);\n+                    if (scorers[ctx.ord][f] == null) {\n+                        // Doesn't find anything in this leaf\n+                        continue;\n+                    }\n+                    if (estimatedCost >= 0 && estimatedCost <= limit) {\n+                        // If we've overflowed or are past the limit skip the cost\n+                        estimatedCost += scorers[ctx.ord][f].cost();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5ODE4NA=="}, "originalCommit": {"oid": "9fe8d5204cc38bbeea6f3d661ba54895aa88c9ce"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2915, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}