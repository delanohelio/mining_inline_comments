{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMjM5NDIw", "number": 60522, "reviewThreads": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxMjo0MFrOEWrccA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTo1MzoyN1rOEcgIzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjE1OTIwOnYy", "diffSide": "LEFT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxMjo0MFrOG-DiMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxMjo0MFrOG-DiMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMjgwMw==", "bodyText": "Pushed down to the cached index input only, the other implementation doesn't use this.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467722803", "createdAt": "2020-08-10T07:12:40Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "diffHunk": "@@ -101,34 +102,6 @@ public final void close() throws IOException {\n \n     public abstract void innerClose() throws IOException;\n \n-    protected InputStream openInputStream(final long position, final long length) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjE1OTUzOnYy", "diffSide": "LEFT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxMjo0OVrOG-DiaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxMjo0OVrOG-DiaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMjg1Nw==", "bodyText": "Pushed these methods down to the cached index input only, the other implementation doesn't use them.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467722857", "createdAt": "2020-08-10T07:12:49Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "diffHunk": "@@ -149,29 +122,4 @@ protected final boolean assertCurrentThreadMayAccessBlobStore() {\n         return true;\n     }\n \n-    private long getPartNumberForPosition(long position) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjE2NzM2OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxNTo1MVrOG-Dmzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxNTo1MVrOG-Dmzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMzk4Mg==", "bodyText": "In fact we (almost) never looped here, the inner read methods always satisfied the complete read. The only case where we did loop is if the read spanned two 32MB-aligned ranges, but in that case we may as well read both ranges in one go anyway so that's what we do now.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467723982", "createdAt": "2020-08-10T07:15:51Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjE2OTM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxNjo0M1rOG-Dn-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxNjo0M1rOG-Dn-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyNDI4MA==", "bodyText": "This (and subsequent methods) moved here from the base class.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467724280", "createdAt": "2020-08-10T07:16:43Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -370,6 +558,76 @@ private void writeCacheFile(final FileChannel fc, final long start, final long e\n         }\n     }\n \n+    /**\n+     * Opens an {@link InputStream} for the given range of bytes which reads the data directly from the blob store. If the requested range\n+     * spans multiple blobs then this stream will request them in turn.\n+     *\n+     * @param position The start of the range of bytes to read, relative to the start of the corresponding Lucene file.\n+     * @param length The number of bytes to read\n+     */\n+    private InputStream openInputStreamFromBlobStore(final long position, final long length) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjE3MDE2OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxNjo1OVrOG-DoWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNzoxNjo1OVrOG-DoWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyNDM3OA==", "bodyText": "Inlined this into another method.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467724378", "createdAt": "2020-08-10T07:16:59Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -431,43 +689,11 @@ public String toString() {\n             + getFilePointer()\n             + \", rangeSize=\"\n             + getDefaultRangeSize()\n+            + \", directory=\"\n+            + directory\n             + '}';\n     }\n \n-    private int readDirectly(long start, long end, ByteBuffer b) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 455}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjMzMjY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODoxMzozOVrOG-FGow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDowMDo0NVrOG-IX4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0ODUxNQ==", "bodyText": "Small preference for defining canBeFullyCached before isStartOfFile.\nAlso, I wonder whether the logic to cache up to 2 * DEFAULT_SIZE is truly needed (perhaps canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE; would work just as well in practice, and give us a simpler upper bound on the size of cached blobs?). Alternatively, we could extend this in the future, do it file-type or content-based instead?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467748515", "createdAt": "2020-08-10T08:13:39Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMjA4MQ==", "bodyText": "Ok, reordered defs in 974c095.\nI don't have a great way to decide on the heuristics for what should go in the cache, so I'm deferring to @tlrx's better judgement here. There's scope for all sorts of cleverness here, such as caching the header of slices within a .cfs file.\nNote that there's an assertion (on the put path) that cached blobs are no larger than the size of the copy buffer.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467802081", "createdAt": "2020-08-10T10:00:45Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0ODUxNQ=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjM1MDMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODoxODoyNVrOG-FQmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwOToyNDozOVrOG-HQrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MTA2Ng==", "bodyText": "Is this comment addressed now?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467751066", "createdAt": "2020-08-10T08:18:25Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));\n+                    return;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Cache miss may be that the cache is completely unavailable (no point in populating it) or that the blob is\n+                // definitely absent. TODO only bother populating the cache in the latter case.\n+            }\n+\n+            // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+            // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+            // {start, end} ranges where positions are relative to the whole file.\n+            if (canBeFullyCached) {\n+                // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                indexCacheMisses = List.of(Tuple.tuple(0L, fileInfo.length()));\n+            } else {\n+                indexCacheMisses = List.of(Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_SIZE));\n+            }\n+            logger.trace(\"recovery cache miss for [{}], falling through with regions [{}]\", this, indexCacheMisses);\n+        } else {\n+            indexCacheMisses = List.of();\n+        }\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Read all target ranges in one go, including any cache misses identified above.\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMisses.stream().mapToLong(Tuple::v1).max().orElse(Long.MAX_VALUE)),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMisses.stream().mapToLong(Tuple::v2).max().orElse(Long.MIN_VALUE))\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n                     }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                for (Tuple<Long, Long> indexCacheMiss : indexCacheMisses) {\n+                    cacheFile.populateAndRead(indexCacheMiss, indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc4Mzg1Mg==", "bodyText": "The comment is deliberate, to explain why we don't call readCacheFile here.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467783852", "createdAt": "2020-08-10T09:24:39Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));\n+                    return;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Cache miss may be that the cache is completely unavailable (no point in populating it) or that the blob is\n+                // definitely absent. TODO only bother populating the cache in the latter case.\n+            }\n+\n+            // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+            // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+            // {start, end} ranges where positions are relative to the whole file.\n+            if (canBeFullyCached) {\n+                // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                indexCacheMisses = List.of(Tuple.tuple(0L, fileInfo.length()));\n+            } else {\n+                indexCacheMisses = List.of(Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_SIZE));\n+            }\n+            logger.trace(\"recovery cache miss for [{}], falling through with regions [{}]\", this, indexCacheMisses);\n+        } else {\n+            indexCacheMisses = List.of();\n+        }\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Read all target ranges in one go, including any cache misses identified above.\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMisses.stream().mapToLong(Tuple::v1).max().orElse(Long.MAX_VALUE)),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMisses.stream().mapToLong(Tuple::v2).max().orElse(Long.MIN_VALUE))\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n                     }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                for (Tuple<Long, Long> indexCacheMiss : indexCacheMisses) {\n+                    cacheFile.populateAndRead(indexCacheMiss, indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MTA2Ng=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjM4NzE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODoyOToyN1rOG-Fl9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDowMDo1NVrOG-IYIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1NjUzNA==", "bodyText": "Why is indexCacheMisses a list if it only contains a single entry?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467756534", "createdAt": "2020-08-10T08:29:27Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));\n+                    return;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Cache miss may be that the cache is completely unavailable (no point in populating it) or that the blob is\n+                // definitely absent. TODO only bother populating the cache in the latter case.\n+            }\n+\n+            // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+            // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+            // {start, end} ranges where positions are relative to the whole file.\n+            if (canBeFullyCached) {\n+                // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                indexCacheMisses = List.of(Tuple.tuple(0L, fileInfo.length()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMjE0NQ==", "bodyText": "Premature generalisation, changed to a nullable variable in c5b65bc.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467802145", "createdAt": "2020-08-10T10:00:55Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));\n+                    return;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Cache miss may be that the cache is completely unavailable (no point in populating it) or that the blob is\n+                // definitely absent. TODO only bother populating the cache in the latter case.\n+            }\n+\n+            // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+            // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+            // {start, end} ranges where positions are relative to the whole file.\n+            if (canBeFullyCached) {\n+                // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                indexCacheMisses = List.of(Tuple.tuple(0L, fileInfo.length()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1NjUzNA=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjQwODgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODozNjoxMFrOG-FyrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDowMzoyNFrOG-Ic_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1OTc4OA==", "bodyText": "let's make this dynamic: strict", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467759788", "createdAt": "2020-08-10T08:36:10Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin().indices().prepareCreate(index).setSettings(settings()).setMapping(mappings()).execute(new ActionListener<>() {\n+                @Override\n+                public void onResponse(CreateIndexResponse createIndexResponse) {\n+                    assert createIndexResponse.index().equals(index);\n+                    listener.onResponse(createIndexResponse.index());\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof ResourceAlreadyExistsException\n+                        || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                        listener.onResponse(index);\n+                    } else {\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings settings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"false\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMzM5MQ==", "bodyText": "++ 2abf126.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467803391", "createdAt": "2020-08-10T10:03:24Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin().indices().prepareCreate(index).setSettings(settings()).setMapping(mappings()).execute(new ActionListener<>() {\n+                @Override\n+                public void onResponse(CreateIndexResponse createIndexResponse) {\n+                    assert createIndexResponse.index().equals(index);\n+                    listener.onResponse(createIndexResponse.index());\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof ResourceAlreadyExistsException\n+                        || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                        listener.onResponse(index);\n+                    } else {\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings settings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"false\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1OTc4OA=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjQxOTkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODozOTo1N1rOG-F5aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDowMDo1OFrOG-IYQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MTUxMg==", "bodyText": "Where is this exception propagated to? Do we fail the blobstore read because we failed to  populate the index cache?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467761512", "createdAt": "2020-08-10T08:39:57Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));\n+                    return;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Cache miss may be that the cache is completely unavailable (no point in populating it) or that the blob is\n+                // definitely absent. TODO only bother populating the cache in the latter case.\n+            }\n+\n+            // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+            // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+            // {start, end} ranges where positions are relative to the whole file.\n+            if (canBeFullyCached) {\n+                // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                indexCacheMisses = List.of(Tuple.tuple(0L, fileInfo.length()));\n+            } else {\n+                indexCacheMisses = List.of(Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_SIZE));\n+            }\n+            logger.trace(\"recovery cache miss for [{}], falling through with regions [{}]\", this, indexCacheMisses);\n+        } else {\n+            indexCacheMisses = List.of();\n+        }\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Read all target ranges in one go, including any cache misses identified above.\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMisses.stream().mapToLong(Tuple::v1).max().orElse(Long.MAX_VALUE)),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMisses.stream().mapToLong(Tuple::v2).max().orElse(Long.MIN_VALUE))\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n                     }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                for (Tuple<Long, Long> indexCacheMiss : indexCacheMisses) {\n+                    cacheFile.populateAndRead(indexCacheMiss, indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats\n+                        byteBuffer.flip();\n+                        final BytesReference content = BytesReference.fromByteBuffer(byteBuffer);\n+                        directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content);\n+                        return indexCacheMissLength;\n+                    }, (channel, from, to, progressUpdater) -> {\n+                        // normally doesn't happen, we're already obtaining a range covering all cache misses above, but this\n+                        // can happen if the real populateAndRead call already failed to obtain this range of the file. In that\n+                        // case, we don't retry, we simply fail to populate the index cache.\n+                        logger.debug(\n+                            \"failed to fill index cache miss [{}-{}] of {} due to earlier failure\",\n+                            from,\n+                            to,\n+                            CachedBlobContainerIndexInput.this\n+                        );\n+                        throw new IOException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMjE3OQ==", "bodyText": "This doesn't happen if we failed to populate the index cache, it only happens if the larger read above already failed.\nHowever it is a good question to ask because I now realise that there may in principle be subsequent reads waiting on this range that we've claimed but then fail to fill. Let's just fill them, see f06e0ae.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467802179", "createdAt": "2020-08-10T10:00:58Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));\n+                    return;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Cache miss may be that the cache is completely unavailable (no point in populating it) or that the blob is\n+                // definitely absent. TODO only bother populating the cache in the latter case.\n+            }\n+\n+            // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+            // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+            // {start, end} ranges where positions are relative to the whole file.\n+            if (canBeFullyCached) {\n+                // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                indexCacheMisses = List.of(Tuple.tuple(0L, fileInfo.length()));\n+            } else {\n+                indexCacheMisses = List.of(Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_SIZE));\n+            }\n+            logger.trace(\"recovery cache miss for [{}], falling through with regions [{}]\", this, indexCacheMisses);\n+        } else {\n+            indexCacheMisses = List.of();\n+        }\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Read all target ranges in one go, including any cache misses identified above.\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMisses.stream().mapToLong(Tuple::v1).max().orElse(Long.MAX_VALUE)),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMisses.stream().mapToLong(Tuple::v2).max().orElse(Long.MIN_VALUE))\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n                     }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                for (Tuple<Long, Long> indexCacheMiss : indexCacheMisses) {\n+                    cacheFile.populateAndRead(indexCacheMiss, indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats\n+                        byteBuffer.flip();\n+                        final BytesReference content = BytesReference.fromByteBuffer(byteBuffer);\n+                        directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content);\n+                        return indexCacheMissLength;\n+                    }, (channel, from, to, progressUpdater) -> {\n+                        // normally doesn't happen, we're already obtaining a range covering all cache misses above, but this\n+                        // can happen if the real populateAndRead call already failed to obtain this range of the file. In that\n+                        // case, we don't retry, we simply fail to populate the index cache.\n+                        logger.debug(\n+                            \"failed to fill index cache miss [{}-{}] of {} due to earlier failure\",\n+                            from,\n+                            to,\n+                            CachedBlobContainerIndexInput.this\n+                        );\n+                        throw new IOException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MTUxMg=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjQ0NDE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODo0NzoyM1rOG-GIHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowMDowMlrOG_WLrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2NTI3Nw==", "bodyText": "Probably good to address this in the PR here.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467765277", "createdAt": "2020-08-10T08:47:23Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,654 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.BlobStore;\n+import org.elasticsearch.common.blobstore.support.FilterBlobContainer;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.indices.recovery.RecoverySettings;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.PluginsService;\n+import org.elasticsearch.plugins.RepositoryPlugin;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.function.BiConsumer;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.add(TrackingRepositoryPlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            // Use a cache range size setting aligned with BufferedIndexInput's buffer size and BlobStoreCacheService's default size\n+            // TODO randomized this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NjkwOQ==", "bodyText": "Yes this is now randomised.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469076909", "createdAt": "2020-08-12T08:00:02Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,654 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.BlobStore;\n+import org.elasticsearch.common.blobstore.support.FilterBlobContainer;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.indices.recovery.RecoverySettings;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.PluginsService;\n+import org.elasticsearch.plugins.RepositoryPlugin;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.function.BiConsumer;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.add(TrackingRepositoryPlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            // Use a cache range size setting aligned with BufferedIndexInput's buffer size and BlobStoreCacheService's default size\n+            // TODO randomized this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2NTI3Nw=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjQ4MTkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODo1ODozNlrOG-GeHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowMDoxN1rOG_WMOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3MDkwOQ==", "bodyText": "???", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467770909", "createdAt": "2020-08-10T08:58:36Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,654 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.BlobStore;\n+import org.elasticsearch.common.blobstore.support.FilterBlobContainer;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.indices.recovery.RecoverySettings;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.PluginsService;\n+import org.elasticsearch.plugins.RepositoryPlugin;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.function.BiConsumer;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.add(TrackingRepositoryPlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            // Use a cache range size setting aligned with BufferedIndexInput's buffer size and BlobStoreCacheService's default size\n+            // TODO randomized this\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                new ByteSizeValue(BlobStoreCacheService.DEFAULT_SIZE, ByteSizeUnit.BYTES)\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        final ForceMergeResponse forceMergeResponse = client().admin().indices().prepareForceMerge(indexName).setMaxNumSegments(1).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        // register a new repository that can track blob read operations\n+        assertAcked(client().admin().cluster().prepareDeleteRepository(repositoryName));\n+        createRepository(\n+            repositoryName,\n+            TrackingRepositoryPlugin.TRACKING,\n+            Settings.builder().put(FsRepository.LOCATION_SETTING.getKey(), repositoryLocation).build(),\n+            false\n+        );\n+        assertBusy(this::ensureClusterStateConsistency);\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        final boolean usePrewarming = false; // TODO randomize this and adapt test\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), usePrewarming)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        refreshSystemIndex();\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+\n+        ensureBlobStoreRepositoriesWithActiveShards(\n+            restoredIndex,\n+            (nodeId, blobStore) -> assertThat(\n+                \"Blob read operations should have been executed on node [\" + nodeId + ']',\n+                blobStore.numberOfReads(),\n+                greaterThan(0L)\n+            )\n+        );\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+        resetTrackedFiles();\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), usePrewarming)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+\n+        logger.info(\"--> verifying blobs read from the repository\");\n+        assertBlobsReadFromRemoteRepository(restoredAgainIndex, blobsInSnapshot);\n+\n+        resetTrackedFiles();\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+\n+        logger.info(\"--> verifying blobs read from the repository after restart\");\n+        // Without the WaitForSnapshotBlobCacheShardsActivePlugin this would fail\n+        assertBlobsReadFromRemoteRepository(restoredAgainIndex, blobsInSnapshot);\n+\n+        // TODO would be great to test when the index is frozen\n+    }\n+\n+    /**\n+     * @return a {@link Client} that can be used to query the blob store cache system index\n+     */\n+    private Client systemClient() {\n+        return new OriginSettingClient(client(), ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN);\n+    }\n+\n+    private void refreshSystemIndex() {\n+        final RefreshResponse refreshResponse = systemClient().admin().indices().prepareRefresh(SNAPSHOT_BLOB_CACHE_INDEX).get();\n+        assertThat(refreshResponse.getSuccessfulShards(), greaterThan(0));\n+        assertThat(refreshResponse.getFailedShards(), equalTo(0));\n+    }\n+\n+    /**\n+     * Reads a repository location on disk and extracts the list of blobs for each shards\n+     */\n+    private Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot(Path repositoryLocation, String snapshotId) throws IOException {\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsPerShard = new HashMap<>();\n+        Files.walkFileTree(repositoryLocation.resolve(\"indices\"), new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                final String fileName = file.getFileName().toString();\n+                if (fileName.equals(\"snap-\" + snapshotId + \".dat\")) {\n+                    blobsPerShard.put(\n+                        String.join(\n+                            \"/\",\n+                            snapshotId,\n+                            file.getParent().getParent().getFileName().toString(),\n+                            file.getParent().getFileName().toString()\n+                        ),\n+                        INDEX_SHARD_SNAPSHOT_FORMAT.deserialize(fileName, xContentRegistry(), Streams.readFully(Files.newInputStream(file)))\n+                    );\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        return Map.copyOf(blobsPerShard);\n+    }\n+\n+    private void ensureExecutorsAreIdle() throws Exception {\n+        assertBusy(() -> {\n+            for (ThreadPool threadPool : internalCluster().getDataNodeInstances(ThreadPool.class)) {\n+                for (String threadPoolName : List.of(CACHE_FETCH_ASYNC_THREAD_POOL_NAME, CACHE_PREWARMING_THREAD_POOL_NAME)) {\n+                    final ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.executor(threadPoolName);\n+                    assertThat(threadPoolName, executor.getQueue().size(), equalTo(0));\n+                    assertThat(threadPoolName, executor.getActiveCount(), equalTo(0));\n+                }\n+            }\n+        });\n+    }\n+\n+    private void assertCachedBlobsInSystemIndex(final String repositoryName, final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot)\n+        throws Exception {\n+        assertBusy(() -> {\n+            refreshSystemIndex();\n+\n+            long numberOfCachedBlobs = 0L;\n+            for (Map.Entry<String, BlobStoreIndexShardSnapshot> blob : blobsInSnapshot.entrySet()) {\n+                for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : blob.getValue().indexFiles()) {\n+                    if (fileInfo.name().startsWith(\"__\") == false) {\n+                        continue;\n+                    }\n+\n+                    final String path = String.join(\"/\", repositoryName, blob.getKey(), fileInfo.physicalName());\n+                    if (fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2) {\n+                        // file has been fully cached\n+                        final GetResponse getResponse = systemClient().prepareGet(SNAPSHOT_BLOB_CACHE_INDEX, path + \"/@0\").get();\n+                        assertThat(\"not cached: [\" + path + \"/@0] for blob [\" + fileInfo + \"]\", getResponse.isExists(), is(true));\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(getResponse.getSourceAsMap());\n+                        assertThat(cachedBlob.from(), equalTo(0L));\n+                        assertThat(cachedBlob.to(), equalTo(fileInfo.length()));\n+                        assertThat((long) cachedBlob.length(), equalTo(fileInfo.length()));\n+                        numberOfCachedBlobs += 1;\n+\n+                    } else {\n+                        // first region of file has been cached\n+                        GetResponse getResponse = systemClient().prepareGet(SNAPSHOT_BLOB_CACHE_INDEX, path + \"/@0\").get();\n+                        assertThat(\n+                            \"not cached: [\" + path + \"/@0] for first region of blob [\" + fileInfo + \"]\",\n+                            getResponse.isExists(),\n+                            is(true)\n+                        );\n+\n+                        CachedBlob cachedBlob = CachedBlob.fromSource(getResponse.getSourceAsMap());\n+                        assertThat(cachedBlob.from(), equalTo(0L));\n+                        assertThat(cachedBlob.to(), equalTo((long) BlobStoreCacheService.DEFAULT_SIZE));\n+                        assertThat(cachedBlob.length(), equalTo(BlobStoreCacheService.DEFAULT_SIZE));\n+                        numberOfCachedBlobs += 1;\n+                    }\n+                }\n+            }\n+\n+            refreshSystemIndex();\n+            assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        });\n+    }\n+\n+    private void assertBlobsReadFromRemoteRepository(\n+        final String indexName,\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot\n+    ) {\n+        ensureBlobStoreRepositoriesWithActiveShards(indexName, (nodeId, blobStore) -> {\n+            for (Map.Entry<String, List<Tuple<Long, Long>>> blob : blobStore.blobs.entrySet()) {\n+                final String blobName = blob.getKey();\n+\n+                if (blobName.endsWith(\".dat\") || blobName.equals(\"index-0\")) {\n+                    // The snapshot metadata files are accessed when recovering from the snapshot during restore and do not benefit from\n+                    // the snapshot blob cache as the files are accessed outside of a searchable snapshot directory\n+                    assertThat(\n+                        blobName + \" should be fully read from the beginning\",\n+                        blob.getValue().stream().allMatch(read -> read.v1() == 0L),\n+                        is(true)\n+                    );\n+                    // TODO assert it is read til the end", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NzA0OA==", "bodyText": "I've reworked these assertions now.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469077048", "createdAt": "2020-08-12T08:00:17Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,654 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.BlobStore;\n+import org.elasticsearch.common.blobstore.support.FilterBlobContainer;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.indices.recovery.RecoverySettings;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.PluginsService;\n+import org.elasticsearch.plugins.RepositoryPlugin;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.function.BiConsumer;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.add(TrackingRepositoryPlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            // Use a cache range size setting aligned with BufferedIndexInput's buffer size and BlobStoreCacheService's default size\n+            // TODO randomized this\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                new ByteSizeValue(BlobStoreCacheService.DEFAULT_SIZE, ByteSizeUnit.BYTES)\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        final ForceMergeResponse forceMergeResponse = client().admin().indices().prepareForceMerge(indexName).setMaxNumSegments(1).get();\n+        assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+        assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        // register a new repository that can track blob read operations\n+        assertAcked(client().admin().cluster().prepareDeleteRepository(repositoryName));\n+        createRepository(\n+            repositoryName,\n+            TrackingRepositoryPlugin.TRACKING,\n+            Settings.builder().put(FsRepository.LOCATION_SETTING.getKey(), repositoryLocation).build(),\n+            false\n+        );\n+        assertBusy(this::ensureClusterStateConsistency);\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        final boolean usePrewarming = false; // TODO randomize this and adapt test\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), usePrewarming)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        refreshSystemIndex();\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+\n+        ensureBlobStoreRepositoriesWithActiveShards(\n+            restoredIndex,\n+            (nodeId, blobStore) -> assertThat(\n+                \"Blob read operations should have been executed on node [\" + nodeId + ']',\n+                blobStore.numberOfReads(),\n+                greaterThan(0L)\n+            )\n+        );\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+        resetTrackedFiles();\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), usePrewarming)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+\n+        logger.info(\"--> verifying blobs read from the repository\");\n+        assertBlobsReadFromRemoteRepository(restoredAgainIndex, blobsInSnapshot);\n+\n+        resetTrackedFiles();\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+\n+        logger.info(\"--> verifying blobs read from the repository after restart\");\n+        // Without the WaitForSnapshotBlobCacheShardsActivePlugin this would fail\n+        assertBlobsReadFromRemoteRepository(restoredAgainIndex, blobsInSnapshot);\n+\n+        // TODO would be great to test when the index is frozen\n+    }\n+\n+    /**\n+     * @return a {@link Client} that can be used to query the blob store cache system index\n+     */\n+    private Client systemClient() {\n+        return new OriginSettingClient(client(), ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN);\n+    }\n+\n+    private void refreshSystemIndex() {\n+        final RefreshResponse refreshResponse = systemClient().admin().indices().prepareRefresh(SNAPSHOT_BLOB_CACHE_INDEX).get();\n+        assertThat(refreshResponse.getSuccessfulShards(), greaterThan(0));\n+        assertThat(refreshResponse.getFailedShards(), equalTo(0));\n+    }\n+\n+    /**\n+     * Reads a repository location on disk and extracts the list of blobs for each shards\n+     */\n+    private Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot(Path repositoryLocation, String snapshotId) throws IOException {\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsPerShard = new HashMap<>();\n+        Files.walkFileTree(repositoryLocation.resolve(\"indices\"), new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                final String fileName = file.getFileName().toString();\n+                if (fileName.equals(\"snap-\" + snapshotId + \".dat\")) {\n+                    blobsPerShard.put(\n+                        String.join(\n+                            \"/\",\n+                            snapshotId,\n+                            file.getParent().getParent().getFileName().toString(),\n+                            file.getParent().getFileName().toString()\n+                        ),\n+                        INDEX_SHARD_SNAPSHOT_FORMAT.deserialize(fileName, xContentRegistry(), Streams.readFully(Files.newInputStream(file)))\n+                    );\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        return Map.copyOf(blobsPerShard);\n+    }\n+\n+    private void ensureExecutorsAreIdle() throws Exception {\n+        assertBusy(() -> {\n+            for (ThreadPool threadPool : internalCluster().getDataNodeInstances(ThreadPool.class)) {\n+                for (String threadPoolName : List.of(CACHE_FETCH_ASYNC_THREAD_POOL_NAME, CACHE_PREWARMING_THREAD_POOL_NAME)) {\n+                    final ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.executor(threadPoolName);\n+                    assertThat(threadPoolName, executor.getQueue().size(), equalTo(0));\n+                    assertThat(threadPoolName, executor.getActiveCount(), equalTo(0));\n+                }\n+            }\n+        });\n+    }\n+\n+    private void assertCachedBlobsInSystemIndex(final String repositoryName, final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot)\n+        throws Exception {\n+        assertBusy(() -> {\n+            refreshSystemIndex();\n+\n+            long numberOfCachedBlobs = 0L;\n+            for (Map.Entry<String, BlobStoreIndexShardSnapshot> blob : blobsInSnapshot.entrySet()) {\n+                for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : blob.getValue().indexFiles()) {\n+                    if (fileInfo.name().startsWith(\"__\") == false) {\n+                        continue;\n+                    }\n+\n+                    final String path = String.join(\"/\", repositoryName, blob.getKey(), fileInfo.physicalName());\n+                    if (fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2) {\n+                        // file has been fully cached\n+                        final GetResponse getResponse = systemClient().prepareGet(SNAPSHOT_BLOB_CACHE_INDEX, path + \"/@0\").get();\n+                        assertThat(\"not cached: [\" + path + \"/@0] for blob [\" + fileInfo + \"]\", getResponse.isExists(), is(true));\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(getResponse.getSourceAsMap());\n+                        assertThat(cachedBlob.from(), equalTo(0L));\n+                        assertThat(cachedBlob.to(), equalTo(fileInfo.length()));\n+                        assertThat((long) cachedBlob.length(), equalTo(fileInfo.length()));\n+                        numberOfCachedBlobs += 1;\n+\n+                    } else {\n+                        // first region of file has been cached\n+                        GetResponse getResponse = systemClient().prepareGet(SNAPSHOT_BLOB_CACHE_INDEX, path + \"/@0\").get();\n+                        assertThat(\n+                            \"not cached: [\" + path + \"/@0] for first region of blob [\" + fileInfo + \"]\",\n+                            getResponse.isExists(),\n+                            is(true)\n+                        );\n+\n+                        CachedBlob cachedBlob = CachedBlob.fromSource(getResponse.getSourceAsMap());\n+                        assertThat(cachedBlob.from(), equalTo(0L));\n+                        assertThat(cachedBlob.to(), equalTo((long) BlobStoreCacheService.DEFAULT_SIZE));\n+                        assertThat(cachedBlob.length(), equalTo(BlobStoreCacheService.DEFAULT_SIZE));\n+                        numberOfCachedBlobs += 1;\n+                    }\n+                }\n+            }\n+\n+            refreshSystemIndex();\n+            assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        });\n+    }\n+\n+    private void assertBlobsReadFromRemoteRepository(\n+        final String indexName,\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot\n+    ) {\n+        ensureBlobStoreRepositoriesWithActiveShards(indexName, (nodeId, blobStore) -> {\n+            for (Map.Entry<String, List<Tuple<Long, Long>>> blob : blobStore.blobs.entrySet()) {\n+                final String blobName = blob.getKey();\n+\n+                if (blobName.endsWith(\".dat\") || blobName.equals(\"index-0\")) {\n+                    // The snapshot metadata files are accessed when recovering from the snapshot during restore and do not benefit from\n+                    // the snapshot blob cache as the files are accessed outside of a searchable snapshot directory\n+                    assertThat(\n+                        blobName + \" should be fully read from the beginning\",\n+                        blob.getValue().stream().allMatch(read -> read.v1() == 0L),\n+                        is(true)\n+                    );\n+                    // TODO assert it is read til the end", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3MDkwOQ=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 418}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjUwNjQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwOTowNjowMVrOG-Gs0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDowMzoxM1rOG-Icrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3NDY3NA==", "bodyText": "let's remove this field for now", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467774674", "createdAt": "2020-08-10T09:06:01Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin().indices().prepareCreate(index).setSettings(settings()).setMapping(mappings()).execute(new ActionListener<>() {\n+                @Override\n+                public void onResponse(CreateIndexResponse createIndexResponse) {\n+                    assert createIndexResponse.index().equals(index);\n+                    listener.onResponse(createIndexResponse.index());\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof ResourceAlreadyExistsException\n+                        || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                        listener.onResponse(index);\n+                    } else {\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings settings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"false\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"accessed_time\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMzMxMA==", "bodyText": "++ 2abf126.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467803310", "createdAt": "2020-08-10T10:03:13Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin().indices().prepareCreate(index).setSettings(settings()).setMapping(mappings()).execute(new ActionListener<>() {\n+                @Override\n+                public void onResponse(CreateIndexResponse createIndexResponse) {\n+                    assert createIndexResponse.index().equals(index);\n+                    listener.onResponse(createIndexResponse.index());\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof ResourceAlreadyExistsException\n+                        || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                        listener.onResponse(index);\n+                    } else {\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings settings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"false\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"accessed_time\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3NDY3NA=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjUzMjY1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwOToxMzo0OVrOG-G7_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzo1MzoyMFrOG_V9MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3ODU1Ng==", "bodyText": "Do we want to put the file during recovery into the node-local cache (at least if it's the full file)? Can be done in follow-up ofc.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467778556", "createdAt": "2020-08-10T09:13:49Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5Nzk5Nw==", "bodyText": "Mmm maybe, but it does introduce a good deal of troublesome interplay with cache eviction and other reads. We would have to acquire the cache file, possibly evicting other files, in order to put the data on disk. We may never need it again after the shard started up too.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r467797997", "createdAt": "2020-08-10T09:52:38Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3ODU1Ng=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3MzIwMA==", "bodyText": "Ok yes we need to do this, or else we start the shard without all this stuff in node-local cache and then have to fetch them on the first search since we ignore the index cache once recovery is finished.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469073200", "createdAt": "2020-08-12T07:53:20Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,221 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n-                        }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+        logger.trace(\"readInternal: read [{}-{}] from [{}]\", position, position + length, this);\n+\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        final List<Tuple<Long, Long>> indexCacheMisses;\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_SIZE);\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_SIZE * 2;\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+                if (cachedBlob != null) {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    b.put(BytesReference.toBytes(cachedBlob.bytes().slice(Math.toIntExact(position), length)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3ODU1Ng=="}, "originalCommit": {"oid": "1b459aed4a79035dc9366f4ff19118463f745eaf"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTA4Nzc3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo0MjowM1rOG_Xqvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxMzo1MFrOHFf1LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwMTI0Nw==", "bodyText": "A similar case could be made for setting doc_values : false. I wonder though if we should just leave these fields indexed for now, giving us maximum flexibility later to query them whichever way we want. The overhead of indexing them should be fairly small.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469101247", "createdAt": "2020-08-12T08:42:03Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.field(\"index\", \"false\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNjQ0NA==", "bodyText": "Ok reverted in 4f9584c.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475526444", "createdAt": "2020-08-24T11:13:50Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.field(\"index\", \"false\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwMTI0Nw=="}, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTEwNTI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo0NjozMVrOG_X1NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxNDowMVrOHFf1kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwMzkyNQ==", "bodyText": "this is no longer needed, right?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469103925", "createdAt": "2020-08-12T08:46:31Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        // register a new repository that can track blob read operations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNjU0NA==", "bodyText": "Right. Removed in cd77a43.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475526544", "createdAt": "2020-08-24T11:14:01Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        // register a new repository that can track blob read operations", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwMzkyNQ=="}, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTExNzgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo0OTo1MFrOG_X87Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo0OTo1MFrOG_X87Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNTkwMQ==", "bodyText": "I wonder if this is a bit brittle perhaps, with these stats being tracked in-memory on the node that is hosting the shard. In particular, it does not survive restarts / relocations, and could also be different on a replica that recovered after the primary already had some docs. I wonder if we should instead query the number of docs in the SNAPSHOT_BLOB_CACHE_INDEX index.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469105901", "createdAt": "2020-08-12T08:49:50Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.repositories.fs.FsRepository;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        // register a new repository that can track blob read operations\n+        assertAcked(client().admin().cluster().prepareDeleteRepository(repositoryName));\n+        createRepository(\n+            repositoryName,\n+            \"fs\",\n+            Settings.builder().put(FsRepository.LOCATION_SETTING.getKey(), repositoryLocation).build(),\n+            false\n+        );\n+        assertBusy(this::ensureClusterStateConsistency);\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        refreshSystemIndex();\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTE0ODkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo1Nzo0MFrOG_YP0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxNDoxN1rOHFf1-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExMDczOA==", "bodyText": "is this still an issue with the latest changes?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469110738", "createdAt": "2020-08-12T08:57:40Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -793,11 +792,12 @@ private void assertSearchableSnapshotStats(String indexName, boolean cacheEnable\n                             equalTo(0L)\n                         );\n                     } else if (nodeIdsWithLargeEnoughCache.contains(stats.getShardRouting().currentNodeId())) {\n-                        assertThat(\n-                            \"Expected at least 1 cache read or write for \" + fileName + \" of shard \" + shardRouting,\n-                            Math.max(indexInputStats.getCachedBytesRead().getCount(), indexInputStats.getCachedBytesWritten().getCount()),\n-                            greaterThan(0L)\n-                        );\n+                        // not necessarily, it may have been entirely in blob cache TODO improve stats to handle this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNjY1MA==", "bodyText": "Stats look ok now I think", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475526650", "createdAt": "2020-08-24T11:14:17Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -793,11 +792,12 @@ private void assertSearchableSnapshotStats(String indexName, boolean cacheEnable\n                             equalTo(0L)\n                         );\n                     } else if (nodeIdsWithLargeEnoughCache.contains(stats.getShardRouting().currentNodeId())) {\n-                        assertThat(\n-                            \"Expected at least 1 cache read or write for \" + fileName + \" of shard \" + shardRouting,\n-                            Math.max(indexInputStats.getCachedBytesRead().getCount(), indexInputStats.getCachedBytesWritten().getCount()),\n-                            greaterThan(0L)\n-                        );\n+                        // not necessarily, it may have been entirely in blob cache TODO improve stats to handle this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExMDczOA=="}, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTE5ODYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOToxMToyNlrOG_YugQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjozNTowNFrOHFiQgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExODU5Mw==", "bodyText": "Do we still want to keep this check around? Given that we now always open a CacheFile, should we always go with that first, and then make use of this fallback instead?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r469118593", "createdAt": "2020-08-12T09:11:26Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,260 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2NjIxMQ==", "bodyText": "I've gone back and forth on this a few times, but now think this is a better idea, see b50d158. If we can serve the data from disk we do so; if we can't then we try the cache index, and finally fall back on the blob store, regardless of the phase of the shard's life.\nIn the case of no evictions it doesn't make much difference (we never have the data on disk during recovery) but I think this flow will work better for evicted data.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475566211", "createdAt": "2020-08-24T12:35:04Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +146,260 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExODU5Mw=="}, "originalCommit": {"oid": "d2632ee1a7c5fc973f9155ea127d86a0d214327e"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NTk4NDU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoyNTowOFrOHEiNgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoyNTowOFrOHEiNgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNjg2Nw==", "bodyText": "nit: inline in the previous assertion?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474516867", "createdAt": "2020-08-21T08:25:08Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -585,6 +614,17 @@ public static SearchableSnapshotDirectory unwrapDirectory(Directory dir) {\n         return null;\n     }\n \n+    public CachedBlob getCachedBlob(String name, long offset, int length) {\n+        final CachedBlob cachedBlob = blobStoreCacheService.get(repository, name, blobStoreCachePath, offset);\n+        assert cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY || cachedBlob.from() <= offset;\n+        assert cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY || offset + length <= cachedBlob.to();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjAwMDE2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODoyODowM1rOHEiXUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyMTowNlrOHFj_BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxOTM3Ng==", "bodyText": "I guess that it is unlikely CodecUtil.footerLength() will change in future versions, right?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474519376", "createdAt": "2020-08-21T08:28:03Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NDUwMQ==", "bodyText": "It will certainly cause problems, however I added an assertion in 1c38aaa and another in 299443f which will catch this.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475594501", "createdAt": "2020-08-24T13:21:06Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxOTM3Ng=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjE1NDU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/checksum/ChecksumBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODo1NTozNFrOHEj6XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjozNTozMlrOHFiRpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDczMw==", "bodyText": "AFAICS, we allocate a 1KB array here, I wonder if we should use ByteArrayDataOutput instead since we know the exact result size? Alternatively limit the size of the allocation.\nMight not be important, at this time I am not sure of the frequency this would be called.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474544733", "createdAt": "2020-08-21T08:55:34Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/checksum/ChecksumBlobContainerIndexInput.java", "diffHunk": "@@ -131,14 +131,18 @@ private static void ensureReadOnceChecksumContext(IOContext context) {\n      * @throws IOException if something goes wrong when creating the {@link ChecksumBlobContainerIndexInput}\n      */\n     public static ChecksumBlobContainerIndexInput create(String name, long length, String checksum, IOContext context) throws IOException {\n+        return new ChecksumBlobContainerIndexInput(name, length, checksumToBytesArray(checksum), context);\n+    }\n+\n+    public static byte[] checksumToBytesArray(String checksum) throws IOException {\n         final ByteBuffersDataOutput out = new ByteBuffersDataOutput();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2NjUwMw==", "bodyText": "I don't think it's very important, but yes we can do better here (and it's shorter too), see 1c38aaa.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475566503", "createdAt": "2020-08-24T12:35:32Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/checksum/ChecksumBlobContainerIndexInput.java", "diffHunk": "@@ -131,14 +131,18 @@ private static void ensureReadOnceChecksumContext(IOContext context) {\n      * @throws IOException if something goes wrong when creating the {@link ChecksumBlobContainerIndexInput}\n      */\n     public static ChecksumBlobContainerIndexInput create(String name, long length, String checksum, IOContext context) throws IOException {\n+        return new ChecksumBlobContainerIndexInput(name, length, checksumToBytesArray(checksum), context);\n+    }\n+\n+    public static byte[] checksumToBytesArray(String checksum) throws IOException {\n         final ByteBuffersDataOutput out = new ByteBuffersDataOutput();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDczMw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjE4OTMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTowMTo0MVrOHEkQNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMToxNzowM1rOHHHY9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1MDMyNA==", "bodyText": "I wonder if this introduces a risk of deadlock if all GET threads end here?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474550324", "createdAt": "2020-08-21T09:01:41Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzMjc1Mg==", "bodyText": "On further reflection, this is likely only an issue if system indices utilize searchable snapshots. Cannot think of a case where that makes sense now, so we could perhaps guard against system indices using searchable snapshots (if we do not do that already)?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475432752", "createdAt": "2020-08-24T08:42:13Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1MDMyNA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2MTg4MA==", "bodyText": "We talked about this via another channel and we agreed that there could be bad situations in the case of system indices using searchable snapshots. Elasticsearch expects system indices to be writable and searchable snapshots indices are read-only by nature; this can lead to malfunctional features. Similarly system and hidden indices can be snapshotted but we want to prevent snapshot to be mounted as system indices like .security or .snapshot-blob-cache.\nI opened #61517 to forbid mounting system indices.\nWe also agreed on improving the timeouts around gets/puts in snapshot blob cache to allow recoveries to move forward even if the snapshot blob cache index is unavailable.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r476361880", "createdAt": "2020-08-25T11:01:26Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1MDMyNA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA4ODE1Mg==", "bodyText": "A possible alternative idea is to bypass the cache index for indices on which the GET would run on the SYSTEM_READ threadpool. This would let us support them as searchable snapshots, just without the recovery speed advantage of the cache; maybe we can recommend running them with replicas so as not to need the faster startup anyway.\nAdding a timeout is relatively easy, the only question remains how long should it be? What do you think about 5s?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477088152", "createdAt": "2020-08-26T07:23:24Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1MDMyNA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwOTMwMQ==", "bodyText": "A possible alternative idea is to bypass the cache index for indices on which the GET would run on the SYSTEM_READ threadpool.\n\nThat's a interesting idea and I did not know about this new thread pool. This would work I think, but I'm struggling finding a good reason to allow system indices being mounted as searchable snapshots whereas I can see reasons to prevent them being slowish and read-only. I think #61517 makes sense today (with comments made there) and this is something we can revisit later.\n\nWhat do you think about 5s?\n\nAnything below 10s looks good to me.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477109301", "createdAt": "2020-08-26T08:00:19Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1MDMyNA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIyMzE1OA==", "bodyText": "Bit of a wild goose chase checking this one. We could be on a GET thread and I suddenly worried that we also use a GET thread for reading from the cache index, which would still cause a deadlock:\n\n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/action/get/TransportGetAction.java\n    \n    \n        Lines 53 to 54\n      in\n      8c51fc7\n    \n    \n    \n    \n\n        \n          \n           super(GetAction.NAME, threadPool, clusterService, transportService, actionFilters, indexNameExpressionResolver, \n        \n\n        \n          \n                   GetRequest::new, ThreadPool.Names.GET); \n        \n    \n  \n\n\nBut then I saw that we have special handling for gets against system indices:\n\n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/action/get/TransportGetAction.java\n    \n    \n        Lines 117 to 126\n      in\n      8c51fc7\n    \n    \n    \n    \n\n        \n          \n           protected String getExecutor(GetRequest request, ShardId shardId) { \n        \n\n        \n          \n               final ClusterState clusterState = clusterService.state(); \n        \n\n        \n          \n               if (clusterState.metadata().index(shardId.getIndex()).isSystem()) { \n        \n\n        \n          \n                   return ThreadPool.Names.SYSTEM_READ; \n        \n\n        \n          \n               } else if (indicesService.indexServiceSafe(shardId.getIndex()).getIndexSettings().isSearchThrottled()) { \n        \n\n        \n          \n                   return ThreadPool.Names.SEARCH_THROTTLED; \n        \n\n        \n          \n               } else { \n        \n\n        \n          \n                   return super.getExecutor(request, shardId); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nThe constructor parameter suggests that we might first dispatch to a GET thread, and then dispatch again to the result of getExecutor, but in fact we don't we handle the transport action on SAME and then dispatch once. So it's all ok.\nI added a 5-second timeout and some logging in eb1a08e.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477223158", "createdAt": "2020-08-26T11:17:03Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1MDMyNA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjIyNDc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTowNzo0NVrOHEkmFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjozNjoxOFrOHFiTOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NTkyNw==", "bodyText": "I think we would see a remote wrapper exception here? Perhaps we can use TransportActions.isShardNotAvailableException?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474555927", "createdAt": "2020-08-21T09:07:45Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2NjkwNg==", "bodyText": "Yes, and we can also expect a ConnectTransportException and I think a NodeClosedException too. Extended this in 7bd0e47 and added an assertion that these are the only possibilities.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475566906", "createdAt": "2020-08-24T12:36:18Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NTkyNw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjI0OTAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOToxMjoxM1rOHEk1YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjozNzoyM1rOHFiVoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1OTg0MQ==", "bodyText": "I am torn on this. If the cause is a bug, we would like to see it to surface it. But in any failure that is not a bug, I think we would like to assume the cache is unavailable?\nFor instance a network issue to the node holding the shard, I think that would fall out here? And in that case, I would prefer to warn and move on.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474559841", "createdAt": "2020-08-21T09:12:13Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {\n+                        // In case the blob cache system index got unavailable, we pretend we didn't find a cache entry and we move on.\n+                        // Failing here might bubble up the exception and fail the searchable snapshot shard which is potentially\n+                        // recovering.\n+                        logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+                    } else {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onFailure(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2NzUyMA==", "bodyText": "See 7bd0e47, we now treat a network issue as something we expect, not even worthy of a warning, but we also now have an assert false to hopefully expose any bugs.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475567520", "createdAt": "2020-08-24T12:37:23Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {\n+                        // In case the blob cache system index got unavailable, we pretend we didn't find a cache entry and we move on.\n+                        // Failing here might bubble up the exception and fail the searchable snapshot shard which is potentially\n+                        // recovering.\n+                        logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+                    } else {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onFailure(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1OTg0MQ=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjM4NDAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozNjo0MVrOHEmLoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOTo0MToxMlrOHGQL4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU4MTkyMA==", "bodyText": "Should we also stat the time spent reading from the cache?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474581920", "createdAt": "2020-08-21T09:36:41Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                    // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+                    // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+                    // {start, end} ranges where positions are relative to the whole file.\n+                    if (canBeFullyCached) {\n+                        // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                        indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n+                    } else {\n+                        // the index input is too large to fully cache, so just cache the initial range\n+                        indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+                    }\n+\n+                    // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                    // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                } else {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    stats.addIndexCacheBytesRead(cachedBlob.length());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4NzQ2NA==", "bodyText": "Sure; didn't need the timings for tests but it might be useful in future, see d53443e.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475587464", "createdAt": "2020-08-24T13:09:14Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                    // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+                    // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+                    // {start, end} ranges where positions are relative to the whole file.\n+                    if (canBeFullyCached) {\n+                        // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                        indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n+                    } else {\n+                        // the index input is too large to fully cache, so just cache the initial range\n+                        indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+                    }\n+\n+                    // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                    // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                } else {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    stats.addIndexCacheBytesRead(cachedBlob.length());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU4MTkyMA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODY4OA==", "bodyText": "I've reverted this change because it interferes with other assertions about how the stats are collected when we are concurrently fetching and reading data. It's probably fixable in a followup but since there's no immediate need for these timings I won't do it here.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r476318688", "createdAt": "2020-08-25T09:41:12Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                    // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested so\n+                    // we compute the regions of the file we would like to have the next time. The regions are expressed as tuples of\n+                    // {start, end} ranges where positions are relative to the whole file.\n+                    if (canBeFullyCached) {\n+                        // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                        indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n+                    } else {\n+                        // the index input is too large to fully cache, so just cache the initial range\n+                        indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+                    }\n+\n+                    // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                    // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                } else {\n+                    logger.trace(\n+                        \"reading [{}] bytes of file [{}] at position [{}] using index cache\",\n+                        length,\n+                        fileInfo.physicalName(),\n+                        position\n+                    );\n+                    stats.addIndexCacheBytesRead(cachedBlob.length());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU4MTkyMA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjQzNzkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTo0NjoyMFrOHEmuMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyMTozOFrOHFkARw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5MDc2OA==", "bodyText": "I think we aren't handling the exceptions for this call, is that ok? maybe we should treat them as a CACHE_NOT_READY?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474590768", "createdAt": "2020-08-21T09:46:20Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NDgyMw==", "bodyText": "Some change since you last looked has meant that getCachedBlob doesn't return an error any more (at least not unless there's a bug)", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475594823", "createdAt": "2020-08-24T13:21:38Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {\n+            // We try to use the snapshot blob cache if:\n+            // - the file is small enough to be fully cached in the blob cache\n+            final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+            // - we're reading the first N bytes of the file\n+            final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+            if (canBeFullyCached || isStartOfFile) {\n+                final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5MDc2OA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjQ0MjA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTo0NzowOVrOHEmw4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjoxOTo1NlrOHGVYyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5MTQ1Nw==", "bodyText": "Currently If the pre-warm phase fails, recovery won't move to DONE, I guess that's ok?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474591457", "createdAt": "2020-08-21T09:47:09Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMzkxMw==", "bodyText": "Ok, we no longer care about the recovery state as of b50d158 (also removed that machinery entirely in abdbf3c)", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r476403913", "createdAt": "2020-08-25T12:19:56Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,276 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n-                        } else {\n-                            read = readCacheFile(channel, pos, b);\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+        // We prefer to use the index cache if the recovery is not done yet\n+        if (directory.isRecoveryDone() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5MTQ1Nw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjU5OTk1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMDozMzowNVrOHEoQjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzowOTozN1rOHFjkaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNTk1MA==", "bodyText": "I think we need to delegate this failure to the listener too to decrement the current index cache fills stats (and to keep the principle of listener always being notified).", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474615950", "createdAt": "2020-08-21T10:33:05Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {\n+                        // In case the blob cache system index got unavailable, we pretend we didn't find a cache entry and we move on.\n+                        // Failing here might bubble up the exception and fail the searchable snapshot shard which is potentially\n+                        // recovering.\n+                        logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+                    } else {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void putAsync(String repository, String name, String path, long offset, BytesReference content, ActionListener<Void> listener) {\n+        createIndexIfNecessary(new ActionListener<>() {\n+            @Override\n+            public void onResponse(String s) {\n+                try {\n+                    final CachedBlob cachedBlob = new CachedBlob(\n+                        Instant.ofEpochMilli(threadPool.absoluteTimeInMillis()),\n+                        Version.CURRENT,\n+                        repository,\n+                        name,\n+                        path,\n+                        content,\n+                        offset\n+                    );\n+                    final IndexRequest request = new IndexRequest(index).id(cachedBlob.generatedId());\n+                    try (XContentBuilder builder = jsonBuilder()) {\n+                        request.source(cachedBlob.toXContent(builder, ToXContent.EMPTY_PARAMS));\n+                    }\n+                    client.index(request, new ActionListener<>() {\n+                        @Override\n+                        public void onResponse(IndexResponse indexResponse) {\n+                            logger.trace(\"cache fill ({}): [{}]\", indexResponse.status(), request.id());\n+                            listener.onResponse(null);\n+                        }\n+\n+                        @Override\n+                        public void onFailure(Exception e) {\n+                            logger.debug(new ParameterizedMessage(\"failure in cache fill: [{}]\", request.id()), e);\n+                            listener.onFailure(e);\n+                        }\n+                    });\n+                } catch (IOException e) {\n+                    logger.warn(\n+                        new ParameterizedMessage(\"cache fill failure: [{}]\", CachedBlob.generateId(repository, name, path, offset)),\n+                        e\n+                    );\n+                }\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                logger.error(() -> new ParameterizedMessage(\"failed to create blob cache system index [{}]\", index), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4NzY4OQ==", "bodyText": "Ah yes, good catch. Fixed in 7e6eb53.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475587689", "createdAt": "2020-08-24T13:09:37Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {\n+                        // In case the blob cache system index got unavailable, we pretend we didn't find a cache entry and we move on.\n+                        // Failing here might bubble up the exception and fail the searchable snapshot shard which is potentially\n+                        // recovering.\n+                        logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+                    } else {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void putAsync(String repository, String name, String path, long offset, BytesReference content, ActionListener<Void> listener) {\n+        createIndexIfNecessary(new ActionListener<>() {\n+            @Override\n+            public void onResponse(String s) {\n+                try {\n+                    final CachedBlob cachedBlob = new CachedBlob(\n+                        Instant.ofEpochMilli(threadPool.absoluteTimeInMillis()),\n+                        Version.CURRENT,\n+                        repository,\n+                        name,\n+                        path,\n+                        content,\n+                        offset\n+                    );\n+                    final IndexRequest request = new IndexRequest(index).id(cachedBlob.generatedId());\n+                    try (XContentBuilder builder = jsonBuilder()) {\n+                        request.source(cachedBlob.toXContent(builder, ToXContent.EMPTY_PARAMS));\n+                    }\n+                    client.index(request, new ActionListener<>() {\n+                        @Override\n+                        public void onResponse(IndexResponse indexResponse) {\n+                            logger.trace(\"cache fill ({}): [{}]\", indexResponse.status(), request.id());\n+                            listener.onResponse(null);\n+                        }\n+\n+                        @Override\n+                        public void onFailure(Exception e) {\n+                            logger.debug(new ParameterizedMessage(\"failure in cache fill: [{}]\", request.id()), e);\n+                            listener.onFailure(e);\n+                        }\n+                    });\n+                } catch (IOException e) {\n+                    logger.warn(\n+                        new ParameterizedMessage(\"cache fill failure: [{}]\", CachedBlob.generateId(repository, name, path, offset)),\n+                        e\n+                    );\n+                }\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                logger.error(() -> new ParameterizedMessage(\"failed to create blob cache system index [{}]\", index), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNTk1MA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Njc0NTk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMToyNjozNVrOHEpmgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjozNDoyMFrOHGV61Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzNzk1NA==", "bodyText": "This can be prone to races, as we add pre-warm tasks one by one. I've been hit by this in the past \ud83d\ude05 .", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474637954", "createdAt": "2020-08-21T11:26:35Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@TestLogging(reason = \"debugging\", value = \"org.elasticsearch.index.store.cache.CachedBlobContainerIndexInput:TRACE,\"\n+    + \"org.elasticsearch.blobstore.cache.BlobStoreCacheService:TRACE\") // TODO remove this before merge\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));\n+                }\n+            }\n+        });\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()\n+            .indices()\n+            .prepareStats(SNAPSHOT_BLOB_CACHE_INDEX)\n+            .clear()\n+            .setIndexing(true)\n+            .get()\n+            .getTotal().indexing.getTotal().getIndexCount();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying shards of [{}] were started without using the blob store more than necessary\", restoredAgainIndex);\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                final boolean mayReadMoreThanHeader\n+                // we read the header of each file contained within the .cfs file, which could be anywhere\n+                    = indexInputStats.getFileName().endsWith(\".cfs\")\n+                        // we read a couple of longs at the end of the .fdt file (see https://issues.apache.org/jira/browse/LUCENE-9456)\n+                        // TODO revisit this when this issue is addressed in Lucene\n+                        || indexInputStats.getFileName().endsWith(\".fdt\");\n+                if (indexInputStats.getFileLength() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2\n+                    || mayReadMoreThanHeader == false) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), equalTo(0L));\n+                }\n+            }\n+        }\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no extra cached blobs were indexed [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(numberOfCacheWrites)\n+        );\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(0L)\n+        );\n+\n+        // TODO also test when the index is frozen\n+        // TODO also test when prewarming is enabled\n+    }\n+\n+    /**\n+     * @return a {@link Client} that can be used to query the blob store cache system index\n+     */\n+    private Client systemClient() {\n+        return new OriginSettingClient(client(), ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN);\n+    }\n+\n+    private void refreshSystemIndex() {\n+        try {\n+            final RefreshResponse refreshResponse = systemClient().admin().indices().prepareRefresh(SNAPSHOT_BLOB_CACHE_INDEX).get();\n+            assertThat(refreshResponse.getSuccessfulShards(), greaterThan(0));\n+            assertThat(refreshResponse.getFailedShards(), equalTo(0));\n+        } catch (IndexNotFoundException indexNotFoundException) {\n+            throw new AssertionError(\"unexpected\", indexNotFoundException);\n+        }\n+    }\n+\n+    /**\n+     * Reads a repository location on disk and extracts the list of blobs for each shards\n+     */\n+    private Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot(Path repositoryLocation, String snapshotId) throws IOException {\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsPerShard = new HashMap<>();\n+        Files.walkFileTree(repositoryLocation.resolve(\"indices\"), new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                final String fileName = file.getFileName().toString();\n+                if (fileName.equals(\"snap-\" + snapshotId + \".dat\")) {\n+                    blobsPerShard.put(\n+                        String.join(\n+                            \"/\",\n+                            snapshotId,\n+                            file.getParent().getParent().getFileName().toString(),\n+                            file.getParent().getFileName().toString()\n+                        ),\n+                        INDEX_SHARD_SNAPSHOT_FORMAT.deserialize(fileName, xContentRegistry(), Streams.readFully(Files.newInputStream(file)))\n+                    );\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        return Map.copyOf(blobsPerShard);\n+    }\n+\n+    private void ensureExecutorsAreIdle() throws Exception {\n+        assertBusy(() -> {\n+            for (ThreadPool threadPool : internalCluster().getDataNodeInstances(ThreadPool.class)) {\n+                for (String threadPoolName : List.of(CACHE_FETCH_ASYNC_THREAD_POOL_NAME, CACHE_PREWARMING_THREAD_POOL_NAME)) {\n+                    final ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.executor(threadPoolName);\n+                    assertThat(threadPoolName, executor.getQueue().size(), equalTo(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDAxOA==", "bodyText": "Yes I think we don't need this any more (we aren't pre-warming) so I removed it in 38bf697. @tlrx does that look ok to you?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r476410018", "createdAt": "2020-08-25T12:29:43Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@TestLogging(reason = \"debugging\", value = \"org.elasticsearch.index.store.cache.CachedBlobContainerIndexInput:TRACE,\"\n+    + \"org.elasticsearch.blobstore.cache.BlobStoreCacheService:TRACE\") // TODO remove this before merge\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));\n+                }\n+            }\n+        });\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()\n+            .indices()\n+            .prepareStats(SNAPSHOT_BLOB_CACHE_INDEX)\n+            .clear()\n+            .setIndexing(true)\n+            .get()\n+            .getTotal().indexing.getTotal().getIndexCount();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying shards of [{}] were started without using the blob store more than necessary\", restoredAgainIndex);\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                final boolean mayReadMoreThanHeader\n+                // we read the header of each file contained within the .cfs file, which could be anywhere\n+                    = indexInputStats.getFileName().endsWith(\".cfs\")\n+                        // we read a couple of longs at the end of the .fdt file (see https://issues.apache.org/jira/browse/LUCENE-9456)\n+                        // TODO revisit this when this issue is addressed in Lucene\n+                        || indexInputStats.getFileName().endsWith(\".fdt\");\n+                if (indexInputStats.getFileLength() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2\n+                    || mayReadMoreThanHeader == false) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), equalTo(0L));\n+                }\n+            }\n+        }\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no extra cached blobs were indexed [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(numberOfCacheWrites)\n+        );\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(0L)\n+        );\n+\n+        // TODO also test when the index is frozen\n+        // TODO also test when prewarming is enabled\n+    }\n+\n+    /**\n+     * @return a {@link Client} that can be used to query the blob store cache system index\n+     */\n+    private Client systemClient() {\n+        return new OriginSettingClient(client(), ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN);\n+    }\n+\n+    private void refreshSystemIndex() {\n+        try {\n+            final RefreshResponse refreshResponse = systemClient().admin().indices().prepareRefresh(SNAPSHOT_BLOB_CACHE_INDEX).get();\n+            assertThat(refreshResponse.getSuccessfulShards(), greaterThan(0));\n+            assertThat(refreshResponse.getFailedShards(), equalTo(0));\n+        } catch (IndexNotFoundException indexNotFoundException) {\n+            throw new AssertionError(\"unexpected\", indexNotFoundException);\n+        }\n+    }\n+\n+    /**\n+     * Reads a repository location on disk and extracts the list of blobs for each shards\n+     */\n+    private Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot(Path repositoryLocation, String snapshotId) throws IOException {\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsPerShard = new HashMap<>();\n+        Files.walkFileTree(repositoryLocation.resolve(\"indices\"), new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                final String fileName = file.getFileName().toString();\n+                if (fileName.equals(\"snap-\" + snapshotId + \".dat\")) {\n+                    blobsPerShard.put(\n+                        String.join(\n+                            \"/\",\n+                            snapshotId,\n+                            file.getParent().getParent().getFileName().toString(),\n+                            file.getParent().getFileName().toString()\n+                        ),\n+                        INDEX_SHARD_SNAPSHOT_FORMAT.deserialize(fileName, xContentRegistry(), Streams.readFully(Files.newInputStream(file)))\n+                    );\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        return Map.copyOf(blobsPerShard);\n+    }\n+\n+    private void ensureExecutorsAreIdle() throws Exception {\n+        assertBusy(() -> {\n+            for (ThreadPool threadPool : internalCluster().getDataNodeInstances(ThreadPool.class)) {\n+                for (String threadPoolName : List.of(CACHE_FETCH_ASYNC_THREAD_POOL_NAME, CACHE_PREWARMING_THREAD_POOL_NAME)) {\n+                    final ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.executor(threadPoolName);\n+                    assertThat(threadPoolName, executor.getQueue().size(), equalTo(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzNzk1NA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjYyOQ==", "bodyText": "It does look OK to me, the main purpose was to wait for cache writes to complete and it now uses stats to do so.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r476412629", "createdAt": "2020-08-25T12:34:20Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@TestLogging(reason = \"debugging\", value = \"org.elasticsearch.index.store.cache.CachedBlobContainerIndexInput:TRACE,\"\n+    + \"org.elasticsearch.blobstore.cache.BlobStoreCacheService:TRACE\") // TODO remove this before merge\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));\n+                }\n+            }\n+        });\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()\n+            .indices()\n+            .prepareStats(SNAPSHOT_BLOB_CACHE_INDEX)\n+            .clear()\n+            .setIndexing(true)\n+            .get()\n+            .getTotal().indexing.getTotal().getIndexCount();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying shards of [{}] were started without using the blob store more than necessary\", restoredAgainIndex);\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                final boolean mayReadMoreThanHeader\n+                // we read the header of each file contained within the .cfs file, which could be anywhere\n+                    = indexInputStats.getFileName().endsWith(\".cfs\")\n+                        // we read a couple of longs at the end of the .fdt file (see https://issues.apache.org/jira/browse/LUCENE-9456)\n+                        // TODO revisit this when this issue is addressed in Lucene\n+                        || indexInputStats.getFileName().endsWith(\".fdt\");\n+                if (indexInputStats.getFileLength() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2\n+                    || mayReadMoreThanHeader == false) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), equalTo(0L));\n+                }\n+            }\n+        }\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no extra cached blobs were indexed [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(numberOfCacheWrites)\n+        );\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(0L)\n+        );\n+\n+        // TODO also test when the index is frozen\n+        // TODO also test when prewarming is enabled\n+    }\n+\n+    /**\n+     * @return a {@link Client} that can be used to query the blob store cache system index\n+     */\n+    private Client systemClient() {\n+        return new OriginSettingClient(client(), ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN);\n+    }\n+\n+    private void refreshSystemIndex() {\n+        try {\n+            final RefreshResponse refreshResponse = systemClient().admin().indices().prepareRefresh(SNAPSHOT_BLOB_CACHE_INDEX).get();\n+            assertThat(refreshResponse.getSuccessfulShards(), greaterThan(0));\n+            assertThat(refreshResponse.getFailedShards(), equalTo(0));\n+        } catch (IndexNotFoundException indexNotFoundException) {\n+            throw new AssertionError(\"unexpected\", indexNotFoundException);\n+        }\n+    }\n+\n+    /**\n+     * Reads a repository location on disk and extracts the list of blobs for each shards\n+     */\n+    private Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot(Path repositoryLocation, String snapshotId) throws IOException {\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsPerShard = new HashMap<>();\n+        Files.walkFileTree(repositoryLocation.resolve(\"indices\"), new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                final String fileName = file.getFileName().toString();\n+                if (fileName.equals(\"snap-\" + snapshotId + \".dat\")) {\n+                    blobsPerShard.put(\n+                        String.join(\n+                            \"/\",\n+                            snapshotId,\n+                            file.getParent().getParent().getFileName().toString(),\n+                            file.getParent().getFileName().toString()\n+                        ),\n+                        INDEX_SHARD_SNAPSHOT_FORMAT.deserialize(fileName, xContentRegistry(), Streams.readFully(Files.newInputStream(file)))\n+                    );\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        return Map.copyOf(blobsPerShard);\n+    }\n+\n+    private void ensureExecutorsAreIdle() throws Exception {\n+        assertBusy(() -> {\n+            for (ThreadPool threadPool : internalCluster().getDataNodeInstances(ThreadPool.class)) {\n+                for (String threadPoolName : List.of(CACHE_FETCH_ASYNC_THREAD_POOL_NAME, CACHE_PREWARMING_THREAD_POOL_NAME)) {\n+                    final ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.executor(threadPoolName);\n+                    assertThat(threadPoolName, executor.getQueue().size(), equalTo(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzNzk1NA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Njc1NjQyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMTozMDozMlrOHEptEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyMTo1M1rOHFkBBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzOTYzMw==", "bodyText": "Can we add a test where BlobStoreCacheService#getCachedBlob fails?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474639633", "createdAt": "2020-08-21T11:30:32Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@TestLogging(reason = \"debugging\", value = \"org.elasticsearch.index.store.cache.CachedBlobContainerIndexInput:TRACE,\"\n+    + \"org.elasticsearch.blobstore.cache.BlobStoreCacheService:TRACE\") // TODO remove this before merge\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));\n+                }\n+            }\n+        });\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()\n+            .indices()\n+            .prepareStats(SNAPSHOT_BLOB_CACHE_INDEX)\n+            .clear()\n+            .setIndexing(true)\n+            .get()\n+            .getTotal().indexing.getTotal().getIndexCount();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying shards of [{}] were started without using the blob store more than necessary\", restoredAgainIndex);\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                final boolean mayReadMoreThanHeader\n+                // we read the header of each file contained within the .cfs file, which could be anywhere\n+                    = indexInputStats.getFileName().endsWith(\".cfs\")\n+                        // we read a couple of longs at the end of the .fdt file (see https://issues.apache.org/jira/browse/LUCENE-9456)\n+                        // TODO revisit this when this issue is addressed in Lucene\n+                        || indexInputStats.getFileName().endsWith(\".fdt\");\n+                if (indexInputStats.getFileLength() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2\n+                    || mayReadMoreThanHeader == false) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), equalTo(0L));\n+                }\n+            }\n+        }\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no extra cached blobs were indexed [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(numberOfCacheWrites)\n+        );\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(0L)\n+        );\n+\n+        // TODO also test when the index is frozen\n+        // TODO also test when prewarming is enabled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NTAxMw==", "bodyText": "Some change since you last looked has meant that getCachedBlob doesn't return an error any more (at least not unless there's a bug)", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475595013", "createdAt": "2020-08-24T13:21:53Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_FETCH_ASYNC_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@TestLogging(reason = \"debugging\", value = \"org.elasticsearch.index.store.cache.CachedBlobContainerIndexInput:TRACE,\"\n+    + \"org.elasticsearch.blobstore.cache.BlobStoreCacheService:TRACE\") // TODO remove this before merge\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+        ensureExecutorsAreIdle();\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));\n+                }\n+            }\n+        });\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()\n+            .indices()\n+            .prepareStats(SNAPSHOT_BLOB_CACHE_INDEX)\n+            .clear()\n+            .setIndexing(true)\n+            .get()\n+            .getTotal().indexing.getTotal().getIndexCount();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying shards of [{}] were started without using the blob store more than necessary\", restoredAgainIndex);\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                final boolean mayReadMoreThanHeader\n+                // we read the header of each file contained within the .cfs file, which could be anywhere\n+                    = indexInputStats.getFileName().endsWith(\".cfs\")\n+                        // we read a couple of longs at the end of the .fdt file (see https://issues.apache.org/jira/browse/LUCENE-9456)\n+                        // TODO revisit this when this issue is addressed in Lucene\n+                        || indexInputStats.getFileName().endsWith(\".fdt\");\n+                if (indexInputStats.getFileLength() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2\n+                    || mayReadMoreThanHeader == false) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), equalTo(0L));\n+                }\n+            }\n+        }\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no extra cached blobs were indexed [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(numberOfCacheWrites)\n+        );\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+        ensureExecutorsAreIdle();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (after restart) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no cached blobs were indexed in system index [{}] after restart\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(0L)\n+        );\n+\n+        // TODO also test when the index is frozen\n+        // TODO also test when prewarming is enabled", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYzOTYzMw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Njc2NTA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/CachedBlob.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMTozMzozN1rOHEpyCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzo0ODo1NlrOHFlhew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY0MDkwNw==", "bodyText": "We're populating this field with Version.CURRENT I think I'm missing where is this useful? I think it would make more sense to populate with the version of the snapshot itself so we can determine if it's possible to read this or not?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r474640907", "createdAt": "2020-08-21T11:33:37Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/CachedBlob.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Map;\n+\n+public class CachedBlob implements ToXContent {\n+\n+    /**\n+     * Sentinel {@link CachedBlob} indicating that searching the cache index returned an error.\n+     */\n+    public static final CachedBlob CACHE_NOT_READY = new CachedBlob(null, null, null, \"CACHE_NOT_READY\", null, BytesArray.EMPTY, 0L, 0L);\n+\n+    /**\n+     * Sentinel {@link CachedBlob} indicating that the cache index definitely did not contain the requested data.\n+     */\n+    public static final CachedBlob CACHE_MISS = new CachedBlob(null, null, null, \"CACHE_MISS\", null, BytesArray.EMPTY, 0L, 0L);\n+\n+    private static final String TYPE = \"blob\";\n+\n+    private final Instant creationTime;\n+    private final Version version;\n+    private final String repository;\n+    private final String name;\n+    private final String path;\n+\n+    private final BytesReference bytes;\n+    private final long from;\n+    private final long to;\n+\n+    public CachedBlob(\n+        Instant creationTime,\n+        Version version,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NjYyNA==", "bodyText": "The actual format of blobs in the index is not settled but is relatively easy to change. I can see value in recording the version of Elasticsearch that filled the cache since this should enable BWC should we need to change the format in future.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475596624", "createdAt": "2020-08-24T13:24:29Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/CachedBlob.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Map;\n+\n+public class CachedBlob implements ToXContent {\n+\n+    /**\n+     * Sentinel {@link CachedBlob} indicating that searching the cache index returned an error.\n+     */\n+    public static final CachedBlob CACHE_NOT_READY = new CachedBlob(null, null, null, \"CACHE_NOT_READY\", null, BytesArray.EMPTY, 0L, 0L);\n+\n+    /**\n+     * Sentinel {@link CachedBlob} indicating that the cache index definitely did not contain the requested data.\n+     */\n+    public static final CachedBlob CACHE_MISS = new CachedBlob(null, null, null, \"CACHE_MISS\", null, BytesArray.EMPTY, 0L, 0L);\n+\n+    private static final String TYPE = \"blob\";\n+\n+    private final Instant creationTime;\n+    private final Version version;\n+    private final String repository;\n+    private final String name;\n+    private final String path;\n+\n+    private final BytesReference bytes;\n+    private final long from;\n+    private final long to;\n+\n+    public CachedBlob(\n+        Instant creationTime,\n+        Version version,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY0MDkwNw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYxOTcwNw==", "bodyText": "this should enable BWC should we need to change the format in future.\n\nYes, that was the main reason I added this information. The version of the index is already stored in the index.version.created metadata which is set back during restore and never modified.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475619707", "createdAt": "2020-08-24T13:48:56Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/CachedBlob.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Map;\n+\n+public class CachedBlob implements ToXContent {\n+\n+    /**\n+     * Sentinel {@link CachedBlob} indicating that searching the cache index returned an error.\n+     */\n+    public static final CachedBlob CACHE_NOT_READY = new CachedBlob(null, null, null, \"CACHE_NOT_READY\", null, BytesArray.EMPTY, 0L, 0L);\n+\n+    /**\n+     * Sentinel {@link CachedBlob} indicating that the cache index definitely did not contain the requested data.\n+     */\n+    public static final CachedBlob CACHE_MISS = new CachedBlob(null, null, null, \"CACHE_MISS\", null, BytesArray.EMPTY, 0L, 0L);\n+\n+    private static final String TYPE = \"blob\";\n+\n+    private final Instant creationTime;\n+    private final Version version;\n+    private final String repository;\n+    private final String name;\n+    private final String path;\n+\n+    private final BytesReference bytes;\n+    private final long from;\n+    private final long to;\n+\n+    public CachedBlob(\n+        Instant creationTime,\n+        Version version,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY0MDkwNw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjM2NzI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1MToxM1rOHFab-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTowNDo0OFrOHFflCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzODA3Mw==", "bodyText": "Should we trigger the listener on this exception too?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475438073", "createdAt": "2020-08-24T08:51:13Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {\n+                        // In case the blob cache system index got unavailable, we pretend we didn't find a cache entry and we move on.\n+                        // Failing here might bubble up the exception and fail the searchable snapshot shard which is potentially\n+                        // recovering.\n+                        logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+                    } else {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void putAsync(String repository, String name, String path, long offset, BytesReference content, ActionListener<Void> listener) {\n+        createIndexIfNecessary(new ActionListener<>() {\n+            @Override\n+            public void onResponse(String s) {\n+                try {\n+                    final CachedBlob cachedBlob = new CachedBlob(\n+                        Instant.ofEpochMilli(threadPool.absoluteTimeInMillis()),\n+                        Version.CURRENT,\n+                        repository,\n+                        name,\n+                        path,\n+                        content,\n+                        offset\n+                    );\n+                    final IndexRequest request = new IndexRequest(index).id(cachedBlob.generatedId());\n+                    try (XContentBuilder builder = jsonBuilder()) {\n+                        request.source(cachedBlob.toXContent(builder, ToXContent.EMPTY_PARAMS));\n+                    }\n+                    client.index(request, new ActionListener<>() {\n+                        @Override\n+                        public void onResponse(IndexResponse indexResponse) {\n+                            logger.trace(\"cache fill ({}): [{}]\", indexResponse.status(), request.id());\n+                            listener.onResponse(null);\n+                        }\n+\n+                        @Override\n+                        public void onFailure(Exception e) {\n+                            logger.debug(new ParameterizedMessage(\"failure in cache fill: [{}]\", request.id()), e);\n+                            listener.onFailure(e);\n+                        }\n+                    });\n+                } catch (IOException e) {\n+                    logger.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMjMxMw==", "bodyText": "Yes, I think this could be wrapped so that the listener is always called in case of exception\nedit: Henning saw it too earlier #60522 (comment)", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475522313", "createdAt": "2020-08-24T11:04:48Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        try {\n+            final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+            client.get(request, new ActionListener<>() {\n+                @Override\n+                public void onResponse(GetResponse response) {\n+                    if (response.isExists()) {\n+                        logger.debug(\"cache hit : [{}]\", request.id());\n+                        assert response.isSourceEmpty() == false;\n+\n+                        final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                        assert response.getId().equals(cachedBlob.generatedId());\n+                        listener.onResponse(cachedBlob);\n+                    } else {\n+                        logger.debug(\"cache miss: [{}]\", request.id());\n+                        listener.onResponse(CachedBlob.CACHE_MISS);\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof IndexNotFoundException || e instanceof NoShardAvailableActionException) {\n+                        // In case the blob cache system index got unavailable, we pretend we didn't find a cache entry and we move on.\n+                        // Failing here might bubble up the exception and fail the searchable snapshot shard which is potentially\n+                        // recovering.\n+                        logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+                    } else {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                        listener.onFailure(e);\n+                    }\n+                }\n+            });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void putAsync(String repository, String name, String path, long offset, BytesReference content, ActionListener<Void> listener) {\n+        createIndexIfNecessary(new ActionListener<>() {\n+            @Override\n+            public void onResponse(String s) {\n+                try {\n+                    final CachedBlob cachedBlob = new CachedBlob(\n+                        Instant.ofEpochMilli(threadPool.absoluteTimeInMillis()),\n+                        Version.CURRENT,\n+                        repository,\n+                        name,\n+                        path,\n+                        content,\n+                        offset\n+                    );\n+                    final IndexRequest request = new IndexRequest(index).id(cachedBlob.generatedId());\n+                    try (XContentBuilder builder = jsonBuilder()) {\n+                        request.source(cachedBlob.toXContent(builder, ToXContent.EMPTY_PARAMS));\n+                    }\n+                    client.index(request, new ActionListener<>() {\n+                        @Override\n+                        public void onResponse(IndexResponse indexResponse) {\n+                            logger.trace(\"cache fill ({}): [{}]\", indexResponse.status(), request.id());\n+                            listener.onResponse(null);\n+                        }\n+\n+                        @Override\n+                        public void onFailure(Exception e) {\n+                            logger.debug(new ParameterizedMessage(\"failure in cache fill: [{}]\", request.id()), e);\n+                            listener.onFailure(e);\n+                        }\n+                    });\n+                } catch (IOException e) {\n+                    logger.warn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzODA3Mw=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjYwODE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTo0Mzo0OVrOHFcywg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoxNjoyM1rOHFjz3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NjY3NA==", "bodyText": "Why is this value 4kb? to match the page cache size?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475476674", "createdAt": "2020-08-24T09:43:49Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5MTY0Ng==", "bodyText": "Nothing so scientific I think, we're trying to balance not putting too much data in the index against not needing to hit the blob store too often when restarting a shard.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r475591646", "createdAt": "2020-08-24T13:16:23Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.NoShardAvailableActionException;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NjY3NA=="}, "originalCommit": {"oid": "cd77a43bce70607c961bbb9fd8e3ce6240da2304"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjY5Njk2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotShardStats.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNzo0MTowOFrOHG_vCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNzo1M1rOHHLnHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5NzczNg==", "bodyText": "Can we update the stats.yml tests with the new fields?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477097736", "createdAt": "2020-08-26T07:41:08Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotShardStats.java", "diffHunk": "@@ -263,6 +302,7 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n                 builder.field(\"contiguous_bytes_read\", getContiguousReads());\n                 builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n                 builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"index_cache_bytes_read\", getIndexCacheBytesRead());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MjMxOQ==", "bodyText": "++ see 2003ec0", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477292319", "createdAt": "2020-08-26T13:17:53Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotShardStats.java", "diffHunk": "@@ -263,6 +302,7 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n                 builder.field(\"contiguous_bytes_read\", getContiguousReads());\n                 builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n                 builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"index_cache_bytes_read\", getIndexCacheBytesRead());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5NzczNg=="}, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjgzMDgzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODoxNjowMlrOHHBAUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNzozM1rOHHLmMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExODU0NQ==", "bodyText": "I think we should catch any exception on this and calls the listener appropriately (ActionListener.wrap() would do this for us)", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477118545", "createdAt": "2020-08-26T08:16:02Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.TransportActions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.node.NodeClosedException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.ConnectTransportException;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+        client.get(request, new ActionListener<>() {\n+            @Override\n+            public void onResponse(GetResponse response) {\n+                if (response.isExists()) {\n+                    logger.debug(\"cache hit : [{}]\", request.id());\n+                    assert response.isSourceEmpty() == false;\n+\n+                    final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                    assert response.getId().equals(cachedBlob.generatedId());\n+                    listener.onResponse(cachedBlob);\n+                } else {\n+                    logger.debug(\"cache miss: [{}]\", request.id());\n+                    listener.onResponse(CachedBlob.CACHE_MISS);\n+                }\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                // In case the blob cache system index is unavailable, we indicate it's not ready and move on. We do not fail the request:\n+                // a failure here is not fatal since the data exists in the blob store, so we can simply indicate the cache is not ready.\n+                if (isExpectedCacheGetException(e)) {\n+                    logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                } else {\n+                    logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                    assert false : e;\n+                }\n+                listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            }\n+        });\n+    }\n+\n+    private static boolean isExpectedCacheGetException(Exception e) {\n+        return TransportActions.isShardNotAvailableException(e)\n+            || e instanceof ConnectTransportException\n+            || ExceptionsHelper.unwrapCause(e) instanceof NodeClosedException;\n+    }\n+\n+    public void putAsync(String repository, String name, String path, long offset, BytesReference content, ActionListener<Void> listener) {\n+        createIndexIfNecessary(new ActionListener<>() {\n+            @Override\n+            public void onResponse(String s) {\n+                final IndexRequest request;\n+                try {\n+                    final CachedBlob cachedBlob = new CachedBlob(\n+                        Instant.ofEpochMilli(threadPool.absoluteTimeInMillis()),\n+                        Version.CURRENT,\n+                        repository,\n+                        name,\n+                        path,\n+                        content,\n+                        offset\n+                    );\n+                    request = new IndexRequest(index).id(cachedBlob.generatedId());\n+                    try (XContentBuilder builder = jsonBuilder()) {\n+                        request.source(cachedBlob.toXContent(builder, ToXContent.EMPTY_PARAMS));\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\n+                        new ParameterizedMessage(\"cache fill failure: [{}]\", CachedBlob.generateId(repository, name, path, offset)),\n+                        e\n+                    );\n+                    listener.onFailure(e);\n+                    return;\n+                }\n+\n+                client.index(request, new ActionListener<>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MjA4MQ==", "bodyText": "++ see 62fe090.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477292081", "createdAt": "2020-08-26T13:17:33Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/blobstore/cache/BlobStoreCacheService.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.ResourceAlreadyExistsException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.TransportActions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.node.NodeClosedException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.ConnectTransportException;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;\n+import static org.elasticsearch.xpack.core.ClientHelper.SEARCHABLE_SNAPSHOTS_ORIGIN;\n+\n+public class BlobStoreCacheService extends AbstractLifecycleComponent implements ClusterStateListener {\n+\n+    private static final Logger logger = LogManager.getLogger(BlobStoreCacheService.class);\n+\n+    public static final int DEFAULT_CACHED_BLOB_SIZE = Math.toIntExact(ByteSizeUnit.KB.toBytes(4L));\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final AtomicBoolean ready;\n+    private final Client client;\n+    private final String index;\n+\n+    public BlobStoreCacheService(ClusterService clusterService, ThreadPool threadPool, Client client, String index) {\n+        this.client = new OriginSettingClient(client, SEARCHABLE_SNAPSHOTS_ORIGIN);\n+        this.ready = new AtomicBoolean(false);\n+        this.clusterService = clusterService;\n+        this.threadPool = threadPool;\n+        this.index = index;\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        clusterService.addListener(this);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        clusterService.removeListener(this);\n+    }\n+\n+    @Override\n+    protected void doClose() {}\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (lifecycle.started() == false || event.routingTableChanged() == false) {\n+            return;\n+        }\n+        if (event.indexRoutingTableChanged(index)) {\n+            final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);\n+            if (indexRoutingTable == null) {\n+                ready.set(false);\n+                return;\n+            }\n+            ready.set(indexRoutingTable.allPrimaryShardsActive());\n+        }\n+    }\n+\n+    private void createIndexIfNecessary(ActionListener<String> listener) {\n+        if (clusterService.state().routingTable().hasIndex(index)) {\n+            listener.onResponse(index);\n+            return;\n+        }\n+        try {\n+            client.admin()\n+                .indices()\n+                .prepareCreate(index)\n+                .setSettings(indexSettings())\n+                .setMapping(mappings())\n+                .execute(new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(CreateIndexResponse createIndexResponse) {\n+                        assert createIndexResponse.index().equals(index);\n+                        listener.onResponse(createIndexResponse.index());\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (e instanceof ResourceAlreadyExistsException\n+                            || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {\n+                            listener.onResponse(index);\n+                        } else {\n+                            listener.onFailure(e);\n+                        }\n+                    }\n+                });\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private static Settings indexSettings() {\n+        return Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n+            .put(IndexMetadata.SETTING_PRIORITY, \"900\")\n+            .build();\n+    }\n+\n+    private static XContentBuilder mappings() throws IOException {\n+        final XContentBuilder builder = jsonBuilder();\n+        {\n+            builder.startObject();\n+            {\n+                builder.startObject(SINGLE_MAPPING_NAME);\n+                builder.field(\"dynamic\", \"strict\");\n+                {\n+                    builder.startObject(\"_meta\");\n+                    builder.field(\"version\", Version.CURRENT);\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"properties\");\n+                    {\n+                        builder.startObject(\"type\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"creation_time\");\n+                        builder.field(\"type\", \"date\");\n+                        builder.field(\"format\", \"epoch_millis\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"version\");\n+                        builder.field(\"type\", \"integer\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"repository\");\n+                        builder.field(\"type\", \"keyword\");\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"blob\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"name\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                                builder.startObject(\"path\");\n+                                builder.field(\"type\", \"keyword\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    {\n+                        builder.startObject(\"data\");\n+                        builder.field(\"type\", \"object\");\n+                        {\n+                            builder.startObject(\"properties\");\n+                            {\n+                                builder.startObject(\"content\");\n+                                builder.field(\"type\", \"binary\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"length\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"from\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            {\n+                                builder.startObject(\"to\");\n+                                builder.field(\"type\", \"long\");\n+                                builder.endObject();\n+                            }\n+                            builder.endObject();\n+                        }\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+                }\n+                builder.endObject();\n+            }\n+            builder.endObject();\n+        }\n+        return builder;\n+    }\n+\n+    public CachedBlob get(String repository, String name, String path, long offset) {\n+        final PlainActionFuture<CachedBlob> future = PlainActionFuture.newFuture();\n+        getAsync(repository, name, path, offset, future);\n+        return future.actionGet();\n+    }\n+\n+    protected void getAsync(String repository, String name, String path, long offset, ActionListener<CachedBlob> listener) {\n+        if ((lifecycle.started() && ready.get()) == false) {\n+            // TODO TBD can we just execute the GET request and let it fail if the index isn't ready yet?\n+            // We might get lucky and hit a started shard anyway.\n+            logger.debug(\"not ready : [{}]\", CachedBlob.generateId(repository, name, path, offset));\n+            listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            return;\n+        }\n+        final GetRequest request = new GetRequest(index).id(CachedBlob.generateId(repository, name, path, offset));\n+        client.get(request, new ActionListener<>() {\n+            @Override\n+            public void onResponse(GetResponse response) {\n+                if (response.isExists()) {\n+                    logger.debug(\"cache hit : [{}]\", request.id());\n+                    assert response.isSourceEmpty() == false;\n+\n+                    final CachedBlob cachedBlob = CachedBlob.fromSource(response.getSource());\n+                    assert response.getId().equals(cachedBlob.generatedId());\n+                    listener.onResponse(cachedBlob);\n+                } else {\n+                    logger.debug(\"cache miss: [{}]\", request.id());\n+                    listener.onResponse(CachedBlob.CACHE_MISS);\n+                }\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                // In case the blob cache system index is unavailable, we indicate it's not ready and move on. We do not fail the request:\n+                // a failure here is not fatal since the data exists in the blob store, so we can simply indicate the cache is not ready.\n+                if (isExpectedCacheGetException(e)) {\n+                    logger.debug(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                } else {\n+                    logger.warn(() -> new ParameterizedMessage(\"failed to retrieve cached blob from system index [{}]\", index), e);\n+                    assert false : e;\n+                }\n+                listener.onResponse(CachedBlob.CACHE_NOT_READY);\n+            }\n+        });\n+    }\n+\n+    private static boolean isExpectedCacheGetException(Exception e) {\n+        return TransportActions.isShardNotAvailableException(e)\n+            || e instanceof ConnectTransportException\n+            || ExceptionsHelper.unwrapCause(e) instanceof NodeClosedException;\n+    }\n+\n+    public void putAsync(String repository, String name, String path, long offset, BytesReference content, ActionListener<Void> listener) {\n+        createIndexIfNecessary(new ActionListener<>() {\n+            @Override\n+            public void onResponse(String s) {\n+                final IndexRequest request;\n+                try {\n+                    final CachedBlob cachedBlob = new CachedBlob(\n+                        Instant.ofEpochMilli(threadPool.absoluteTimeInMillis()),\n+                        Version.CURRENT,\n+                        repository,\n+                        name,\n+                        path,\n+                        content,\n+                        offset\n+                    );\n+                    request = new IndexRequest(index).id(cachedBlob.generatedId());\n+                    try (XContentBuilder builder = jsonBuilder()) {\n+                        request.source(cachedBlob.toXContent(builder, ToXContent.EMPTY_PARAMS));\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\n+                        new ParameterizedMessage(\"cache fill failure: [{}]\", CachedBlob.generateId(repository, name, path, offset)),\n+                        e\n+                    );\n+                    listener.onFailure(e);\n+                    return;\n+                }\n+\n+                client.index(request, new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExODU0NQ=="}, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzAzNDY5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTowNzoyOFrOHHC-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTo1NzoxM1rOHHIpFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1MDc1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content, new ActionListener<>() {\n          \n          \n            \n                                        @Override\n          \n          \n            \n                                        public void onResponse(Void response) {\n          \n          \n            \n                                            onCacheFillComplete.close();\n          \n          \n            \n                                        }\n          \n          \n            \n            \n          \n          \n            \n                                        @Override\n          \n          \n            \n                                        public void onFailure(Exception e1) {\n          \n          \n            \n                                            onCacheFillComplete.close();\n          \n          \n            \n                                        }\n          \n          \n            \n                                    });\n          \n          \n            \n                                    directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content, ActionListener.wrap(onCacheFillComplete::close));", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477150753", "createdAt": "2020-08-26T09:07:28Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,296 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Can we serve the read directly from disk? If so, do so and don't worry about anything else.\n+\n+                final CompletableFuture<Integer> waitingForRead = cacheFile.readIfAvailableOrPending(\n+                    Tuple.tuple(position, position + length),\n+                    channel -> {\n+                        final int read = readCacheFile(channel, position, b);\n+                        assert read == length : read + \" vs \" + length;\n+                        return read;\n+                    }\n+                );\n+\n+                if (waitingForRead != null) {\n+                    final Integer read = waitingForRead.get();\n+                    assert read == length;\n+                    readComplete(position, length);\n+                    return;\n+                }\n+\n+                // Requested data is not on disk, so try the cache index next.\n+\n+                final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+                // We try to use the cache index if:\n+                // - the file is small enough to be fully cached\n+                final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+                // - we're reading the first N bytes of the file\n+                final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+                if (canBeFullyCached || isStartOfFile) {\n+                    final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                    if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                        // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested\n+                        // so we compute the region of the file we would like to have the next time. The region is expressed as a tuple of\n+                        // {start, end} where positions are relative to the whole file.\n+\n+                        if (canBeFullyCached) {\n+                            // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                            indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n                         } else {\n-                            read = readCacheFile(channel, pos, b);\n+                            // the index input is too large to fully cache, so just cache the initial range\n+                            indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n                         }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+\n+                        // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                        // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                    } else {\n+                        logger.trace(\n+                            \"reading [{}] bytes of file [{}] at position [{}] using cache index\",\n+                            length,\n+                            fileInfo.physicalName(),\n+                            position\n+                        );\n+                        stats.addIndexCacheBytesRead(cachedBlob.length());\n+\n+                        final BytesRefIterator cachedBytesIterator = cachedBlob.bytes().slice(Math.toIntExact(position), length).iterator();\n+                        BytesRef bytesRef;\n+                        while ((bytesRef = cachedBytesIterator.next()) != null) {\n+                            b.put(bytesRef.bytes, bytesRef.offset, bytesRef.length);\n+                        }\n+                        assert b.position() == length : \"copied \" + b.position() + \" but expected \" + length;\n+\n+                        try {\n+                            final Tuple<Long, Long> cachedRange = Tuple.tuple(cachedBlob.from(), cachedBlob.to());\n+                            cacheFile.populateAndRead(\n+                                cachedRange,\n+                                cachedRange,\n+                                channel -> cachedBlob.length(),\n+                                (channel, from, to, progressUpdater) -> {\n+                                    final long startTimeNanos = stats.currentTimeNanos();\n+                                    final BytesRefIterator iterator = cachedBlob.bytes()\n+                                        .slice(Math.toIntExact(from - cachedBlob.from()), Math.toIntExact(to - from))\n+                                        .iterator();\n+                                    long writePosition = from;\n+                                    BytesRef current;\n+                                    while ((current = iterator.next()) != null) {\n+                                        final ByteBuffer byteBuffer = ByteBuffer.wrap(current.bytes, current.offset, current.length);\n+                                        while (byteBuffer.remaining() > 0) {\n+                                            writePosition += positionalWrite(channel, writePosition, byteBuffer);\n+                                            progressUpdater.accept(writePosition);\n+                                        }\n+                                    }\n+                                    assert writePosition == to : writePosition + \" vs \" + to;\n+                                    final long endTimeNanos = stats.currentTimeNanos();\n+                                    stats.addCachedBytesWritten(to - from, endTimeNanos - startTimeNanos);\n+                                    logger.trace(\"copied bytes [{}-{}] of file [{}] from cache index to disk\", from, to, fileInfo);\n+                                },\n+                                directory.cacheFetchAsyncExecutor()\n+                            );\n+                        } catch (Exception e) {\n+                            logger.debug(\n+                                new ParameterizedMessage(\n+                                    \"failed to store bytes [{}-{}] of file [{}] obtained from index cache\",\n+                                    cachedBlob.from(),\n+                                    cachedBlob.to(),\n+                                    fileInfo\n+                                ),\n+                                e\n+                            );\n+                            // oh well, no big deal, at least we can return them to the caller.\n+                        }\n+\n+                        readComplete(position, length);\n+\n+                        return;\n+                    }\n+                } else {\n+                    // requested range is not eligible for caching\n+                    indexCacheMiss = null;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Requested data is also not in the cache index, so we must visit the blob store to satisfy both the target range and any\n+                // miss in the cache index.\n+\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMiss == null ? Long.MAX_VALUE : indexCacheMiss.v1()),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMiss == null ? Long.MIN_VALUE : indexCacheMiss.v2())\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n+                    }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                if (indexCacheMiss != null) {\n+                    final Releasable onCacheFillComplete = stats.addIndexCacheFill();\n+                    final CompletableFuture<Integer> readFuture = cacheFile.readIfAvailableOrPending(indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats\n+                        byteBuffer.flip();\n+                        final BytesReference content = BytesReference.fromByteBuffer(byteBuffer);\n+                        directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content, new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void response) {\n+                                onCacheFillComplete.close();\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e1) {\n+                                onCacheFillComplete.close();\n+                            }\n+                        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0MzY3MA==", "bodyText": "ActionListener#wrap is trappy, if onResponse throws then it calls onFailure which is effectively a double-notification. Doesn't really matter here, perhaps, but I'd rather not add another usage that needs thought when it comes time to remove it.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477243670", "createdAt": "2020-08-26T11:57:13Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,296 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Can we serve the read directly from disk? If so, do so and don't worry about anything else.\n+\n+                final CompletableFuture<Integer> waitingForRead = cacheFile.readIfAvailableOrPending(\n+                    Tuple.tuple(position, position + length),\n+                    channel -> {\n+                        final int read = readCacheFile(channel, position, b);\n+                        assert read == length : read + \" vs \" + length;\n+                        return read;\n+                    }\n+                );\n+\n+                if (waitingForRead != null) {\n+                    final Integer read = waitingForRead.get();\n+                    assert read == length;\n+                    readComplete(position, length);\n+                    return;\n+                }\n+\n+                // Requested data is not on disk, so try the cache index next.\n+\n+                final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+                // We try to use the cache index if:\n+                // - the file is small enough to be fully cached\n+                final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+                // - we're reading the first N bytes of the file\n+                final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+                if (canBeFullyCached || isStartOfFile) {\n+                    final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                    if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                        // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested\n+                        // so we compute the region of the file we would like to have the next time. The region is expressed as a tuple of\n+                        // {start, end} where positions are relative to the whole file.\n+\n+                        if (canBeFullyCached) {\n+                            // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                            indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n                         } else {\n-                            read = readCacheFile(channel, pos, b);\n+                            // the index input is too large to fully cache, so just cache the initial range\n+                            indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n                         }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+\n+                        // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                        // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                    } else {\n+                        logger.trace(\n+                            \"reading [{}] bytes of file [{}] at position [{}] using cache index\",\n+                            length,\n+                            fileInfo.physicalName(),\n+                            position\n+                        );\n+                        stats.addIndexCacheBytesRead(cachedBlob.length());\n+\n+                        final BytesRefIterator cachedBytesIterator = cachedBlob.bytes().slice(Math.toIntExact(position), length).iterator();\n+                        BytesRef bytesRef;\n+                        while ((bytesRef = cachedBytesIterator.next()) != null) {\n+                            b.put(bytesRef.bytes, bytesRef.offset, bytesRef.length);\n+                        }\n+                        assert b.position() == length : \"copied \" + b.position() + \" but expected \" + length;\n+\n+                        try {\n+                            final Tuple<Long, Long> cachedRange = Tuple.tuple(cachedBlob.from(), cachedBlob.to());\n+                            cacheFile.populateAndRead(\n+                                cachedRange,\n+                                cachedRange,\n+                                channel -> cachedBlob.length(),\n+                                (channel, from, to, progressUpdater) -> {\n+                                    final long startTimeNanos = stats.currentTimeNanos();\n+                                    final BytesRefIterator iterator = cachedBlob.bytes()\n+                                        .slice(Math.toIntExact(from - cachedBlob.from()), Math.toIntExact(to - from))\n+                                        .iterator();\n+                                    long writePosition = from;\n+                                    BytesRef current;\n+                                    while ((current = iterator.next()) != null) {\n+                                        final ByteBuffer byteBuffer = ByteBuffer.wrap(current.bytes, current.offset, current.length);\n+                                        while (byteBuffer.remaining() > 0) {\n+                                            writePosition += positionalWrite(channel, writePosition, byteBuffer);\n+                                            progressUpdater.accept(writePosition);\n+                                        }\n+                                    }\n+                                    assert writePosition == to : writePosition + \" vs \" + to;\n+                                    final long endTimeNanos = stats.currentTimeNanos();\n+                                    stats.addCachedBytesWritten(to - from, endTimeNanos - startTimeNanos);\n+                                    logger.trace(\"copied bytes [{}-{}] of file [{}] from cache index to disk\", from, to, fileInfo);\n+                                },\n+                                directory.cacheFetchAsyncExecutor()\n+                            );\n+                        } catch (Exception e) {\n+                            logger.debug(\n+                                new ParameterizedMessage(\n+                                    \"failed to store bytes [{}-{}] of file [{}] obtained from index cache\",\n+                                    cachedBlob.from(),\n+                                    cachedBlob.to(),\n+                                    fileInfo\n+                                ),\n+                                e\n+                            );\n+                            // oh well, no big deal, at least we can return them to the caller.\n+                        }\n+\n+                        readComplete(position, length);\n+\n+                        return;\n+                    }\n+                } else {\n+                    // requested range is not eligible for caching\n+                    indexCacheMiss = null;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Requested data is also not in the cache index, so we must visit the blob store to satisfy both the target range and any\n+                // miss in the cache index.\n+\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMiss == null ? Long.MAX_VALUE : indexCacheMiss.v1()),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMiss == null ? Long.MIN_VALUE : indexCacheMiss.v2())\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n+                    }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                if (indexCacheMiss != null) {\n+                    final Releasable onCacheFillComplete = stats.addIndexCacheFill();\n+                    final CompletableFuture<Integer> readFuture = cacheFile.readIfAvailableOrPending(indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats\n+                        byteBuffer.flip();\n+                        final BytesReference content = BytesReference.fromByteBuffer(byteBuffer);\n+                        directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content, new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void response) {\n+                                onCacheFillComplete.close();\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e1) {\n+                                onCacheFillComplete.close();\n+                            }\n+                        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1MDc1Mw=="}, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzA0MzE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTowOTo1MFrOHHDDWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjowMDo1MVrOHHIwrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1MjA5MQ==", "bodyText": "Would it be possible to check that readFuture is effectively done in case of indexCacheMiss not null?", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477152091", "createdAt": "2020-08-26T09:09:50Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,296 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Can we serve the read directly from disk? If so, do so and don't worry about anything else.\n+\n+                final CompletableFuture<Integer> waitingForRead = cacheFile.readIfAvailableOrPending(\n+                    Tuple.tuple(position, position + length),\n+                    channel -> {\n+                        final int read = readCacheFile(channel, position, b);\n+                        assert read == length : read + \" vs \" + length;\n+                        return read;\n+                    }\n+                );\n+\n+                if (waitingForRead != null) {\n+                    final Integer read = waitingForRead.get();\n+                    assert read == length;\n+                    readComplete(position, length);\n+                    return;\n+                }\n+\n+                // Requested data is not on disk, so try the cache index next.\n+\n+                final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+                // We try to use the cache index if:\n+                // - the file is small enough to be fully cached\n+                final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+                // - we're reading the first N bytes of the file\n+                final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+                if (canBeFullyCached || isStartOfFile) {\n+                    final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                    if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                        // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested\n+                        // so we compute the region of the file we would like to have the next time. The region is expressed as a tuple of\n+                        // {start, end} where positions are relative to the whole file.\n+\n+                        if (canBeFullyCached) {\n+                            // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                            indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n                         } else {\n-                            read = readCacheFile(channel, pos, b);\n+                            // the index input is too large to fully cache, so just cache the initial range\n+                            indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n                         }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+\n+                        // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                        // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                    } else {\n+                        logger.trace(\n+                            \"reading [{}] bytes of file [{}] at position [{}] using cache index\",\n+                            length,\n+                            fileInfo.physicalName(),\n+                            position\n+                        );\n+                        stats.addIndexCacheBytesRead(cachedBlob.length());\n+\n+                        final BytesRefIterator cachedBytesIterator = cachedBlob.bytes().slice(Math.toIntExact(position), length).iterator();\n+                        BytesRef bytesRef;\n+                        while ((bytesRef = cachedBytesIterator.next()) != null) {\n+                            b.put(bytesRef.bytes, bytesRef.offset, bytesRef.length);\n+                        }\n+                        assert b.position() == length : \"copied \" + b.position() + \" but expected \" + length;\n+\n+                        try {\n+                            final Tuple<Long, Long> cachedRange = Tuple.tuple(cachedBlob.from(), cachedBlob.to());\n+                            cacheFile.populateAndRead(\n+                                cachedRange,\n+                                cachedRange,\n+                                channel -> cachedBlob.length(),\n+                                (channel, from, to, progressUpdater) -> {\n+                                    final long startTimeNanos = stats.currentTimeNanos();\n+                                    final BytesRefIterator iterator = cachedBlob.bytes()\n+                                        .slice(Math.toIntExact(from - cachedBlob.from()), Math.toIntExact(to - from))\n+                                        .iterator();\n+                                    long writePosition = from;\n+                                    BytesRef current;\n+                                    while ((current = iterator.next()) != null) {\n+                                        final ByteBuffer byteBuffer = ByteBuffer.wrap(current.bytes, current.offset, current.length);\n+                                        while (byteBuffer.remaining() > 0) {\n+                                            writePosition += positionalWrite(channel, writePosition, byteBuffer);\n+                                            progressUpdater.accept(writePosition);\n+                                        }\n+                                    }\n+                                    assert writePosition == to : writePosition + \" vs \" + to;\n+                                    final long endTimeNanos = stats.currentTimeNanos();\n+                                    stats.addCachedBytesWritten(to - from, endTimeNanos - startTimeNanos);\n+                                    logger.trace(\"copied bytes [{}-{}] of file [{}] from cache index to disk\", from, to, fileInfo);\n+                                },\n+                                directory.cacheFetchAsyncExecutor()\n+                            );\n+                        } catch (Exception e) {\n+                            logger.debug(\n+                                new ParameterizedMessage(\n+                                    \"failed to store bytes [{}-{}] of file [{}] obtained from index cache\",\n+                                    cachedBlob.from(),\n+                                    cachedBlob.to(),\n+                                    fileInfo\n+                                ),\n+                                e\n+                            );\n+                            // oh well, no big deal, at least we can return them to the caller.\n+                        }\n+\n+                        readComplete(position, length);\n+\n+                        return;\n+                    }\n+                } else {\n+                    // requested range is not eligible for caching\n+                    indexCacheMiss = null;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Requested data is also not in the cache index, so we must visit the blob store to satisfy both the target range and any\n+                // miss in the cache index.\n+\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMiss == null ? Long.MAX_VALUE : indexCacheMiss.v1()),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMiss == null ? Long.MIN_VALUE : indexCacheMiss.v2())\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n+                    }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                if (indexCacheMiss != null) {\n+                    final Releasable onCacheFillComplete = stats.addIndexCacheFill();\n+                    final CompletableFuture<Integer> readFuture = cacheFile.readIfAvailableOrPending(indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats\n+                        byteBuffer.flip();\n+                        final BytesReference content = BytesReference.fromByteBuffer(byteBuffer);\n+                        directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content, new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void response) {\n+                                onCacheFillComplete.close();\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e1) {\n+                                onCacheFillComplete.close();\n+                            }\n+                        });\n+                        return indexCacheMissLength;\n+                    });\n+\n+                    if (readFuture == null) {\n+                        // Normally doesn't happen, we're already obtaining a range covering all cache misses above, but theoretically\n+                        // possible in the case that the real populateAndRead call already failed to obtain this range of the file. In that\n+                        // case, simply move on.\n+                        onCacheFillComplete.close();\n                     }\n                 }\n-                throw new IOException(\"Fail to read data from cache\", e);\n \n-            } finally {\n-                totalBytesRead += bytesRead;\n+                final int bytesRead = populateCacheFuture.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0NTYxMg==", "bodyText": "It is possible but I don't think it's needed. It gets completed by whoever filled in the last piece of the range needed for the cache index, so is still protected from eviction, but it's completed before the call to directory.putCachedBlob returns. If it's completed exceptionally then we don't really care.", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477245612", "createdAt": "2020-08-26T12:00:51Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -136,53 +148,296 @@ protected void readInternal(ByteBuffer b) throws IOException {\n         final long position = getFilePointer() + this.offset;\n         final int length = b.remaining();\n \n-        int totalBytesRead = 0;\n-        while (totalBytesRead < length) {\n-            final long pos = position + totalBytesRead;\n-            final int len = length - totalBytesRead;\n-            int bytesRead = 0;\n-            try {\n-                final CacheFile cacheFile = getCacheFileSafe();\n-                try (Releasable ignored = cacheFile.fileLock()) {\n-                    final Tuple<Long, Long> rangeToWrite = computeRange(pos);\n-                    final Tuple<Long, Long> rangeToRead = Tuple.tuple(pos, Math.min(pos + len, rangeToWrite.v2()));\n-\n-                    bytesRead = cacheFile.fetchAsync(rangeToWrite, rangeToRead, (channel) -> {\n-                        final int read;\n-                        if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n-                            final ByteBuffer duplicate = b.duplicate();\n-                            duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n-                            read = readCacheFile(channel, pos, duplicate);\n-                            assert duplicate.position() <= b.limit();\n-                            b.position(duplicate.position());\n+        // We can detect that we're going to read the last 16 bytes (that contains the footer checksum) of the file. Such reads are often\n+        // executed when opening a Directory and since we have the checksum in the snapshot metadata we can use it to fill the ByteBuffer.\n+        if (length == CodecUtil.footerLength() && isClone == false && position == fileInfo.length() - length) {\n+            if (readChecksumFromFileInfo(b)) {\n+                logger.trace(\"read footer of file [{}] at position [{}], bypassing all caches\", fileInfo.physicalName(), position);\n+                return;\n+            }\n+            assert b.remaining() == length;\n+        }\n+\n+        logger.trace(\"readInternal: read [{}-{}] ([{}] bytes) from [{}]\", position, position + length, length, this);\n+\n+        try {\n+            final CacheFile cacheFile = getCacheFileSafe();\n+            try (Releasable ignored = cacheFile.fileLock()) {\n+\n+                // Can we serve the read directly from disk? If so, do so and don't worry about anything else.\n+\n+                final CompletableFuture<Integer> waitingForRead = cacheFile.readIfAvailableOrPending(\n+                    Tuple.tuple(position, position + length),\n+                    channel -> {\n+                        final int read = readCacheFile(channel, position, b);\n+                        assert read == length : read + \" vs \" + length;\n+                        return read;\n+                    }\n+                );\n+\n+                if (waitingForRead != null) {\n+                    final Integer read = waitingForRead.get();\n+                    assert read == length;\n+                    readComplete(position, length);\n+                    return;\n+                }\n+\n+                // Requested data is not on disk, so try the cache index next.\n+\n+                final Tuple<Long, Long> indexCacheMiss; // null if not a miss\n+\n+                // We try to use the cache index if:\n+                // - the file is small enough to be fully cached\n+                final boolean canBeFullyCached = fileInfo.length() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2;\n+                // - we're reading the first N bytes of the file\n+                final boolean isStartOfFile = (position + length <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n+\n+                if (canBeFullyCached || isStartOfFile) {\n+                    final CachedBlob cachedBlob = directory.getCachedBlob(fileInfo.physicalName(), 0L, length);\n+\n+                    if (cachedBlob == CachedBlob.CACHE_MISS || cachedBlob == CachedBlob.CACHE_NOT_READY) {\n+                        // We would have liked to find a cached entry but we did not find anything: the cache on the disk will be requested\n+                        // so we compute the region of the file we would like to have the next time. The region is expressed as a tuple of\n+                        // {start, end} where positions are relative to the whole file.\n+\n+                        if (canBeFullyCached) {\n+                            // if the index input is smaller than twice the size of the blob cache, it will be fully indexed\n+                            indexCacheMiss = Tuple.tuple(0L, fileInfo.length());\n                         } else {\n-                            read = readCacheFile(channel, pos, b);\n+                            // the index input is too large to fully cache, so just cache the initial range\n+                            indexCacheMiss = Tuple.tuple(0L, (long) BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE);\n                         }\n-                        return read;\n-                    }, this::writeCacheFile, directory.cacheFetchAsyncExecutor()).get();\n+\n+                        // We must fill in a cache miss even if CACHE_NOT_READY since the cache index is only created on the first put.\n+                        // TODO TBD use a different trigger for creating the cache index and avoid a put in the CACHE_NOT_READY case.\n+                    } else {\n+                        logger.trace(\n+                            \"reading [{}] bytes of file [{}] at position [{}] using cache index\",\n+                            length,\n+                            fileInfo.physicalName(),\n+                            position\n+                        );\n+                        stats.addIndexCacheBytesRead(cachedBlob.length());\n+\n+                        final BytesRefIterator cachedBytesIterator = cachedBlob.bytes().slice(Math.toIntExact(position), length).iterator();\n+                        BytesRef bytesRef;\n+                        while ((bytesRef = cachedBytesIterator.next()) != null) {\n+                            b.put(bytesRef.bytes, bytesRef.offset, bytesRef.length);\n+                        }\n+                        assert b.position() == length : \"copied \" + b.position() + \" but expected \" + length;\n+\n+                        try {\n+                            final Tuple<Long, Long> cachedRange = Tuple.tuple(cachedBlob.from(), cachedBlob.to());\n+                            cacheFile.populateAndRead(\n+                                cachedRange,\n+                                cachedRange,\n+                                channel -> cachedBlob.length(),\n+                                (channel, from, to, progressUpdater) -> {\n+                                    final long startTimeNanos = stats.currentTimeNanos();\n+                                    final BytesRefIterator iterator = cachedBlob.bytes()\n+                                        .slice(Math.toIntExact(from - cachedBlob.from()), Math.toIntExact(to - from))\n+                                        .iterator();\n+                                    long writePosition = from;\n+                                    BytesRef current;\n+                                    while ((current = iterator.next()) != null) {\n+                                        final ByteBuffer byteBuffer = ByteBuffer.wrap(current.bytes, current.offset, current.length);\n+                                        while (byteBuffer.remaining() > 0) {\n+                                            writePosition += positionalWrite(channel, writePosition, byteBuffer);\n+                                            progressUpdater.accept(writePosition);\n+                                        }\n+                                    }\n+                                    assert writePosition == to : writePosition + \" vs \" + to;\n+                                    final long endTimeNanos = stats.currentTimeNanos();\n+                                    stats.addCachedBytesWritten(to - from, endTimeNanos - startTimeNanos);\n+                                    logger.trace(\"copied bytes [{}-{}] of file [{}] from cache index to disk\", from, to, fileInfo);\n+                                },\n+                                directory.cacheFetchAsyncExecutor()\n+                            );\n+                        } catch (Exception e) {\n+                            logger.debug(\n+                                new ParameterizedMessage(\n+                                    \"failed to store bytes [{}-{}] of file [{}] obtained from index cache\",\n+                                    cachedBlob.from(),\n+                                    cachedBlob.to(),\n+                                    fileInfo\n+                                ),\n+                                e\n+                            );\n+                            // oh well, no big deal, at least we can return them to the caller.\n+                        }\n+\n+                        readComplete(position, length);\n+\n+                        return;\n+                    }\n+                } else {\n+                    // requested range is not eligible for caching\n+                    indexCacheMiss = null;\n                 }\n-            } catch (final Exception e) {\n-                if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n-                    try {\n-                        // cache file was evicted during the range fetching, read bytes directly from source\n-                        bytesRead = readDirectly(pos, pos + len, b);\n-                        continue;\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n+\n+                // Requested data is also not in the cache index, so we must visit the blob store to satisfy both the target range and any\n+                // miss in the cache index.\n+\n+                final Tuple<Long, Long> startRangeToWrite = computeRange(position);\n+                final Tuple<Long, Long> endRangeToWrite = computeRange(position + length - 1);\n+                assert startRangeToWrite.v2() <= endRangeToWrite.v2() : startRangeToWrite + \" vs \" + endRangeToWrite;\n+                final Tuple<Long, Long> rangeToWrite = Tuple.tuple(\n+                    Math.min(startRangeToWrite.v1(), indexCacheMiss == null ? Long.MAX_VALUE : indexCacheMiss.v1()),\n+                    Math.max(endRangeToWrite.v2(), indexCacheMiss == null ? Long.MIN_VALUE : indexCacheMiss.v2())\n+                );\n+\n+                assert rangeToWrite.v1() <= position && position + length <= rangeToWrite.v2() : \"[\"\n+                    + position\n+                    + \"-\"\n+                    + (position + length)\n+                    + \"] vs \"\n+                    + rangeToWrite;\n+                final Tuple<Long, Long> rangeToRead = Tuple.tuple(position, position + length);\n+\n+                final CompletableFuture<Integer> populateCacheFuture = cacheFile.populateAndRead(rangeToWrite, rangeToRead, channel -> {\n+                    final int read;\n+                    if ((rangeToRead.v2() - rangeToRead.v1()) < b.remaining()) {\n+                        final ByteBuffer duplicate = b.duplicate();\n+                        duplicate.limit(duplicate.position() + Math.toIntExact(rangeToRead.v2() - rangeToRead.v1()));\n+                        read = readCacheFile(channel, position, duplicate);\n+                        assert duplicate.position() <= b.limit();\n+                        b.position(duplicate.position());\n+                    } else {\n+                        read = readCacheFile(channel, position, b);\n+                    }\n+                    return read;\n+                }, this::writeCacheFile, directory.cacheFetchAsyncExecutor());\n+\n+                if (indexCacheMiss != null) {\n+                    final Releasable onCacheFillComplete = stats.addIndexCacheFill();\n+                    final CompletableFuture<Integer> readFuture = cacheFile.readIfAvailableOrPending(indexCacheMiss, channel -> {\n+                        final int indexCacheMissLength = Math.toIntExact(indexCacheMiss.v2() - indexCacheMiss.v1());\n+\n+                        // We assume that we only cache small portions of blobs so that we do not need to:\n+                        // - use a BigArrays for allocation\n+                        // - use an intermediate copy buffer to read the file in sensibly-sized chunks\n+                        // - release the buffer once the indexing operation is complete\n+                        assert indexCacheMissLength <= COPY_BUFFER_SIZE : indexCacheMiss;\n+\n+                        final ByteBuffer byteBuffer = ByteBuffer.allocate(indexCacheMissLength);\n+                        Channels.readFromFileChannelWithEofException(channel, indexCacheMiss.v1(), byteBuffer);\n+                        // NB use Channels.readFromFileChannelWithEofException not readCacheFile() to avoid counting this in the stats\n+                        byteBuffer.flip();\n+                        final BytesReference content = BytesReference.fromByteBuffer(byteBuffer);\n+                        directory.putCachedBlob(fileInfo.physicalName(), indexCacheMiss.v1(), content, new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void response) {\n+                                onCacheFillComplete.close();\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e1) {\n+                                onCacheFillComplete.close();\n+                            }\n+                        });\n+                        return indexCacheMissLength;\n+                    });\n+\n+                    if (readFuture == null) {\n+                        // Normally doesn't happen, we're already obtaining a range covering all cache misses above, but theoretically\n+                        // possible in the case that the real populateAndRead call already failed to obtain this range of the file. In that\n+                        // case, simply move on.\n+                        onCacheFillComplete.close();\n                     }\n                 }\n-                throw new IOException(\"Fail to read data from cache\", e);\n \n-            } finally {\n-                totalBytesRead += bytesRead;\n+                final int bytesRead = populateCacheFuture.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1MjA5MQ=="}, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzIwNjU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTo0OTozNVrOHHEoWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTo0OTozNVrOHHEoWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3Nzk0NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477177945", "createdAt": "2020-08-26T09:49:35Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzIyMTI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTo1MzoyN1rOHHExUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwOTo1MzoyN1rOHHExUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4MDI0Mg==", "bodyText": "nit: duplicate", "url": "https://github.com/elastic/elasticsearch/pull/60522#discussion_r477180242", "createdAt": "2020-08-26T09:53:27Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/blobstore/cache/SearchableSnapshotsBlobStoreCacheIntegTests.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.blobstore.cache;\n+\n+import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeResponse;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.Streams;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.plugins.ClusterPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotShardStats;\n+import org.elasticsearch.xpack.searchablesnapshots.BaseSearchableSnapshotsIntegTestCase;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.SearchableSnapshotsStatsRequest;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheService;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.repositories.blobstore.BlobStoreRepository.INDEX_SHARD_SNAPSHOT_FORMAT;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotsConstants.SNAPSHOT_BLOB_CACHE_INDEX;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnapshotsBlobStoreCacheIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        final List<Class<? extends Plugin>> plugins = new ArrayList<>();\n+        plugins.add(WaitForSnapshotBlobCacheShardsActivePlugin.class);\n+        plugins.addAll(super.nodePlugins());\n+        return List.copyOf(plugins);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(\n+                CacheService.SNAPSHOT_CACHE_RANGE_SIZE_SETTING.getKey(),\n+                randomLongBetween(new ByteSizeValue(4, ByteSizeUnit.KB).getBytes(), new ByteSizeValue(20, ByteSizeUnit.KB).getBytes()) + \"b\"\n+            )\n+            .put(CacheService.SNAPSHOT_CACHE_SIZE_SETTING.getKey(), new ByteSizeValue(Long.MAX_VALUE, ByteSizeUnit.BYTES))\n+            .build();\n+    }\n+\n+    public void testBlobStoreCache() throws Exception {\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        createIndex(indexName);\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = scaledRandomIntBetween(0, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"text\", randomUnicodeOfLength(10), \"num\", i));\n+        }\n+        indexRandom(true, false, true, indexRequestBuilders);\n+        final long numberOfDocs = indexRequestBuilders.size();\n+        final NumShards numberOfShards = getNumShards(indexName);\n+\n+        if (randomBoolean()) {\n+            logger.info(\"--> force-merging index before snapshotting\");\n+            final ForceMergeResponse forceMergeResponse = client().admin()\n+                .indices()\n+                .prepareForceMerge(indexName)\n+                .setMaxNumSegments(1)\n+                .get();\n+            assertThat(forceMergeResponse.getSuccessfulShards(), equalTo(numberOfShards.totalNumShards));\n+            assertThat(forceMergeResponse.getFailedShards(), equalTo(0));\n+        }\n+\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Path repositoryLocation = randomRepoPath();\n+        createFsRepository(repositoryName, repositoryLocation);\n+\n+        final SnapshotId snapshot = createSnapshot(repositoryName, List.of(indexName));\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        // extract the list of blobs per shard from the snapshot directory on disk\n+        final Map<String, BlobStoreIndexShardSnapshot> blobsInSnapshot = blobsInSnapshot(repositoryLocation, snapshot.getUUID());\n+        assertThat(\"Failed to load all shard snapshot metadata files\", blobsInSnapshot.size(), equalTo(numberOfShards.numPrimaries));\n+\n+        expectThrows(\n+            IndexNotFoundException.class,\n+            \".snapshot-blob-cache system index should not be created yet\",\n+            () -> systemClient().admin().indices().prepareGetIndex().addIndices(SNAPSHOT_BLOB_CACHE_INDEX).get()\n+        );\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the first time\", snapshot);\n+        final String restoredIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredIndex);\n+\n+        // wait for all async cache fills to complete\n+        assertBusy(() -> {\n+            for (final SearchableSnapshotShardStats shardStats : client().execute(\n+                SearchableSnapshotsStatsAction.INSTANCE,\n+                new SearchableSnapshotsStatsRequest()\n+            ).actionGet().getStats()) {\n+                for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getCurrentIndexCacheFills(), equalTo(0L));\n+                }\n+            }\n+        });\n+\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), greaterThan(0L));\n+            }\n+        }\n+\n+        logger.info(\"--> verifying cached documents in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        final long numberOfCachedBlobs = systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).get().getHits().getTotalHits().value;\n+        final long numberOfCacheWrites = systemClient().admin()\n+            .indices()\n+            .prepareStats(SNAPSHOT_BLOB_CACHE_INDEX)\n+            .clear()\n+            .setIndexing(true)\n+            .get()\n+            .getTotal().indexing.getTotal().getIndexCount();\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredIndex);\n+        assertHitCount(client().prepareSearch(restoredIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        assertAcked(client().admin().indices().prepareDelete(restoredIndex));\n+\n+        logger.info(\"--> mount snapshot [{}] as an index for the second time\", snapshot);\n+        final String restoredAgainIndex = mountSnapshot(\n+            repositoryName,\n+            snapshot.getName(),\n+            indexName,\n+            Settings.builder()\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), true)\n+                .put(SearchableSnapshots.SNAPSHOT_CACHE_PREWARM_ENABLED_SETTING.getKey(), false)\n+                .build()\n+        );\n+        ensureGreen(restoredAgainIndex);\n+\n+        logger.info(\"--> verifying shards of [{}] were started without using the blob store more than necessary\", restoredAgainIndex);\n+        for (final SearchableSnapshotShardStats shardStats : client().execute(\n+            SearchableSnapshotsStatsAction.INSTANCE,\n+            new SearchableSnapshotsStatsRequest()\n+        ).actionGet().getStats()) {\n+            for (final SearchableSnapshotShardStats.CacheIndexInputStats indexInputStats : shardStats.getStats()) {\n+                final boolean mayReadMoreThanHeader\n+                // we read the header of each file contained within the .cfs file, which could be anywhere\n+                    = indexInputStats.getFileName().endsWith(\".cfs\")\n+                        // we read a couple of longs at the end of the .fdt file (see https://issues.apache.org/jira/browse/LUCENE-9456)\n+                        // TODO revisit this when this issue is addressed in Lucene\n+                        || indexInputStats.getFileName().endsWith(\".fdt\");\n+                if (indexInputStats.getFileLength() <= BlobStoreCacheService.DEFAULT_CACHED_BLOB_SIZE * 2\n+                    || mayReadMoreThanHeader == false) {\n+                    assertThat(Strings.toString(indexInputStats), indexInputStats.getBlobStoreBytesRequested().getCount(), equalTo(0L));\n+                }\n+            }\n+        }\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").lte(numberOfDocs))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            numberOfDocs\n+        );\n+        assertHitCount(\n+            client().prepareSearch(restoredAgainIndex)\n+                .setQuery(QueryBuilders.rangeQuery(\"num\").gt(numberOfDocs + 1))\n+                .setSize(0)\n+                .setTrackTotalHits(true)\n+                .get(),\n+            0L\n+        );\n+\n+        logger.info(\"--> verifying cached documents (again) in system index [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        assertCachedBlobsInSystemIndex(repositoryName, blobsInSnapshot);\n+\n+        logger.info(\"--> verifying that no extra cached blobs were indexed [{}]\", SNAPSHOT_BLOB_CACHE_INDEX);\n+        refreshSystemIndex();\n+        assertHitCount(systemClient().prepareSearch(SNAPSHOT_BLOB_CACHE_INDEX).setSize(0).get(), numberOfCachedBlobs);\n+        assertThat(\n+            systemClient().admin().indices().prepareStats(SNAPSHOT_BLOB_CACHE_INDEX).clear().setIndexing(true).get().getTotal().indexing\n+                .getTotal()\n+                .getIndexCount(),\n+            equalTo(numberOfCacheWrites)\n+        );\n+\n+        logger.info(\"--> restarting cluster\");\n+        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                return Settings.builder()\n+                    .put(super.onNodeStopped(nodeName))\n+                    .put(WaitForSnapshotBlobCacheShardsActivePlugin.ENABLED.getKey(), true)\n+                    .build();\n+            }\n+        });\n+        ensureGreen(restoredAgainIndex);\n+\n+        logger.info(\"--> verifying documents in index [{}]\", restoredAgainIndex);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);\n+        assertHitCount(client().prepareSearch(restoredAgainIndex).setSize(0).setTrackTotalHits(true).get(), numberOfDocs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790bdc10bc4090c4bf41510057cda0e9b6fffc9d"}, "originalPosition": 276}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2684, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}