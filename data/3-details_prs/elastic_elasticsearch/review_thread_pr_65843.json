{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxOTgyNDAx", "number": 65843, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxMzoxOFrOFAs6SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo0OTozNVrOFAw4Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjgwMTM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxMzoxOFrOH_HptA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozNDo0N1rOH_Ig3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA==", "bodyText": "Are you sure that buildResponse() is the expensive bit? That's not where the serialisation happens, it's just reorganising some maps a bit.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535947700", "createdAt": "2020-12-04T09:13:18Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                ActionRunnable.supply(listener, () -> buildResponse(request, currentState)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1ODg0MA==", "bodyText": "It's not but the thread that resolves the listener is also the thread that will do the serialization in the TCP transport (OutboundHandler). I could obviously just resolve the listener on the management thread for that reason, but if I already fork-off then I might as well fork off as much work as I can?", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535958840", "createdAt": "2020-12-04T09:30:27Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                ActionRunnable.supply(listener, () -> buildResponse(request, currentState)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA=="}, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTgyMw==", "bodyText": "Right, sorry, I lost track.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535961823", "createdAt": "2020-12-04T09:34:47Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                ActionRunnable.supply(listener, () -> buildResponse(request, currentState)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NzcwMA=="}, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjgxMjM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxNTo1NVrOH_HwQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTozNDozMFrOH_IgMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA==", "bodyText": "If we build a response not on a transport thread, we still serialise it on the transport thread right? If it's just the outbound serialization bit that's slow, how is it logged? AIUI today we only log slowness when processing an inbound request.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535949378", "createdAt": "2020-12-04T09:15:55Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1OTI5OA==", "bodyText": "If we build a response not on a transport thread, we still serialise it on the transport thread right?\n\nNah not anymore, we reverted that change. Once again serialization happens on the thread that resolves the listener in the transport action.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535959298", "createdAt": "2020-12-04T09:31:07Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA=="}, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTY0OA==", "bodyText": "Oh yeah, sorry, I lost track. This is ok then, at least until we reinstate that change.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535961648", "createdAt": "2020-12-04T09:34:30Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java", "diffHunk": "@@ -115,6 +116,13 @@ public void onTimeout(TimeValue timeout) {\n         }\n     }\n \n+    // The cluster state can be a large object so we resolve the response listener on the MANAGEMENT pool to not serialize the resulting\n+    // large response on a transport or cluster state thread which we don't want to block needlessly\n+    private void resolveListener(ClusterStateRequest request, ClusterState currentState, ActionListener<ClusterStateResponse> listener) {\n+        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0OTM3OA=="}, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjgxNjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxNjo1M1rOH_HywA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToxNjo1M1rOH_HywA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1MDAxNg==", "bodyText": "Nice \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r535950016", "createdAt": "2020-12-04T09:16:53Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0ea978a519531400b8df96c75fa21e91ed9761"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzI4NjY3OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/state/ClusterStateApiTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowNjowOFrOH_MC7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTowNjowOFrOH_MC7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxOTY5Mg==", "bodyText": "I kept this test cleanup even though it's not necessary now with the transport action changes reverted because busy asserting on futures was just weird ...", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536019692", "createdAt": "2020-12-04T11:06:08Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/state/ClusterStateApiTests.java", "diffHunk": "@@ -52,10 +53,7 @@ public void testWaitForMetadataVersion() throws Exception {\n         updateSettingsRequest.transientSettings(Settings.builder().put(\"cluster.max_shards_per_node\", 999));\n         assertAcked(client().admin().cluster().updateSettings(updateSettingsRequest).actionGet());\n \n-        assertBusy(() -> {\n-            assertThat(future2.isDone(), is(true));\n-        });\n-        ClusterStateResponse response = future2.actionGet();\n+        response = future2.get(10L, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzQ1MTE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo0OTozNVrOH_Nfog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo1NDo1NFrOH_Nq2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0MzQyNg==", "bodyText": "Seems a bit weird to create the listener just to immediately complete it. Why not inline this?", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536043426", "createdAt": "2020-12-04T11:49:35Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");\n+                                        }\n+                                        builder.startObject();\n+                                        if (clusterStateRequest.waitForMetadataVersion() != null) {\n+                                            builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n+                                        }\n+                                        builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n+                                        ToXContent.Params params = new ToXContent.DelegatingMapParams(\n+                                                singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n+                                        response.getState().toXContent(builder, params);\n+                                        builder.endObject();\n+                                        return new BytesRestResponse(RestStatus.OK, builder);\n+                                    }\n+                                }.onResponse(response)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NjI5OA==", "bodyText": "Did the same for the mappings, so I didn't have to duplicate the logic in RestBuilderListener but now that we have two spots that follow this pattern I think we can refactor this in a follow-up and extract the logic for writing out the response somewhere so we don't have to do this.", "url": "https://github.com/elastic/elasticsearch/pull/65843#discussion_r536046298", "createdAt": "2020-12-04T11:54:54Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestClusterStateAction.java", "diffHunk": "@@ -107,20 +114,36 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         }\n         settingsFilter.addFilterSettingParams(request);\n \n-        return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {\n-                builder.startObject();\n-                if (clusterStateRequest.waitForMetadataVersion() != null) {\n-                    builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n-                }\n-                builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n-                ToXContent.Params params = new ToXContent.DelegatingMapParams(\n-                    singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n-                response.getState().toXContent(builder, params);\n-                builder.endObject();\n-                return new BytesRestResponse(RestStatus.OK, builder);\n-            }\n+        return channel -> client.admin().cluster().state(clusterStateRequest, new RestActionListener<>(channel) {\n+\n+                    @Override\n+                    protected void processResponse(ClusterStateResponse response) {\n+                        final long startTimeMs = threadPool.relativeTimeInMillis();\n+                        // Process serialization on MANAGEMENT pool since the serialization of the cluster state to XContent\n+                        // can be too slow to execute on an IO thread\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(\n+                                ActionRunnable.wrap(this, l -> new RestBuilderListener<ClusterStateResponse>(channel) {\n+                                    @Override\n+                                    public RestResponse buildResponse(final ClusterStateResponse response,\n+                                                                      final XContentBuilder builder) throws Exception {\n+                                        if (clusterStateRequest.local() == false &&\n+                                                threadPool.relativeTimeInMillis() - startTimeMs >\n+                                                        clusterStateRequest.masterNodeTimeout().millis()) {\n+                                            throw new ElasticsearchTimeoutException(\"Timed out getting cluster state\");\n+                                        }\n+                                        builder.startObject();\n+                                        if (clusterStateRequest.waitForMetadataVersion() != null) {\n+                                            builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut());\n+                                        }\n+                                        builder.field(Fields.CLUSTER_NAME, response.getClusterName().value());\n+                                        ToXContent.Params params = new ToXContent.DelegatingMapParams(\n+                                                singletonMap(Metadata.CONTEXT_MODE_PARAM, Metadata.CONTEXT_MODE_API), request);\n+                                        response.getState().toXContent(builder, params);\n+                                        builder.endObject();\n+                                        return new BytesRestResponse(RestStatus.OK, builder);\n+                                    }\n+                                }.onResponse(response)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0MzQyNg=="}, "originalCommit": {"oid": "02b7fb649528f6707a4e33b98a239e8786a8b3e9"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1849, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}