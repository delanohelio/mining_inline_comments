{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MDQ4ODUx", "number": 62469, "title": "EQL: Fetch sequence documents using Point-In-Time", "bodyText": "To preserve the PIT semantics, the retrieval of results has moved from\nusing multi-get to using an idsQuery.", "createdAt": "2020-09-16T14:55:26Z", "url": "https://github.com/elastic/elasticsearch/pull/62469", "merged": true, "mergeCommit": {"oid": "1c2362fcf2be62ce568b3772924abce7331ef23c"}, "closed": true, "closedAt": "2020-09-16T17:01:17Z", "author": {"login": "costin"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJdf-2AH2gAyNDg4MDQ4ODUxOjRkM2MyYTcwMjc1ODcyYjE1NjBmY2ZhZmUwMjNjNzdiZWExNWRhYWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJeiEVgFqTQ4OTc3Mjc5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d3c2a70275872b1560fcfafe023c77bea15daae", "committedDate": "2020-09-16T14:44:44Z", "message": "EQL: Fetch sequence documents using Point-In-Time\n\nTo preserve the PIT semantics, the retrieval of results has moved from\nusing multi-get to using an idsQuery."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NzI0MzE4", "url": "https://github.com/elastic/elasticsearch/pull/62469#pullrequestreview-489724318", "createdAt": "2020-09-16T15:06:16Z", "commit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTowNjoxNlrOHS1a8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNToxMToyNFrOHS1pzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMTY2Ng==", "bodyText": "is the innerListSize updated correctly? From what I understand it's the last one from the for loop.", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489511666", "createdAt": "2020-09-16T15:06:16Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNDIwMw==", "bodyText": "Is the ref.id() unique across indices? Is there a possibility to fetch more than one document residing in different indices?", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489514203", "createdAt": "2020-09-16T15:09:44Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNTQ3MQ==", "bodyText": "Is it possible to use some other key for the HashMap to avoid the creation of HitReference objects?", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489515471", "createdAt": "2020-09-16T15:11:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());\n+                indices.add(ref.index());\n+                // remember the reference position\n+                List<Integer> positions = referenceToPosition.computeIfAbsent(ref, v -> new ArrayList<>(1));\n+                positions.add(counter++);\n             }\n         }\n \n-        final int listSize = sz;\n-        client.multiGet(requestBuilder.request(), wrap(r -> {\n-            List<List<GetResponse>> hits = new ArrayList<>(r.getResponses().length / listSize);\n-\n-            List<GetResponse> sequence = new ArrayList<>(listSize);\n-\n-            int counter = 0;\n-            for (MultiGetItemResponse mgr : r.getResponses()) {\n-                if (mgr.isFailed()) {\n-                    listener.onFailure(mgr.getFailure().getFailure());\n-                    return;\n-                }\n+        SearchSourceBuilder builder = SearchSourceBuilder.searchSource()\n+            // make sure to fetch the whole source\n+            .fetchSource(FetchSourceContext.FETCH_SOURCE)\n+            .trackTotalHits(false)\n+            .trackScores(false)\n+            .query(idsQuery);\n+\n+        final int listSize = innerListSize;\n+        final int topListSize = counter / listSize;\n+        // pre-allocate the response matrix\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        List<SearchHit>[] hits = new List[topListSize];\n+        for (int i = 0; i < hits.length; i++) {\n+            hits[i] = Arrays.asList(new SearchHit[listSize]);\n+        }\n+        final List<List<SearchHit>> seq = Arrays.asList(hits);\n \n-                sequence.add(mgr.getResponse());\n+        SearchRequest search = prepareRequest(client, builder, false, indices.toArray(new String[0]));\n \n-                if (++counter == listSize) {\n-                    counter = 0;\n-                    hits.add(sequence);\n-                    sequence = new ArrayList<>(listSize);\n-                }\n+        search(search, ActionListeners.map(listener, r -> {\n+            for (SearchHit hit : RuntimeUtils.searchHits(r)) {\n+                List<Integer> positions = referenceToPosition.get(new HitReference(hit));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NzcyNzk1", "url": "https://github.com/elastic/elasticsearch/pull/62469#pullrequestreview-489772795", "createdAt": "2020-09-16T15:56:55Z", "commit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4501, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}