{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4Nzc0OTY3", "number": 62560, "title": "Use Globals Ords in Cardinality aggregation when it makes sense", "bodyText": "After introducing a sparse HLL++ implementation, it may make sense for shards that do not have many different values to use global ords to generate the cardinality sketch.", "createdAt": "2020-09-17T16:02:51Z", "url": "https://github.com/elastic/elasticsearch/pull/62560", "merged": true, "mergeCommit": {"oid": "1dea28a87843cb10360fda60cd409208814eb87b"}, "closed": true, "closedAt": "2020-10-13T07:19:15Z", "author": {"login": "iverase"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJzJljgH2gAyNDg4Nzc0OTY3OjczMWJlZmQwOGQyYjZlOTBhM2VkNzEzOGI0MmFjMDZkOWJlNzEwNWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSCaFBAH2gAyNDg4Nzc0OTY3OjM5MTU3YzI4OGJlNWQ0NGI3Y2VkODRmMDU5YWFmMWZjNzhmNWRhMDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "731befd08d2b6e90a3ed7138b42ac06d9be7105d", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/731befd08d2b6e90a3ed7138b42ac06d9be7105d", "committedDate": "2020-09-17T15:58:11Z", "message": "Use Globals Ords in Cardinality aggregation when it makes sense"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODA1OTQx", "url": "https://github.com/elastic/elasticsearch/pull/62560#pullrequestreview-490805941", "createdAt": "2020-09-17T16:57:21Z", "commit": {"oid": "731befd08d2b6e90a3ed7138b42ac06d9be7105d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1NzoyMVrOHTso0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowMzowMVrOHTs2gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjMzOA==", "bodyText": "I know that building global ords is expensive. You pay the cost each time you need them and the index has been modified. Beyond that, I dunno if this is expensive.", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490416338", "createdAt": "2020-09-17T16:57:21Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/CardinalityAggregatorFactory.java", "diffHunk": "@@ -48,7 +49,28 @@\n     }\n \n     public static void registerAggregators(ValuesSourceRegistry.Builder builder) {\n-        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY, CoreValuesSourceType.ALL_CORE, CardinalityAggregator::new, true);\n+        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY,\n+            CoreValuesSourceType.ALL_CORE,\n+            (name, valuesSourceConfig, precision, context, parent, metadata) -> {\n+                // super hacky but it shows the point of the approach\n+                if (valuesSourceConfig.hasValues()) {\n+                    ValuesSource valuesSource = valuesSourceConfig.getValuesSource();\n+                    if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals) {\n+                        ValuesSource.Bytes.WithOrdinals source = (ValuesSource.Bytes.WithOrdinals) valuesSource;\n+                        // is this call expensive? I hope not\n+                        final long maxOrd = source.globalMaxOrd(context.searcher());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731befd08d2b6e90a3ed7138b42ac06d9be7105d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzE5MQ==", "bodyText": "I think a more \"normal\" way to do this is to pull all of these into the aggregator itself and return a \"small\" Collector.", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490417191", "createdAt": "2020-09-17T16:58:44Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.FixedBitSet;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private final OrdinalsCollector collector;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = new HyperLogLogPlusPlusSparse(precision, context.bigArrays(), maxOrd, 1);\n+        this.collector = new OrdinalsCollector(counts, context.bigArrays(), maxOrd);\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        collector.postCollect();\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);\n+    }\n+\n+    private static class OrdinalsCollector extends LeafBucketCollector implements Releasable {\n+\n+        private final BigArrays bigArrays;\n+        private SortedSetDocValues values;\n+        private final int maxOrd;\n+        private final HyperLogLogPlusPlusSparse counts;\n+        private ObjectArray<FixedBitSet> visitedOrds;  // Danger! This is not tracked by BigArrays!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731befd08d2b6e90a3ed7138b42ac06d9be7105d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxOTg0MQ==", "bodyText": "It can be quite large if the incoming cardinality is high and the cardinality of the field we're measuring is low. We have that problem in the implementation we have today though. I mean, like, say you have date_hist(hours) -> terms(high_cardinality) -> cardinality(average value around 2 or something). In that case we'll allocate the whole bit map for every incoming ord, only to set one or two bits.", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r490419841", "createdAt": "2020-09-17T17:03:01Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/CardinalityAggregatorFactory.java", "diffHunk": "@@ -48,7 +49,28 @@\n     }\n \n     public static void registerAggregators(ValuesSourceRegistry.Builder builder) {\n-        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY, CoreValuesSourceType.ALL_CORE, CardinalityAggregator::new, true);\n+        builder.register(CardinalityAggregationBuilder.REGISTRY_KEY,\n+            CoreValuesSourceType.ALL_CORE,\n+            (name, valuesSourceConfig, precision, context, parent, metadata) -> {\n+                // super hacky but it shows the point of the approach\n+                if (valuesSourceConfig.hasValues()) {\n+                    ValuesSource valuesSource = valuesSourceConfig.getValuesSource();\n+                    if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals) {\n+                        ValuesSource.Bytes.WithOrdinals source = (ValuesSource.Bytes.WithOrdinals) valuesSource;\n+                        // is this call expensive? I hope not\n+                        final long maxOrd = source.globalMaxOrd(context.searcher());\n+                        final long countsMemoryUsage = HyperLogLogPlusPlus.memoryUsage(precision);\n+                        final long ordinalsMemoryUsage = maxOrd * 4;\n+                        // better heuristic? Currently we pay the price of the bitSet but it should be small\n+                        if (ordinalsMemoryUsage < countsMemoryUsage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731befd08d2b6e90a3ed7138b42ac06d9be7105d"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fde41b13e0d72d221a8a36b589341704acf4ac82", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/fde41b13e0d72d221a8a36b589341704acf4ac82", "committedDate": "2020-09-18T11:31:38Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9221d5bc5976b5e5cf109dc8022405044497fe82", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/9221d5bc5976b5e5cf109dc8022405044497fe82", "committedDate": "2020-09-18T11:56:03Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d06005f056dc3f45224e69447788e02c845b9864", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/d06005f056dc3f45224e69447788e02c845b9864", "committedDate": "2020-09-18T14:12:00Z", "message": "Change the way we storage hashes in HyperLogLogPlusPlusSparse so we can have variable length arrays!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6191f818d842b7c32e923ddb748c76f5fa2307fb", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/6191f818d842b7c32e923ddb748c76f5fa2307fb", "committedDate": "2020-09-18T16:35:31Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32c9ce30bd728b6f2e9d938e39262731ab253d64", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/32c9ce30bd728b6f2e9d938e39262731ab253d64", "committedDate": "2020-09-19T10:21:23Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b26d9637e6c71483386b19bfa8137d0e7977d338", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/b26d9637e6c71483386b19bfa8137d0e7977d338", "committedDate": "2020-09-20T06:34:02Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70f2f44cf2b6bddc40d5db2046cc168102b4b904", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/70f2f44cf2b6bddc40d5db2046cc168102b4b904", "committedDate": "2020-09-20T06:48:11Z", "message": "use final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9a0b2696aa4db26837225747da77dbf816f5a53", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/e9a0b2696aa4db26837225747da77dbf816f5a53", "committedDate": "2020-09-20T07:12:01Z", "message": "make sure we release counts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b70c625996e59e23ad3335744f5d44094ffc90fd", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/b70c625996e59e23ad3335744f5d44094ffc90fd", "committedDate": "2020-09-20T07:19:13Z", "message": "release collector early"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76db2514ba01c648aa7e916ceaa50a356a70acc2", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/76db2514ba01c648aa7e916ceaa50a356a70acc2", "committedDate": "2020-09-20T08:06:29Z", "message": "fix npe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b59d13a5ba11d320d5bb2774b3b3639c07089091", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/b59d13a5ba11d320d5bb2774b3b3639c07089091", "committedDate": "2020-09-20T09:02:51Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "595afd6500f7d911e09c93e689d722f156e7f6ff", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/595afd6500f7d911e09c93e689d722f156e7f6ff", "committedDate": "2020-09-21T09:13:50Z", "message": "Don't leak CircuitBreaker on construction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3389f230b5682019309ed7bb64a9d0465e58dc44", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/3389f230b5682019309ed7bb64a9d0465e58dc44", "committedDate": "2020-09-21T13:45:03Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6125508d92bf4b9754f5cd22c1fb291b7f86662b", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/6125508d92bf4b9754f5cd22c1fb291b7f86662b", "committedDate": "2020-09-22T10:34:04Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjQ3Mjgx", "url": "https://github.com/elastic/elasticsearch/pull/62560#pullrequestreview-494647281", "createdAt": "2020-09-23T13:16:21Z", "commit": {"oid": "6125508d92bf4b9754f5cd22c1fb291b7f86662b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzoxNjoyMVrOHWtdtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMzoyMjoxM1rOHWt0Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NTYwNQ==", "bodyText": "We don't need these at all. We'll get the information that this is the global ords-based aggregator by default in the debug info. If we want anything here is might be debug insight into the sparse hll++ data structure.", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493575605", "createdAt": "2020-09-23T13:16:21Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private OrdinalsCollector collector;\n+\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = null;\n+        this.collector = new OrdinalsCollector(context.bigArrays(), maxOrd);\n+        this.precision = precision;\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, collector.bigArrays, collector.visitedOrds.size());\n+        collector.postCollect(counts);\n+        collector.close();\n+        collector = null;\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts == null ? 0 : counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (counts == null || owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 1);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6125508d92bf4b9754f5cd22c1fb291b7f86662b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3OTU3Mg==", "bodyText": "I'm not generally a fan of ObjectArray just because it means we're allocating something per bucket. It makes sense here though. Probably worth talking about.\nI wonder if it'd be worth having two storage mechanisms here - a list of longs and transitioning into a BitArray. BitArray would take up a bunch of space if all you are doing is recording a hand full of big longs. But maybe this isn't really worth our time. This is already fairly complex to have these two collection mechanisms.", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493579572", "createdAt": "2020-09-23T13:20:30Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private OrdinalsCollector collector;\n+\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = null;\n+        this.collector = new OrdinalsCollector(context.bigArrays(), maxOrd);\n+        this.precision = precision;\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, collector.bigArrays, collector.visitedOrds.size());\n+        collector.postCollect(counts);\n+        collector.close();\n+        collector = null;\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts == null ? 0 : counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (counts == null || owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 1);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);\n+    }\n+\n+    private static class OrdinalsCollector extends LeafBucketCollector implements Releasable {\n+\n+        private final BigArrays bigArrays;\n+        private SortedSetDocValues values;\n+        private final int maxOrd;\n+        private ObjectArray<BitArray> visitedOrds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6125508d92bf4b9754f5cd22c1fb291b7f86662b"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU4MTM1OQ==", "bodyText": "I wonder if we need a second class here - maybe all of these members should just go into the top level class?", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r493581359", "createdAt": "2020-09-23T13:22:13Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private OrdinalsCollector collector;\n+\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.counts = null;\n+        this.collector = new OrdinalsCollector(context.bigArrays(), maxOrd);\n+        this.precision = precision;\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        this.collector.set(valuesSource.globalOrdinalsValues(ctx));\n+        return collector;\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, collector.bigArrays, collector.visitedOrds.size());\n+        collector.postCollect(counts);\n+        collector.close();\n+        collector = null;\n+    }\n+\n+    @Override\n+    public double metric(long owningBucketOrd) {\n+        return counts == null ? 0 : counts.cardinality(owningBucketOrd);\n+    }\n+\n+    @Override\n+    public InternalAggregation buildAggregation(long owningBucketOrdinal) {\n+        if (counts == null || owningBucketOrdinal >= counts.maxOrd() || counts.cardinality(owningBucketOrdinal) == 0) {\n+            return buildEmptyAggregation();\n+        }\n+        // We need to build a copy because the returned Aggregation needs remain usable after\n+        // this Aggregator (and its HLL++ counters) is released.\n+        AbstractHyperLogLogPlusPlus copy = counts.clone(owningBucketOrdinal, BigArrays.NON_RECYCLING_INSTANCE);\n+        return new InternalCardinality(name, copy, metadata());\n+    }\n+\n+    @Override\n+    public InternalAggregation buildEmptyAggregation() {\n+        return new InternalCardinality(name, null, metadata());\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+        Releasables.close(counts, collector);\n+    }\n+\n+    @Override\n+    public void collectDebugInfo(BiConsumer<String, Object> add) {\n+        // maybe need to add something for global?\n+        super.collectDebugInfo(add);\n+        add.accept(\"empty_collectors_used\", 0);\n+        add.accept(\"numeric_collectors_used\", 0);\n+        add.accept(\"ordinals_collectors_used\", 1);\n+        add.accept(\"ordinals_collectors_overhead_too_high\", 0);\n+        add.accept(\"string_hashing_collectors_used\", 0);\n+    }\n+\n+    private static class OrdinalsCollector extends LeafBucketCollector implements Releasable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6125508d92bf4b9754f5cd22c1fb291b7f86662b"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6fa137074f1e5b3df15e389cc6480ae711d2718", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/f6fa137074f1e5b3df15e389cc6480ae711d2718", "committedDate": "2020-09-25T13:22:52Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4dba1b3311677ee605dd6bf08635703293b2165", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/e4dba1b3311677ee605dd6bf08635703293b2165", "committedDate": "2020-09-25T13:40:54Z", "message": "Change yml test so it does not fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "183b2378df06879467bae6c56c88b415a897f11f", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/183b2378df06879467bae6c56c88b415a897f11f", "committedDate": "2020-09-25T13:51:30Z", "message": "remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e57075183339b5dc5d8709035f800b75218a597c", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/e57075183339b5dc5d8709035f800b75218a597c", "committedDate": "2020-10-07T05:51:03Z", "message": "Move collector to the class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87630396be05709bb05321cdb6505dc42079d8bc", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/87630396be05709bb05321cdb6505dc42079d8bc", "committedDate": "2020-10-07T05:52:43Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDY3OTUx", "url": "https://github.com/elastic/elasticsearch/pull/62560#pullrequestreview-504067951", "createdAt": "2020-10-07T16:37:00Z", "commit": {"oid": "87630396be05709bb05321cdb6505dc42079d8bc"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjozNzowMFrOHd8DQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjozOToyNlrOHd8JPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1NDYyNg==", "bodyText": "Could you move the final stuff above the non-final stuff? It makes it just a little easier for me to read.", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r501154626", "createdAt": "2020-10-07T16:37:00Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private final BigArrays bigArrays;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87630396be05709bb05321cdb6505dc42079d8bc"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1NjE1Nw==", "bodyText": "I think we cold free allVisitedOrds here. Do you think it'd be worth shifting the method around so LongArray hashes is the outer most try?", "url": "https://github.com/elastic/elasticsearch/pull/62560#discussion_r501156157", "createdAt": "2020-10-07T16:39:26Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/GlobalOrdCardinalityAggregator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.metrics;\n+\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedSetDocValues;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.hash.MurmurHash3;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BitArray;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.ObjectArray;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.support.ValuesSource;\n+import org.elasticsearch.search.internal.SearchContext;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/**\n+ * An aggregator that computes approximate counts of unique values.\n+ */\n+public class GlobalOrdCardinalityAggregator extends NumericMetricsAggregator.SingleValue {\n+\n+    private final ValuesSource.Bytes.WithOrdinals valuesSource;\n+\n+    // Build at post-collection phase\n+    @Nullable\n+    private HyperLogLogPlusPlusSparse counts;\n+\n+    private final BigArrays bigArrays;\n+    private SortedSetDocValues values;\n+    private final int maxOrd;\n+    private ObjectArray<BitArray> visitedOrds;\n+    private final int precision;\n+\n+    public GlobalOrdCardinalityAggregator(\n+            String name,\n+            ValuesSource.Bytes.WithOrdinals valuesSource,\n+            int precision,\n+            int maxOrd,\n+            SearchContext context,\n+            Aggregator parent,\n+            Map<String, Object> metadata) throws IOException {\n+        super(name, context, parent, metadata);\n+        this.valuesSource = valuesSource;\n+        this.precision = precision;\n+        this.maxOrd = maxOrd;\n+        this.bigArrays = context.bigArrays();\n+        this.visitedOrds = bigArrays.newObjectArray(1);\n+    }\n+\n+    @Override\n+    public ScoreMode scoreMode() {\n+        return valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        values = valuesSource.globalOrdinalsValues(ctx);\n+        return new LeafBucketCollector() {\n+            @Override\n+            public void collect(int doc, long bucketOrd) throws IOException {\n+                visitedOrds = bigArrays.grow(visitedOrds, bucketOrd + 1);\n+                BitArray bits = visitedOrds.get(bucketOrd);\n+                if (bits == null) {\n+                    bits = new BitArray(maxOrd, bigArrays);\n+                    visitedOrds.set(bucketOrd, bits);\n+                }\n+                if (values.advanceExact(doc)) {\n+                    for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n+                        bits.set((int) ord);\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected void doPostCollection() throws IOException {\n+        counts = new HyperLogLogPlusPlusSparse(precision, bigArrays, visitedOrds.size());\n+        try (BitArray allVisitedOrds = new BitArray(maxOrd, bigArrays)) {\n+            for (long bucket = visitedOrds.size() - 1; bucket >= 0; --bucket) {\n+                final BitArray bits = visitedOrds.get(bucket);\n+                if (bits != null) {\n+                    allVisitedOrds.or(bits);\n+                }\n+            }\n+\n+            try (LongArray hashes = bigArrays.newLongArray(maxOrd, false)) {\n+                final MurmurHash3.Hash128 hash = new MurmurHash3.Hash128();\n+                for (long ord = allVisitedOrds.nextSetBit(0); ord < Long.MAX_VALUE;\n+                     ord = ord + 1 < maxOrd ? allVisitedOrds.nextSetBit(ord + 1) : Long.MAX_VALUE) {\n+                    final BytesRef value = values.lookupOrd(ord);\n+                    MurmurHash3.hash128(value.bytes, value.offset, value.length, 0, hash);\n+                    hashes.set(ord, hash.h1);\n+                }\n+                for (long bucket = visitedOrds.size() - 1; bucket >= 0; --bucket) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87630396be05709bb05321cdb6505dc42079d8bc"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb3598f1f7db45cf9301e2d85d0bfdca30048b05", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/eb3598f1f7db45cf9301e2d85d0bfdca30048b05", "committedDate": "2020-10-08T12:26:06Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38f85a50ebe0d79b636efd0c9866dfe154d34644", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/38f85a50ebe0d79b636efd0c9866dfe154d34644", "committedDate": "2020-10-08T13:46:23Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39157c288be5d44b7ced84f059aaf1fc78f5da08", "author": {"user": {"login": "iverase", "name": "Ignacio Vera"}}, "url": "https://github.com/elastic/elasticsearch/commit/39157c288be5d44b7ced84f059aaf1fc78f5da08", "committedDate": "2020-10-13T06:16:10Z", "message": "Merge branch 'master' into GlobalOrdsCardinalityAggregator\n\n# Conflicts:\n#\tserver/src/main/java/org/elasticsearch/search/aggregations/metrics/CardinalityAggregatorFactory.java"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3649, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}