{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxNzc1NDc2", "number": 61436, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoxOTo1OFrOEbECSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoxOTo1OFrOEbECSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODEzMTMwOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoxOTo1OFrOHE24lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoyODoxNVrOHE3GxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NTU3NA==", "bodyText": "Is the only thing we're wanting to defer is the destination dir? If so, can we just compute that ahead of time rather than query it from the task itself?", "url": "https://github.com/elastic/elasticsearch/pull/61436#discussion_r474855574", "createdAt": "2020-08-21T18:19:58Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -237,57 +252,56 @@ public void apply(Project project) {\n         return versionTasks;\n     }\n \n-    private static Jdk createJdk(\n-        NamedDomainObjectContainer<Jdk> jdksContainer,\n-        String name,\n+    private static TaskProvider<Copy> createJdk(\n+        Project project,\n+        String purpose,\n         String vendor,\n         String version,\n         String platform,\n         String architecture\n     ) {\n-        Jdk jdk = jdksContainer.create(name);\n+        Jdk jdk = JdkDownloadPlugin.getContainer(project).create(platform + \"-\" + purpose);\n         jdk.setVendor(vendor);\n         jdk.setVersion(version);\n         jdk.setPlatform(platform);\n         jdk.setArchitecture(architecture);\n-        return jdk;\n+\n+        String taskname = \"copy\" + Util.capitalize(platform) + Util.capitalize(purpose) + \"Jdk\";\n+        TaskProvider<Copy> copyTask = project.getTasks().register(taskname, Copy.class);\n+        copyTask.configure(t -> {\n+            t.from(jdk);\n+            t.into(new File(project.getBuildDir(), \"jdks/\" + platform + \"-\" + architecture + \"-\" + vendor + \"-\" + version));\n+        });\n+        return copyTask;\n     }\n \n-    private static List<Object> configureVM(Project project) {\n+    private static void configureVM(Project project, TaskProvider<Copy> gradleJdkProvider, TaskProvider<Copy> systemJdkProvider) {\n         String box = project.getName();\n \n-        // setup jdks used by the distro tests, and by gradle executing\n-\n-        NamedDomainObjectContainer<Jdk> jdksContainer = JdkDownloadPlugin.getContainer(project);\n-        String platform = box.contains(\"windows\") ? \"windows\" : \"linux\";\n-        Jdk systemJdk = createJdk(jdksContainer, \"system\", SYSTEM_JDK_VENDOR, SYSTEM_JDK_VERSION, platform, \"x64\");\n-        Jdk gradleJdk = createJdk(jdksContainer, \"gradle\", GRADLE_JDK_VENDOR, GRADLE_JDK_VERSION, platform, \"x64\");\n-\n         // setup VM used by these tests\n         VagrantExtension vagrant = project.getExtensions().getByType(VagrantExtension.class);\n         vagrant.setBox(box);\n-        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdk, \"\", \"\"));\n-        vagrant.vmEnv(\"JAVA_HOME\", \"\"); // make sure any default java on the system is ignored\n-        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdk, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n+\n+        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdkProvider, \"\", \"\"));\n+        vagrant.vmEnv(\"JAVA_HOME\",\"\"); // make sure any default java on the system is ignored\n+        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdkProvider, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n         // pass these along to get correct build scans\n         if (System.getenv(\"JENKINS_URL\") != null) {\n             Stream.of(\"JOB_NAME\", \"JENKINS_URL\", \"BUILD_NUMBER\", \"BUILD_URL\").forEach(name -> vagrant.vmEnv(name, System.getenv(name)));\n         }\n         vagrant.setIsWindowsVM(isWindows(project));\n-\n-        return Arrays.asList(systemJdk, gradleJdk);\n     }\n \n-    private static Object convertPath(Project project, VagrantExtension vagrant, Jdk jdk, String additionaLinux, String additionalWindows) {\n-        return new Object() {\n-            @Override\n-            public String toString() {\n-                if (vagrant.isWindowsVM()) {\n-                    return convertWindowsPath(project, jdk.getPath()) + additionalWindows;\n-                }\n-                return convertLinuxPath(project, jdk.getPath()) + additionaLinux;\n+    private static Object convertPath(Project project, VagrantExtension vagrant, TaskProvider<Copy> jdkProvider,\n+                                      String additionaLinux, String additionalWindows) {\n+        return Util.toStringable(() -> {\n+            String hostPath = jdkProvider.get().getDestinationDir().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e17b5144526a3dd549e38370d7ce8cd9b5b6c6a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NjQxOA==", "bodyText": "We could, but then I would need to keep track of 4 additional variables, one for the path, and one for the task itself. Is there a downside to using the task?", "url": "https://github.com/elastic/elasticsearch/pull/61436#discussion_r474856418", "createdAt": "2020-08-21T18:21:46Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -237,57 +252,56 @@ public void apply(Project project) {\n         return versionTasks;\n     }\n \n-    private static Jdk createJdk(\n-        NamedDomainObjectContainer<Jdk> jdksContainer,\n-        String name,\n+    private static TaskProvider<Copy> createJdk(\n+        Project project,\n+        String purpose,\n         String vendor,\n         String version,\n         String platform,\n         String architecture\n     ) {\n-        Jdk jdk = jdksContainer.create(name);\n+        Jdk jdk = JdkDownloadPlugin.getContainer(project).create(platform + \"-\" + purpose);\n         jdk.setVendor(vendor);\n         jdk.setVersion(version);\n         jdk.setPlatform(platform);\n         jdk.setArchitecture(architecture);\n-        return jdk;\n+\n+        String taskname = \"copy\" + Util.capitalize(platform) + Util.capitalize(purpose) + \"Jdk\";\n+        TaskProvider<Copy> copyTask = project.getTasks().register(taskname, Copy.class);\n+        copyTask.configure(t -> {\n+            t.from(jdk);\n+            t.into(new File(project.getBuildDir(), \"jdks/\" + platform + \"-\" + architecture + \"-\" + vendor + \"-\" + version));\n+        });\n+        return copyTask;\n     }\n \n-    private static List<Object> configureVM(Project project) {\n+    private static void configureVM(Project project, TaskProvider<Copy> gradleJdkProvider, TaskProvider<Copy> systemJdkProvider) {\n         String box = project.getName();\n \n-        // setup jdks used by the distro tests, and by gradle executing\n-\n-        NamedDomainObjectContainer<Jdk> jdksContainer = JdkDownloadPlugin.getContainer(project);\n-        String platform = box.contains(\"windows\") ? \"windows\" : \"linux\";\n-        Jdk systemJdk = createJdk(jdksContainer, \"system\", SYSTEM_JDK_VENDOR, SYSTEM_JDK_VERSION, platform, \"x64\");\n-        Jdk gradleJdk = createJdk(jdksContainer, \"gradle\", GRADLE_JDK_VENDOR, GRADLE_JDK_VERSION, platform, \"x64\");\n-\n         // setup VM used by these tests\n         VagrantExtension vagrant = project.getExtensions().getByType(VagrantExtension.class);\n         vagrant.setBox(box);\n-        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdk, \"\", \"\"));\n-        vagrant.vmEnv(\"JAVA_HOME\", \"\"); // make sure any default java on the system is ignored\n-        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdk, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n+\n+        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdkProvider, \"\", \"\"));\n+        vagrant.vmEnv(\"JAVA_HOME\",\"\"); // make sure any default java on the system is ignored\n+        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdkProvider, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n         // pass these along to get correct build scans\n         if (System.getenv(\"JENKINS_URL\") != null) {\n             Stream.of(\"JOB_NAME\", \"JENKINS_URL\", \"BUILD_NUMBER\", \"BUILD_URL\").forEach(name -> vagrant.vmEnv(name, System.getenv(name)));\n         }\n         vagrant.setIsWindowsVM(isWindows(project));\n-\n-        return Arrays.asList(systemJdk, gradleJdk);\n     }\n \n-    private static Object convertPath(Project project, VagrantExtension vagrant, Jdk jdk, String additionaLinux, String additionalWindows) {\n-        return new Object() {\n-            @Override\n-            public String toString() {\n-                if (vagrant.isWindowsVM()) {\n-                    return convertWindowsPath(project, jdk.getPath()) + additionalWindows;\n-                }\n-                return convertLinuxPath(project, jdk.getPath()) + additionaLinux;\n+    private static Object convertPath(Project project, VagrantExtension vagrant, TaskProvider<Copy> jdkProvider,\n+                                      String additionaLinux, String additionalWindows) {\n+        return Util.toStringable(() -> {\n+            String hostPath = jdkProvider.get().getDestinationDir().toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NTU3NA=="}, "originalCommit": {"oid": "5e17b5144526a3dd549e38370d7ce8cd9b5b6c6a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NjY4MQ==", "bodyText": "It would also complicate the helper to create each jdk, since it would need to return 2 things, the path and the task.", "url": "https://github.com/elastic/elasticsearch/pull/61436#discussion_r474856681", "createdAt": "2020-08-21T18:22:23Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -237,57 +252,56 @@ public void apply(Project project) {\n         return versionTasks;\n     }\n \n-    private static Jdk createJdk(\n-        NamedDomainObjectContainer<Jdk> jdksContainer,\n-        String name,\n+    private static TaskProvider<Copy> createJdk(\n+        Project project,\n+        String purpose,\n         String vendor,\n         String version,\n         String platform,\n         String architecture\n     ) {\n-        Jdk jdk = jdksContainer.create(name);\n+        Jdk jdk = JdkDownloadPlugin.getContainer(project).create(platform + \"-\" + purpose);\n         jdk.setVendor(vendor);\n         jdk.setVersion(version);\n         jdk.setPlatform(platform);\n         jdk.setArchitecture(architecture);\n-        return jdk;\n+\n+        String taskname = \"copy\" + Util.capitalize(platform) + Util.capitalize(purpose) + \"Jdk\";\n+        TaskProvider<Copy> copyTask = project.getTasks().register(taskname, Copy.class);\n+        copyTask.configure(t -> {\n+            t.from(jdk);\n+            t.into(new File(project.getBuildDir(), \"jdks/\" + platform + \"-\" + architecture + \"-\" + vendor + \"-\" + version));\n+        });\n+        return copyTask;\n     }\n \n-    private static List<Object> configureVM(Project project) {\n+    private static void configureVM(Project project, TaskProvider<Copy> gradleJdkProvider, TaskProvider<Copy> systemJdkProvider) {\n         String box = project.getName();\n \n-        // setup jdks used by the distro tests, and by gradle executing\n-\n-        NamedDomainObjectContainer<Jdk> jdksContainer = JdkDownloadPlugin.getContainer(project);\n-        String platform = box.contains(\"windows\") ? \"windows\" : \"linux\";\n-        Jdk systemJdk = createJdk(jdksContainer, \"system\", SYSTEM_JDK_VENDOR, SYSTEM_JDK_VERSION, platform, \"x64\");\n-        Jdk gradleJdk = createJdk(jdksContainer, \"gradle\", GRADLE_JDK_VENDOR, GRADLE_JDK_VERSION, platform, \"x64\");\n-\n         // setup VM used by these tests\n         VagrantExtension vagrant = project.getExtensions().getByType(VagrantExtension.class);\n         vagrant.setBox(box);\n-        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdk, \"\", \"\"));\n-        vagrant.vmEnv(\"JAVA_HOME\", \"\"); // make sure any default java on the system is ignored\n-        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdk, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n+\n+        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdkProvider, \"\", \"\"));\n+        vagrant.vmEnv(\"JAVA_HOME\",\"\"); // make sure any default java on the system is ignored\n+        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdkProvider, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n         // pass these along to get correct build scans\n         if (System.getenv(\"JENKINS_URL\") != null) {\n             Stream.of(\"JOB_NAME\", \"JENKINS_URL\", \"BUILD_NUMBER\", \"BUILD_URL\").forEach(name -> vagrant.vmEnv(name, System.getenv(name)));\n         }\n         vagrant.setIsWindowsVM(isWindows(project));\n-\n-        return Arrays.asList(systemJdk, gradleJdk);\n     }\n \n-    private static Object convertPath(Project project, VagrantExtension vagrant, Jdk jdk, String additionaLinux, String additionalWindows) {\n-        return new Object() {\n-            @Override\n-            public String toString() {\n-                if (vagrant.isWindowsVM()) {\n-                    return convertWindowsPath(project, jdk.getPath()) + additionalWindows;\n-                }\n-                return convertLinuxPath(project, jdk.getPath()) + additionaLinux;\n+    private static Object convertPath(Project project, VagrantExtension vagrant, TaskProvider<Copy> jdkProvider,\n+                                      String additionaLinux, String additionalWindows) {\n+        return Util.toStringable(() -> {\n+            String hostPath = jdkProvider.get().getDestinationDir().toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NTU3NA=="}, "originalCommit": {"oid": "5e17b5144526a3dd549e38370d7ce8cd9b5b6c6a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1OTIwNA==", "bodyText": "Meh, sounds fine to me then \ud83d\ude04", "url": "https://github.com/elastic/elasticsearch/pull/61436#discussion_r474859204", "createdAt": "2020-08-21T18:28:15Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -237,57 +252,56 @@ public void apply(Project project) {\n         return versionTasks;\n     }\n \n-    private static Jdk createJdk(\n-        NamedDomainObjectContainer<Jdk> jdksContainer,\n-        String name,\n+    private static TaskProvider<Copy> createJdk(\n+        Project project,\n+        String purpose,\n         String vendor,\n         String version,\n         String platform,\n         String architecture\n     ) {\n-        Jdk jdk = jdksContainer.create(name);\n+        Jdk jdk = JdkDownloadPlugin.getContainer(project).create(platform + \"-\" + purpose);\n         jdk.setVendor(vendor);\n         jdk.setVersion(version);\n         jdk.setPlatform(platform);\n         jdk.setArchitecture(architecture);\n-        return jdk;\n+\n+        String taskname = \"copy\" + Util.capitalize(platform) + Util.capitalize(purpose) + \"Jdk\";\n+        TaskProvider<Copy> copyTask = project.getTasks().register(taskname, Copy.class);\n+        copyTask.configure(t -> {\n+            t.from(jdk);\n+            t.into(new File(project.getBuildDir(), \"jdks/\" + platform + \"-\" + architecture + \"-\" + vendor + \"-\" + version));\n+        });\n+        return copyTask;\n     }\n \n-    private static List<Object> configureVM(Project project) {\n+    private static void configureVM(Project project, TaskProvider<Copy> gradleJdkProvider, TaskProvider<Copy> systemJdkProvider) {\n         String box = project.getName();\n \n-        // setup jdks used by the distro tests, and by gradle executing\n-\n-        NamedDomainObjectContainer<Jdk> jdksContainer = JdkDownloadPlugin.getContainer(project);\n-        String platform = box.contains(\"windows\") ? \"windows\" : \"linux\";\n-        Jdk systemJdk = createJdk(jdksContainer, \"system\", SYSTEM_JDK_VENDOR, SYSTEM_JDK_VERSION, platform, \"x64\");\n-        Jdk gradleJdk = createJdk(jdksContainer, \"gradle\", GRADLE_JDK_VENDOR, GRADLE_JDK_VERSION, platform, \"x64\");\n-\n         // setup VM used by these tests\n         VagrantExtension vagrant = project.getExtensions().getByType(VagrantExtension.class);\n         vagrant.setBox(box);\n-        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdk, \"\", \"\"));\n-        vagrant.vmEnv(\"JAVA_HOME\", \"\"); // make sure any default java on the system is ignored\n-        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdk, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n+\n+        vagrant.vmEnv(\"SYSTEM_JAVA_HOME\", convertPath(project, vagrant, systemJdkProvider, \"\", \"\"));\n+        vagrant.vmEnv(\"JAVA_HOME\",\"\"); // make sure any default java on the system is ignored\n+        vagrant.vmEnv(\"PATH\", convertPath(project, vagrant, gradleJdkProvider, \"/bin:$PATH\", \"\\\\bin;$Env:PATH\"));\n         // pass these along to get correct build scans\n         if (System.getenv(\"JENKINS_URL\") != null) {\n             Stream.of(\"JOB_NAME\", \"JENKINS_URL\", \"BUILD_NUMBER\", \"BUILD_URL\").forEach(name -> vagrant.vmEnv(name, System.getenv(name)));\n         }\n         vagrant.setIsWindowsVM(isWindows(project));\n-\n-        return Arrays.asList(systemJdk, gradleJdk);\n     }\n \n-    private static Object convertPath(Project project, VagrantExtension vagrant, Jdk jdk, String additionaLinux, String additionalWindows) {\n-        return new Object() {\n-            @Override\n-            public String toString() {\n-                if (vagrant.isWindowsVM()) {\n-                    return convertWindowsPath(project, jdk.getPath()) + additionalWindows;\n-                }\n-                return convertLinuxPath(project, jdk.getPath()) + additionaLinux;\n+    private static Object convertPath(Project project, VagrantExtension vagrant, TaskProvider<Copy> jdkProvider,\n+                                      String additionaLinux, String additionalWindows) {\n+        return Util.toStringable(() -> {\n+            String hostPath = jdkProvider.get().getDestinationDir().toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NTU3NA=="}, "originalCommit": {"oid": "5e17b5144526a3dd549e38370d7ce8cd9b5b6c6a"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 786, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}