{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MDAxNjA5", "number": 61592, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowNjozMFrOEf65oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjo1Mzo0MlrOEgiqJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTA2MzM2OnYy", "diffSide": "LEFT", "path": "distribution/docker/build.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowNjozMFrOHMfo-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDowNjozMFrOHMfo-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2MzM1NA==", "bodyText": "didn't find any use of this one", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r482863354", "createdAt": "2020-09-03T10:06:30Z", "author": {"login": "breskeby"}, "path": "distribution/docker/build.gradle", "diffHunk": "@@ -146,8 +155,6 @@ void addCopyDockerContextTask(Architecture architecture, boolean oss, DockerBase\n         from configurations.dockerSource\n       }\n     }\n-\n-    from configurations.dockerPlugins", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTUxNjI2OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/DistributionArchive.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjoxMjoxM1rOHNcvbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMToyNFrOHOhgrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NDQyOQ==", "bodyText": "Do we really need this interface? Could we not just use Supplier<CopySpec>?", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483864429", "createdAt": "2020-09-04T22:12:13Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/DistributionArchive.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.gradle.api.Named;\n+import org.gradle.api.file.CopySpec;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+\n+public class DistributionArchive implements Named {\n+\n+    private TaskProvider<? extends AbstractArchiveTask> archiveTask;\n+    private TaskProvider<Copy> explodedDistTask;\n+    private final String name;\n+\n+    public DistributionArchive(TaskProvider<? extends AbstractArchiveTask> archiveTask, TaskProvider<Copy> explodedDistTask, String name) {\n+        this.archiveTask = archiveTask;\n+        this.explodedDistTask = explodedDistTask;\n+        this.name = name;\n+    }\n+\n+    public void setArchiveClassifier(String classifier) {\n+        this.archiveTask.configure(abstractArchiveTask -> abstractArchiveTask.getArchiveClassifier().set(classifier));\n+    }\n+\n+    public void content(ContentProvider p) {\n+        this.archiveTask.configure(t -> { t.with(p.provide()); });\n+        this.explodedDistTask.configure(t -> { t.with(p.provide()); });\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public TaskProvider<? extends AbstractArchiveTask> getArchiveTask() {\n+        return archiveTask;\n+    }\n+\n+    public TaskProvider<Copy> getExplodedArchiveTask() {\n+        return explodedDistTask;\n+    }\n+\n+    interface ContentProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MTE0OQ==", "bodyText": "fixed", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484991149", "createdAt": "2020-09-08T15:01:24Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/DistributionArchive.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.gradle.api.Named;\n+import org.gradle.api.file.CopySpec;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+\n+public class DistributionArchive implements Named {\n+\n+    private TaskProvider<? extends AbstractArchiveTask> archiveTask;\n+    private TaskProvider<Copy> explodedDistTask;\n+    private final String name;\n+\n+    public DistributionArchive(TaskProvider<? extends AbstractArchiveTask> archiveTask, TaskProvider<Copy> explodedDistTask, String name) {\n+        this.archiveTask = archiveTask;\n+        this.explodedDistTask = explodedDistTask;\n+        this.name = name;\n+    }\n+\n+    public void setArchiveClassifier(String classifier) {\n+        this.archiveTask.configure(abstractArchiveTask -> abstractArchiveTask.getArchiveClassifier().set(classifier));\n+    }\n+\n+    public void content(ContentProvider p) {\n+        this.archiveTask.configure(t -> { t.with(p.provide()); });\n+        this.explodedDistTask.configure(t -> { t.with(p.provide()); });\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public TaskProvider<? extends AbstractArchiveTask> getArchiveTask() {\n+        return archiveTask;\n+    }\n+\n+    public TaskProvider<Copy> getExplodedArchiveTask() {\n+        return explodedDistTask;\n+    }\n+\n+    interface ContentProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NDQyOQ=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTUxODI1OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjoxMzo1MVrOHNcwug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMTozMVrOHOhhBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NDc2Mg==", "bodyText": "Having per-distribution sub-projects means we can build them in parallel.", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483864762", "createdAt": "2020-09-04T22:13:51Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MTIzNw==", "bodyText": "Added", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484991237", "createdAt": "2020-09-08T15:01:31Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NDc2Mg=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTUyMTQyOnYy", "diffSide": "RIGHT", "path": "distribution/archives/build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjoxNTo1MFrOHNcypA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNzozMDo1MFrOHNzUiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NTI1Mg==", "bodyText": "I would love for us to either a) make a proper DSL from this or b) use named parameters when calling this method rather than have foo(true, false, null, false) all over the place which is a poor description of what is happening.", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483865252", "createdAt": "2020-09-04T22:15:50Z", "author": {"login": "mark-vieira"}, "path": "distribution/archives/build.gradle", "diffHunk": "@@ -17,39 +17,11 @@\n  * under the License.\n  */\n \n-import org.elasticsearch.gradle.BuildPlugin\n-import org.elasticsearch.gradle.EmptyDirTask\n-import org.elasticsearch.gradle.LoggedExec\n import org.elasticsearch.gradle.MavenFilteringHack\n-import org.elasticsearch.gradle.VersionProperties\n-import org.elasticsearch.gradle.info.BuildParams\n-import org.elasticsearch.gradle.plugin.PluginBuildPlugin\n-import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar\n-import groovy.io.FileType\n import java.nio.file.Files\n import java.nio.file.Path\n \n-// need this so Zip/Tar tasks get basic defaults...\n-apply plugin: 'base'\n-\n-// CopySpec does not make it easy to create an empty directory so we\n-// create the directory that we want, and then point CopySpec to its\n-// parent to copy to the root of the distribution\n-ext.logsDir = new File(buildDir, 'logs-hack/logs')\n-tasks.register('createLogsDir', EmptyDirTask) {\n-  dir = \"${logsDir}\"\n-  dirMode = 0755\n-}\n-ext.pluginsDir = new File(buildDir, 'plugins-hack/plugins')\n-tasks.register('createPluginsDir', EmptyDirTask) {\n-  dir = \"${pluginsDir}\"\n-  dirMode = 0755\n-}\n-ext.jvmOptionsDir = new File(buildDir, 'jvm-options-hack/jvm.options.d')\n-tasks.register('createJvmOptionsDir', EmptyDirTask) {\n-  dir = \"${jvmOptionsDir}\"\n-  dirMode = 0750\n-}\n+apply plugin: 'elasticsearch.internal-distribution-archive-setup'\n \n CopySpec archiveFiles(CopySpec modulesFiles, String distributionType, String platform, String architecture, boolean oss, boolean jdk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNDM3OQ==", "bodyText": "a proper DSL is currently a bit tricky as bits of that copySpec even live in the distribution package one level above. I see what I can do to make it a bit more readable though (named parameters sound like a good idea for now)", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484234379", "createdAt": "2020-09-07T07:30:50Z", "author": {"login": "breskeby"}, "path": "distribution/archives/build.gradle", "diffHunk": "@@ -17,39 +17,11 @@\n  * under the License.\n  */\n \n-import org.elasticsearch.gradle.BuildPlugin\n-import org.elasticsearch.gradle.EmptyDirTask\n-import org.elasticsearch.gradle.LoggedExec\n import org.elasticsearch.gradle.MavenFilteringHack\n-import org.elasticsearch.gradle.VersionProperties\n-import org.elasticsearch.gradle.info.BuildParams\n-import org.elasticsearch.gradle.plugin.PluginBuildPlugin\n-import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar\n-import groovy.io.FileType\n import java.nio.file.Files\n import java.nio.file.Path\n \n-// need this so Zip/Tar tasks get basic defaults...\n-apply plugin: 'base'\n-\n-// CopySpec does not make it easy to create an empty directory so we\n-// create the directory that we want, and then point CopySpec to its\n-// parent to copy to the root of the distribution\n-ext.logsDir = new File(buildDir, 'logs-hack/logs')\n-tasks.register('createLogsDir', EmptyDirTask) {\n-  dir = \"${logsDir}\"\n-  dirMode = 0755\n-}\n-ext.pluginsDir = new File(buildDir, 'plugins-hack/plugins')\n-tasks.register('createPluginsDir', EmptyDirTask) {\n-  dir = \"${pluginsDir}\"\n-  dirMode = 0755\n-}\n-ext.jvmOptionsDir = new File(buildDir, 'jvm-options-hack/jvm.options.d')\n-tasks.register('createJvmOptionsDir', EmptyDirTask) {\n-  dir = \"${jvmOptionsDir}\"\n-  dirMode = 0750\n-}\n+apply plugin: 'elasticsearch.internal-distribution-archive-setup'\n \n CopySpec archiveFiles(CopySpec modulesFiles, String distributionType, String platform, String architecture, boolean oss, boolean jdk) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NTI1Mg=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTU1Njk0OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjozOToxMlrOHNdGjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMTo0MFrOHOhhgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MDM1MA==", "bodyText": "I'm not sure we need the \"build\" prefix convention here for container entries. The DSL is meant to describe a distribution, the the task that eventually constructs it. The latter is an implementation detail handled by the plugin. I think it makes more sense to create a darwinTar and then the plugin incidentally creates a buildDarwinTar task.", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483870350", "createdAt": "2020-09-04T22:39:12Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));\n+            });\n+        });\n+        project.getExtensions().add(\"distribution_archives\", container);\n+    }\n+\n+    private void configureGeneralTaskDefaults(Project project) {\n+        // common config across all copy / archive tasks\n+        project.getTasks().withType(AbstractCopyTask.class).configureEach(t -> {\n+            t.dependsOn(project.getTasks().withType(EmptyDirTask.class));\n+            t.setIncludeEmptyDirs(true);\n+            t.setDirMode(0755);\n+            t.setFileMode(0644);\n+        });\n+\n+        // common config across all archives\n+        project.getTasks().withType(AbstractArchiveTask.class).configureEach(t -> {\n+            String subdir = buildTaskToSubprojectName(t.getName());\n+            t.getDestinationDirectory().set(project.file(subdir + \"/build/distributions\"));\n+            t.getArchiveBaseName().set(subdir.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\");\n+        });\n+    }\n+\n+    private void configureTarDefaults(Project project) {\n+        // common config across all tars\n+        project.getTasks().withType(SymbolicLinkPreservingTar.class).configureEach(t -> {\n+            t.getArchiveExtension().set(\"tar.gz\");\n+            t.setCompression(Compression.GZIP);\n+        });\n+    }\n+\n+    private void registerEmptyDirectoryTasks(Project project) {\n+        // CopySpec does not make it easy to create an empty directory so we\n+        // create the directory that we want, and then point CopySpec to its\n+        // parent to copy to the root of the distribution\n+        File logsDir = new File(project.getBuildDir(), \"logs-hack/logs\");\n+        project.getExtensions().add(\"logsDir\", new File(project.getBuildDir(), \"logs-hack/logs\"));\n+        project.getTasks().register(\"createLogsDir\", EmptyDirTask.class, t -> {\n+            t.setDir(logsDir);\n+            t.setDirMode(0755);\n+        });\n+\n+        File pluginsDir = new File(project.getBuildDir(), \"plugins-hack/plugins\");\n+        project.getExtensions().add(\"pluginsDir\", pluginsDir);\n+        project.getTasks().register(\"createPluginsDir\", EmptyDirTask.class, t -> {\n+            t.setDir(pluginsDir);\n+            t.setDirMode(0755);\n+        });\n+\n+        File jvmOptionsDir = new File(project.getBuildDir(), \"jvm-options-hack/jvm.options.d\");\n+        project.getExtensions().add(\"jvmOptionsDir\", jvmOptionsDir);\n+        project.getTasks().register(\"createJvmOptionsDir\", EmptyDirTask.class, t -> {\n+            t.setDir(jvmOptionsDir);\n+            t.setDirMode(0750);\n+        });\n+    }\n+\n+    private String buildTaskToSubprojectName(String taskName) {\n+        return taskName.substring(\"build\".length()).replaceAll(\"[A-Z]\", \"-$0\").toLowerCase().substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MTM2MA==", "bodyText": "fixed", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484991360", "createdAt": "2020-09-08T15:01:40Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));\n+            });\n+        });\n+        project.getExtensions().add(\"distribution_archives\", container);\n+    }\n+\n+    private void configureGeneralTaskDefaults(Project project) {\n+        // common config across all copy / archive tasks\n+        project.getTasks().withType(AbstractCopyTask.class).configureEach(t -> {\n+            t.dependsOn(project.getTasks().withType(EmptyDirTask.class));\n+            t.setIncludeEmptyDirs(true);\n+            t.setDirMode(0755);\n+            t.setFileMode(0644);\n+        });\n+\n+        // common config across all archives\n+        project.getTasks().withType(AbstractArchiveTask.class).configureEach(t -> {\n+            String subdir = buildTaskToSubprojectName(t.getName());\n+            t.getDestinationDirectory().set(project.file(subdir + \"/build/distributions\"));\n+            t.getArchiveBaseName().set(subdir.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\");\n+        });\n+    }\n+\n+    private void configureTarDefaults(Project project) {\n+        // common config across all tars\n+        project.getTasks().withType(SymbolicLinkPreservingTar.class).configureEach(t -> {\n+            t.getArchiveExtension().set(\"tar.gz\");\n+            t.setCompression(Compression.GZIP);\n+        });\n+    }\n+\n+    private void registerEmptyDirectoryTasks(Project project) {\n+        // CopySpec does not make it easy to create an empty directory so we\n+        // create the directory that we want, and then point CopySpec to its\n+        // parent to copy to the root of the distribution\n+        File logsDir = new File(project.getBuildDir(), \"logs-hack/logs\");\n+        project.getExtensions().add(\"logsDir\", new File(project.getBuildDir(), \"logs-hack/logs\"));\n+        project.getTasks().register(\"createLogsDir\", EmptyDirTask.class, t -> {\n+            t.setDir(logsDir);\n+            t.setDirMode(0755);\n+        });\n+\n+        File pluginsDir = new File(project.getBuildDir(), \"plugins-hack/plugins\");\n+        project.getExtensions().add(\"pluginsDir\", pluginsDir);\n+        project.getTasks().register(\"createPluginsDir\", EmptyDirTask.class, t -> {\n+            t.setDir(pluginsDir);\n+            t.setDirMode(0755);\n+        });\n+\n+        File jvmOptionsDir = new File(project.getBuildDir(), \"jvm-options-hack/jvm.options.d\");\n+        project.getExtensions().add(\"jvmOptionsDir\", jvmOptionsDir);\n+        project.getTasks().register(\"createJvmOptionsDir\", EmptyDirTask.class, t -> {\n+            t.setDir(jvmOptionsDir);\n+            t.setDirMode(0750);\n+        });\n+    }\n+\n+    private String buildTaskToSubprojectName(String taskName) {\n+        return taskName.substring(\"build\".length()).replaceAll(\"[A-Z]\", \"-$0\").toLowerCase().substring(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MDM1MA=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTU2MjQ5OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjo0Mjo0NlrOHNdJhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMjoyM1rOHOhjnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MTExMQ==", "bodyText": "Is there no public API to accomplish this?", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483871111", "createdAt": "2020-09-04T22:42:46Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNDc0NA==", "bodyText": "Unfortunately there isn't as far as I can tell. I also reached out to the gradle folks in slack and in the forum at https://discuss.gradle.org/t/registering-a-directory-type-variant-backed-by-a-custom-copy-task/37486/2 but so far no feedback", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484234744", "createdAt": "2020-09-07T07:31:32Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MTExMQ=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MTkwMw==", "bodyText": "I changed the implementation here to rely on a different configuration for the explodedDist. This allows us to not rely on internal api and makes the setup a bit simpler", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484991903", "createdAt": "2020-09-08T15:02:23Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MTExMQ=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTU2NjE5OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjo0NToyOFrOHNdLlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMjozMlrOHOhj-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MTYzNw==", "bodyText": "Shouldn't these be extra properties instead of extensions? I assume there's not too much difference but extensions end up get decorated by Gradle at runtime which we probably don't need in this case.", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483871637", "createdAt": "2020-09-04T22:45:28Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));\n+            });\n+        });\n+        project.getExtensions().add(\"distribution_archives\", container);\n+    }\n+\n+    private void configureGeneralTaskDefaults(Project project) {\n+        // common config across all copy / archive tasks\n+        project.getTasks().withType(AbstractCopyTask.class).configureEach(t -> {\n+            t.dependsOn(project.getTasks().withType(EmptyDirTask.class));\n+            t.setIncludeEmptyDirs(true);\n+            t.setDirMode(0755);\n+            t.setFileMode(0644);\n+        });\n+\n+        // common config across all archives\n+        project.getTasks().withType(AbstractArchiveTask.class).configureEach(t -> {\n+            String subdir = buildTaskToSubprojectName(t.getName());\n+            t.getDestinationDirectory().set(project.file(subdir + \"/build/distributions\"));\n+            t.getArchiveBaseName().set(subdir.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\");\n+        });\n+    }\n+\n+    private void configureTarDefaults(Project project) {\n+        // common config across all tars\n+        project.getTasks().withType(SymbolicLinkPreservingTar.class).configureEach(t -> {\n+            t.getArchiveExtension().set(\"tar.gz\");\n+            t.setCompression(Compression.GZIP);\n+        });\n+    }\n+\n+    private void registerEmptyDirectoryTasks(Project project) {\n+        // CopySpec does not make it easy to create an empty directory so we\n+        // create the directory that we want, and then point CopySpec to its\n+        // parent to copy to the root of the distribution\n+        File logsDir = new File(project.getBuildDir(), \"logs-hack/logs\");\n+        project.getExtensions().add(\"logsDir\", new File(project.getBuildDir(), \"logs-hack/logs\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MTk5Mg==", "bodyText": "good point. fixed.", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484991992", "createdAt": "2020-09-08T15:02:32Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionArchiveSetupPlugin.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.EmptyDirTask;\n+import org.elasticsearch.gradle.tar.SymbolicLinkPreservingTar;\n+import org.gradle.api.NamedDomainObjectContainer;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.artifacts.type.ArtifactTypeDefinition;\n+import org.gradle.api.internal.artifacts.ArtifactAttributes;\n+import org.gradle.api.internal.artifacts.ConfigurationVariantInternal;\n+import org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact;\n+import org.gradle.api.plugins.BasePlugin;\n+import org.gradle.api.tasks.AbstractCopyTask;\n+import org.gradle.api.tasks.Copy;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.tasks.bundling.AbstractArchiveTask;\n+import org.gradle.api.tasks.bundling.Compression;\n+import org.gradle.api.tasks.bundling.Zip;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+/**\n+ * Provides a DSL and common configurations to define different types of\n+ * Elasticsearch distribution archives. See ':distribution:archives'.\n+ *\n+ * This configures the default artifacts for the distribution specific\n+ * subprojects. We have subprojects for two reasons:\n+ * 1. Gradle project substitutions can only bind to the default\n+ *    configuration of a project\n+ * 2. The integ-test-zip and zip distributions have the exact same\n+ *    filename, so they must be placed in different directories.\n+ * 3. We provide a packed and an unpacked variant of the distribution\n+ *    - the unpacked variant is used by consumers like test cluster definitions\n+ */\n+public class InternalDistributionArchiveSetupPlugin implements Plugin<Project> {\n+\n+    private NamedDomainObjectContainer<DistributionArchive> container;\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getPlugins().apply(BasePlugin.class);\n+        registerAndConfigureDistributionArchivesExtension(project);\n+        registerEmptyDirectoryTasks(project);\n+        configureGeneralTaskDefaults(project);\n+        configureTarDefaults(project);\n+    }\n+\n+    private void registerAndConfigureDistributionArchivesExtension(Project project) {\n+        container = project.container(DistributionArchive.class, name -> {\n+            var subProjectDir = buildTaskToSubprojectName(name);\n+            var copyDistributionTaskName = name.substring(0, name.length() - 3);\n+            var explodedDist = project.getTasks()\n+                .register(copyDistributionTaskName, Copy.class, copy -> copy.into(subProjectDir + \"/build/install/\"));\n+            return name.endsWith(\"Tar\")\n+                ? new DistributionArchive(project.getTasks().register(name, SymbolicLinkPreservingTar.class), explodedDist, name)\n+                : new DistributionArchive(project.getTasks().register(name, Zip.class), explodedDist, name);\n+        });\n+        // Each defined distribution archive is linked to a subproject.\n+        // A distribution archive definition not matching a sub project will result in build failure.\n+        container.whenObjectAdded(distributionArchive -> {\n+            var subProjectName = buildTaskToSubprojectName(distributionArchive.getArchiveTask().getName());\n+            project.project(subProjectName, sub -> {\n+                sub.getPlugins().apply(\"base\");\n+                sub.getArtifacts().add(\"default\", distributionArchive.getArchiveTask());\n+                var explodedArchiveTask = distributionArchive.getExplodedArchiveTask();\n+                var defaultConfiguration = sub.getConfigurations().getByName(\"default\");\n+                var publications = defaultConfiguration.getOutgoing();\n+                var variant = (ConfigurationVariantInternal) publications.getVariants().maybeCreate(\"directory\");\n+                variant.getAttributes().attribute(ArtifactAttributes.ARTIFACT_FORMAT, ArtifactTypeDefinition.DIRECTORY_TYPE);\n+                variant.artifactsProvider(() -> Collections.singletonList(new DirectoryPublishArtifact(explodedArchiveTask)));\n+            });\n+        });\n+        project.getExtensions().add(\"distribution_archives\", container);\n+    }\n+\n+    private void configureGeneralTaskDefaults(Project project) {\n+        // common config across all copy / archive tasks\n+        project.getTasks().withType(AbstractCopyTask.class).configureEach(t -> {\n+            t.dependsOn(project.getTasks().withType(EmptyDirTask.class));\n+            t.setIncludeEmptyDirs(true);\n+            t.setDirMode(0755);\n+            t.setFileMode(0644);\n+        });\n+\n+        // common config across all archives\n+        project.getTasks().withType(AbstractArchiveTask.class).configureEach(t -> {\n+            String subdir = buildTaskToSubprojectName(t.getName());\n+            t.getDestinationDirectory().set(project.file(subdir + \"/build/distributions\"));\n+            t.getArchiveBaseName().set(subdir.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\");\n+        });\n+    }\n+\n+    private void configureTarDefaults(Project project) {\n+        // common config across all tars\n+        project.getTasks().withType(SymbolicLinkPreservingTar.class).configureEach(t -> {\n+            t.getArchiveExtension().set(\"tar.gz\");\n+            t.setCompression(Compression.GZIP);\n+        });\n+    }\n+\n+    private void registerEmptyDirectoryTasks(Project project) {\n+        // CopySpec does not make it easy to create an empty directory so we\n+        // create the directory that we want, and then point CopySpec to its\n+        // parent to copy to the root of the distribution\n+        File logsDir = new File(project.getBuildDir(), \"logs-hack/logs\");\n+        project.getExtensions().add(\"logsDir\", new File(project.getBuildDir(), \"logs-hack/logs\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MTYzNw=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTU3MTAyOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/DistributionDownloadPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjo0OToxNVrOHNdOaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMjozN1rOHOhkPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MjM2Mw==", "bodyText": "I think this should be resolveArchiveFormat.", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483872363", "createdAt": "2020-09-04T22:49:15Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/DistributionDownloadPlugin.java", "diffHunk": "@@ -124,13 +124,22 @@ void setupDistributions(Project project) {\n             dependencies.add(distribution.configuration.getName(), resolvedDependency);\n             // no extraction allowed for rpm, deb or docker\n             if (distribution.getType().shouldExtract()) {\n+                distribution.configuration.getAttributes()\n+                    .attribute(ArtifactAttributes.ARTIFACT_FORMAT, resolveArtifactFormat(distribution));\n                 // The extracted configuration depends on the artifact directly but has\n                 // an artifact transform registered to resolve it as an unpacked folder.\n                 dependencies.add(distribution.getExtracted().getName(), resolvedDependency);\n             }\n         }\n     }\n \n+    private String resolveArtifactFormat(ElasticsearchDistribution distribution) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjA2MA==", "bodyText": "changed", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484992060", "createdAt": "2020-09-08T15:02:37Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/DistributionDownloadPlugin.java", "diffHunk": "@@ -124,13 +124,22 @@ void setupDistributions(Project project) {\n             dependencies.add(distribution.configuration.getName(), resolvedDependency);\n             // no extraction allowed for rpm, deb or docker\n             if (distribution.getType().shouldExtract()) {\n+                distribution.configuration.getAttributes()\n+                    .attribute(ArtifactAttributes.ARTIFACT_FORMAT, resolveArtifactFormat(distribution));\n                 // The extracted configuration depends on the artifact directly but has\n                 // an artifact transform registered to resolve it as an unpacked folder.\n                 dependencies.add(distribution.getExtracted().getName(), resolvedDependency);\n             }\n         }\n     }\n \n+    private String resolveArtifactFormat(ElasticsearchDistribution distribution) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MjM2Mw=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTU3NzMzOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/DistributionDownloadPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMjo1Mzo0MlrOHNdR4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMzoyMFrOHOhmHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MzI0OQ==", "bodyText": "Is this strictly required? If we don't add any attributes shouldn't it default to to a particular variant? If not, any way we can avoid having to explicitly determine the archive type here and use something generic for both zip and tar?", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r483873249", "createdAt": "2020-09-04T22:53:42Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/DistributionDownloadPlugin.java", "diffHunk": "@@ -124,13 +124,22 @@ void setupDistributions(Project project) {\n             dependencies.add(distribution.configuration.getName(), resolvedDependency);\n             // no extraction allowed for rpm, deb or docker\n             if (distribution.getType().shouldExtract()) {\n+                distribution.configuration.getAttributes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjU0Mw==", "bodyText": "I changed the providing setup to rely on different configurations instead (default and extended). This means we do not need that bit anymore", "url": "https://github.com/elastic/elasticsearch/pull/61592#discussion_r484992543", "createdAt": "2020-09-08T15:03:20Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/DistributionDownloadPlugin.java", "diffHunk": "@@ -124,13 +124,22 @@ void setupDistributions(Project project) {\n             dependencies.add(distribution.configuration.getName(), resolvedDependency);\n             // no extraction allowed for rpm, deb or docker\n             if (distribution.getType().shouldExtract()) {\n+                distribution.configuration.getAttributes()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3MzI0OQ=="}, "originalCommit": {"oid": "e76b07ef39845fadc683321d4dc5431aa72a3119"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 727, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}