{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MTAyNjE1", "number": 51244, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNTo0MToxNFrODZYWhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDo1NjozMVrODaYsZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTM5OTcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNTo0MToxNFrOFfu8Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNTo0MToxNFrOFfu8Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxOTIxMA==", "bodyText": "Without the fix to not close the credentials, this line would fail with:\n\nSecureString has already been closed", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368819210", "createdAt": "2020-01-21T05:41:14Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTYxNTY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzo1NToxNVrOFfw9Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMzozMjo0NFrOFhTLiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1MjMxNA==", "bodyText": "A minor comment: Is it worthwhile to wrap the ActionListeners earlier on so that we don't have to call credentials.close() in multiple places. That is once we know credentials is not null, we can have:\nvar credentialsClosingListener = ActionListener.wrap(...);\nThen just use the new listener in subsequent code. At this point, it may be worthwhile to extract this part of code into a new method.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368852314", "createdAt": "2020-01-21T07:55:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -301,10 +301,15 @@ void authenticateWithApiKeyIfPresent(ThreadContext ctx, ActionListener<Authentic\n                         .request();\n                 executeAsyncWithOrigin(ctx, SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {\n                     if (response.isExists()) {\n-                        try (ApiKeyCredentials ignore = credentials) {\n-                            final Map<String, Object> source = response.getSource();\n-                            validateApiKeyCredentials(docId, source, credentials, clock, listener);\n-                        }\n+                        final Map<String, Object> source = response.getSource();\n+                        validateApiKeyCredentials(docId, source, credentials, clock, ActionListener.wrap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2MTU3OQ==", "bodyText": "Good idea, I'll see how it looks.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370461579", "createdAt": "2020-01-24T03:32:44Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -301,10 +301,15 @@ void authenticateWithApiKeyIfPresent(ThreadContext ctx, ActionListener<Authentic\n                         .request();\n                 executeAsyncWithOrigin(ctx, SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {\n                     if (response.isExists()) {\n-                        try (ApiKeyCredentials ignore = credentials) {\n-                            final Map<String, Object> source = response.getSource();\n-                            validateApiKeyCredentials(docId, source, credentials, clock, listener);\n-                        }\n+                        final Map<String, Object> source = response.getSource();\n+                        validateApiKeyCredentials(docId, source, credentials, clock, ActionListener.wrap(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1MjMxNA=="}, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTY0MTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODowNzo0NlrOFfxNSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDowMzoyNFrOFhTc0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA==", "bodyText": "Mainly curious: it really takes 2 seconds for the notify to work?", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368856394", "createdAt": "2020-01-21T08:07:46Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);\n+\n+        assertThat(hashCounter.get(), equalTo(1));\n+        if (future2.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future2.actionGet());\n+        }\n+\n+        synchronized (hashWait) {\n+            hashWait.notify();\n+        }\n+\n+        assertThat(future1.actionGet(TimeValue.timeValueSeconds(2)).isAuthenticated(), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2MjAxNw==", "bodyText": "No, but in these tests there's a delicate balance between not having the tests run too long and not getting noise.\nThis should be done in milliseconds. But if the VM that running CI get slowed down for some reason, or we get really long GC pause, and this takes 1.5 seconds, that shouldn't cause the test to fail.\nWe want a time that is long enough that the timeout means \"this is never going to happen, the test failed\" but not so long that you're sitting there wondering if the test is ever going to be done.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370462017", "createdAt": "2020-01-24T03:35:41Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);\n+\n+        assertThat(hashCounter.get(), equalTo(1));\n+        if (future2.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future2.actionGet());\n+        }\n+\n+        synchronized (hashWait) {\n+            hashWait.notify();\n+        }\n+\n+        assertThat(future1.actionGet(TimeValue.timeValueSeconds(2)).isAuthenticated(), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA=="}, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2NjAwMg==", "bodyText": "Thanks that makes sense.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370466002", "createdAt": "2020-01-24T04:03:24Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);\n+\n+        assertThat(hashCounter.get(), equalTo(1));\n+        if (future2.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future2.actionGet());\n+        }\n+\n+        synchronized (hashWait) {\n+            hashWait.notify();\n+        }\n+\n+        assertThat(future1.actionGet(TimeValue.timeValueSeconds(2)).isAuthenticated(), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA=="}, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTY0NTYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODowOTo0MFrOFfxPtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDozODoxNFrOFhTwxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NzAxMw==", "bodyText": "Trivial: Could probably replace this with a CompletableFuture object? If so, could save a couple of lines.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368857013", "createdAt": "2020-01-21T08:09:40Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3MTExMQ==", "bodyText": "I used a semaphore instead, but thanks for the prompt. When I wrote the test I planned to come back and replace the wait/notify with something else after it was all working, but I forgot.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370471111", "createdAt": "2020-01-24T04:38:14Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NzAxMw=="}, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MDA3NTk2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDozNjo0MVrOFf1XQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDozNjo0MVrOFf1XQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyNDQ4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Call the top level method because it has been know to be buggy in async situations\n          \n          \n            \n                    // Call the top level method because it has been known to be buggy in async situations", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368924480", "createdAt": "2020-01-21T10:36:41Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTk0MTQ4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpProxy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDo1NjozMVrOFhT7XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDo1NjozMVrOFhT7XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3MzgyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public  HttpProxy(String host, Integer port, Scheme scheme) {\n          \n          \n            \n                public HttpProxy(String host, Integer port, Scheme scheme) {", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370473820", "createdAt": "2020-01-24T04:56:31Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpProxy.java", "diffHunk": "@@ -32,7 +32,7 @@ public HttpProxy(String host, Integer port) {\n         this.port = port;\n     }\n \n-    public HttpProxy(String host, Integer port, Scheme scheme) {\n+    public  HttpProxy(String host, Integer port, Scheme scheme) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b59c67ac4d042e70f0b642df5d631b363b4b5b37"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4397, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}