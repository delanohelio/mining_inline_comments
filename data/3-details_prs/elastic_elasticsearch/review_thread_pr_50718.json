{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMTg5MDE0", "number": 50718, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MDoyNlrODYQdrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDoxN1rODY5Bnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzYyMTU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MDoyNlrOFeAvnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MDoyNlrOFeAvnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxMzc4OA==", "bodyText": "Can you add a comment above this about why we are setting it to zero (for future code spelunkers)", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367013788", "createdAt": "2020-01-15T17:40:26Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -70,6 +71,7 @@ public void performAction(IndexMetaData indexMetaData, ClusterState currentClust\n \n         // Calling rollover with no conditions will always roll over the index\n         RolloverRequest rolloverRequest = new RolloverRequest(rolloverAlias, null);\n+        rolloverRequest.setWaitForActiveShards(ActiveShardCount.NONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NzYyNjkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MjoxNFrOFeAy2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MjoxNFrOFeAy2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNDYxOA==", "bodyText": "We should check for this to be null here (in the event the index was deleted immediately prior to the invocation), our other ClusterStateWaitSteps have this null check", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367014618", "createdAt": "2020-01-15T17:42:14Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.List;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODQyOTU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjozNjoyNFrOFeIsrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjozNjoyNFrOFeIsrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NDEwOQ==", "bodyText": "I think we can return a more descriptive information object here, something like \"waiting for 3 shards to become active, currently 2 are active\" or something that includes the amount we're waiting for and the amount currently active.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367144109", "createdAt": "2020-01-15T22:36:24Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.List;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +\n+                \"one index\";\n+            IndexMetaData indexMetaData = indices.get(0);\n+            rolledIndexName = indexMetaData.getIndex().getName();\n+            waitForActiveShardsSettingValue = indexMetaData.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        return new Result(activeShardCount.enoughShardsActive(clusterState, rolledIndexName), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4615f8e23006c9d3c0416d7e864d26afc64ec7a"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MTEyMDA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1MzozOVrOFeiUnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDo0MjoxOFrOFe7DOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzkzMw==", "bodyText": "this assertion doesn't stand in a CCR environment", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367563933", "createdAt": "2020-01-16T17:53:39Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2OTA4MA==", "bodyText": "coming up with the fix by parsing the number from the index name and finding the rolled index by \"max number\"", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367969080", "createdAt": "2020-01-17T14:42:18Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzkzMw=="}, "originalCommit": {"oid": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDIxOTgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyNToyOFrOFe__cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyNToyOFrOFe__cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MDAzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String rolledIndexName;\n          \n          \n            \n                    final String rolledIndexName;", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368050035", "createdAt": "2020-01-17T17:25:28Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDIyMDMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyNTozN1rOFe__wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyNTozN1rOFe__wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MDExMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String waitForActiveShardsSettingValue;\n          \n          \n            \n                    final String waitForActiveShardsSettingValue;", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368050113", "createdAt": "2020-01-17T17:25:37Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDIyODM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyODo0NVrOFfAErQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyODo0NVrOFfAErQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTM3Mw==", "bodyText": "Can we return the above log message as part of the \"info\" ToXContent object here? Otherwise this could stick in false forever and the user would never know why", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368051373", "createdAt": "2020-01-17T17:28:45Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI0NzY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzozNjoyNVrOFfAQQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzozNjoyNVrOFfAQQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDMzOQ==", "bodyText": "I think we should remove this assert and throw a regular error", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368054339", "createdAt": "2020-01-17T17:36:25Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI1MTIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzozNzozNlrOFfASYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDoyNjo1NFrOFfZw7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDg4MQ==", "bodyText": "This should catch the NumberFormatException and format it into a nicer, more human readable exception. It's possible to hit this if someone were to take an index foo-000003 and snapshot it, then restore it with a different name (like foo-000003-restored for example), this would flip out but it wouldn't be clear why.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368054881", "createdAt": "2020-01-17T17:37:36Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjMwMw==", "bodyText": "I've kept the exception handling light here as this step follows closely the RolloverStep (which would not succeed in the example you illustrated as the source index would not match the ^.*-\\d+$ pattern). Its visibility is package default solely for testing purposes.\nI guess renames and such could occur between steps, so I'll add the exception handling and remove the assumptions.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368472303", "createdAt": "2020-01-20T10:26:54Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDg4MQ=="}, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI2Mjc5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0MjoxOFrOFfAZmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0MjoxOFrOFfAZmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NjczMQ==", "bodyText": "I believe this PARSER is never actually used?", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368056731", "createdAt": "2020-01-17T17:42:18Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI2Njg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDowN1rOFfAcNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDowN1rOFfAcNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzM5Nw==", "bodyText": "Minor nit, but we should keep these lowercase, and I don't think we need a trailing period (these are more like error messages than sentences)", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368057397", "createdAt": "2020-01-17T17:44:07Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",\n+            a -> new Info((long) a[0], (String) a[1], (boolean) a[2]));\n+\n+        static {\n+            PARSER.declareLong(ConstructingObjectParser.constructorArg(), CURRENT_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareString(ConstructingObjectParser.constructorArg(), TARGET_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENOUGH_SHARDS_ACTIVE);\n+            PARSER.declareString((i, s) -> {\n+            }, MESSAGE);\n+        }\n+\n+        public Info(long currentActiveShardsCount, String targetActiveShardsCount, boolean enoughShardsActive) {\n+            this.currentActiveShardsCount = currentActiveShardsCount;\n+            this.targetActiveShardsCount = targetActiveShardsCount;\n+            this.enoughShardsActive = enoughShardsActive;\n+\n+            if (enoughShardsActive) {\n+                message = \"The target of [\" + targetActiveShardsCount + \"] are active. Don't need to wait anymore.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI2NzE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDoxN1rOFfAccQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDoxN1rOFfAccQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzQ1Nw==", "bodyText": "Same about lowercasing/trailing-period here.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368057457", "createdAt": "2020-01-17T17:44:17Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",\n+            a -> new Info((long) a[0], (String) a[1], (boolean) a[2]));\n+\n+        static {\n+            PARSER.declareLong(ConstructingObjectParser.constructorArg(), CURRENT_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareString(ConstructingObjectParser.constructorArg(), TARGET_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENOUGH_SHARDS_ACTIVE);\n+            PARSER.declareString((i, s) -> {\n+            }, MESSAGE);\n+        }\n+\n+        public Info(long currentActiveShardsCount, String targetActiveShardsCount, boolean enoughShardsActive) {\n+            this.currentActiveShardsCount = currentActiveShardsCount;\n+            this.targetActiveShardsCount = targetActiveShardsCount;\n+            this.enoughShardsActive = enoughShardsActive;\n+\n+            if (enoughShardsActive) {\n+                message = \"The target of [\" + targetActiveShardsCount + \"] are active. Don't need to wait anymore.\";\n+            } else {\n+                message = \"Waiting for [\" + targetActiveShardsCount + \"] shards to become active, but only [\" + currentActiveShardsCount +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 157}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4909, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}