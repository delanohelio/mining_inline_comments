{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NzEwMDU1", "number": 61993, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMjowMTozN1rOEpSL0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMjoxMFrOEy-5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzI1MDA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ccr/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ccr/AutoFollowIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMjowMTozN1rOHa3mqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMjowMTozN1rOHa3mqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzNjA0Mg==", "bodyText": "Can you add a test where an auto-follow pattern is added after the leader cluster has created a data stream?", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r497936042", "createdAt": "2020-10-01T02:01:37Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ccr/AutoFollowIT.java", "diffHunk": "@@ -163,12 +172,142 @@ public void testPutAutoFollowPatternThatOverridesRequiredLeaderSetting() throws\n         );\n     }\n \n+    public void testDataStreams() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzI5Mjc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMjoxMzoxNlrOHa4Dsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDowNzowMVrOHp7dEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzQ3NA==", "bodyText": "Can we make this change directly in RestoreService? A SnapshotInfo from CcrReposity should contain the data streams from the leader cluster?", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r497943474", "createdAt": "2020-10-01T02:13:16Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -158,9 +165,24 @@ public void onFailure(Exception e) {\n \n             @Override\n             protected void doRun() {\n-                restoreService.restoreSnapshot(restoreRequest,\n-                    ActionListener.delegateFailure(listener,\n-                        (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)));\n+                ActionListener<RestoreService.RestoreCompletionResponse> delegatelistener = ActionListener.delegateFailure(\n+                    listener,\n+                    (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)\n+                );\n+                if (remoteDataStream == null) {\n+                    restoreService.restoreSnapshot(restoreRequest, delegatelistener);\n+                } else {\n+                    String followerIndexName = request.getFollowerIndex();\n+                    BiConsumer<ClusterState, Metadata.Builder> updater = (currentState, mdBuilder) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEwMDA4OQ==", "bodyText": "Let me see if that works. If so, then I agree that is a cleaner change.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r498100089", "createdAt": "2020-10-01T09:16:23Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -158,9 +165,24 @@ public void onFailure(Exception e) {\n \n             @Override\n             protected void doRun() {\n-                restoreService.restoreSnapshot(restoreRequest,\n-                    ActionListener.delegateFailure(listener,\n-                        (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)));\n+                ActionListener<RestoreService.RestoreCompletionResponse> delegatelistener = ActionListener.delegateFailure(\n+                    listener,\n+                    (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)\n+                );\n+                if (remoteDataStream == null) {\n+                    restoreService.restoreSnapshot(restoreRequest, delegatelistener);\n+                } else {\n+                    String followerIndexName = request.getFollowerIndex();\n+                    BiConsumer<ClusterState, Metadata.Builder> updater = (currentState, mdBuilder) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzQ3NA=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5MzI2Ng==", "bodyText": "The RestoreService currently only restores the data stream metadata if a data stream needs to be restored or an entire snapshot. In the case that a specific backing index is restored the associated data stream isn't restored. The put follow only 'restores' a backing index at a time and if this logic would be included in RestoreService then I think we always need to load and check global metadata state in order to determine whether an index is a backing index of a data stream (when #61525 is merged then some backing indices may not follow the backing index naming scheme).\nI think we would need to introduce additional parameter on RestoreSnapshotRequest to indicate that we intent to restore a backing index and therefor the associated data stream should be restored as well (or existing local data stream should be updated). Otherwise regular restore operations would always need to load the global metadata state in order to determine whether an index is a backing index of a data stream. Do you think that this is still an improvement over the current logic?", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r508593266", "createdAt": "2020-10-20T15:10:49Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -158,9 +165,24 @@ public void onFailure(Exception e) {\n \n             @Override\n             protected void doRun() {\n-                restoreService.restoreSnapshot(restoreRequest,\n-                    ActionListener.delegateFailure(listener,\n-                        (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)));\n+                ActionListener<RestoreService.RestoreCompletionResponse> delegatelistener = ActionListener.delegateFailure(\n+                    listener,\n+                    (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)\n+                );\n+                if (remoteDataStream == null) {\n+                    restoreService.restoreSnapshot(restoreRequest, delegatelistener);\n+                } else {\n+                    String followerIndexName = request.getFollowerIndex();\n+                    BiConsumer<ClusterState, Metadata.Builder> updater = (currentState, mdBuilder) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzQ3NA=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyNzc2MA==", "bodyText": "Ok, let's keep the current implementation. We can look into the improvement once the datastream becomes mature.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r513727760", "createdAt": "2020-10-28T20:07:01Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -158,9 +165,24 @@ public void onFailure(Exception e) {\n \n             @Override\n             protected void doRun() {\n-                restoreService.restoreSnapshot(restoreRequest,\n-                    ActionListener.delegateFailure(listener,\n-                        (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)));\n+                ActionListener<RestoreService.RestoreCompletionResponse> delegatelistener = ActionListener.delegateFailure(\n+                    listener,\n+                    (delegatedListener, response) -> afterRestoreStarted(clientWithHeaders, request, delegatedListener, response)\n+                );\n+                if (remoteDataStream == null) {\n+                    restoreService.restoreSnapshot(restoreRequest, delegatelistener);\n+                } else {\n+                    String followerIndexName = request.getFollowerIndex();\n+                    BiConsumer<ClusterState, Metadata.Builder> updater = (currentState, mdBuilder) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzQ3NA=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDE3ODEyOnYy", "diffSide": "RIGHT", "path": "docs/reference/ccr/auto-follow.asciidoc", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDo0ODozN1rOHb7NMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzoxMDo1NVrOHkNiwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzYzMg==", "bodyText": "@martijnvg, this is great! I'm trying to clarify this statement and landed on two renditions. Please let me know if the condensed version or the longer version is most appropriate without losing meaning.\nCondensed version\n\nWhen a data stream name matches an auto-follow pattern on the remote cluster, only new backing indices are followed. If you create a data stream after creating an auto-follow pattern, all backing indices are followed.\n\nLonger version\n\nYou can also create auto-follow patterns for data streams. When a new backing index is generated on a remote cluster, that index and its data stream are followed automatically if the data stream name matches an auto-follow pattern. If you create a data stream after creating an auto-follow pattern, all backing indices are followed automatically.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r499043632", "createdAt": "2020-10-02T20:48:37Z", "author": {"login": "lockewritesdocs"}, "path": "docs/reference/ccr/auto-follow.asciidoc", "diffHunk": "@@ -7,6 +7,13 @@ each new index in the series is replicated automatically. Whenever the name of\n a new index on the remote cluster matches the auto-follow pattern, a\n corresponding follower index is added to the local cluster.\n \n+Data streams can also be auto followed. If a new backing index's data stream name\n+on the remote cluster matches with the auto-follow pattern then that index and\n+data stream is also auto followed. If a data stream is created on or after the\n+moment the auto follow pattern is created then all backing indices are auto\n+followed, otherwise only the backing indices on or after the creation of\n+the auto follow pattern are auto followed.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY2ODkwMQ==", "bodyText": "@dnhatn, is the condensed version in my previous comment still technically accurate? If so, I can commit the change to this branch.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r499668901", "createdAt": "2020-10-05T15:05:50Z", "author": {"login": "lockewritesdocs"}, "path": "docs/reference/ccr/auto-follow.asciidoc", "diffHunk": "@@ -7,6 +7,13 @@ each new index in the series is replicated automatically. Whenever the name of\n a new index on the remote cluster matches the auto-follow pattern, a\n corresponding follower index is added to the local cluster.\n \n+Data streams can also be auto followed. If a new backing index's data stream name\n+on the remote cluster matches with the auto-follow pattern then that index and\n+data stream is also auto followed. If a data stream is created on or after the\n+moment the auto follow pattern is created then all backing indices are auto\n+followed, otherwise only the backing indices on or after the creation of\n+the auto follow pattern are auto followed.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzYzMg=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3Njk5OQ==", "bodyText": "I prefer the longer version. It's easier to understand.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r499676999", "createdAt": "2020-10-05T15:16:57Z", "author": {"login": "dnhatn"}, "path": "docs/reference/ccr/auto-follow.asciidoc", "diffHunk": "@@ -7,6 +7,13 @@ each new index in the series is replicated automatically. Whenever the name of\n a new index on the remote cluster matches the auto-follow pattern, a\n corresponding follower index is added to the local cluster.\n \n+Data streams can also be auto followed. If a new backing index's data stream name\n+on the remote cluster matches with the auto-follow pattern then that index and\n+data stream is also auto followed. If a data stream is created on or after the\n+moment the auto follow pattern is created then all backing indices are auto\n+followed, otherwise only the backing indices on or after the creation of\n+the auto follow pattern are auto followed.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzYzMg=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczMjY3NA==", "bodyText": "Thanks @lockewritesdocs! I also prefer the longer version.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r507732674", "createdAt": "2020-10-19T13:10:55Z", "author": {"login": "martijnvg"}, "path": "docs/reference/ccr/auto-follow.asciidoc", "diffHunk": "@@ -7,6 +7,13 @@ each new index in the series is replicated automatically. Whenever the name of\n a new index on the remote cluster matches the auto-follow pattern, a\n corresponding follower index is added to the local cluster.\n \n+Data streams can also be auto followed. If a new backing index's data stream name\n+on the remote cluster matches with the auto-follow pattern then that index and\n+data stream is also auto followed. If a data stream is created on or after the\n+moment the auto follow pattern is created then all backing indices are auto\n+followed, otherwise only the backing indices on or after the creation of\n+the auto follow pattern are auto followed.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzYzMg=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODk1NDkxOnYy", "diffSide": "RIGHT", "path": "docs/reference/ccr/auto-follow.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo0Njo1N1rOHclb1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo0OTo1NFrOHclifA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNTUxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Data streams can also be auto followed. If a new backing index's data stream name\n          \n          \n            \n            on the remote cluster matches with the auto-follow pattern then that index and\n          \n          \n            \n            data stream is also auto followed. If a data stream is created on or after the\n          \n          \n            \n            moment the auto follow pattern is created then all backing indices are auto\n          \n          \n            \n            followed, otherwise only the backing indices on or after the creation of\n          \n          \n            \n            the auto follow pattern are auto followed.\n          \n          \n            \n            You can also create auto-follow patterns for data streams. When a new backing\n          \n          \n            \n            index is generated on a remote cluster, that index and its data stream are\n          \n          \n            \n            automatically followed if the data stream name matches an auto-follow\n          \n          \n            \n            pattern. If you create a data stream after creating the auto-follow pattern,\n          \n          \n            \n            all backing indices are followed automatically.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r499735510", "createdAt": "2020-10-05T16:46:57Z", "author": {"login": "lockewritesdocs"}, "path": "docs/reference/ccr/auto-follow.asciidoc", "diffHunk": "@@ -7,6 +7,13 @@ each new index in the series is replicated automatically. Whenever the name of\n a new index on the remote cluster matches the auto-follow pattern, a\n corresponding follower index is added to the local cluster.\n \n+Data streams can also be auto followed. If a new backing index's data stream name\n+on the remote cluster matches with the auto-follow pattern then that index and\n+data stream is also auto followed. If a data stream is created on or after the\n+moment the auto follow pattern is created then all backing indices are auto\n+followed, otherwise only the backing indices on or after the creation of\n+the auto follow pattern are auto followed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNzIxMg==", "bodyText": "Applying suggest changes based on input from @dnhatn.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r499737212", "createdAt": "2020-10-05T16:49:54Z", "author": {"login": "lockewritesdocs"}, "path": "docs/reference/ccr/auto-follow.asciidoc", "diffHunk": "@@ -7,6 +7,13 @@ each new index in the series is replicated automatically. Whenever the name of\n a new index on the remote cluster matches the auto-follow pattern, a\n corresponding follower index is added to the local cluster.\n \n+Data streams can also be auto followed. If a new backing index's data stream name\n+on the remote cluster matches with the auto-follow pattern then that index and\n+data stream is also auto followed. If a data stream is created on or after the\n+moment the auto follow pattern is created then all backing indices are auto\n+followed, otherwise only the backing indices on or after the creation of\n+the auto follow pattern are auto followed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNTUxMA=="}, "originalCommit": {"oid": "715dfe3532cbfc17fc84512ba6be168b973e0449"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODk0NDMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMToyNFrOHp7mbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoxMDo1NFrOHsLJVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDE1OQ==", "bodyText": "I think we can't use the generation from the remoteDataStream as it will break the assertion in DataStream's constructor. For example, here we are following .ds-1 and the ds generation on the remote is 2 already.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r513730159", "createdAt": "2020-10-28T20:11:24Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI0NDU5OQ==", "bodyText": "That assertion will be removed: https://github.com/elastic/elasticsearch/pull/61525/files#diff-c1a5087d37ad81d4b2339167eadc38bcee234a4f7d646b7b4b193ae665075334L60\nThis to support migrating write alias with indices to a data stream. It was added as sanity check\ninitially, because backing indices were created by Elasticsearch exclusively.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r514244599", "createdAt": "2020-10-29T13:09:14Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDE1OQ=="}, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MjAwNg==", "bodyText": "Ok", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r516082006", "createdAt": "2020-11-02T16:10:54Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDE1OQ=="}, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODk0NzA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMjoxMFrOHp7oFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwOToxNzoyNFrOHsl2qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDU4MQ==", "bodyText": "What if the generation of the local datastream is higher than the remote?", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r513730581", "createdAt": "2020-10-28T20:12:10Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),\n+                List.of(backingIndexToFollow), remoteDataStream.getGeneration(), remoteDataStream.getMetadata());\n+        } else {\n+            List<Index> backingIndices = new ArrayList<>(localDataStream.getIndices());\n+            backingIndices.add(backingIndexToFollow);\n+\n+            // When following an older backing index it should be positioned before the newer backing indices.\n+            // Currently the assumption is that the newest index (highest generation) is the write index.\n+            // (just appending an older backing index to the list of backing indices would break that assumption)\n+            // (string sorting works because of the naming backing index naming scheme)\n+            backingIndices.sort(Comparator.comparing(Index::getName));\n+\n+            return new DataStream(localDataStream.getName(), localDataStream.getTimeStampField(), backingIndices,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI1MzU0MA==", "bodyText": "The generation isn't really used yet, so there isn't a real consequence when the local data stream's generation is higher than the leader's data stream.\nThis would happen if the local data stream would be rollover independently. This is possible, but shouldn't really happen. Because that would create an index that doesn't follow anything and will remain empty and unused. The rollover should only occur in the remote cluster.\nSo I think we should try to prevent data streams from being rolled over when that data stream is actually just following another data stream. What I think we can do for this is add a flag to a data stream that it is replicated and a rollover would disallow rolling over a replicated data stream. When unfollowing that data stream, the replicate flag would be unset. What do you think about this?", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r514253540", "createdAt": "2020-10-29T13:23:03Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),\n+                List.of(backingIndexToFollow), remoteDataStream.getGeneration(), remoteDataStream.getMetadata());\n+        } else {\n+            List<Index> backingIndices = new ArrayList<>(localDataStream.getIndices());\n+            backingIndices.add(backingIndexToFollow);\n+\n+            // When following an older backing index it should be positioned before the newer backing indices.\n+            // Currently the assumption is that the newest index (highest generation) is the write index.\n+            // (just appending an older backing index to the list of backing indices would break that assumption)\n+            // (string sorting works because of the naming backing index naming scheme)\n+            backingIndices.sort(Comparator.comparing(Index::getName));\n+\n+            return new DataStream(localDataStream.getName(), localDataStream.getTimeStampField(), backingIndices,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDU4MQ=="}, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MTM1Nw==", "bodyText": "So I think we should try to prevent data streams from being rolled over when that data stream is actually just following another data stream. What I think we can do for this is add a flag to a data stream that it is replicated and a rollover would disallow rolling over a replicated data stream. When unfollowing that data stream, the replicate flag would be unset. What do you think about this?\n\n+1. This makes a lot of sense.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r516081357", "createdAt": "2020-11-02T16:10:03Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),\n+                List.of(backingIndexToFollow), remoteDataStream.getGeneration(), remoteDataStream.getMetadata());\n+        } else {\n+            List<Index> backingIndices = new ArrayList<>(localDataStream.getIndices());\n+            backingIndices.add(backingIndexToFollow);\n+\n+            // When following an older backing index it should be positioned before the newer backing indices.\n+            // Currently the assumption is that the newest index (highest generation) is the write index.\n+            // (just appending an older backing index to the list of backing indices would break that assumption)\n+            // (string sorting works because of the naming backing index naming scheme)\n+            backingIndices.sort(Comparator.comparing(Index::getName));\n+\n+            return new DataStream(localDataStream.getName(), localDataStream.getTimeStampField(), backingIndices,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDU4MQ=="}, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNjE3Mg==", "bodyText": "Martijn will implement this in a follow up.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r516406172", "createdAt": "2020-11-03T03:08:31Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),\n+                List.of(backingIndexToFollow), remoteDataStream.getGeneration(), remoteDataStream.getMetadata());\n+        } else {\n+            List<Index> backingIndices = new ArrayList<>(localDataStream.getIndices());\n+            backingIndices.add(backingIndexToFollow);\n+\n+            // When following an older backing index it should be positioned before the newer backing indices.\n+            // Currently the assumption is that the newest index (highest generation) is the write index.\n+            // (just appending an older backing index to the list of backing indices would break that assumption)\n+            // (string sorting works because of the naming backing index naming scheme)\n+            backingIndices.sort(Comparator.comparing(Index::getName));\n+\n+            return new DataStream(localDataStream.getName(), localDataStream.getTimeStampField(), backingIndices,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDU4MQ=="}, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUxOTU5Mw==", "bodyText": "Yes, in a followup PR, I will add an additional field to DataStream class that indicates that it is a replicated data stream. Then in the rollover api validation will be added that prevents rolling over a replicated data stream.", "url": "https://github.com/elastic/elasticsearch/pull/61993#discussion_r516519593", "createdAt": "2020-11-03T09:17:24Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutFollowAction.java", "diffHunk": "@@ -211,6 +244,29 @@ private void initiateFollowing(\n         ));\n     }\n \n+    static DataStream updateLocalDataStream(Index backingIndexToFollow,\n+                                            DataStream localDataStream,\n+                                            DataStream remoteDataStream) {\n+        if (localDataStream == null) {\n+            // The data stream and the backing indices have been created and validated in the remote cluster,\n+            // just copying the data stream is in this case safe.\n+            return new DataStream(remoteDataStream.getName(), remoteDataStream.getTimeStampField(),\n+                List.of(backingIndexToFollow), remoteDataStream.getGeneration(), remoteDataStream.getMetadata());\n+        } else {\n+            List<Index> backingIndices = new ArrayList<>(localDataStream.getIndices());\n+            backingIndices.add(backingIndexToFollow);\n+\n+            // When following an older backing index it should be positioned before the newer backing indices.\n+            // Currently the assumption is that the newest index (highest generation) is the write index.\n+            // (just appending an older backing index to the list of backing indices would break that assumption)\n+            // (string sorting works because of the naming backing index naming scheme)\n+            backingIndices.sort(Comparator.comparing(Index::getName));\n+\n+            return new DataStream(localDataStream.getName(), localDataStream.getTimeStampField(), backingIndices,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMDU4MQ=="}, "originalCommit": {"oid": "efac2e45687d828f0cf7fb587289ed53f6ff9a82"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1755, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}