{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMDgyNzA0", "number": 51894, "title": "SQL: Fix ORDER BY on aggregates and GROUPed BY fields", "bodyText": "Previously, in the in-memory sorting module\nLocalAggregationSorterListener only the aggregate functions where used\n(grabbed by the sortingColumns). As a consequence, if the ORDER BY\nwas also using columns of the GROUP BY clause, (especially in the case\nof higher priority - before the aggregate functions) wrong results were\nproduced. E.g.:\nSELECT gender, MAX(salary) AS max FROM test_emp\nGROUP BY gender\nORDER BY gender, max\n\nAdd all columns of the ORDER BY to the sortingColumns so that the\nLocalAggregationSorterListener can use the correct comparators in\nthe underlying PriorityQueue used to implement the in-memory sorting.\nFixes: #50355", "createdAt": "2020-02-04T22:29:47Z", "url": "https://github.com/elastic/elasticsearch/pull/51894", "merged": true, "mergeCommit": {"oid": "be680af11c823292c2d115bff01658f7b75abd76"}, "closed": true, "closedAt": "2020-02-12T08:37:37Z", "author": {"login": "matriv"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBJOsUAH2gAyMzcxMDgyNzA0OmI0OWEyM2NlNTY0ODNmNzE5OWJlN2NiMjY0MTkxMDkxNTAzNmM3NDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDXjB6AH2gAyMzcxMDgyNzA0OjYzN2E5Zjk1OTE1NDJlOWJiMjNhMWQ0NDM1NTBiMTA0ZTQzYmVjNDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b49a23ce56483f7199be7cb2641910915036c741", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/b49a23ce56483f7199be7cb2641910915036c741", "committedDate": "2020-02-04T22:25:12Z", "message": "SQL: Fix ORDER BY on aggregates and GROUPed BY fields\n\nPreviously, in the in-memory sorting module\n`LocalAggregationSorterListener` only the aggregate functions where used\n(grabbed by the `sortingColumns`). As a consequence, if the ORDER BY\nwas also using columns of the GROUP BY clause, (especially in the case\nof higher priority - before the aggregate functions) wrong results were\nproduced. E.g.:\n```\nSELECT gender, MAX(salary) AS max FROM test_emp\nGROUP BY gender\nORDER BY gender, max\n```\n\nAdd all columns of the ORDER BY to the `sortingColumns` so that the\n`LocalAggregationSorterListener` can use the correct comparators in\nthe underlying PriorityQueue used to implement the in-memory sorting.\n\nFixes: #50355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/a68c6ded5058e7a77824ab0cabb35155db027a8b", "committedDate": "2020-02-05T00:13:12Z", "message": "Merge remote-tracking branch 'upstream/master' into fix-50355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90cb862906c76bb26f78862da76f6fe0471bc853", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/90cb862906c76bb26f78862da76f6fe0471bc853", "committedDate": "2020-02-05T12:00:51Z", "message": "make field private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab0c62787068fbf465e051b9e425447c24bda026", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab0c62787068fbf465e051b9e425447c24bda026", "committedDate": "2020-02-05T12:00:59Z", "message": "Merge remote-tracking branch 'upstream/master' into fix-50355"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNjU4NTgy", "url": "https://github.com/elastic/elasticsearch/pull/51894#pullrequestreview-353658582", "createdAt": "2020-02-05T11:52:59Z", "commit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTo1Mjo1OVrOFl1IeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMjowMDowNlrOFl1TgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjE1Mg==", "bodyText": "Why not breaking early, if there's the first AggregateSort found?", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212152", "createdAt": "2020-02-05T11:52:59Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjYwOA==", "bodyText": "atIndex == -1", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212608", "createdAt": "2020-02-05T11:54:05Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;\n             }\n-            sortingColumns.add(tuple);\n         }\n-        \n+\n+        // If no custom sort is used break early\n         if (customSort == null) {\n-            customSort = Boolean.valueOf(aggSort);\n+            customSort = Boolean.FALSE;\n+            return emptyList();\n         }\n \n-        return aggSort ? sortingColumns : emptyList();\n+        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n+        for (Sort s: sort) {\n+            int atIndex = -1;\n+            for (int i = 0; i < fields.size(); i++) {\n+                Tuple<FieldExtraction, String> field = fields.get(i);\n+                if (field.v2().equals(s.id())) {\n+                    atIndex = i;\n+                    break;\n+                }\n+            }\n+            if (atIndex==-1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjc1Nw==", "bodyText": "Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212757", "createdAt": "2020-02-05T11:54:27Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;\n             }\n-            sortingColumns.add(tuple);\n         }\n-        \n+\n+        // If no custom sort is used break early\n         if (customSort == null) {\n-            customSort = Boolean.valueOf(aggSort);\n+            customSort = Boolean.FALSE;\n+            return emptyList();\n         }\n \n-        return aggSort ? sortingColumns : emptyList();\n+        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n+        for (Sort s: sort) {\n+            int atIndex = -1;\n+            for (int i = 0; i < fields.size(); i++) {\n+                Tuple<FieldExtraction, String> field = fields.get(i);\n+                if (field.v2().equals(s.id())) {\n+                    atIndex = i;\n+                    break;\n+                }\n+            }\n+            if (atIndex==-1) {\n+                throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n+            }\n+            // assemble a comparator for it\n+            Comparator comp = s.direction()==Sort.Direction.ASC ? Comparator.naturalOrder():Comparator.reverseOrder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxMjg1Mg==", "bodyText": "comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375212852", "createdAt": "2020-02-05T11:54:41Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -134,45 +133,39 @@ public QueryContainer(Query query,\n             return emptyList();\n         }\n \n-        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n-\n-        boolean aggSort = false;\n         for (Sort s : sort) {\n-            Tuple<Integer, Comparator> tuple = new Tuple<>(Integer.valueOf(-1), null);\n-            \n             if (s instanceof AggregateSort) {\n-                AggregateSort as = (AggregateSort) s;\n-                // find the relevant column of each aggregate function\n-                AggregateFunction af = as.agg();\n-\n-                aggSort = true;\n-                int atIndex = -1;\n-                String id = Expressions.id(af);\n-\n-                for (int i = 0; i < fields.size(); i++) {\n-                    Tuple<FieldExtraction, String> field = fields.get(i);\n-                    if (field.v2().equals(id)) {\n-                        atIndex = i;\n-                        break;\n-                    }\n-                }\n-                if (atIndex == -1) {\n-                    throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n-                }\n-                // assemble a comparator for it\n-                Comparator comp = s.direction() == Sort.Direction.ASC ? Comparator.naturalOrder() : Comparator.reverseOrder();\n-                comp = s.missing() == Sort.Missing.FIRST ? Comparator.nullsFirst(comp) : Comparator.nullsLast(comp);\n-\n-                tuple = new Tuple<>(Integer.valueOf(atIndex), comp);\n+                customSort = Boolean.TRUE;\n             }\n-            sortingColumns.add(tuple);\n         }\n-        \n+\n+        // If no custom sort is used break early\n         if (customSort == null) {\n-            customSort = Boolean.valueOf(aggSort);\n+            customSort = Boolean.FALSE;\n+            return emptyList();\n         }\n \n-        return aggSort ? sortingColumns : emptyList();\n+        List<Tuple<Integer, Comparator>> sortingColumns = new ArrayList<>(sort.size());\n+        for (Sort s: sort) {\n+            int atIndex = -1;\n+            for (int i = 0; i < fields.size(); i++) {\n+                Tuple<FieldExtraction, String> field = fields.get(i);\n+                if (field.v2().equals(s.id())) {\n+                    atIndex = i;\n+                    break;\n+                }\n+            }\n+            if (atIndex==-1) {\n+                throw new SqlIllegalArgumentException(\"Cannot find backing column for ordering aggregation [{}]\", s);\n+            }\n+            // assemble a comparator for it\n+            Comparator comp = s.direction()==Sort.Direction.ASC ? Comparator.naturalOrder():Comparator.reverseOrder();\n+            comp = s.missing()==Sort.Missing.FIRST ? Comparator.nullsFirst(comp):Comparator.nullsLast(comp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDk3Nw==", "bodyText": "Did you explore the idea of having the id as part of Sort, as I'm seeing a lot of repeated code? (skimming through this PR's changes, the id seems to be introduced in all classes inheriting Sort). I am probably missing something that prevents this approach to be used, would love to hear the reasons.", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r375214977", "createdAt": "2020-02-05T12:00:06Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/container/ScoreSort.java", "diffHunk": "@@ -8,13 +8,22 @@\n import java.util.Objects;\n \n public class ScoreSort extends Sort {\n-    public ScoreSort(Direction direction, Missing missing) {\n+\n+    final String id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a68c6ded5058e7a77824ab0cabb35155db027a8b"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d25c93fda2f51bf9b343e8ced01ab724a18c47d", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d25c93fda2f51bf9b343e8ced01ab724a18c47d", "committedDate": "2020-02-05T12:12:02Z", "message": "fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaf2bd3805852294ebfc8be12a613b4f44c82776", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/aaf2bd3805852294ebfc8be12a613b4f44c82776", "committedDate": "2020-02-05T12:14:47Z", "message": "break from loop once custom sort is recognized"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNjc3OTMx", "url": "https://github.com/elastic/elasticsearch/pull/51894#pullrequestreview-353677931", "createdAt": "2020-02-05T12:28:48Z", "commit": {"oid": "aaf2bd3805852294ebfc8be12a613b4f44c82776"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTc3ODI3", "url": "https://github.com/elastic/elasticsearch/pull/51894#pullrequestreview-355177827", "createdAt": "2020-02-07T14:07:18Z", "commit": {"oid": "aaf2bd3805852294ebfc8be12a613b4f44c82776"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1ec293d57854afa1cdf46cac39d3a78549e0b12", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1ec293d57854afa1cdf46cac39d3a78549e0b12", "committedDate": "2020-02-11T18:07:02Z", "message": "change approach - add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65a1ca34bee5b9f4ee16d6bf4ad08cf04897dcb0", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/65a1ca34bee5b9f4ee16d6bf4ad08cf04897dcb0", "committedDate": "2020-02-11T18:07:19Z", "message": "Merge remote-tracking branch 'upstream/master' into fix-50355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b9700ef80131a3cc88022991c6c9983d294ca9", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/46b9700ef80131a3cc88022991c6c9983d294ca9", "committedDate": "2020-02-11T18:10:16Z", "message": "revert changes to untouched files"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTU4MDgy", "url": "https://github.com/elastic/elasticsearch/pull/51894#pullrequestreview-356958082", "createdAt": "2020-02-11T20:07:38Z", "commit": {"oid": "46b9700ef80131a3cc88022991c6c9983d294ca9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDowNzozOFrOFoXW4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDowNzozOFrOFoXW4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3MDA0OA==", "bodyText": "Nit: or else -> else or otherwise", "url": "https://github.com/elastic/elasticsearch/pull/51894#discussion_r377870048", "createdAt": "2020-02-11T20:07:38Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/execution/search/Querier.java", "diffHunk": "@@ -594,36 +594,51 @@ public final void onFailure(Exception ex) {\n             this.sortingColumns = sortingColumns;\n         }\n \n-        // compare row based on the received attribute sort\n-        // if a sort item is not in the list, it is assumed the sorting happened in ES\n-        // and the results are left as is (by using the row ordering), otherwise it is sorted based on the given criteria.\n-        //\n-        // Take for example ORDER BY a, x, b, y\n-        // a, b - are sorted in ES\n-        // x, y - need to be sorted client-side\n-        // sorting on x kicks in, only if the values for a are equal.\n-\n+        /**\n+         * Compare row based on the received attribute sort\n+         * <ul>\n+         *     <li>\n+         *         If a tuple in {@code sortingColumns} has a null comparator, it is assumed the sorting\n+         *         happened in ES and the results are left as is (by using the row ordering), otherwise it is\n+         *         sorted based on the given criteria.\n+         *     </li>\n+         *     <li>\n+         *         If no tuple exists in {@code sortingColumns} for an output column, it means this column\n+         *         is not included at all in the ORDER BY\n+         *     </li>\n+         *</ul>\n+         *\n+         * Take for example ORDER BY a, x, b, y\n+         * a, b - are sorted in ES\n+         * x, y - need to be sorted client-side\n+         * sorting on x kicks in only if the values for a are equal.\n+         * sorting on y kicks in only if the values for a, x and b are all equal\n+         *\n+         */\n         // thanks to @jpountz for the row ordering idea as a way to preserve ordering\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         protected boolean lessThan(Tuple<List<?>, Integer> l, Tuple<List<?>, Integer> r) {\n             for (Tuple<Integer, Comparator> tuple : sortingColumns) {\n-                int i = tuple.v1().intValue();\n+                int columnIdx = tuple.v1().intValue();\n                 Comparator comparator = tuple.v2();\n \n-                Object vl = l.v1().get(i);\n-                Object vr = r.v1().get(i);\n+                // Get the values for left and right rows at the current column index\n+                Object vl = l.v1().get(columnIdx);\n+                Object vr = r.v1().get(columnIdx);\n                 if (comparator != null) {\n                     int result = comparator.compare(vl, vr);\n-                    // if things are equals, move to the next comparator\n+                    // if things are not equal: return the comparison result,\n+                    // or else: move to the next comparator to solve the tie.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46b9700ef80131a3cc88022991c6c9983d294ca9"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "637a9f9591542e9bb23a1d443550b104e43bec41", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/637a9f9591542e9bb23a1d443550b104e43bec41", "committedDate": "2020-02-11T20:13:56Z", "message": "Address comment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2801, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}