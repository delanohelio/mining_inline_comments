{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NDc2Mjkw", "number": 54312, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyOToyOFrODshwyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowODoyNlrODtcWJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE3MDk5OnYy", "diffSide": "RIGHT", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyOToyOFrOF9bOXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyOToyOFrOF9bOXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwMQ==", "bodyText": "should we check before the unblock that cancelFuture.isDone == false?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399953501", "createdAt": "2020-03-30T06:29:28Z", "author": {"login": "ywelsch"}, "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -159,7 +162,9 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         logger.debug(\"unblocking the blocked update\");\n         ALLOWED_OPERATIONS.release(builder.request().getSlices());\n-\n+        ListTasksResponse cancelTasksResponse = cancelFuture.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE3NjgyOnYy", "diffSide": "RIGHT", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjozMTo1OVrOF9bR4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjozMTo1OVrOF9bR4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NDQwMw==", "bodyText": "Given the test change here, I wonder if there should be an option for task cancellation to say whether it should wait for its children to be cancelled / completed before returning. As soon as the parent is cancelled, we know that eventually the children will be cancelled (not yet guaranteed by the current implementation, but something we eventually want with the keepalive).", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399954403", "createdAt": "2020-03-30T06:31:59Z", "author": {"login": "ywelsch"}, "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -131,16 +132,18 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         // Cancel the request while the action is blocked by the indexing operation listeners.\n         // This will prevent further requests from being sent.\n-        ListTasksResponse cancelTasksResponse = client().admin().cluster().prepareCancelTasks().setTaskId(mainTask.getTaskId()).get();\n-        cancelTasksResponse.rethrowFailures(\"Cancel\");\n-        assertThat(cancelTasksResponse.getTasks(), hasSize(1));\n+        ActionFuture<CancelTasksResponse> cancelFuture = client().admin().cluster().prepareCancelTasks()\n+            .setTaskId(mainTask.getTaskId()).execute();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE4OTQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjozNzoxNVrOF9bZdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODozOToxM1rOF93Ilg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw==", "bodyText": "In theory, we could coordinate the banning / unbanning on a per-node basis, i.e., as soon as the parent is cancelled, and all requests from a child node have completed, we can send an unban to that node. I don't think that this optimization is needed (as it might make the code unnecessarily more complex), just thought I should mention it.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399956343", "createdAt": "2020-03-30T06:37:15Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMDc3NA==", "bodyText": "Ok, I will try to implement this in a follow-up if it's simple.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400410774", "createdAt": "2020-03-30T18:39:13Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE5NjMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjozOTo1MVrOF9bdgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjozOTo1MVrOF9bdgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzM3Ng==", "bodyText": "let's also log the childNodes here", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399957376", "createdAt": "2020-03-30T06:39:51Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDIwNzc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo0NDoyOFrOF9bkUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo1Mjo0N1rOF93nsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw==", "bodyText": "if (canceled == false) we're not calling groupedListener?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959123", "createdAt": "2020-03-30T06:44:28Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);\n+                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n+                },\n+                e -> {\n+                    try {\n+                        removeBanOnNodes(cancellableTask, childNodes);\n+                    } catch (Exception inner) {\n+                        e.addSuppressed(inner);\n                     }\n+                    listener.onFailure(e);\n                 });\n+            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (canceled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxODczNg==", "bodyText": "We throw exception at the end. Anyway, I moved up that statement right after we cancel (see a5af596).", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400418736", "createdAt": "2020-03-30T18:52:47Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);\n+                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n+                },\n+                e -> {\n+                    try {\n+                        removeBanOnNodes(cancellableTask, childNodes);\n+                    } catch (Exception inner) {\n+                        e.addSuppressed(inner);\n                     }\n+                    listener.onFailure(e);\n                 });\n+            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (canceled) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDIwOTcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo0NToxN1rOF9blfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo0NToxN1rOF9blfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTQyMA==", "bodyText": "log at trace level", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959420", "createdAt": "2020-03-30T06:45:17Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());\n+        GroupedActionListener<Void> groupedListener =\n+            new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n+        final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(\n+            new TaskId(clusterService.localNode().getId(), task.getId()), reason);\n+        for (DiscoveryNode node : childNodes) {\n+            transportService.sendRequest(node, BAN_PARENT_ACTION_NAME, banRequest,\n                 new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {\n                     @Override\n                     public void handleResponse(TransportResponse.Empty response) {\n-                        listener.onResponse(null);\n+                        groupedListener.onResponse(null);\n                     }\n \n                     @Override\n                     public void handleException(TransportException exp) {\n-                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-                        listener.onFailure(exp);\n+                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", banRequest.parentTaskId, node);\n+                        groupedListener.onFailure(exp);\n                     }\n                 });\n         }\n     }\n \n-    private void sendRemoveBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request, EmptyTransportResponseHandler\n-                .INSTANCE_SAME);\n+    private void removeBanOnNodes(CancellableTask task, Collection<DiscoveryNode> childNodes) {\n+        final BanParentTaskRequest request =\n+            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()));\n+        for (DiscoveryNode node : childNodes) {\n+            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDIyNTcwOnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1MTozN1rOF9bu5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODozOTo0OFrOF93J_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ==", "bodyText": "I wonder if we should leave this optimization in (and add a comment as well). This avoids computing the hash of the task id in order to look it up in the map.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399961829", "createdAt": "2020-03-30T06:51:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -163,7 +178,7 @@ private void registerCancellableTask(Task task) {\n         CancellableTaskHolder oldHolder = cancellableTasks.put(task.getId(), holder);\n         assert oldHolder == null;\n         // Check if this task was banned before we start it\n-        if (task.getParentTaskId().isSet() && banedParents.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMTEzMw==", "bodyText": "I restored and added a comment 297b787", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400411133", "createdAt": "2020-03-30T18:39:48Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -163,7 +178,7 @@ private void registerCancellableTask(Task task) {\n         CancellableTaskHolder oldHolder = cancellableTasks.put(task.getId(), holder);\n         assert oldHolder == null;\n         // Check if this task was banned before we start it\n-        if (task.getParentTaskId().isSet() && banedParents.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDIzNjAxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NToxNVrOF9b06A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NToxNVrOF9b06A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzM2OA==", "bodyText": "when do we expect this to happen?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963368", "createdAt": "2020-03-30T06:55:15Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDIzNjc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NTozNVrOF9b1bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0MjozNFrOF93P9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA==", "bodyText": "I'm not sure I understand this comment. Can you elaborate on this?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963500", "createdAt": "2020-03-30T06:55:35Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n+            // We still need to set ban on local node for persistent tasks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMjY2MQ==", "bodyText": "I don't know either. It's from the draft version. Sorry.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400412661", "createdAt": "2020-03-30T18:42:34Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n+            // We still need to set ban on local node for persistent tasks", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDIzOTU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NjozOFrOF9b3KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NjozOFrOF9b3KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2Mzk0NQ==", "bodyText": "perhaps call this onChildTasksCompleted?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963945", "createdAt": "2020-03-30T06:56:38Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI0NjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1ODo1OVrOF9b7Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1ODo1OVrOF9b7Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NDk3MA==", "bodyText": "any child tasks", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399964970", "createdAt": "2020-03-30T06:58:59Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI1MTExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowMDo0M1rOF9b9_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0Njo1MFrOF93Zkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg==", "bodyText": "perhaps runnable = {}, which avoids the null check later down", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399965692", "createdAt": "2020-03-30T07:00:43Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTEyMw==", "bodyText": "onChildTasksCompleted is still null if we do not cancel the task.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400415123", "createdAt": "2020-03-30T18:46:50Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI1NDk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowMjowNFrOF9cAWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowMjowNFrOF9cAWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjI5OA==", "bodyText": "why does this deserve a warning?\nWhen do we expect this to happen?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966298", "createdAt": "2020-03-30T07:02:04Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI1NzQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzowMzowMFrOF9cB1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0NzoyNVrOF93bAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ==", "bodyText": "Why use empty set here and not the actual set? Will this not lead to incorrectness?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966679", "createdAt": "2020-03-30T07:03:00Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());\n+                    pendingChildNodes = Collections.emptySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTQ4OQ==", "bodyText": "Good catch. Fixed in 226a541", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400415489", "createdAt": "2020-03-30T18:47:25Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());\n+                    pendingChildNodes = Collections.emptySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI4ODEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxMjo1NVrOF9cT3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0OTo1OVrOF93hHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw==", "bodyText": "I think that we need to actually capture the connection (not the DiscoveryNode object). The reason for this is cross-cluster connections. In the task cancellation action, we assume that the DiscoveryNode is sufficient to resolve the target of the cancellation. This only works for nodes in the same cluster, however.\nI don't think that we need to solve this all in this PR, but we need to capture the issue properly, and add an item to the planning.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971293", "createdAt": "2020-03-30T07:12:55Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNzA1Mw==", "bodyText": "++ see 4f337de", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400417053", "createdAt": "2020-03-30T18:49:59Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw=="}, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI5MDcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxMzo0M1rOF9cVgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxMzo0M1rOF9cVgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTcxMg==", "bodyText": "should we call this in a finally block?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971712", "createdAt": "2020-03-30T07:13:43Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI5MTE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxMzo1M1rOF9cVyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxMzo1M1rOF9cVyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTc4NQ==", "bodyText": "should we call this in a finally block?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971785", "createdAt": "2020-03-30T07:13:53Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);\n+                    }\n+\n+                    @Override\n+                    public void handleException(TransportException exp) {\n+                        unregisterChildNode.close();\n+                        delegate.handleException(exp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDI5NzIzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxNTo0NVrOF9cZWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxNTo0NVrOF9cZWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjY5OQ==", "bodyText": "assert that cancelFuture.isDone == false before disabling blocks?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399972699", "createdAt": "2020-03-30T07:15:45Z", "author": {"login": "ywelsch"}, "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java", "diffHunk": "@@ -151,8 +151,9 @@ public void testCancellationDuringQueryPhase() throws Exception {\n             .execute();\n \n         awaitForBlock(plugins);\n-        cancelSearch(SearchAction.NAME);\n+        ActionFuture<CancelTasksResponse> cancelFuture = cancelSearch(SearchAction.NAME);\n         disableBlocks(plugins);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDMwMzk4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxODowMVrOF9cdZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxODowMVrOF9cdZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MzczNQ==", "bodyText": "testBanOnly...", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399973735", "createdAt": "2020-03-30T07:18:01Z", "author": {"login": "ywelsch"}, "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.cluster.node.tasks;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionRunnable;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksResponse;\n+import org.elasticsearch.action.admin.cluster.node.tasks.list.ListTasksResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.plugins.ActionPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.tasks.CancellableTask;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.tasks.TaskManager;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportResponse;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class CancellableTasksIT extends ESIntegTestCase {\n+    static final Map<ChildRequest, CountDownLatch> arrivedLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> beforeExecuteLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> completedLatches = ConcurrentCollections.newConcurrentMap();\n+\n+    @Before\n+    public void resetTestStates() {\n+        arrivedLatches.clear();\n+        beforeExecuteLatches.clear();\n+        completedLatches.clear();\n+    }\n+\n+    public void testBandOnlyNodesWithOutstandingChildTasks() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTAyNDY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwODowMDoxM1rOF-JuEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoxMTo1NVrOF-mYRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA==", "bodyText": "I wonder if this message is misleading. The task could have been cancelled, but it could also have completed successfully before this request came in.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400715280", "createdAt": "2020-03-31T08:00:13Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjU0Mw==", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716543", "createdAt": "2020-03-31T08:02:20Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg5NDQ3Mw==", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.\n\nI thought about that scenario but decided not to implement it as I worried about its complexity (we need to keep track of a list of cancellation listeners and childTasksCompleted listeners). Anyway, I will work on it.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400894473", "createdAt": "2020-03-31T13:02:27Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkwMDA3OQ==", "bodyText": "Let's add a TODO for that part, and consider it in a follow-up", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400900079", "createdAt": "2020-03-31T13:10:28Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDgzOQ==", "bodyText": "The cancel() method is a bit trappy. I have removed the return value and made it idempotent in 9a55fe4.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401184839", "createdAt": "2020-03-31T20:11:55Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTAzNTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwODowMzowMlrOF-J0oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NToxN1rOF-l0TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA==", "bodyText": "basis", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716960", "createdAt": "2020-03-31T08:03:02Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n-        }  else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTYyOQ==", "bodyText": "thanks, fixed in a01325e", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175629", "createdAt": "2020-03-31T19:55:17Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n-        }  else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTM3MjkwOnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/api/tasks.cancel.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTozMjoyMFrOF-NK-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NTo0MFrOF-l1IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MTgzNQ==", "bodyText": "I prefer the wait_for_completion, as this is also about completing the cancellation of the parent task. Also, I think that the default should be false (also needs to be documented).", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400771835", "createdAt": "2020-03-31T09:32:20Z", "author": {"login": "ywelsch"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/tasks.cancel.json", "diffHunk": "@@ -39,6 +39,10 @@\n       \"parent_task_id\":{\n         \"type\":\"string\",\n         \"description\":\"Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.\"\n+      },\n+      \"wait_for_child_tasks\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTg0MA==", "bodyText": "++ I pushed 8cff3b0.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175840", "createdAt": "2020-03-31T19:55:40Z", "author": {"login": "dnhatn"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/tasks.cancel.json", "diffHunk": "@@ -39,6 +39,10 @@\n       \"parent_task_id\":{\n         \"type\":\"string\",\n         \"description\":\"Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.\"\n+      },\n+      \"wait_for_child_tasks\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MTgzNQ=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTkzOTM3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjoxMDoxMlrOF-Snmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NTo1N1rOF-l1tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw==", "bodyText": "shouldn't we get the default value from the cancelTasksRequest so we don't duplicate it?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400861083", "createdAt": "2020-03-31T12:10:12Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForChildTasks(request.paramAsBoolean(\"wait_for_child_tasks\", true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTk5MQ==", "bodyText": "yes, fixed in 8cff3b0.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175991", "createdAt": "2020-03-31T19:55:57Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForChildTasks(request.paramAsBoolean(\"wait_for_child_tasks\", true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTk2MDcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjoxNjoxNVrOF-S1EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1ODowM1rOF-l6LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA==", "bodyText": "I am curious about this: the child tasks are already cancelled or banned before the delete async search call returns?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400864528", "createdAt": "2020-03-31T12:16:15Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java", "diffHunk": "@@ -190,8 +193,11 @@ public void testDeleteCancelRunningTask() throws Exception {\n         SearchResponseIterator it =\n             assertBlockingIterator(indexName, new SearchSourceBuilder(), randomBoolean() ? 1 : 0, 2);\n         initial = it.next();\n-        deleteAsyncSearch(initial.getId());\n+        ActionFuture<AcknowledgedResponse> cancelFuture =\n+            client().execute(DeleteAsyncSearchAction.INSTANCE, new DeleteAsyncSearchAction.Request(initial.getId()));\n+        ensureChildTasksCancelledOrBanned(AsyncSearchId.decode(initial.getId()).getTaskId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEzMw==", "bodyText": "Yes, but this is an async call. Anyway, I've reverted this change as wait_for_completion now defaults to false.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401177133", "createdAt": "2020-03-31T19:58:03Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java", "diffHunk": "@@ -190,8 +193,11 @@ public void testDeleteCancelRunningTask() throws Exception {\n         SearchResponseIterator it =\n             assertBlockingIterator(indexName, new SearchSourceBuilder(), randomBoolean() ? 1 : 0, 2);\n         initial = it.next();\n-        deleteAsyncSearch(initial.getId());\n+        ActionFuture<AcknowledgedResponse> cancelFuture =\n+            client().execute(DeleteAsyncSearchAction.INSTANCE, new DeleteAsyncSearchAction.Request(initial.getId()));\n+        ensureChildTasksCancelledOrBanned(AsyncSearchId.decode(initial.getId()).getTaskId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTc1NzgzOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowNToxMVrOF-3ZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTozMTowMVrOF-4XrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg==", "bodyText": "Use this in TasksRequestConvertersTests?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401463562", "createdAt": "2020-04-01T09:05:11Z", "author": {"login": "ywelsch"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "diffHunk": "@@ -138,13 +150,21 @@ public Builder withNodesFiltered(List<String> nodes){\n             return this;\n         }\n \n+        public Builder withWaitForCompletion(boolean waitForCompletion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3OTU5Ng==", "bodyText": "As well as in TasksClientDocumentationIT to document it there as well?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401479596", "createdAt": "2020-04-01T09:31:01Z", "author": {"login": "ywelsch"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "diffHunk": "@@ -138,13 +150,21 @@ public Builder withNodesFiltered(List<String> nodes){\n             return this;\n         }\n \n+        public Builder withWaitForCompletion(boolean waitForCompletion) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg=="}, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTc2ODU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowODoxMVrOF-3f9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowODoxMVrOF-3f9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTMzNQ==", "bodyText": "call this getWaitForCompletion", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465335", "createdAt": "2020-04-01T09:08:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java", "diffHunk": "@@ -68,4 +77,16 @@ public CancelTasksRequest setReason(String reason) {\n     public String getReason() {\n         return reason;\n     }\n+\n+    /**\n+     * If {@code true}, the request blocks until the cancellation of the task and its child tasks is completed.\n+     * Otherwise, the request can return soon after the cancellation is started. Defaults to {@code false}.\n+     */\n+    public void setWaitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    public boolean waitForChildTasks() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTc2OTM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowODoyNlrOF-3gfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowODoyNlrOF-3gfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTQ2OA==", "bodyText": "instead of introducing this constant, just use cancelTasksRequest.getWaitForCompletion() here", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465468", "createdAt": "2020-04-01T09:08:26Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,8 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForCompletion(\n+            request.paramAsBoolean(\"wait_for_child_tasks\", CancelTasksRequest.DEFAULT_WAIT_FOR_COMPLETION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4031, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}