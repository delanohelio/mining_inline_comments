{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODA0Mjgy", "number": 59076, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxMjo1NFrOELwM9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzoxMjo1NlrOENFiWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzU5NTQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComposableIndexTemplate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxMjo1NFrOGtd_OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxMjo1NFrOGtd_OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzMDQyNQ==", "bodyText": "Can we make this a public static string so it can be referenced elsewhere?", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450330425", "createdAt": "2020-07-06T16:12:54Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComposableIndexTemplate.java", "diffHunk": "@@ -256,6 +257,10 @@ public String toString() {\n         private final String timestampField;\n \n         public DataStreamTemplate(String timestampField) {\n+            if (\"@timestamp\".equals(timestampField) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95e5b2cad41c9e9724b2db0575f378c7138b9cce"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzYwNTczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComposableIndexTemplate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxNToyMVrOGteFeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxNToyMVrOGteFeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzMjAyNA==", "bodyText": "Super minor:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return Map.of(\"_doc\", Map.of(TimestampFieldMapper.NAME, Map.of(\"path\", timestampField)));\n          \n          \n            \n                        return Map.of(MapperService.SINGLE_MAPPING_NAME, Map.of(TimestampFieldMapper.NAME, Map.of(\"path\", timestampField)));", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450332024", "createdAt": "2020-07-06T16:15:21Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComposableIndexTemplate.java", "diffHunk": "@@ -267,6 +272,13 @@ public String getTimestampField() {\n             this(in.readString());\n         }\n \n+        /**\n+         * @return a mapping snippet for a backing index with `_timestamp` meta field mapper properly configured.\n+         */\n+        public Map<String, Object> getDataSteamMappingSnippet() {\n+            return Map.of(\"_doc\", Map.of(TimestampFieldMapper.NAME, Map.of(\"path\", timestampField)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95e5b2cad41c9e9724b2db0575f378c7138b9cce"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzYyMDA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxOTowMFrOGteOaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowNDoyN1rOGtf4nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNDMxMg==", "bodyText": "I think we should transform this into an actual error, that way if we end up using it for the HLRC it doesn't fail to throw because assertions are disabled", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450334312", "createdAt": "2020-07-06T16:19:00Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "diffHunk": "@@ -213,67 +207,37 @@ public int hashCode() {\n     public static final class TimestampField implements Writeable, ToXContentObject {\n \n         static ParseField NAME_FIELD = new ParseField(\"name\");\n-        static ParseField FIELD_MAPPING_FIELD = new ParseField(\"mapping\");\n \n         @SuppressWarnings(\"unchecked\")\n         private static final ConstructingObjectParser<TimestampField, Void> PARSER = new ConstructingObjectParser<>(\n             \"timestamp_field\",\n-            args -> new TimestampField((String) args[0], (Map<String, Object>) args[1])\n+            args -> new TimestampField((String) args[0])\n         );\n \n         static {\n             PARSER.declareString(ConstructingObjectParser.constructorArg(), NAME_FIELD);\n-            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.mapOrdered(), FIELD_MAPPING_FIELD);\n         }\n \n         private final String name;\n-        private final Map<String, Object> fieldMapping;\n-\n-        public TimestampField(String name, Map<String, Object> fieldMapping) {\n-            assert fieldMapping.containsKey(\"type\") : \"no type defined for mapping of timestamp_field\";\n-            assert ALLOWED_TIMESTAMPFIELD_TYPES.contains(fieldMapping.get(\"type\")) :\n-                \"invalid type defined for mapping of timestamp_field\";\n \n+        public TimestampField(String name) {\n+            assert \"@timestamp\".equals(name) : \"unexpected timestamp field [\" + name + \"]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95e5b2cad41c9e9724b2db0575f378c7138b9cce"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2MTUwMA==", "bodyText": "I think HLRC uses its own DataStream pojo. I will change this from an assertion to an actual error.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450361500", "createdAt": "2020-07-06T17:04:27Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "diffHunk": "@@ -213,67 +207,37 @@ public int hashCode() {\n     public static final class TimestampField implements Writeable, ToXContentObject {\n \n         static ParseField NAME_FIELD = new ParseField(\"name\");\n-        static ParseField FIELD_MAPPING_FIELD = new ParseField(\"mapping\");\n \n         @SuppressWarnings(\"unchecked\")\n         private static final ConstructingObjectParser<TimestampField, Void> PARSER = new ConstructingObjectParser<>(\n             \"timestamp_field\",\n-            args -> new TimestampField((String) args[0], (Map<String, Object>) args[1])\n+            args -> new TimestampField((String) args[0])\n         );\n \n         static {\n             PARSER.declareString(ConstructingObjectParser.constructorArg(), NAME_FIELD);\n-            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.mapOrdered(), FIELD_MAPPING_FIELD);\n         }\n \n         private final String name;\n-        private final Map<String, Object> fieldMapping;\n-\n-        public TimestampField(String name, Map<String, Object> fieldMapping) {\n-            assert fieldMapping.containsKey(\"type\") : \"no type defined for mapping of timestamp_field\";\n-            assert ALLOWED_TIMESTAMPFIELD_TYPES.contains(fieldMapping.get(\"type\")) :\n-                \"invalid type defined for mapping of timestamp_field\";\n \n+        public TimestampField(String name) {\n+            assert \"@timestamp\".equals(name) : \"unexpected timestamp field [\" + name + \"]\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNDMxMg=="}, "originalCommit": {"oid": "95e5b2cad41c9e9724b2db0575f378c7138b9cce"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzYyNDc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoyMDowNFrOGteRIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowOToyM1rOGtgC_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNTAwOQ==", "bodyText": "This makes me wonder, this is fine as-is, but should we even bother having this class or specifying the name of the field if it's going to be hardcoded for the foreseeable future?", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450335009", "createdAt": "2020-07-06T16:20:04Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "diffHunk": "@@ -213,67 +207,37 @@ public int hashCode() {\n     public static final class TimestampField implements Writeable, ToXContentObject {\n \n         static ParseField NAME_FIELD = new ParseField(\"name\");\n-        static ParseField FIELD_MAPPING_FIELD = new ParseField(\"mapping\");\n \n         @SuppressWarnings(\"unchecked\")\n         private static final ConstructingObjectParser<TimestampField, Void> PARSER = new ConstructingObjectParser<>(\n             \"timestamp_field\",\n-            args -> new TimestampField((String) args[0], (Map<String, Object>) args[1])\n+            args -> new TimestampField((String) args[0])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95e5b2cad41c9e9724b2db0575f378c7138b9cce"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2NDE1Nw==", "bodyText": "I prefer to keep this class. I think that that the timestamp field will not stay hard coded for a long time.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450364157", "createdAt": "2020-07-06T17:09:23Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "diffHunk": "@@ -213,67 +207,37 @@ public int hashCode() {\n     public static final class TimestampField implements Writeable, ToXContentObject {\n \n         static ParseField NAME_FIELD = new ParseField(\"name\");\n-        static ParseField FIELD_MAPPING_FIELD = new ParseField(\"mapping\");\n \n         @SuppressWarnings(\"unchecked\")\n         private static final ConstructingObjectParser<TimestampField, Void> PARSER = new ConstructingObjectParser<>(\n             \"timestamp_field\",\n-            args -> new TimestampField((String) args[0], (Map<String, Object>) args[1])\n+            args -> new TimestampField((String) args[0])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNTAwOQ=="}, "originalCommit": {"oid": "95e5b2cad41c9e9724b2db0575f378c7138b9cce"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDc2NjQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjozMjo0OVrOGt8Ylw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMToxMDoxMVrOGvmsgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyODQzOQ==", "bodyText": "@dakrone I had to add this if statement otherwise the meta field mapper was going to be applied on each create index api call. In a docs test, the new logs-- composable index template was triggered by a regular create index api call and then the test failed, because the document being indexed had no timestamp field.\nI think only applying the meta field automatically makes sense for backing indices only and not when a user creates a new index via create index api and the index composable template matches?\nSee commits: a23d2e4, which then was superseded by: c787332", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450828439", "createdAt": "2020-07-07T12:32:49Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -902,6 +909,23 @@ public static String findV2Template(Metadata metadata, String indexName, boolean\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n+\n+        // Only include _timestamp mapping snippet if creating backing index.\n+        if (indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c78733204c12cf44b53026052aff9865d99ced03"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMTU3OA==", "bodyText": "Note currently in master, the _timestamp field gets only applied if the create index request originates from create data stream api and data stream rollover (signalled via CreateIndexClusterStateUpdateRequest#dataStreamName field), but now this logic moved MetadataIndexTemplateService.collectMappings(...) method, which didn't have that context.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r450831578", "createdAt": "2020-07-07T12:38:34Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -902,6 +909,23 @@ public static String findV2Template(Metadata metadata, String indexName, boolean\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n+\n+        // Only include _timestamp mapping snippet if creating backing index.\n+        if (indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyODQzOQ=="}, "originalCommit": {"oid": "c78733204c12cf44b53026052aff9865d99ced03"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3MDI0Mw==", "bodyText": "Would it be cleaner to pull this check out of collectMappings and into the caller? That way we could avoid the workaround here: https://github.com/elastic/elasticsearch/pull/59076/files#diff-115cd2f0fff9dd97acc95e1d29012a15R1075.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r452570243", "createdAt": "2020-07-10T01:10:11Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -902,6 +909,23 @@ public static String findV2Template(Metadata metadata, String indexName, boolean\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n+\n+        // Only include _timestamp mapping snippet if creating backing index.\n+        if (indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyODQzOQ=="}, "originalCommit": {"oid": "c78733204c12cf44b53026052aff9865d99ced03"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTU1MDMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComposableIndexTemplate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzowMDoxMlrOGvkiVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzowMDoxMlrOGvkiVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDg3MA==", "bodyText": "Noticed this typo as I was trying to pull up the method: DataSteam -> DataStream.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r452534870", "createdAt": "2020-07-09T23:00:12Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComposableIndexTemplate.java", "diffHunk": "@@ -267,6 +275,13 @@ public String getTimestampField() {\n             this(in.readString());\n         }\n \n+        /**\n+         * @return a mapping snippet for a backing index with `_timestamp` meta field mapper properly configured.\n+         */\n+        public Map<String, Object> getDataSteamMappingSnippet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5052d876998c61bb50fb9de20f2cff0b9de7a325"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTU2MTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzowNTozNFrOGvko7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzowNTozNFrOGvko7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNjU1OQ==", "bodyText": "Does TimestampFieldMapper need a path parameter now? We're not sure how we will eventually implement custom timestamp names, I can see an implementation where we don't use path here at all. So maybe we could simplify and just have an enabled boolean flag instead.\nDepending on the implementation, we can always add path later and just default to @timestamp if it's not specified.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r452536559", "createdAt": "2020-07-09T23:05:34Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -196,6 +196,10 @@ public void validate(DocumentFieldMappers lookup) {\n         }\n     }\n \n+    public String getPath() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5052d876998c61bb50fb9de20f2cff0b9de7a325"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTU3NjU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateDataStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzoxMjo1NlrOGvkxmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzozNjoyOVrOGxH4pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODc3OA==", "bodyText": "I think this error will be hard for end users to understand, since they shouldn't be aware of the _timestamp field. Maybe we won't even need this check, once we remove the ability to set timestamp_field, as discussed in #59317 (comment)?", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r452538778", "createdAt": "2020-07-09T23:12:56Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateDataStreamService.java", "diffHunk": "@@ -183,31 +169,16 @@ public static ComposableIndexTemplate lookupTemplateForDataStream(String dataStr\n     }\n \n     public static void validateTimestampFieldMapping(String timestampFieldName, MapperService mapperService) {\n-        MappedFieldType timestampFieldMapper = mapperService.fieldType(timestampFieldName);\n-        if (timestampFieldMapper == null) {\n-            throw new IllegalArgumentException(\"expected timestamp field [\" + timestampFieldName + \"], but found no timestamp field\");\n-        }\n-        String type = timestampFieldMapper.typeName();\n-        if (ALLOWED_TIMESTAMPFIELD_TYPES.contains(type) == false) {\n-            throw new IllegalArgumentException(\"expected timestamp field [\" + timestampFieldName + \"] to be of types \" +\n-                ALLOWED_TIMESTAMPFIELD_TYPES + \", but instead found type [\" + type  + \"]\");\n-        }\n-    }\n+        TimestampFieldMapper fieldMapper = (TimestampFieldMapper) mapperService.documentMapper().mappers().getMapper(\"_timestamp\");\n+        assert fieldMapper != null : \"[_timestamp] meta field mapper must exist\";\n \n-    public static String convertFieldPathToMappingPath(String fieldPath) {\n-        // The mapping won't allow such fields, so this is a sanity check:\n-        assert Arrays.stream(fieldPath.split(\"\\\\.\")).filter(String::isEmpty).count() == 0L ||\n-            fieldPath.startsWith(\".\") ||\n-            fieldPath.endsWith(\".\") : \"illegal field path [\" + fieldPath + \"]\";\n-\n-        String mappingPath;\n-        if (fieldPath.indexOf('.') == -1) {\n-            mappingPath = \"properties.\" + fieldPath;\n-        } else {\n-            mappingPath = \"properties.\" + fieldPath.replace(\".\", \".properties.\");\n+        if (timestampFieldName.equals(fieldMapper.getPath()) == false) {\n+            throw new IllegalArgumentException(\"[_timestamp] meta field doesn't point to data stream timestamp field [\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5052d876998c61bb50fb9de20f2cff0b9de7a325"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2MjU5Nw==", "bodyText": "This is more of a sanity check. Kind of ensuring that we did apply the _data_stream_timestamp meta field mapper. If a user would run into this error then this would be a bug. Can tweak this check.", "url": "https://github.com/elastic/elasticsearch/pull/59076#discussion_r454162597", "createdAt": "2020-07-14T07:36:29Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateDataStreamService.java", "diffHunk": "@@ -183,31 +169,16 @@ public static ComposableIndexTemplate lookupTemplateForDataStream(String dataStr\n     }\n \n     public static void validateTimestampFieldMapping(String timestampFieldName, MapperService mapperService) {\n-        MappedFieldType timestampFieldMapper = mapperService.fieldType(timestampFieldName);\n-        if (timestampFieldMapper == null) {\n-            throw new IllegalArgumentException(\"expected timestamp field [\" + timestampFieldName + \"], but found no timestamp field\");\n-        }\n-        String type = timestampFieldMapper.typeName();\n-        if (ALLOWED_TIMESTAMPFIELD_TYPES.contains(type) == false) {\n-            throw new IllegalArgumentException(\"expected timestamp field [\" + timestampFieldName + \"] to be of types \" +\n-                ALLOWED_TIMESTAMPFIELD_TYPES + \", but instead found type [\" + type  + \"]\");\n-        }\n-    }\n+        TimestampFieldMapper fieldMapper = (TimestampFieldMapper) mapperService.documentMapper().mappers().getMapper(\"_timestamp\");\n+        assert fieldMapper != null : \"[_timestamp] meta field mapper must exist\";\n \n-    public static String convertFieldPathToMappingPath(String fieldPath) {\n-        // The mapping won't allow such fields, so this is a sanity check:\n-        assert Arrays.stream(fieldPath.split(\"\\\\.\")).filter(String::isEmpty).count() == 0L ||\n-            fieldPath.startsWith(\".\") ||\n-            fieldPath.endsWith(\".\") : \"illegal field path [\" + fieldPath + \"]\";\n-\n-        String mappingPath;\n-        if (fieldPath.indexOf('.') == -1) {\n-            mappingPath = \"properties.\" + fieldPath;\n-        } else {\n-            mappingPath = \"properties.\" + fieldPath.replace(\".\", \".properties.\");\n+        if (timestampFieldName.equals(fieldMapper.getPath()) == false) {\n+            throw new IllegalArgumentException(\"[_timestamp] meta field doesn't point to data stream timestamp field [\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODc3OA=="}, "originalCommit": {"oid": "5052d876998c61bb50fb9de20f2cff0b9de7a325"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2059, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}