{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzODU4ODk5", "number": 66724, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1MjoyM1rOFIy2HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDoxMDoxNFrOFIy_yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY1OTgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1MjoyM1rOIK7A3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1MjoyM1rOIK7A3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzU0OA==", "bodyText": "Shoud we guard these with a check for p.length() == 0?", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548323548", "createdAt": "2020-12-23T23:52:23Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY3MzIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowMjozNVrOIK7IMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowMjozNVrOIK7IMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNTQyNw==", "bodyText": "It is possible that the pattern is **. As such the infix is an empty string and can be skipped. But as discussed, it is probably better handled as part of compacting all consecutive *, which can be done in a separate PR.", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548325427", "createdAt": "2020-12-24T00:02:35Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);\n+            if (p.length() <= 1 || first == '/') {\n+                // Single character strings (like \"x\" or \"*\") or regex (\"/something/\")\n+                misc.add(p);\n+            } else if (first == '*') {\n+                if (last == '*') {\n+                    // *something*\n+                    infix.add(p.substring(1, p.length() - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY3ODE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowNTo1N1rOIK7KvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowNTo1N1rOIK7KvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNjA3Nw==", "bodyText": "I think the pattern like something* should also reach here and should be part of the comment.", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548326077", "createdAt": "2020-12-24T00:05:57Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);\n+            if (p.length() <= 1 || first == '/') {\n+                // Single character strings (like \"x\" or \"*\") or regex (\"/something/\")\n+                misc.add(p);\n+            } else if (first == '*') {\n+                if (last == '*') {\n+                    // *something*\n+                    infix.add(p.substring(1, p.length() - 1));\n+                } else {\n+                    // *something\n+                    suffix.add(p.substring(1));\n+                }\n+            } else if (last == '*' && p.indexOf('*') != p.length() - 1) {\n+                // some*thing*\n+                // For simple prefix patterns (\"something*\") it's more efficient to do a single pass\n+                // Lucene handles the shared trailing '*' on an accept state well,\n+                // and performing 2 minimizes (on for the union of strings, then on again after concatenating MATCH_ANY) is slower.\n+                // But, that's not true if the string has an embedded '*' in it - in that case, we should handle them in this special way.\n+                prefix.add(p.substring(0, p.length() - 1));\n+            } else {\n+                // some*thing / some?thing / etc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY4MTE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowNzo1N1rOIK7MWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowNzo1N1rOIK7MWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNjQ5MA==", "bodyText": "This sentence reads weird to me. Should it be something like ... (one for the union of strings, and another one after ...)", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548326490", "createdAt": "2020-12-24T00:07:57Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {\n+            List<Automaton> automata = new ArrayList<>(strings.size());\n+            for (String pattern : strings) {\n+                final Automaton patternAutomaton = pattern(pattern);\n+                automata.add(patternAutomaton);\n+            }\n+            return unionAndMinimize(automata);\n+        };\n+\n+        // We originally just compiled each automaton separately and then unioned them all.\n+        // However, that approach can be quite slow, and very memory intensive.\n+        // It is far more efficient if\n+        //   1. we strip leading/trailing \"*\"\n+        //   2. union the automaton produced from the remaining text\n+        //   3. append/prepend MatchAnyString automatons as appropriate\n+        // That is:\n+        //  - `MATCH_ALL + (bullseye|daredevil) + MATCH_ALL`\n+        //  can be determinized more efficiently than\n+        //  - `(MATCH_ALL + bullseye + MATCH_ALL)|(MATCH_ALL + daredevil + MATCH_ALL)`\n+\n+        final Set<String> prefix = new HashSet<>();\n+        final Set<String> infix = new HashSet<>();\n+        final Set<String> suffix = new HashSet<>();\n+        final Set<String> misc = new HashSet<>();\n+\n+        for (String p : patterns) {\n+            final char first = p.charAt(0);\n+            final char last = p.charAt(p.length() - 1);\n+            if (p.length() <= 1 || first == '/') {\n+                // Single character strings (like \"x\" or \"*\") or regex (\"/something/\")\n+                misc.add(p);\n+            } else if (first == '*') {\n+                if (last == '*') {\n+                    // *something*\n+                    infix.add(p.substring(1, p.length() - 1));\n+                } else {\n+                    // *something\n+                    suffix.add(p.substring(1));\n+                }\n+            } else if (last == '*' && p.indexOf('*') != p.length() - 1) {\n+                // some*thing*\n+                // For simple prefix patterns (\"something*\") it's more efficient to do a single pass\n+                // Lucene handles the shared trailing '*' on an accept state well,\n+                // and performing 2 minimizes (on for the union of strings, then on again after concatenating MATCH_ANY) is slower.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY4NDU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDoxMDoxNFrOIK7OKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDoxMDoxNFrOIK7OKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNjk1Mg==", "bodyText": "Nit: I'd prefer to name this variable with a noun, something like buildFunc.", "url": "https://github.com/elastic/elasticsearch/pull/66724#discussion_r548326952", "createdAt": "2020-12-24T00:10:14Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java", "diffHunk": "@@ -84,10 +88,74 @@ public static Automaton patterns(Collection<String> patterns) {\n     }\n \n     private static Automaton buildAutomaton(Collection<String> patterns) {\n-        List<Automaton> automata = new ArrayList<>(patterns.size());\n-        for (String pattern : patterns) {\n-            final Automaton patternAutomaton = pattern(pattern);\n-            automata.add(patternAutomaton);\n+        if (patterns.size() == 1) {\n+            return minimize(pattern(patterns.iterator().next()));\n+        }\n+\n+        final Function<Collection<String>, Automaton> build = strings -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb4e52c8b319d2ec9ab8543cf2a8b260ac1ea08"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4415, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}