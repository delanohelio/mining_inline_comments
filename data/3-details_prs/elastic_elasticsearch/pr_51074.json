{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMzU4MzAx", "number": 51074, "title": "Add CoolDown Period to S3 Repository", "bodyText": "WIP still needs tests, would just like to confirm we're good with the approach first.\n7.6.0 label is intentional here, this one is important for 7.6.", "createdAt": "2020-01-15T22:01:28Z", "url": "https://github.com/elastic/elasticsearch/pull/51074", "merged": true, "mergeCommit": {"oid": "f4293597fcbdfe451c8188a88cb60f237c0bd925"}, "closed": true, "closedAt": "2020-01-20T09:32:22Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6l3iQgH2gAyMzYzMzU4MzAxOmRlNWE2NWNhNzcyNWJkOTgzZDZiMzg5MjA1ZjcxYTBlY2IxMzliMWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8H5iZAFqTM0NTEyODQ1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "de5a65ca7725bd983d6b389205f71a0ecb139b1f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/de5a65ca7725bd983d6b389205f71a0ecb139b1f", "committedDate": "2020-01-15T13:49:41Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c14ac7ce798a2d3f60ed180ba7323aa2b538abf7", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c14ac7ce798a2d3f60ed180ba7323aa2b538abf7", "committedDate": "2020-01-15T16:32:01Z", "message": "Merge remote-tracking branch 'elastic/master' into s3-cooldown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c25c52802e704a64aca0558229f243721ab1d3f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5c25c52802e704a64aca0558229f243721ab1d3f", "committedDate": "2020-01-15T21:58:24Z", "message": "Add Cooldown Period to S3 Repository\n\nWIP, still missing tests but would like to confirm we agree on the approach taken here first."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4a8e098bd9952c8949ac017e72d657f4b5f7ad2", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f4a8e098bd9952c8949ac017e72d657f4b5f7ad2", "committedDate": "2020-01-15T22:00:07Z", "message": "cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzODcyMjAw", "url": "https://github.com/elastic/elasticsearch/pull/51074#pullrequestreview-343872200", "createdAt": "2020-01-16T12:20:15Z", "commit": {"oid": "f4a8e098bd9952c8949ac017e72d657f4b5f7ad2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMjoyMDoxNlrOFeXkgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMjoyMDoxNlrOFeXkgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Nzc3OA==", "bodyText": "@ywelsch I went with doing it this way instead of just keeping track of a timestamp and then failing a new snapshot if it's started to close to the last timestamp. I'm afraid having random failures from concurrent snapshot exceptions when no running snapshot is visible to APIs could mess with Cloud orchestration (not necessarily breaking it but causing an unreasonable amount of _status requests).", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r367387778", "createdAt": "2020-01-16T12:20:16Z", "author": {"login": "original-brownbear"}, "path": "plugins/repository-s3/src/main/java/org/elasticsearch/repositories/s3/S3Repository.java", "diffHunk": "@@ -186,6 +220,58 @@\n                 storageClass);\n     }\n \n+    /**\n+     * Holds a reference to delayed repository operation {@link Scheduler.Cancellable} so it can be cancelled should the repository be\n+     * closed concurrently.\n+     */\n+    private final AtomicReference<Scheduler.Cancellable> finalizationFuture = new AtomicReference<>();\n+\n+    @Override\n+    public void finalizeSnapshot(SnapshotId snapshotId, ShardGenerations shardGenerations, long startTime, String failure, int totalShards,\n+                                 List<SnapshotShardFailure> shardFailures, long repositoryStateId, boolean includeGlobalState,\n+                                 MetaData clusterMetaData, Map<String, Object> userMetadata, boolean writeShardGens,\n+                                 ActionListener<SnapshotInfo> listener) {\n+        if (writeShardGens == false) {\n+            listener = delayedListener(listener);\n+        }\n+        super.finalizeSnapshot(snapshotId, shardGenerations, startTime, failure, totalShards, shardFailures, repositoryStateId,\n+            includeGlobalState, clusterMetaData, userMetadata, writeShardGens, listener);\n+    }\n+\n+    @Override\n+    public void deleteSnapshot(SnapshotId snapshotId, long repositoryStateId, boolean writeShardGens, ActionListener<Void> listener) {\n+        if (writeShardGens == false) {\n+            listener = delayedListener(listener);\n+        }\n+        super.deleteSnapshot(snapshotId, repositoryStateId, writeShardGens, listener);\n+    }\n+\n+    /**\n+     * Wraps given listener such that it is executed with a delay of {@link #coolDown} on the snapshot thread-pool after being invoked.\n+     * See {@link #COOLDOWN_PERIOD} for details.\n+     */\n+    private <T> ActionListener<T> delayedListener(ActionListener<T> listener) {\n+        final ActionListener<T> wrappedListener = ActionListener.runBefore(listener, () -> {\n+            final Scheduler.Cancellable cancellable = finalizationFuture.getAndSet(null);\n+            assert cancellable != null;\n+        });\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(T response) {\n+                final Scheduler.Cancellable existing = finalizationFuture.getAndSet(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a8e098bd9952c8949ac017e72d657f4b5f7ad2"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0ffb44bc4ba1c54745913bcd61367c13573178f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d0ffb44bc4ba1c54745913bcd61367c13573178f", "committedDate": "2020-01-16T20:04:53Z", "message": "Merge remote-tracking branch 'elastic/master' into s3-cooldown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9047d7738f432dea04cd21efb1128d1686fb1be", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f9047d7738f432dea04cd21efb1128d1686fb1be", "committedDate": "2020-01-16T21:53:20Z", "message": "test + docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjQ2MDY3", "url": "https://github.com/elastic/elasticsearch/pull/51074#pullrequestreview-344246067", "createdAt": "2020-01-16T22:00:58Z", "commit": {"oid": "f9047d7738f432dea04cd21efb1128d1686fb1be"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjowMDo1OFrOFeo-Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjowMDo1OFrOFeo-Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY3Mjg4Mw==", "bodyText": "This is admittedly quite the hacky test and it takes 2x 5s of hard waits to verify behaviour.\nWe could create a cleaner test by adding some BwC test infrastructure to the S3 plugin tests but I'm not sure it's worth the complexity. Also, running a real rest test to verify the timing here makes the test even more prone to run into random CI slowness and fail in the last step that verifies no waiting is happening when moving to a repo without any old version snapshot => this seemed like the least bad option to me.\nWe are using a O(5s) hard timeout in some other repo IO-timeout tests and so far that hasn't failed us due to CI running into a longer pause so I'm hopeful this will be stable.", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r367672883", "createdAt": "2020-01-16T22:00:58Z", "author": {"login": "original-brownbear"}, "path": "plugins/repository-s3/src/test/java/org/elasticsearch/repositories/s3/S3BlobStoreRepositoryTests.java", "diffHunk": "@@ -92,6 +111,41 @@ protected Settings nodeSettings(int nodeOrdinal) {\n             .build();\n     }\n \n+    public void testEnforcedCooldownPeriod() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9047d7738f432dea04cd21efb1128d1686fb1be"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f5816701cd953fa16bcec12f14e5834037c6c98", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4f5816701cd953fa16bcec12f14e5834037c6c98", "committedDate": "2020-01-17T05:43:30Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjI4NTg4", "url": "https://github.com/elastic/elasticsearch/pull/51074#pullrequestreview-344628588", "createdAt": "2020-01-17T14:51:07Z", "commit": {"oid": "4f5816701cd953fa16bcec12f14e5834037c6c98"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDo1MTowN1rOFe7Vvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDo1OTo1NVrOFe7osw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3MzgyMw==", "bodyText": "what if we are rejected from the snapshot threadpool? Let's force it onto the threadpool (use AbstractRunnable),  and notify listener as welll on AbstractRunnable.onFaillure", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r367973823", "createdAt": "2020-01-17T14:51:07Z", "author": {"login": "ywelsch"}, "path": "plugins/repository-s3/src/main/java/org/elasticsearch/repositories/s3/S3Repository.java", "diffHunk": "@@ -186,6 +225,69 @@\n                 storageClass);\n     }\n \n+    /**\n+     * Holds a reference to delayed repository operation {@link Scheduler.Cancellable} so it can be cancelled should the repository be\n+     * closed concurrently.\n+     */\n+    private final AtomicReference<Scheduler.Cancellable> finalizationFuture = new AtomicReference<>();\n+\n+    @Override\n+    public void finalizeSnapshot(SnapshotId snapshotId, ShardGenerations shardGenerations, long startTime, String failure, int totalShards,\n+                                 List<SnapshotShardFailure> shardFailures, long repositoryStateId, boolean includeGlobalState,\n+                                 MetaData clusterMetaData, Map<String, Object> userMetadata, boolean writeShardGens,\n+                                 ActionListener<SnapshotInfo> listener) {\n+        if (writeShardGens == false) {\n+            listener = delayedListener(listener);\n+        }\n+        super.finalizeSnapshot(snapshotId, shardGenerations, startTime, failure, totalShards, shardFailures, repositoryStateId,\n+            includeGlobalState, clusterMetaData, userMetadata, writeShardGens, listener);\n+    }\n+\n+    @Override\n+    public void deleteSnapshot(SnapshotId snapshotId, long repositoryStateId, boolean writeShardGens, ActionListener<Void> listener) {\n+        if (writeShardGens == false) {\n+            listener = delayedListener(listener);\n+        }\n+        super.deleteSnapshot(snapshotId, repositoryStateId, writeShardGens, listener);\n+    }\n+\n+    /**\n+     * Wraps given listener such that it is executed with a delay of {@link #coolDown} on the snapshot thread-pool after being invoked.\n+     * See {@link #COOLDOWN_PERIOD} for details.\n+     */\n+    private <T> ActionListener<T> delayedListener(ActionListener<T> listener) {\n+        final ActionListener<T> wrappedListener = ActionListener.runBefore(listener, () -> {\n+            final Scheduler.Cancellable cancellable = finalizationFuture.getAndSet(null);\n+            assert cancellable != null;\n+        });\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(T response) {\n+                logCooldownInfo();\n+                final Scheduler.Cancellable existing = finalizationFuture.getAndSet(\n+                    threadPool.schedule(() -> wrappedListener.onResponse(response), coolDown, ThreadPool.Names.SNAPSHOT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f5816701cd953fa16bcec12f14e5834037c6c98"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NTMxNQ==", "bodyText": "Do we need to log this at warn level?", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r367975315", "createdAt": "2020-01-17T14:53:52Z", "author": {"login": "ywelsch"}, "path": "plugins/repository-s3/src/main/java/org/elasticsearch/repositories/s3/S3Repository.java", "diffHunk": "@@ -210,4 +312,14 @@ protected BlobStore getBlobStore() {\n     protected ByteSizeValue chunkSize() {\n         return chunkSize;\n     }\n+\n+    @Override\n+    protected void doClose() {\n+        final Scheduler.Cancellable cancellable = finalizationFuture.getAndSet(null);\n+        if (cancellable != null) {\n+            logger.warn(\"Repository closed during cooldown period\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f5816701cd953fa16bcec12f14e5834037c6c98"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3ODE2NQ==", "bodyText": "Can we have a SnapshotResiliencyTests with a mock repo that is eventually consistent on actions for X seconds, and then becomes consistent, and then use that one to verify all is going well? Would be a stronger test than this, which just verifies that some sleep is somewhere in place.", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r367978165", "createdAt": "2020-01-17T14:59:03Z", "author": {"login": "ywelsch"}, "path": "plugins/repository-s3/src/test/java/org/elasticsearch/repositories/s3/S3BlobStoreRepositoryTests.java", "diffHunk": "@@ -92,6 +111,41 @@ protected Settings nodeSettings(int nodeOrdinal) {\n             .build();\n     }\n \n+    public void testEnforcedCooldownPeriod() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY3Mjg4Mw=="}, "originalCommit": {"oid": "f9047d7738f432dea04cd21efb1128d1686fb1be"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3ODY3NQ==", "bodyText": "I wonder if there are situations where ThreadPool.schedule will return before the time value specified. This would then fail here.", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r367978675", "createdAt": "2020-01-17T14:59:55Z", "author": {"login": "ywelsch"}, "path": "plugins/repository-s3/src/test/java/org/elasticsearch/repositories/s3/S3BlobStoreRepositoryTests.java", "diffHunk": "@@ -92,6 +111,41 @@ protected Settings nodeSettings(int nodeOrdinal) {\n             .build();\n     }\n \n+    public void testEnforcedCooldownPeriod() throws IOException {\n+        final String repoName = createRepository(randomName(), Settings.builder().put(repositorySettings())\n+            .put(S3Repository.COOLDOWN_PERIOD.getKey(), TEST_COOLDOWN_PERIOD).build());\n+\n+        final SnapshotId fakeOldSnapshot = client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-old\")\n+            .setWaitForCompletion(true).setIndices().get().getSnapshotInfo().snapshotId();\n+        final RepositoriesService repositoriesService = internalCluster().getCurrentMasterNodeInstance(RepositoriesService.class);\n+        final BlobStoreRepository repository = (BlobStoreRepository) repositoriesService.repository(repoName);\n+        final RepositoryData repositoryData =\n+            PlainActionFuture.get(f -> repository.threadPool().generic().execute(() -> repository.getRepositoryData(f)));\n+        final RepositoryData modifiedRepositoryData = repositoryData.withVersions(Collections.singletonMap(fakeOldSnapshot,\n+            SnapshotsService.SHARD_GEN_IN_REPO_DATA_VERSION.minimumCompatibilityVersion()));\n+        final BytesReference serialized =\n+            BytesReference.bytes(modifiedRepositoryData.snapshotsToXContent(XContentFactory.jsonBuilder(), false));\n+        PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.run(f, () -> {\n+            try (InputStream stream = serialized.streamInput()) {\n+                repository.blobStore().blobContainer(repository.basePath()).writeBlobAtomic(\n+                    BlobStoreRepository.INDEX_FILE_PREFIX + modifiedRepositoryData.getGenId(), stream, serialized.length(), true);\n+            }\n+        })));\n+\n+        final String newSnapshotName = \"snapshot-new\";\n+        final long beforeThrottledSnapshot = repository.threadPool().relativeTimeInNanos();\n+        client().admin().cluster().prepareCreateSnapshot(repoName, newSnapshotName).setWaitForCompletion(true).setIndices().get();\n+        assertThat(repository.threadPool().relativeTimeInNanos() - beforeThrottledSnapshot, greaterThan(TEST_COOLDOWN_PERIOD.getNanos()));\n+\n+        final long beforeThrottledDelete = repository.threadPool().relativeTimeInNanos();\n+        client().admin().cluster().prepareDeleteSnapshot(repoName, newSnapshotName).get();\n+        assertThat(repository.threadPool().relativeTimeInNanos() - beforeThrottledDelete, greaterThan(TEST_COOLDOWN_PERIOD.getNanos()));\n+\n+        final long beforeFastDelete = repository.threadPool().relativeTimeInNanos();\n+        client().admin().cluster().prepareDeleteSnapshot(repoName, fakeOldSnapshot.getName()).get();\n+        assertThat(repository.threadPool().relativeTimeInNanos() - beforeFastDelete, lessThan(TEST_COOLDOWN_PERIOD.getNanos()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f5816701cd953fa16bcec12f14e5834037c6c98"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9ad026e9105c8f6464e6771184ca219b174ef36", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f9ad026e9105c8f6464e6771184ca219b174ef36", "committedDate": "2020-01-17T15:21:39Z", "message": "Merge remote-tracking branch 'elastic/master' into s3-cooldown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f1c00d56d2af7fd72338fee56d48870f81f42f3", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9f1c00d56d2af7fd72338fee56d48870f81f42f3", "committedDate": "2020-01-17T22:58:50Z", "message": "CR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88ffa99cdb51188c29a96f513f2b455039f2d977", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/88ffa99cdb51188c29a96f513f2b455039f2d977", "committedDate": "2020-01-19T13:45:54Z", "message": "Merge remote-tracking branch 'elastic/master' into s3-cooldown"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTI4NDU3", "url": "https://github.com/elastic/elasticsearch/pull/51074#pullrequestreview-345128457", "createdAt": "2020-01-20T08:02:24Z", "commit": {"oid": "88ffa99cdb51188c29a96f513f2b455039f2d977"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODowMjoyNFrOFfV4Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODowMjoyNFrOFfV4Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwODYwNw==", "bodyText": "bummer :/", "url": "https://github.com/elastic/elasticsearch/pull/51074#discussion_r368408607", "createdAt": "2020-01-20T08:02:24Z", "author": {"login": "ywelsch"}, "path": "plugins/repository-s3/src/test/java/org/elasticsearch/repositories/s3/S3BlobStoreRepositoryTests.java", "diffHunk": "@@ -92,6 +111,41 @@ protected Settings nodeSettings(int nodeOrdinal) {\n             .build();\n     }\n \n+    public void testEnforcedCooldownPeriod() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY3Mjg4Mw=="}, "originalCommit": {"oid": "f9047d7738f432dea04cd21efb1128d1686fb1be"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3133, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}