{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1MDYzMDQz", "number": 60865, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNjoxOToxNVrOEWqt3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMDowMzo1OVrOEaczgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjAzOTk5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNjoxOToxNVrOG-CecQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDoxNzozMVrOG-I2BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcwNTQ1Nw==", "bodyText": "This may introduce a BWC problem in the case that a response is only empty in some versions, because EMPTY_STREAM_INPUT#getVersion() returns Version.CURRENT which may not match header.getVersion().", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r467705457", "createdAt": "2020-08-10T06:19:15Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -111,17 +114,26 @@ private void messageReceived(TcpChannel channel, InboundMessage message) throws\n                 }\n                 // ignore if its null, the service logs it\n                 if (handler != null) {\n-                    if (header.isError()) {\n-                        handlerResponseError(streamInput, handler);\n+                    final StreamInput streamInput;\n+                    if (message.getContentLength() > 0) {\n+                        streamInput = namedWriteableStream(message.openOrGetStreamInput());\n+                        assertRemoteVersion(streamInput, header.getVersion());\n+                        if (header.isError()) {\n+                            handlerResponseError(streamInput, handler);\n+                        } else {\n+                            handleResponse(remoteAddress, streamInput, handler);\n+                        }\n+                        // Check the entire message has been read\n+                        final int nextByte = streamInput.read();\n+                        // calling read() is useful to make sure the message is fully read, even if there is an EOS marker\n+                        if (nextByte != -1) {\n+                            throw new IllegalStateException(\"Message not fully read (response) for requestId [\"\n+                                + requestId + \"], handler [\" + handler + \"], error [\" + header.isError()\n+                                + \"]; resetting\");\n+                        }\n                     } else {\n-                        handleResponse(remoteAddress, streamInput, handler);\n-                    }\n-                    // Check the entire message has been read\n-                    final int nextByte = streamInput.read();\n-                    // calling read() is useful to make sure the message is fully read, even if there is an EOS marker\n-                    if (nextByte != -1) {\n-                        throw new IllegalStateException(\"Message not fully read (response) for requestId [\" + requestId + \"], handler [\"\n-                            + handler + \"], error [\" + header.isError() + \"]; resetting\");\n+                        assert header.isError() == false;\n+                        handleResponse(remoteAddress, EMPTY_STREAM_INPUT, handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f418bcdddb643df3f1442fea3587f3ee16ccf8b3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwOTc5Nw==", "bodyText": "Yea that was a little lazy on my end, I couldn't find a case where we ever moved from an empty message to a non-empty one but that doesn't mean that won't happen in the future. I adjusted the logic accordingly to use an empty stream per thread.", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r467809797", "createdAt": "2020-08-10T10:17:31Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -111,17 +114,26 @@ private void messageReceived(TcpChannel channel, InboundMessage message) throws\n                 }\n                 // ignore if its null, the service logs it\n                 if (handler != null) {\n-                    if (header.isError()) {\n-                        handlerResponseError(streamInput, handler);\n+                    final StreamInput streamInput;\n+                    if (message.getContentLength() > 0) {\n+                        streamInput = namedWriteableStream(message.openOrGetStreamInput());\n+                        assertRemoteVersion(streamInput, header.getVersion());\n+                        if (header.isError()) {\n+                            handlerResponseError(streamInput, handler);\n+                        } else {\n+                            handleResponse(remoteAddress, streamInput, handler);\n+                        }\n+                        // Check the entire message has been read\n+                        final int nextByte = streamInput.read();\n+                        // calling read() is useful to make sure the message is fully read, even if there is an EOS marker\n+                        if (nextByte != -1) {\n+                            throw new IllegalStateException(\"Message not fully read (response) for requestId [\"\n+                                + requestId + \"], handler [\" + handler + \"], error [\" + header.isError()\n+                                + \"]; resetting\");\n+                        }\n                     } else {\n-                        handleResponse(remoteAddress, streamInput, handler);\n-                    }\n-                    // Check the entire message has been read\n-                    final int nextByte = streamInput.read();\n-                    // calling read() is useful to make sure the message is fully read, even if there is an EOS marker\n-                    if (nextByte != -1) {\n-                        throw new IllegalStateException(\"Message not fully read (response) for requestId [\" + requestId + \"], handler [\"\n-                            + handler + \"], error [\" + header.isError() + \"]; resetting\");\n+                        assert header.isError() == false;\n+                        handleResponse(remoteAddress, EMPTY_STREAM_INPUT, handler);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcwNTQ1Nw=="}, "originalCommit": {"oid": "f418bcdddb643df3f1442fea3587f3ee16ccf8b3"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjc4NjIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDozNDoyNVrOG-JTmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDo0NzoxM1rOG-JpAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxNzM2OQ==", "bodyText": "I think I'd have just done this rather than introducing thread-locals here, and mixed-version clusters be (slightly) damned.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (message.getContentLength() > 0) {\n          \n          \n            \n                                if (message.getContentLength() > 0 || header.getVersion().equals(Version.CURRENT) == false) {\n          \n      \n    \n    \n  \n\nWhat you've got looks ok as long as we don't refactor the deserialisation onto a different thread at some point in the future, but that's going to be a tricky bug to track down if ever we do so... \ud83d\ude01", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r467817369", "createdAt": "2020-08-10T10:34:25Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -111,18 +120,29 @@ private void messageReceived(TcpChannel channel, InboundMessage message) throws\n                 }\n                 // ignore if its null, the service logs it\n                 if (handler != null) {\n-                    if (header.isError()) {\n-                        handlerResponseError(streamInput, handler);\n+                    final StreamInput streamInput;\n+                    if (message.getContentLength() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4a3ac29b5ce9e48b9718587f855ab65680a42ae"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgyMTM2Ng==", "bodyText": "Yea but that's the least of my worries in that case :D (we already make a million assumptions that assume we never escape the stream from the current thread with the way we release the paged bytes).\nPlus, I tried moving the deserialization off the IO thread in #50138 with pretty mixed results performance wise (it's the same reason we moved the serialization onto the IO loop, we just waste a ton of buffers if we deserialize later, which really hurts with 16k+ page sizes).", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r467821366", "createdAt": "2020-08-10T10:43:48Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -111,18 +120,29 @@ private void messageReceived(TcpChannel channel, InboundMessage message) throws\n                 }\n                 // ignore if its null, the service logs it\n                 if (handler != null) {\n-                    if (header.isError()) {\n-                        handlerResponseError(streamInput, handler);\n+                    final StreamInput streamInput;\n+                    if (message.getContentLength() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxNzM2OQ=="}, "originalCommit": {"oid": "b4a3ac29b5ce9e48b9718587f855ab65680a42ae"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgyMjg0OQ==", "bodyText": "I think I'd have just done this rather than introducing thread-locals here, and mixed-version clusters be (slightly) damned.\n\nYea that's better, applied your suggestion :)", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r467822849", "createdAt": "2020-08-10T10:47:13Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -111,18 +120,29 @@ private void messageReceived(TcpChannel channel, InboundMessage message) throws\n                 }\n                 // ignore if its null, the service logs it\n                 if (handler != null) {\n-                    if (header.isError()) {\n-                        handlerResponseError(streamInput, handler);\n+                    final StreamInput streamInput;\n+                    if (message.getContentLength() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxNzM2OQ=="}, "originalCommit": {"oid": "b4a3ac29b5ce9e48b9718587f855ab65680a42ae"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MTY5MTM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMDowMToyMFrOHD40eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzowMjoxN1rOHD_tgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgzODcxMw==", "bodyText": "This change means that the timeout starts counting from the first retry, rather than from the start of execution of the action. I think we should adjust the timeout to account for this since this retry might be happening a long time later.", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r473838713", "createdAt": "2020-08-20T10:01:20Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java", "diffHunk": "@@ -201,7 +193,15 @@ public void handleException(final TransportException exp) {\n             }\n         }\n \n-        private void retry(final Throwable failure, final Predicate<ClusterState> statePredicate) {\n+        private void retryOnMasterChange(ClusterState state, Throwable failure) {\n+            retry(state, failure, MasterNodeChangePredicate.build(state));\n+        }\n+\n+        private void retry(ClusterState state, final Throwable failure, final Predicate<ClusterState> statePredicate) {\n+            if (observer == null) {\n+                this.observer =\n+                    new ClusterStateObserver(state, clusterService, request.masterNodeTimeout(), logger, threadPool.getThreadContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1df436fa589329887deb76264e37c7a5ba0ed2"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MTYxNw==", "bodyText": "Fair point, I pushed 29806e8 :)", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r473951617", "createdAt": "2020-08-20T13:02:17Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java", "diffHunk": "@@ -201,7 +193,15 @@ public void handleException(final TransportException exp) {\n             }\n         }\n \n-        private void retry(final Throwable failure, final Predicate<ClusterState> statePredicate) {\n+        private void retryOnMasterChange(ClusterState state, Throwable failure) {\n+            retry(state, failure, MasterNodeChangePredicate.build(state));\n+        }\n+\n+        private void retry(ClusterState state, final Throwable failure, final Predicate<ClusterState> statePredicate) {\n+            if (observer == null) {\n+                this.observer =\n+                    new ClusterStateObserver(state, clusterService, request.masterNodeTimeout(), logger, threadPool.getThreadContext());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgzODcxMw=="}, "originalCommit": {"oid": "9f1df436fa589329887deb76264e37c7a5ba0ed2"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MTcwMzY5OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMDowMzo1OVrOHD48zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMDowMzo1OVrOHD48zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg0MDg0Nw==", "bodyText": "\ud83d\udc4d we can always bring this back later if we need it again", "url": "https://github.com/elastic/elasticsearch/pull/60865#discussion_r473840847", "createdAt": "2020-08-20T10:03:59Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java", "diffHunk": "@@ -224,12 +224,4 @@ public void onTimeout(TimeValue timeout) {\n                 }, statePredicate);\n         }\n     }\n-\n-    /**\n-     * Allows to conditionally return a different master node action name in the case an action gets renamed.\n-     * This mainly for backwards compatibility should be used rarely\n-     */\n-    protected String getMasterActionName(DiscoveryNode node) {\n-        return actionName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1df436fa589329887deb76264e37c7a5ba0ed2"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2505, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}