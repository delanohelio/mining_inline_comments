{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2OTAyNTUx", "number": 57573, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjozMzowOFrOEC8Abw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxNDoxMVrOEIThhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE1NzU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjozMzowOFrOGfsoyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODozNzo1NlrOGhqynA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MDM3Nw==", "bodyText": "how do we protect from double-accounting the bulk request / bulk shard requests after it has run through the ingestService?\nAlso, in  case where we forward the bulk request (see forwardIngestRequest), we can probably stop accounting for the bytes of the  original bulk request as soon as the request is sent.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435890377", "createdAt": "2020-06-05T12:33:08Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -699,7 +715,7 @@ public void onFailure(Exception e) {\n \n                                 @Override\n                                 protected void doRun() throws Exception {\n-                                    doExecute(task, bulkRequest, actionListener);\n+                                    doDispatchedExecute(task, bulkRequest, actionListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1OTkwOQ==", "bodyText": "We avoid double accounting because on callback we call doInternalExecute vs. doExecute. doInternalExecute does not account.\n\nAlso, in case where we forward the bulk request (see forwardIngestRequest), we can probably stop accounting for the bytes of the original bulk request as soon as the request is sent.\n\nI'm not sure I understand the logic here. How is this different than the node acting as coordinator node for a normal indexing request? Once we forward a request to a primary we are done until we have to forward the response.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437059909", "createdAt": "2020-06-08T23:43:44Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -699,7 +715,7 @@ public void onFailure(Exception e) {\n \n                                 @Override\n                                 protected void doRun() throws Exception {\n-                                    doExecute(task, bulkRequest, actionListener);\n+                                    doDispatchedExecute(task, bulkRequest, actionListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MDM3Nw=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4OTYwNQ==", "bodyText": "I'm not sure I understand the logic here. How is this different than the node acting as coordinator node for a normal indexing request? Once we forward a request to a primary we are done until we have to forward the response.\n\nIn this case where we forward the bulk request to another ingest node, we're actually not holding onto the request bytes anymore (as there is no retry mechanism at this level), so we could in theory stop accounting for it. I'm not sure yet though if this optimization is relevant at this point, or whether we want to make this more resilient and introduce retries at this level as well.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437389605", "createdAt": "2020-06-09T12:55:21Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -699,7 +715,7 @@ public void onFailure(Exception e) {\n \n                                 @Override\n                                 protected void doRun() throws Exception {\n-                                    doExecute(task, bulkRequest, actionListener);\n+                                    doDispatchedExecute(task, bulkRequest, actionListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MDM3Nw=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NjU2MQ==", "bodyText": "Sure, but we are stilling holding the bytes. Particularly if we are doing the \"unsafe\" thing at the http level.\nWe could not mark the bytes at the TransportBulkAction level if you prefer. For example, we still would mark the coordinating bytes at the TransportShardBulkAction level. Or we could just mark bytes for actual ingest work. And then unmark when we are done (they will be marked again once we become the coordinating node).", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437796561", "createdAt": "2020-06-10T00:36:40Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -699,7 +715,7 @@ public void onFailure(Exception e) {\n \n                                 @Override\n                                 protected void doRun() throws Exception {\n-                                    doExecute(task, bulkRequest, actionListener);\n+                                    doDispatchedExecute(task, bulkRequest, actionListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MDM3Nw=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NzI3Ng==", "bodyText": "I prefer the extra marking (i.e. err on the side of overaccounting instead of underaccounting). If we don't mark at the TransportBulkAction level, then we won't account for requests that are waiting on auto-index creations or local ingest pipeline transformations. Let's keep this as is for now.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437957276", "createdAt": "2020-06-10T08:37:56Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -699,7 +715,7 @@ public void onFailure(Exception e) {\n \n                                 @Override\n                                 protected void doRun() throws Exception {\n-                                    doExecute(task, bulkRequest, actionListener);\n+                                    doDispatchedExecute(task, bulkRequest, actionListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MDM3Nw=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE4NTg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0MTo1OVrOGfs6Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0MTo1OVrOGfs6Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDg3OA==", "bodyText": "we need to take forceExecutionOnPrimary into account here, right?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435894878", "createdAt": "2020-06-05T12:41:59Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "diffHunk": "@@ -273,12 +275,31 @@ boolean isRetryableClusterBlockException(final Throwable e) {\n     }\n \n     protected void handleOperationRequest(final Request request, final TransportChannel channel, Task task) {\n-        execute(task, request, new ChannelActionListener<>(channel, actionName, request));\n+        Releasable releasable = checkOperationLimits(request);\n+        ActionListener<Response> listener =\n+            ActionListener.runAfter(new ChannelActionListener<>(channel, actionName, request), releasable::close);\n+        execute(task, request, listener);\n+    }\n+\n+    protected Releasable checkOperationLimits(final Request request) {\n+        return () -> {};\n     }\n \n     protected void handlePrimaryRequest(final ConcreteShardRequest<Request> request, final TransportChannel channel, final Task task) {\n-        new AsyncPrimaryAction(\n-            request, new ChannelActionListener<>(channel, transportPrimaryAction, request), (ReplicationTask) task).run();\n+        Releasable releasable = checkPrimaryLimits(request.getRequest());\n+        ActionListener<Response> listener =\n+            ActionListener.runAfter(new ChannelActionListener<>(channel, transportPrimaryAction, request), releasable::close);\n+\n+        threadPool.executor(executor).execute(new ActionRunnable<>(listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTE5NDcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/breaker/CircuitBreaker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0NDoyNlrOGfs_iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo0NDoyNlrOGfs_iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjIwMA==", "bodyText": "not needed at this point", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435896200", "createdAt": "2020-06-05T12:44:26Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/common/breaker/CircuitBreaker.java", "diffHunk": "@@ -60,6 +60,8 @@\n      * segments.\n      */\n     String ACCOUNTING = \"accounting\";\n+    // TODO: Description\n+    String INDEXING = \"indexing\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTIxNTAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1MDozN1rOGftMRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1MDozN1rOGftMRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTQ2Mw==", "bodyText": "Why is using forceExecutionOnPrimary still necessary here?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435899463", "createdAt": "2020-06-05T12:50:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "diffHunk": "@@ -160,11 +161,11 @@ protected TransportReplicationAction(Settings settings, String actionName, Trans\n \n         transportService.registerRequestHandler(actionName, ThreadPool.Names.SAME, requestReader, this::handleOperationRequest);\n \n-        transportService.registerRequestHandler(transportPrimaryAction, executor, forceExecutionOnPrimary, true,\n+        transportService.registerRequestHandler(transportPrimaryAction, ThreadPool.Names.SAME, forceExecutionOnPrimary, true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTIyODk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1NDozMFrOGftUpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo0NDoxNlrOGg0B_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTYwNw==", "bodyText": "why are we passing SAME upwards here? Isn't TRA already executing the actions under SAME?\nWhy are we doing similar kind of manual dispatch logic that already exists in TRA? I think I'm missing something here", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435901607", "createdAt": "2020-06-05T12:54:30Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,50 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MDA5Mg==", "bodyText": "This was a mistake. We are passing the SAME up because TransportWriteAction is where we dispatch. I have fixed it now.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437060092", "createdAt": "2020-06-08T23:44:16Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,50 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTYwNw=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTIzMTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/TransportChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1NToxMVrOGftWKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1NToxMVrOGftWKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTk5Mw==", "bodyText": "Should this be TransportChannel.class?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435901993", "createdAt": "2020-06-05T12:55:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportChannel.java", "diffHunk": "@@ -28,6 +32,8 @@\n  */\n public interface TransportChannel {\n \n+    Logger logger = LogManager.getLogger(ChannelActionListener.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTI0MTc2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/DocWriteRequest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMjo1ODozNFrOGftdBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowNToyOVrOGoJgzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc0OQ==", "bodyText": "No directly relevant to this PR, but I think we could implement Lucene's Accountable on DocWriteRequest, and possibly get a more accurate estimate with its helpers.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435903749", "createdAt": "2020-06-05T12:58:34Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/DocWriteRequest.java", "diffHunk": "@@ -256,4 +257,20 @@ static ActionRequestValidationException validateSeqNoBasedCASParams(\n \n         return validationException;\n     }\n+\n+    static long writeSizeInBytes(Stream<DocWriteRequest<?>> requestStream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczOTU0NQ==", "bodyText": "I wonder if getting a more precise estimate out should be part of this PR or a follow-up? I would think the end-goal need to include a more precise estimate and we need to examine the overhead of calculating that?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438739545", "createdAt": "2020-06-11T12:15:47Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/DocWriteRequest.java", "diffHunk": "@@ -256,4 +257,20 @@ static ActionRequestValidationException validateSeqNoBasedCASParams(\n \n         return validationException;\n     }\n+\n+    static long writeSizeInBytes(Stream<DocWriteRequest<?>> requestStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc0OQ=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NzcyNA==", "bodyText": "Just to clarify what I meant here (@henningandersen asked), I was refering to utility methods such as RamUsageEstimator.shallowSizeOfInstance and others here that can give a more accurate estimate of how much memory an object is actually taking up.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438857724", "createdAt": "2020-06-11T15:10:23Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/DocWriteRequest.java", "diffHunk": "@@ -256,4 +257,20 @@ static ActionRequestValidationException validateSeqNoBasedCASParams(\n \n         return validationException;\n     }\n+\n+    static long writeSizeInBytes(Stream<DocWriteRequest<?>> requestStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc0OQ=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg1NTc1Mw==", "bodyText": "I think we can do this in a follow-up", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r440855753", "createdAt": "2020-06-16T13:37:29Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/DocWriteRequest.java", "diffHunk": "@@ -256,4 +257,20 @@ static ActionRequestValidationException validateSeqNoBasedCASParams(\n \n         return validationException;\n     }\n+\n+    static long writeSizeInBytes(Stream<DocWriteRequest<?>> requestStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc0OQ=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MjA3OQ==", "bodyText": "Is this method still useful now that we use the accountable interface? Let's have BulkShardRequest implement Accountable as well, and then use that directly instead of this method", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r444752079", "createdAt": "2020-06-24T09:05:29Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/DocWriteRequest.java", "diffHunk": "@@ -256,4 +257,20 @@ static ActionRequestValidationException validateSeqNoBasedCASParams(\n \n         return validationException;\n     }\n+\n+    static long writeSizeInBytes(Stream<DocWriteRequest<?>> requestStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc0OQ=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTI2ODEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMzowNTo1NlrOGfttDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo0NDo0N1rOGg0CfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNzg1NA==", "bodyText": "worth noting that for users of the REST API (including our client such as beats, logstash, etc.) there's now a chance that they get a ESRejectedExecution at the full bulk level, not only at the bulk shard item level. We'll need to double-check that this is properly handled. I'm also wondering if we want to directly fork to the write thread pool at this point, or whether we want to keep executing on the http thread (as we used to) or transport thread (as we also used to).\nFinally, the threadpool change in IngestService.executeBulkRequest is no longer necessary if we go with this change here, as we are already on the write thread pool.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r435907854", "createdAt": "2020-06-05T13:05:56Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -155,6 +158,18 @@ public static IndexRequest getIndexWriteRequest(DocWriteRequest docWriteRequest)\n \n     @Override\n     protected void doExecute(Task task, BulkRequest bulkRequest, ActionListener<BulkResponse> listener) {\n+        long indexingBytes = DocWriteRequest.writeSizeInBytes(bulkRequest.requests.stream());\n+        final Releasable releasable = writeMemoryLimits.markCoordinatingOperationStarted(indexingBytes);\n+        final ActionListener<BulkResponse> releasingListener = ActionListener.runAfter(listener, releasable::close);\n+        threadPool.executor(ThreadPool.Names.WRITE).execute(new ActionRunnable<>(releasingListener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MDIyMA==", "bodyText": "I backed out the dispatching. I tend to think we do not need to dispatch in the coordinating only case.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437060220", "createdAt": "2020-06-08T23:44:47Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -155,6 +158,18 @@ public static IndexRequest getIndexWriteRequest(DocWriteRequest docWriteRequest)\n \n     @Override\n     protected void doExecute(Task task, BulkRequest bulkRequest, ActionListener<BulkResponse> listener) {\n+        long indexingBytes = DocWriteRequest.writeSizeInBytes(bulkRequest.requests.stream());\n+        final Releasable releasable = writeMemoryLimits.markCoordinatingOperationStarted(indexingBytes);\n+        final ActionListener<BulkResponse> releasingListener = ActionListener.runAfter(listener, releasable::close);\n+        threadPool.executor(ThreadPool.Names.WRITE).execute(new ActionRunnable<>(releasingListener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNzg1NA=="}, "originalCommit": {"oid": "1e421f08dab1cea387cbfb91464ac9705973d918"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDcwODk1OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/cluster/node/tasks/TaskStorageRetryIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyNDoyOVrOGhG08Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyNDoyOVrOGhG08Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2ODA0OQ==", "bodyText": "why is this test deactivated?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437368049", "createdAt": "2020-06-09T12:24:29Z", "author": {"login": "ywelsch"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/cluster/node/tasks/TaskStorageRetryIT.java", "diffHunk": "@@ -41,6 +42,7 @@\n  * Makes sure that tasks that attempt to store themselves on completion retry if\n  * they don't succeed at first.\n  */\n+@LuceneTestCase.AwaitsFix(bugUrl = \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDcwOTkxOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/action/bulk/BulkProcessorRetryIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyNDozOVrOGhG1lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyNDozOVrOGhG1lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2ODIxMg==", "bodyText": "why is this test deactivated?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437368212", "createdAt": "2020-06-09T12:24:39Z", "author": {"login": "ywelsch"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/action/bulk/BulkProcessorRetryIT.java", "diffHunk": "@@ -40,6 +41,7 @@\n import static org.hamcrest.Matchers.lessThan;\n import static org.hamcrest.Matchers.lessThanOrEqualTo;\n \n+@LuceneTestCase.AwaitsFix(bugUrl = \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDc4MzAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjozODozMlrOGhHgrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjozODozMlrOGhHgrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3OTI0Nw==", "bodyText": "This method name reads a bit funky", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437379247", "createdAt": "2020-06-09T12:38:32Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "diffHunk": "@@ -110,7 +112,17 @@ protected BulkShardResponse newResponseInstance(StreamInput in) throws IOExcepti\n     }\n \n     @Override\n-    protected void shardOperationOnPrimary(BulkShardRequest request, IndexShard primary,\n+    protected boolean coordinatingBytesNeedAccounted(BulkShardRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDgxMzQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0NjozMFrOGhHzqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0NjozMFrOGhHzqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NDEwNw==", "bodyText": "what if shardOperationOnReplica throws an exception? We're not releasing the releasable then?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437384107", "createdAt": "2020-06-09T12:46:30Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "diffHunk": "@@ -531,30 +552,28 @@ public RetryOnReplicaException(StreamInput in) throws IOException {\n \n         @Override\n         public void onResponse(Releasable releasable) {\n-            try {\n-                assert replica.getActiveOperationsCount() != 0 : \"must perform shard operation under a permit\";\n-                final ReplicaResult replicaResult = shardOperationOnReplica(replicaRequest.getRequest(), replica);\n+            assert replica.getActiveOperationsCount() != 0 : \"must perform shard operation under a permit\";\n+            shardOperationOnReplica(replicaRequest.getRequest(), replica, ActionListener.wrap((replicaResult) ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDgyMTkzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0ODo1MlrOGhH5PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODozNDoyMVrOGhqppw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NTUzMw==", "bodyText": "This will call writeMemoryLimits.markPrimaryOperationStarted(0) for those actions where we possibly don't want to do accounting (and breaking) for. I wonder if this will lead to confusion, and we might start rejecting requests later when size = 0 but we are already above whatever memory threshold we define.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437385533", "createdAt": "2020-06-09T12:48:52Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,52 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final boolean forceExecutionOnPrimary;\n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);\n+        this.executor = executor;\n+        this.forceExecutionOnPrimary = forceExecutionOnPrimary;\n+        this.writeMemoryLimits = writeMemoryLimits;\n+    }\n+\n+    @Override\n+    protected Releasable checkOperationLimits(Request request) {\n+        if (coordinatingBytesNeedAccounted(request)) {\n+            long operationSizeInBytes = primaryOperationSize(request);\n+            return writeMemoryLimits.markCoordinatingOperationStarted(operationSizeInBytes);\n+        } else {\n+            return () -> {};\n+        }\n+    }\n+\n+    protected boolean coordinatingBytesNeedAccounted(Request request) {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Releasable checkPrimaryLimits(Request request) {\n+        return writeMemoryLimits.markPrimaryOperationStarted(primaryOperationSize(request));\n+    }\n+\n+    protected long primaryOperationSize(Request request) {\n+        return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NTcxNg==", "bodyText": "I thought we want to account some for every op? I understand that we might need special logic to allow things when we implement rejections.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437795716", "createdAt": "2020-06-10T00:32:59Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,52 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final boolean forceExecutionOnPrimary;\n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);\n+        this.executor = executor;\n+        this.forceExecutionOnPrimary = forceExecutionOnPrimary;\n+        this.writeMemoryLimits = writeMemoryLimits;\n+    }\n+\n+    @Override\n+    protected Releasable checkOperationLimits(Request request) {\n+        if (coordinatingBytesNeedAccounted(request)) {\n+            long operationSizeInBytes = primaryOperationSize(request);\n+            return writeMemoryLimits.markCoordinatingOperationStarted(operationSizeInBytes);\n+        } else {\n+            return () -> {};\n+        }\n+    }\n+\n+    protected boolean coordinatingBytesNeedAccounted(Request request) {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Releasable checkPrimaryLimits(Request request) {\n+        return writeMemoryLimits.markPrimaryOperationStarted(primaryOperationSize(request));\n+    }\n+\n+    protected long primaryOperationSize(Request request) {\n+        return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NTUzMw=="}, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NDk4Mw==", "bodyText": "ok, let's move this discussion to a follow-up PR where we introduce rejections. I'm mostly worried that we would forget about the callers that are using 0", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437954983", "createdAt": "2020-06-10T08:34:21Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,52 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final boolean forceExecutionOnPrimary;\n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);\n+        this.executor = executor;\n+        this.forceExecutionOnPrimary = forceExecutionOnPrimary;\n+        this.writeMemoryLimits = writeMemoryLimits;\n+    }\n+\n+    @Override\n+    protected Releasable checkOperationLimits(Request request) {\n+        if (coordinatingBytesNeedAccounted(request)) {\n+            long operationSizeInBytes = primaryOperationSize(request);\n+            return writeMemoryLimits.markCoordinatingOperationStarted(operationSizeInBytes);\n+        } else {\n+            return () -> {};\n+        }\n+    }\n+\n+    protected boolean coordinatingBytesNeedAccounted(Request request) {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Releasable checkPrimaryLimits(Request request) {\n+        return writeMemoryLimits.markPrimaryOperationStarted(primaryOperationSize(request));\n+    }\n+\n+    protected long primaryOperationSize(Request request) {\n+        return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NTUzMw=="}, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDgyNDkzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0OTo0MFrOGhH7Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0OTo0MFrOGhH7Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4NjAzOA==", "bodyText": "add a comment here to SAME that we are manually dispatching here.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r437386038", "createdAt": "2020-06-09T12:49:40Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,52 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final boolean forceExecutionOnPrimary;\n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d461c36e07ee613580ab6a430d96769eb00c7c6a"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODk0MzY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMToyNDozNVrOGhwdNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMToyNDozNVrOGhwdNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1MDEwMg==", "bodyText": "doInternalExecute throws exceptions, which would lead to \"leaked\" memory in the tracker.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438050102", "createdAt": "2020-06-10T11:24:35Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -155,6 +158,13 @@ public static IndexRequest getIndexWriteRequest(DocWriteRequest docWriteRequest)\n \n     @Override\n     protected void doExecute(Task task, BulkRequest bulkRequest, ActionListener<BulkResponse> listener) {\n+        long indexingBytes = DocWriteRequest.writeSizeInBytes(bulkRequest.requests.stream());\n+        final Releasable releasable = writeMemoryLimits.markCoordinatingOperationStarted(indexingBytes);\n+        final ActionListener<BulkResponse> releasingListener = ActionListener.runAfter(listener, releasable::close);\n+        doInternalExecute(task, bulkRequest, releasingListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTAyMzU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTo1MTowNFrOGhxO9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNDoyODowMlrOGi2qWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2MjgzOQ==", "bodyText": "I think I would prefer to not have this and instead rely on the task to tell us if this request originated on this node or not (i.e., is task.getParentTaskId().getNodeId().equals(localNodeId) == true). We could assert that if it is local, the parent task must be the bulk action.\nI wonder if you made the experiment and came to the conclusion that it would not work out?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438062839", "createdAt": "2020-06-10T11:51:04Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java", "diffHunk": "@@ -31,10 +31,12 @@\n import java.io.IOException;\n import java.util.HashSet;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n public class BulkShardRequest extends ReplicatedWriteRequest<BulkShardRequest> {\n \n-    private BulkItemRequest[] items;\n+    private final AtomicBoolean bytesAccounted = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwMDM0NA==", "bodyText": "I'll look at this tomorrow. The primary reason I did not do it that way is if a request was sent to another node and then relocated back to the coordinating node it would not be accounted. But that does not really matter with the current design.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r439200344", "createdAt": "2020-06-12T04:28:02Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java", "diffHunk": "@@ -31,10 +31,12 @@\n import java.io.IOException;\n import java.util.HashSet;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n public class BulkShardRequest extends ReplicatedWriteRequest<BulkShardRequest> {\n \n-    private BulkItemRequest[] items;\n+    private final AtomicBoolean bytesAccounted = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2MjgzOQ=="}, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzQzODU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoyOToyMFrOGidDPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoyOToyMFrOGidDPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MDczNQ==", "bodyText": "This looks unused.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438780735", "createdAt": "2020-06-11T13:29:20Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "diffHunk": "@@ -483,4 +507,10 @@ private static BulkItemResponse processUpdateResponse(final UpdateRequest update\n         }\n         return result;\n     }\n+\n+    private static long operationSizeInBytes(BulkItemRequest[] items) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzkzOTk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToxNzo0OVrOGiiEQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToxNzo0OVrOGiiEQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MjkxMg==", "bodyText": "nit: not that it matters a lot, but I think runBefore is more logical in that we release the memory before responding.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438862912", "createdAt": "2020-06-11T15:17:49Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "diffHunk": "@@ -489,10 +508,21 @@ public void runPostReplicaActions(ActionListener<Void> listener) {\n         }\n     }\n \n-    protected void handleReplicaRequest(final ConcreteReplicaRequest<ReplicaRequest> replicaRequest,\n-                                        final TransportChannel channel, final Task task) {\n-        new AsyncReplicaAction(\n-            replicaRequest, new ChannelActionListener<>(channel, transportReplicaAction, replicaRequest), (ReplicationTask) task).run();\n+    protected void handleReplicaRequest(final ConcreteReplicaRequest<ReplicaRequest> replicaRequest, final TransportChannel channel,\n+                                        final Task task) {\n+        Releasable releasable = checkReplicaLimits(replicaRequest.getRequest());\n+        ActionListener<ReplicaResponse> listener =\n+            ActionListener.runAfter(new ChannelActionListener<>(channel, transportReplicaAction, replicaRequest), releasable::close);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDIzMDQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjoxODozOFrOGik-Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMTo0MzozNVrOGi0Zsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMDQ4Nw==", "bodyText": "I think we need to also check if we already accounted for the bytes here, since the request would normally arrive in the operation phase and then afterwards the primary phase is executed locally?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r438910487", "createdAt": "2020-06-11T16:18:38Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,54 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final boolean forceExecutionOnPrimary;\n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n+        // We pass ThreadPool.Names.SAME to the super class as we control the dispatching to the\n+        // ThreadPool.Names.WRITE thread pool in this class.\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);\n+        this.executor = executor;\n+        this.forceExecutionOnPrimary = forceExecutionOnPrimary;\n+        this.writeMemoryLimits = writeMemoryLimits;\n+    }\n+\n+    @Override\n+    protected Releasable checkOperationLimits(Request request) {\n+        if (shouldMarkCoordinatingBytes(request)) {\n+            long operationSizeInBytes = primaryOperationSize(request);\n+            return writeMemoryLimits.markCoordinatingOperationStarted(operationSizeInBytes);\n+        } else {\n+            return () -> {};\n+        }\n+    }\n+\n+    protected boolean shouldMarkCoordinatingBytes(Request request) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Releasable checkPrimaryLimits(Request request) {\n+        return writeMemoryLimits.markPrimaryOperationStarted(primaryOperationSize(request));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2MzMxNQ==", "bodyText": "This PR accounts coordinating and primary work under different metrics.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r439163315", "createdAt": "2020-06-12T01:43:35Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java", "diffHunk": "@@ -57,12 +60,54 @@\n             Response extends ReplicationResponse & WriteResponse\n         > extends TransportReplicationAction<Request, ReplicaRequest, Response> {\n \n+    private final boolean forceExecutionOnPrimary;\n+    private final WriteMemoryLimits writeMemoryLimits;\n+    private final String executor;\n+\n     protected TransportWriteAction(Settings settings, String actionName, TransportService transportService,\n                                    ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,\n                                    ShardStateAction shardStateAction, ActionFilters actionFilters, Writeable.Reader<Request> request,\n-                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {\n+                                   Writeable.Reader<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary,\n+                                   WriteMemoryLimits writeMemoryLimits) {\n+        // We pass ThreadPool.Names.SAME to the super class as we control the dispatching to the\n+        // ThreadPool.Names.WRITE thread pool in this class.\n         super(settings, actionName, transportService, clusterService, indicesService, threadPool, shardStateAction, actionFilters,\n-              request, replicaRequest, executor, true, forceExecutionOnPrimary);\n+            request, replicaRequest, ThreadPool.Names.SAME, true, forceExecutionOnPrimary);\n+        this.executor = executor;\n+        this.forceExecutionOnPrimary = forceExecutionOnPrimary;\n+        this.writeMemoryLimits = writeMemoryLimits;\n+    }\n+\n+    @Override\n+    protected Releasable checkOperationLimits(Request request) {\n+        if (shouldMarkCoordinatingBytes(request)) {\n+            long operationSizeInBytes = primaryOperationSize(request);\n+            return writeMemoryLimits.markCoordinatingOperationStarted(operationSizeInBytes);\n+        } else {\n+            return () -> {};\n+        }\n+    }\n+\n+    protected boolean shouldMarkCoordinatingBytes(Request request) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Releasable checkPrimaryLimits(Request request) {\n+        return writeMemoryLimits.markPrimaryOperationStarted(primaryOperationSize(request));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxMDQ4Nw=="}, "originalCommit": {"oid": "f06985626cd0f60f9c155e26a75d7969127ff059"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NjY3MDY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo0MDo1M1rOGkb2kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo0MDo1M1rOGkb2kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg1ODI1Nw==", "bodyText": "Shouldn't this be the default implementation in TransportWriteAction? Is there still a need to override this method here?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r440858257", "createdAt": "2020-06-16T13:40:53Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "diffHunk": "@@ -110,7 +112,12 @@ protected BulkShardResponse newResponseInstance(StreamInput in) throws IOExcepti\n     }\n \n     @Override\n-    protected void shardOperationOnPrimary(BulkShardRequest request, IndexShard primary,\n+    protected boolean shouldMarkCoordinatingBytes(BulkShardRequest request) {\n+        return request.getParentTask().getNodeId().equals(clusterService.localNode().getId()) == false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1470244f7420174b255eafa67279d11d357f1a0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Njc0NDY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo1NjoxMVrOGkckyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo1NjoxMVrOGkckyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3MDA4OQ==", "bodyText": "The parent task is currently set in the constructor of the ReroutePhase, which I find to be a bit of an odd place (probably to handle odd callers into this class). If we're going to rely on the parent task being correctly set, I wonder if we should make sure that TransportReplication is correctly setting this again whenever it resends the request to another node. I see some calls to transportService.sendRequest in TransportReplicationAction where this is not done (should prefer to use transportService.sendChildRequest throughout this class instead).\nWe should also assert in TransportBulkAction that task != null when setting the parent task of the bulkShardRequest there.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r440870089", "createdAt": "2020-06-16T13:56:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java", "diffHunk": "@@ -110,7 +112,12 @@ protected BulkShardResponse newResponseInstance(StreamInput in) throws IOExcepti\n     }\n \n     @Override\n-    protected void shardOperationOnPrimary(BulkShardRequest request, IndexShard primary,\n+    protected boolean shouldMarkCoordinatingBytes(BulkShardRequest request) {\n+        return request.getParentTask().getNodeId().equals(clusterService.localNode().getId()) == false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1470244f7420174b255eafa67279d11d357f1a0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTU1MDA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/delete/DeleteRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNDo1NzowNVrOGlzVqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNDo1NzowNVrOGlzVqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5MTYyNA==", "bodyText": "Use RamUsageEstimator.sizeOf(String)? It even covers 0 :)", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r442291624", "createdAt": "2020-06-18T14:57:05Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/delete/DeleteRequest.java", "diffHunk": "@@ -247,4 +250,9 @@ public void writeTo(StreamOutput out) throws IOException {\n     public String toString() {\n         return \"delete {[\" + index + \"][\" + id + \"]}\";\n     }\n+\n+    @Override\n+    public long ramBytesUsed() {\n+        return SHALLOW_SIZE + (id == null ? 0 : (2 * id.length()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd1cfadcaf3b7abc522b03b6c4e8aadde764801"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTU2MDIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNDo1OToyM1rOGlzcPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNDo1OToyM1rOGlzcPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5MzMxMQ==", "bodyText": "Should BulkRequest implement Accountable as well?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r442293311", "createdAt": "2020-06-18T14:59:23Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -158,6 +161,17 @@ public static IndexRequest getIndexWriteRequest(DocWriteRequest docWriteRequest)\n \n     @Override\n     protected void doExecute(Task task, BulkRequest bulkRequest, ActionListener<BulkResponse> listener) {\n+        long indexingBytes = DocWriteRequest.writeSizeInBytes(bulkRequest.requests.stream());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd1cfadcaf3b7abc522b03b6c4e8aadde764801"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTIwNzgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowODoxMVrOGoJnLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowODoxMVrOGoJnLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MzcwOA==", "bodyText": "Let's add some assertions to our test infra (InternalTestCluster) that the bytes here at the end  of the test are always 0, similar to assertNoPendingIndexOperations.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r444753708", "createdAt": "2020-06-24T09:08:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.bulk;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class WriteMemoryLimits {\n+\n+    // A heuristic for the bytes overhead of a single write operation\n+    public static final int WRITE_REQUEST_BYTES_OVERHEAD = 1024;\n+\n+    private final AtomicLong coordinatingBytes = new AtomicLong(0);\n+    private final AtomicLong primaryBytes = new AtomicLong(0);\n+    private final AtomicLong replicaBytes = new AtomicLong(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dc01ea7b2647bf8b2c294698659c2847bced1e7"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTMyMTQ3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTo0MDoxMFrOGoKu_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTo0MDoxMFrOGoKu_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MjA5NQ==", "bodyText": "I would prefer to remove this overhead and instead make both BulkShardRequest and BulkItemRequest` accountable too.\nThis turns the tracking into the semi-exact request bytes that have not yet been responded to by this node.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r444772095", "createdAt": "2020-06-24T09:40:10Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/WriteMemoryLimits.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.bulk;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class WriteMemoryLimits {\n+\n+    // A heuristic for the bytes overhead of a single write operation\n+    public static final int WRITE_REQUEST_BYTES_OVERHEAD = 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dc01ea7b2647bf8b2c294698659c2847bced1e7"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTM3MjM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTo1Mzo0M1rOGoLOUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTo1Mzo0M1rOGoLOUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4MDExMw==", "bodyText": "Use runBefore here too?", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r444780113", "createdAt": "2020-06-24T09:53:43Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "diffHunk": "@@ -272,13 +273,31 @@ boolean isRetryableClusterBlockException(final Throwable e) {\n         return false;\n     }\n \n-    protected void handleOperationRequest(final Request request, final TransportChannel channel, Task task) {\n-        execute(task, request, new ChannelActionListener<>(channel, actionName, request));\n+    private void handleOperationRequest(final Request request, final TransportChannel channel, Task task) {\n+        Releasable releasable = checkOperationLimits(request);\n+        ActionListener<Response> listener =\n+            ActionListener.runAfter(new ChannelActionListener<>(channel, actionName, request), releasable::close);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dc01ea7b2647bf8b2c294698659c2847bced1e7"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQwMTkxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowMjo0NlrOGoLhpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowMjo0NlrOGoLhpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NTA2Mg==", "bodyText": "I think we can remove this catch block now? shardOperationOnReplica should never fail with an exception, only case is if the listener fails, which we are asserting against in completeWith.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r444785062", "createdAt": "2020-06-24T10:02:46Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java", "diffHunk": "@@ -531,27 +561,30 @@ public RetryOnReplicaException(StreamInput in) throws IOException {\n \n         @Override\n         public void onResponse(Releasable releasable) {\n+            assert replica.getActiveOperationsCount() != 0 : \"must perform shard operation under a permit\";\n             try {\n-                assert replica.getActiveOperationsCount() != 0 : \"must perform shard operation under a permit\";\n-                final ReplicaResult replicaResult = shardOperationOnReplica(replicaRequest.getRequest(), replica);\n-                replicaResult.runPostReplicaActions(\n-                    ActionListener.wrap(r -> {\n-                        final TransportReplicationAction.ReplicaResponse response =\n-                            new ReplicaResponse(replica.getLocalCheckpoint(), replica.getLastSyncedGlobalCheckpoint());\n-                        releasable.close(); // release shard operation lock before responding to caller\n-                        if (logger.isTraceEnabled()) {\n-                            logger.trace(\"action [{}] completed on shard [{}] for request [{}]\", transportReplicaAction,\n-                                replicaRequest.getRequest().shardId(),\n-                                replicaRequest.getRequest());\n-                        }\n-                        setPhase(task, \"finished\");\n-                        onCompletionListener.onResponse(response);\n-                    }, e -> {\n-                        Releasables.closeWhileHandlingException(releasable); // release shard operation lock before responding to caller\n-                        this.responseWithFailure(e);\n-                    })\n-                );\n-            } catch (final Exception e) {\n+                shardOperationOnReplica(replicaRequest.getRequest(), replica, ActionListener.wrap((replicaResult) ->\n+                    replicaResult.runPostReplicaActions(\n+                        ActionListener.wrap(r -> {\n+                            final ReplicaResponse response =\n+                                new ReplicaResponse(replica.getLocalCheckpoint(), replica.getLastSyncedGlobalCheckpoint());\n+                            releasable.close(); // release shard operation lock before responding to caller\n+                            if (logger.isTraceEnabled()) {\n+                                logger.trace(\"action [{}] completed on shard [{}] for request [{}]\", transportReplicaAction,\n+                                    replicaRequest.getRequest().shardId(),\n+                                    replicaRequest.getRequest());\n+                            }\n+                            setPhase(task, \"finished\");\n+                            onCompletionListener.onResponse(response);\n+                        }, e -> {\n+                            Releasables.closeWhileHandlingException(releasable); // release shard operation lock before responding to caller\n+                            responseWithFailure(e);\n+                        })\n+                    ), e -> {\n+                    Releasables.closeWhileHandlingException(releasable); // release shard operation lock before responding to caller\n+                    AsyncReplicaAction.this.onFailure(e);\n+                }));\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dc01ea7b2647bf8b2c294698659c2847bced1e7"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTQzOTQzOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/action/bulk/WriteMemoryLimitsIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxNDoxMVrOGoL5Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoxNDoxMVrOGoL5Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MTA1OQ==", "bodyText": "Maybe add a couple of assertions to demonstrate that we do get some byte-size out like bulkRequestSize > totalRequestSize and totalRequestSize > 80 * 4 or similar? I think all assertions here would otherwise succeed if ramBytesUsed() returns 0.", "url": "https://github.com/elastic/elasticsearch/pull/57573#discussion_r444791059", "createdAt": "2020-06-24T10:14:11Z", "author": {"login": "henningandersen"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/action/bulk/WriteMemoryLimitsIT.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.bulk;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;\n+import org.elasticsearch.action.admin.indices.stats.ShardStats;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.test.transport.MockTransportService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Stream;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.SUITE, numDataNodes = 2)\n+public class WriteMemoryLimitsIT extends ESIntegTestCase {\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            // Need at least two threads because we are going to block one\n+            .put(\"thread_pool.write.size\", 2)\n+            .build();\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(MockTransportService.TestPlugin.class, InternalSettingsPlugin.class);\n+    }\n+\n+    @Override\n+    protected int numberOfReplicas() {\n+        return 1;\n+    }\n+\n+    @Override\n+    protected int numberOfShards() {\n+        return 1;\n+    }\n+\n+    public void testWriteBytesAreIncremented() throws Exception {\n+        final String index = \"test\";\n+        assertAcked(prepareCreate(index, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1)));\n+        ensureGreen(index);\n+\n+        IndicesStatsResponse response = client().admin().indices().prepareStats(index).get();\n+        String primaryId = Stream.of(response.getShards())\n+            .map(ShardStats::getShardRouting)\n+            .filter(ShardRouting::primary)\n+            .findAny()\n+            .get()\n+            .currentNodeId();\n+        String replicaId = Stream.of(response.getShards())\n+            .map(ShardStats::getShardRouting)\n+            .filter(sr -> sr.primary() == false)\n+            .findAny()\n+            .get()\n+            .currentNodeId();\n+        String primaryName = client().admin().cluster().prepareState().get().getState().nodes().get(primaryId).getName();\n+        String replicaName = client().admin().cluster().prepareState().get().getState().nodes().get(replicaId).getName();\n+\n+        final CountDownLatch replicationSendPointReached = new CountDownLatch(1);\n+        final CountDownLatch latchBlockingReplicationSend = new CountDownLatch(1);\n+        final CountDownLatch newActionsSendPointReached = new CountDownLatch(2);\n+        final CountDownLatch latchBlockingReplication = new CountDownLatch(1);\n+\n+        TransportService primaryService = internalCluster().getInstance(TransportService.class, primaryName);\n+        final MockTransportService primaryTransportService = (MockTransportService) primaryService;\n+        TransportService replicaService = internalCluster().getInstance(TransportService.class, replicaName);\n+        final MockTransportService replicaTransportService = (MockTransportService) replicaService;\n+\n+        primaryTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n+            if (action.equals(TransportShardBulkAction.ACTION_NAME + \"[r]\")) {\n+                try {\n+                    replicationSendPointReached.countDown();\n+                    latchBlockingReplicationSend.await();\n+                } catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            }\n+            connection.sendRequest(requestId, action, request, options);\n+        });\n+\n+        final BulkRequest bulkRequest = new BulkRequest();\n+        int totalRequestSize = 0;\n+        for (int i = 0; i < 80; ++i) {\n+            IndexRequest request = new IndexRequest(index).id(UUIDs.base64UUID())\n+                .source(Collections.singletonMap(\"key\", randomAlphaOfLength(50)));\n+            totalRequestSize += request.ramBytesUsed();\n+            bulkRequest.add(request);\n+        }\n+\n+        final long bulkRequestSize = bulkRequest.ramBytesUsed() + WriteMemoryLimits.WRITE_REQUEST_BYTES_OVERHEAD;\n+        final long bulkShardRequestSize = totalRequestSize + WriteMemoryLimits.WRITE_REQUEST_BYTES_OVERHEAD;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dc01ea7b2647bf8b2c294698659c2847bced1e7"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3746, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}