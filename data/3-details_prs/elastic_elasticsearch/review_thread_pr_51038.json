{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMTE4MTkz", "number": 51038, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxMTowNFrODYKzTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxNDoxMlrODYK2gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjY5Mzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxMTowNFrOFd3wMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxMTowNFrOFd3wMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NjQ4Mg==", "bodyText": "Sadly, this changes exception handling to renotify onFailure if onResponse fails. Not sure if it is important here, but I would opt to keep the explicit listener until #50886 is merged.", "url": "https://github.com/elastic/elasticsearch/pull/51038#discussion_r366866482", "createdAt": "2020-01-15T13:11:04Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java", "diffHunk": "@@ -68,18 +81,62 @@ public void setClient(Client client) {\n      * potentially waiting for a master node to be available.\n      */\n     public void updateMappingOnMaster(Index index, Mapping mappingUpdate, ActionListener<Void> listener) {\n+        final RunOnce release = new RunOnce(() -> semaphore.release());\n+        try {\n+            semaphore.acquire();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            listener.onFailure(e);\n+            return;\n+        }\n+        boolean successFullySent = false;\n+        try {\n+            sendUpdateMapping(index, mappingUpdate, ActionListener.runBefore(listener, release::run));\n+            successFullySent = true;\n+        } finally {\n+            if (successFullySent == false) {\n+                release.run();\n+            }\n+        }\n+    }\n+\n+    // used by tests\n+    int blockedThreads() {\n+        return semaphore.getQueueLength();\n+    }\n+\n+    // can be overridden by tests\n+    protected void sendUpdateMapping(Index index, Mapping mappingUpdate, ActionListener<Void> listener) {\n         client.preparePutMapping().setConcreteIndex(index).setSource(mappingUpdate.toString(), XContentType.JSON)\n             .setMasterNodeTimeout(dynamicMappingUpdateTimeout).setTimeout(TimeValue.ZERO)\n-            .execute(new ActionListener<>() {\n-                @Override\n-                public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n-                    listener.onResponse(null);\n-                }\n+            .execute(ActionListener.map(listener, resp -> null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15fb96d35f687cc1988e63d68461745d7d2f3af6"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjcwMTY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxNDowMFrOFd31Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxNDowMFrOFd31Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NzczNQ==", "bodyText": "nit: I think this comment is unnecessary (but feel free to leave it in)", "url": "https://github.com/elastic/elasticsearch/pull/51038#discussion_r366867735", "createdAt": "2020-01-15T13:14:00Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java", "diffHunk": "@@ -68,18 +81,62 @@ public void setClient(Client client) {\n      * potentially waiting for a master node to be available.\n      */\n     public void updateMappingOnMaster(Index index, Mapping mappingUpdate, ActionListener<Void> listener) {\n+        final RunOnce release = new RunOnce(() -> semaphore.release());\n+        try {\n+            semaphore.acquire();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            listener.onFailure(e);\n+            return;\n+        }\n+        boolean successFullySent = false;\n+        try {\n+            sendUpdateMapping(index, mappingUpdate, ActionListener.runBefore(listener, release::run));\n+            successFullySent = true;\n+        } finally {\n+            if (successFullySent == false) {\n+                release.run();\n+            }\n+        }\n+    }\n+\n+    // used by tests\n+    int blockedThreads() {\n+        return semaphore.getQueueLength();\n+    }\n+\n+    // can be overridden by tests\n+    protected void sendUpdateMapping(Index index, Mapping mappingUpdate, ActionListener<Void> listener) {\n         client.preparePutMapping().setConcreteIndex(index).setSource(mappingUpdate.toString(), XContentType.JSON)\n             .setMasterNodeTimeout(dynamicMappingUpdateTimeout).setTimeout(TimeValue.ZERO)\n-            .execute(new ActionListener<>() {\n-                @Override\n-                public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n-                    listener.onResponse(null);\n-                }\n+            .execute(ActionListener.map(listener, resp -> null));\n+    }\n+\n+    static class AdjustableSemaphore extends Semaphore {\n \n-                @Override\n-                public void onFailure(Exception e) {\n-                    listener.onFailure(e);\n+        private final Object maxPermitsMutex = new Object();\n+        private int maxPermits;\n+\n+        // sets the number of initial maximum permits", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15fb96d35f687cc1988e63d68461745d7d2f3af6"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjcwMjA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxNDoxMlrOFd31YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoxNDoxMlrOFd31YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NzgwOA==", "bodyText": "nit: I think this comment is unnecessary (but feel free to leave it in)", "url": "https://github.com/elastic/elasticsearch/pull/51038#discussion_r366867808", "createdAt": "2020-01-15T13:14:12Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java", "diffHunk": "@@ -68,18 +81,62 @@ public void setClient(Client client) {\n      * potentially waiting for a master node to be available.\n      */\n     public void updateMappingOnMaster(Index index, Mapping mappingUpdate, ActionListener<Void> listener) {\n+        final RunOnce release = new RunOnce(() -> semaphore.release());\n+        try {\n+            semaphore.acquire();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            listener.onFailure(e);\n+            return;\n+        }\n+        boolean successFullySent = false;\n+        try {\n+            sendUpdateMapping(index, mappingUpdate, ActionListener.runBefore(listener, release::run));\n+            successFullySent = true;\n+        } finally {\n+            if (successFullySent == false) {\n+                release.run();\n+            }\n+        }\n+    }\n+\n+    // used by tests\n+    int blockedThreads() {\n+        return semaphore.getQueueLength();\n+    }\n+\n+    // can be overridden by tests\n+    protected void sendUpdateMapping(Index index, Mapping mappingUpdate, ActionListener<Void> listener) {\n         client.preparePutMapping().setConcreteIndex(index).setSource(mappingUpdate.toString(), XContentType.JSON)\n             .setMasterNodeTimeout(dynamicMappingUpdateTimeout).setTimeout(TimeValue.ZERO)\n-            .execute(new ActionListener<>() {\n-                @Override\n-                public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n-                    listener.onResponse(null);\n-                }\n+            .execute(ActionListener.map(listener, resp -> null));\n+    }\n+\n+    static class AdjustableSemaphore extends Semaphore {\n \n-                @Override\n-                public void onFailure(Exception e) {\n-                    listener.onFailure(e);\n+        private final Object maxPermitsMutex = new Object();\n+        private int maxPermits;\n+\n+        // sets the number of initial maximum permits\n+        AdjustableSemaphore(int maxPermits, boolean fair) {\n+            super(maxPermits, fair);\n+            this.maxPermits = maxPermits;\n+        }\n+\n+        // adjust the number of maximum permits", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15fb96d35f687cc1988e63d68461745d7d2f3af6"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4605, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}