{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNzM0MjU3", "number": 55941, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMjoxOTozMFrOD5OuLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMDo0NjoxNlrOEBNNqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzM2NjIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMjoxOTozMFrOGQYbpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDo1OTozMFrOGRNzdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDY5NA==", "bodyText": "can we make this just logAndHeader I think that is different enough from info, warn etc. and you can always look up at the type of logger.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r419830694", "createdAt": "2020-05-05T02:19:30Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(String loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    public void headerWarnAndLog(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMTA0Mw==", "bodyText": "can we also expose a log and a header method ?  log = logfile, warn = header", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r419831043", "createdAt": "2020-05-05T02:21:12Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(String loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    public void headerWarnAndLog(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDY5NA=="}, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMTM5NQ==", "bodyText": "ninja edit - s/warn/header (in case the comments here don't line up with the contents in the email updates)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r419831395", "createdAt": "2020-05-05T02:22:57Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(String loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    public void headerWarnAndLog(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDY5NA=="}, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY5NjQ0Mw==", "bodyText": "agree - log and header method will be useful too. Not sure about the header method name though #55941 (comment)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r420696443", "createdAt": "2020-05-06T10:42:02Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(String loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    public void headerWarnAndLog(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDY5NA=="}, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNTE0MA==", "bodyText": "hm at the same time there is no usage for just log/header on its own at the moment.\nmaybe let's keep that class small for now and add methods as the need arise?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r420705140", "createdAt": "2020-05-06T10:59:30Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(String loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    public void headerWarnAndLog(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDY5NA=="}, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzM2NzM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMjoyMDoxOFrOGQYcSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDo0MToxNFrOGRNPmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDg1Ng==", "bodyText": "can this be header instead of log ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r419830856", "createdAt": "2020-05-05T02:20:18Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.\n+ * Warning values are formatted according to RFC7234.\n+ */\n+public class HeaderWarningLogger {\n+    /**\n+     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n+     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n+     */\n+    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n+        \"299 \" + // warn code\n+            \"Elasticsearch-\" + // warn agent\n+            \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n+            \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n+            \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n+            // quoted RFC 1123 date format\n+            \"\\\"\" + // opening quote\n+            \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n+            \"\\\\d{2} \" + // 2-digit day\n+            \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n+            \"\\\\d{4} \" + // 4-digit year\n+            \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n+            \"GMT\" + // GMT\n+            \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n+    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n+\n+    /*\n+     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n+     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n+     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n+     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n+     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n+     */\n+    private static final String WARNING_PREFIX =\n+        String.format(\n+            Locale.ROOT,\n+            \"299 Elasticsearch-%s%s-%s\",\n+            Version.CURRENT.toString(),\n+            Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n+            Build.CURRENT.hash());\n+\n+    private static BitSet doesNotNeedEncoding;\n+\n+    static {\n+        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n+        doesNotNeedEncoding.set('\\t');\n+        doesNotNeedEncoding.set(' ');\n+        doesNotNeedEncoding.set('!');\n+        doesNotNeedEncoding.set('\\\\');\n+        doesNotNeedEncoding.set('\"');\n+        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n+        for (int i = 0x23; i <= 0x24; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        for (int i = 0x26; i <= 0x5B; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        for (int i = 0x5D; i <= 0x7E; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        for (int i = 0x80; i <= 0xFF; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    }\n+\n+    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+\n+    /**\n+     * This is set once by the {@code Node} constructor, but it uses {@link CopyOnWriteArraySet} to ensure that tests can run in parallel.\n+     * <p>\n+     * Integration tests will create separate nodes within the same classloader, thus leading to a shared, {@code static} state.\n+     * In order for all tests to appropriately be handled, this must be able to remember <em>all</em> {@link ThreadContext}s that it is\n+     * given in a thread safe manner.\n+     * <p>\n+     * For actual usage, multiple nodes do not share the same JVM and therefore this will only be set once in practice.\n+     */\n+    static final CopyOnWriteArraySet<ThreadContext> THREAD_CONTEXT = new CopyOnWriteArraySet<>();\n+\n+    /**\n+     * Set the {@link ThreadContext} used to add warning headers to network responses.\n+     * <p>\n+     * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).\n+     *\n+     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n+     * @throws IllegalStateException if this {@code threadContext} has already been set\n+     */\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        Objects.requireNonNull(threadContext, \"Cannot register a null ThreadContext\");\n+\n+        // add returning false means it _did_ have it already\n+        if (THREAD_CONTEXT.add(threadContext) == false) {\n+            throw new IllegalStateException(\"Double-setting ThreadContext not allowed!\");\n+        }\n+    }\n+\n+    /**\n+     * Remove the {@link ThreadContext} used to add warning headers to network responses.\n+     * <p>\n+     * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).\n+     *\n+     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n+     * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)\n+     */\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        assert threadContext != null;\n+\n+        // remove returning false means it did not have it already\n+        if (THREAD_CONTEXT.remove(threadContext) == false) {\n+            throw new IllegalStateException(\"Removing unknown ThreadContext not allowed!\");\n+        }\n+    }\n+\n+    /**\n+     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n+     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n+     *\n+     * @param s the value of a warning header formatted according to RFC 7234.\n+     * @return the extracted warning value\n+     */\n+    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n+        /*\n+         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n+         * quote and we know the last quote is at the end of the string\n+         *\n+         *   299 Elasticsearch-6.0.0 \"warning value\"\n+         *                           ^             ^\n+         *                           firstQuote    lastQuote\n+         *\n+         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n+         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n+         * verify that we are maintaining the warning header format.\n+         */\n+        final int firstQuote = s.indexOf('\\\"');\n+        final int lastQuote = s.length() - 1;\n+        String warningValue = s.substring(firstQuote + 1, lastQuote);\n+        assert assertWarningValue(s, warningValue);\n+        if (stripXContentPosition) {\n+            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n+            if (matcher.find()) {\n+                warningValue = warningValue.substring(matcher.end());\n+            }\n+        }\n+        return warningValue;\n+    }\n+\n+    /**\n+     * Assert that the specified string has the warning value equal to the provided warning value.\n+     *\n+     * @param s            the string representing a full warning header\n+     * @param warningValue the expected warning header\n+     * @return {@code true} if the specified string has the expected warning value\n+     */\n+    private static boolean assertWarningValue(final String s, final String warningValue) {\n+        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n+        final boolean matches = matcher.matches();\n+        assert matches;\n+        return matcher.group(1).equals(warningValue);\n+    }\n+\n+    /**\n+     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n+     * and appending the RFC 7231 date.\n+     *\n+     * @param s the warning string to format\n+     * @return a warning value formatted according to RFC 7234\n+     */\n+    public static String formatWarning(final String s) {\n+        // Assume that the common scenario won't have a string to escape and encode.\n+        int length = WARNING_PREFIX.length() + s.length() + 3;\n+        final StringBuilder sb = new StringBuilder(length);\n+        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Escape and encode a string as a valid RFC 7230 quoted-string.\n+     *\n+     * @param s the string to escape and encode\n+     * @return the escaped and encoded string\n+     */\n+    public static String escapeAndEncode(final String s) {\n+        return encode(escapeBackslashesAndQuotes(s));\n+    }\n+\n+    /**\n+     * Escape backslashes and quotes in the specified string.\n+     *\n+     * @param s the string to escape\n+     * @return the escaped string\n+     */\n+    static String escapeBackslashesAndQuotes(final String s) {\n+        /*\n+         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n+         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n+         */\n+        boolean escapingNeeded = false;\n+        for (int i = 0; i < s.length(); i++) {\n+            final char c = s.charAt(i);\n+            if (c == '\\\\' || c == '\"') {\n+                escapingNeeded = true;\n+                break;\n+            }\n+        }\n+\n+        if (escapingNeeded) {\n+            final StringBuilder sb = new StringBuilder();\n+            for (final char c : s.toCharArray()) {\n+                if (c == '\\\\' || c == '\"') {\n+                    sb.append(\"\\\\\");\n+                }\n+                sb.append(c);\n+            }\n+            return sb.toString();\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    /**\n+     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n+     *\n+     * @param s the string to encode\n+     * @return the encoded string\n+     */\n+    static String encode(final String s) {\n+        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n+        boolean encodingNeeded = false;\n+        for (int i = 0; i < s.length(); i++) {\n+            int current = s.charAt(i);\n+            if (doesNotNeedEncoding.get(current) == false) {\n+                encodingNeeded = true;\n+                break;\n+            }\n+        }\n+\n+        if (encodingNeeded == false) {\n+            return s;\n+        }\n+\n+        final StringBuilder sb = new StringBuilder(s.length());\n+        for (int i = 0; i < s.length(); ) {\n+            int current = s.charAt(i);\n+            /*\n+             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n+             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n+             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n+             */\n+            if (doesNotNeedEncoding.get(current)) {\n+                // append directly and move to the next character\n+                sb.append((char) current);\n+                i++;\n+            } else {\n+                int startIndex = i;\n+                do {\n+                    i++;\n+                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n+\n+                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n+                // noinspection ForLoopReplaceableByForEach\n+                for (int j = 0; j < bytes.length; j++) {\n+                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static char hex(int b) {\n+        final char ch = Character.forDigit(b & 0xF, 16);\n+        if (Character.isLetter(ch)) {\n+            return Character.toUpperCase(ch);\n+        } else {\n+            return ch;\n+        }\n+    }\n+\n+    public void log(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY5NTk2Mw==", "bodyText": "hm not sure about this one. Wouldn't some verb be better here? addHeader? addHeaderWarning?\nor maybe simply log as it is now. The class name and the field name should express the intent", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r420695963", "createdAt": "2020-05-06T10:41:14Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.\n+ * Warning values are formatted according to RFC7234.\n+ */\n+public class HeaderWarningLogger {\n+    /**\n+     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n+     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n+     */\n+    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n+        \"299 \" + // warn code\n+            \"Elasticsearch-\" + // warn agent\n+            \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n+            \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n+            \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n+            // quoted RFC 1123 date format\n+            \"\\\"\" + // opening quote\n+            \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n+            \"\\\\d{2} \" + // 2-digit day\n+            \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n+            \"\\\\d{4} \" + // 4-digit year\n+            \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n+            \"GMT\" + // GMT\n+            \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n+    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n+\n+    /*\n+     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n+     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n+     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n+     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n+     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n+     */\n+    private static final String WARNING_PREFIX =\n+        String.format(\n+            Locale.ROOT,\n+            \"299 Elasticsearch-%s%s-%s\",\n+            Version.CURRENT.toString(),\n+            Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n+            Build.CURRENT.hash());\n+\n+    private static BitSet doesNotNeedEncoding;\n+\n+    static {\n+        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n+        doesNotNeedEncoding.set('\\t');\n+        doesNotNeedEncoding.set(' ');\n+        doesNotNeedEncoding.set('!');\n+        doesNotNeedEncoding.set('\\\\');\n+        doesNotNeedEncoding.set('\"');\n+        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n+        for (int i = 0x23; i <= 0x24; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        for (int i = 0x26; i <= 0x5B; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        for (int i = 0x5D; i <= 0x7E; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        for (int i = 0x80; i <= 0xFF; i++) {\n+            doesNotNeedEncoding.set(i);\n+        }\n+        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    }\n+\n+    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+\n+    /**\n+     * This is set once by the {@code Node} constructor, but it uses {@link CopyOnWriteArraySet} to ensure that tests can run in parallel.\n+     * <p>\n+     * Integration tests will create separate nodes within the same classloader, thus leading to a shared, {@code static} state.\n+     * In order for all tests to appropriately be handled, this must be able to remember <em>all</em> {@link ThreadContext}s that it is\n+     * given in a thread safe manner.\n+     * <p>\n+     * For actual usage, multiple nodes do not share the same JVM and therefore this will only be set once in practice.\n+     */\n+    static final CopyOnWriteArraySet<ThreadContext> THREAD_CONTEXT = new CopyOnWriteArraySet<>();\n+\n+    /**\n+     * Set the {@link ThreadContext} used to add warning headers to network responses.\n+     * <p>\n+     * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).\n+     *\n+     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n+     * @throws IllegalStateException if this {@code threadContext} has already been set\n+     */\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        Objects.requireNonNull(threadContext, \"Cannot register a null ThreadContext\");\n+\n+        // add returning false means it _did_ have it already\n+        if (THREAD_CONTEXT.add(threadContext) == false) {\n+            throw new IllegalStateException(\"Double-setting ThreadContext not allowed!\");\n+        }\n+    }\n+\n+    /**\n+     * Remove the {@link ThreadContext} used to add warning headers to network responses.\n+     * <p>\n+     * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).\n+     *\n+     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n+     * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)\n+     */\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        assert threadContext != null;\n+\n+        // remove returning false means it did not have it already\n+        if (THREAD_CONTEXT.remove(threadContext) == false) {\n+            throw new IllegalStateException(\"Removing unknown ThreadContext not allowed!\");\n+        }\n+    }\n+\n+    /**\n+     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n+     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n+     *\n+     * @param s the value of a warning header formatted according to RFC 7234.\n+     * @return the extracted warning value\n+     */\n+    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n+        /*\n+         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n+         * quote and we know the last quote is at the end of the string\n+         *\n+         *   299 Elasticsearch-6.0.0 \"warning value\"\n+         *                           ^             ^\n+         *                           firstQuote    lastQuote\n+         *\n+         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n+         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n+         * verify that we are maintaining the warning header format.\n+         */\n+        final int firstQuote = s.indexOf('\\\"');\n+        final int lastQuote = s.length() - 1;\n+        String warningValue = s.substring(firstQuote + 1, lastQuote);\n+        assert assertWarningValue(s, warningValue);\n+        if (stripXContentPosition) {\n+            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n+            if (matcher.find()) {\n+                warningValue = warningValue.substring(matcher.end());\n+            }\n+        }\n+        return warningValue;\n+    }\n+\n+    /**\n+     * Assert that the specified string has the warning value equal to the provided warning value.\n+     *\n+     * @param s            the string representing a full warning header\n+     * @param warningValue the expected warning header\n+     * @return {@code true} if the specified string has the expected warning value\n+     */\n+    private static boolean assertWarningValue(final String s, final String warningValue) {\n+        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n+        final boolean matches = matcher.matches();\n+        assert matches;\n+        return matcher.group(1).equals(warningValue);\n+    }\n+\n+    /**\n+     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n+     * and appending the RFC 7231 date.\n+     *\n+     * @param s the warning string to format\n+     * @return a warning value formatted according to RFC 7234\n+     */\n+    public static String formatWarning(final String s) {\n+        // Assume that the common scenario won't have a string to escape and encode.\n+        int length = WARNING_PREFIX.length() + s.length() + 3;\n+        final StringBuilder sb = new StringBuilder(length);\n+        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Escape and encode a string as a valid RFC 7230 quoted-string.\n+     *\n+     * @param s the string to escape and encode\n+     * @return the escaped and encoded string\n+     */\n+    public static String escapeAndEncode(final String s) {\n+        return encode(escapeBackslashesAndQuotes(s));\n+    }\n+\n+    /**\n+     * Escape backslashes and quotes in the specified string.\n+     *\n+     * @param s the string to escape\n+     * @return the escaped string\n+     */\n+    static String escapeBackslashesAndQuotes(final String s) {\n+        /*\n+         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n+         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n+         */\n+        boolean escapingNeeded = false;\n+        for (int i = 0; i < s.length(); i++) {\n+            final char c = s.charAt(i);\n+            if (c == '\\\\' || c == '\"') {\n+                escapingNeeded = true;\n+                break;\n+            }\n+        }\n+\n+        if (escapingNeeded) {\n+            final StringBuilder sb = new StringBuilder();\n+            for (final char c : s.toCharArray()) {\n+                if (c == '\\\\' || c == '\"') {\n+                    sb.append(\"\\\\\");\n+                }\n+                sb.append(c);\n+            }\n+            return sb.toString();\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    /**\n+     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n+     *\n+     * @param s the string to encode\n+     * @return the encoded string\n+     */\n+    static String encode(final String s) {\n+        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n+        boolean encodingNeeded = false;\n+        for (int i = 0; i < s.length(); i++) {\n+            int current = s.charAt(i);\n+            if (doesNotNeedEncoding.get(current) == false) {\n+                encodingNeeded = true;\n+                break;\n+            }\n+        }\n+\n+        if (encodingNeeded == false) {\n+            return s;\n+        }\n+\n+        final StringBuilder sb = new StringBuilder(s.length());\n+        for (int i = 0; i < s.length(); ) {\n+            int current = s.charAt(i);\n+            /*\n+             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n+             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n+             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n+             */\n+            if (doesNotNeedEncoding.get(current)) {\n+                // append directly and move to the next character\n+                sb.append((char) current);\n+                i++;\n+            } else {\n+                int startIndex = i;\n+                do {\n+                    i++;\n+                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n+\n+                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n+                // noinspection ForLoopReplaceableByForEach\n+                for (int j = 0; j < bytes.length; j++) {\n+                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static char hex(int b) {\n+        final char ch = Character.forDigit(b & 0xF, 16);\n+        if (Character.isLetter(ch)) {\n+            return Character.toUpperCase(ch);\n+        } else {\n+            return ch;\n+        }\n+    }\n+\n+    public void log(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgzMDg1Ng=="}, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODk4NDIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMTowMjoyMFrOGRN45g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMTowMjoyMFrOGRN45g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjUzNA==", "bodyText": "@jakelandis I am also considering renaming these as deprecatedAndMaybe is not clear enough\nI think this should be just throttleLogAndWarnOnHeader and logAndWarnOnHeader\nthe destination -deprecation log - is clear from the name of the field and class", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r420706534", "createdAt": "2020-05-06T11:02:20Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +34,44 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        super(deprecatedLoggerName(parentLogger));\n+\n+    }\n+\n+    private static String deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n+        return name;\n     }\n \n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n-    }\n-\n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n+    public void deprecated(String msg, Object... params) {\n+        headerWarnAndLog(msg,params);\n     }\n \n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n-    }\n-\n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n-\n     /**\n-     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n+     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n+     * not recently been seen.\n      *\n-     * @param s the string to encode\n-     * @return the encoded string\n+     * @param key    the key used to determine if this deprecation should be logged\n+     * @param msg    the message to log\n+     * @param params parameters to the message\n      */\n-    static String encode(final String s) {\n-        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n-        boolean encodingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            int current = s.charAt(i);\n-            if (doesNotNeedEncoding.get(current) == false) {\n-                encodingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (encodingNeeded == false) {\n-            return s;\n-        }\n-\n-        final StringBuilder sb = new StringBuilder(s.length());\n-        for (int i = 0; i < s.length();) {\n-            int current = s.charAt(i);\n-            /*\n-             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n-             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n-             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n-             */\n-            if (doesNotNeedEncoding.get(current)) {\n-                // append directly and move to the next character\n-                sb.append((char) current);\n-                i++;\n-            } else {\n-                int startIndex = i;\n-                do {\n-                    i++;\n-                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n-\n-                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n-                // noinspection ForLoopReplaceableByForEach\n-                for (int j = 0; j < bytes.length; j++) {\n-                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n-                }\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    private static char hex(int b) {\n-        final char ch = Character.forDigit(b & 0xF, 16);\n-        if (Character.isLetter(ch)) {\n-            return Character.toUpperCase(ch);\n-        } else {\n-            return ch;\n-        }\n+    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb8ff9198bb28c7092a2b403948ab3f3c5a5236"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTk4MTYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTo0ODozMlrOGSRhfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzowNjo0N1rOGSboqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgxNDY1Mg==", "bodyText": "Is it safe to assume all of this is copy/pasted from the prior implementation ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421814652", "createdAt": "2020-05-07T21:48:32Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.tasks.Task;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.\n+ * Warning values are formatted according to RFC7234.\n+ */\n+public class HeaderWarningLogger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk4MDMzMA==", "bodyText": "yes, this was all moved from DeprecationLogger. Tests were moved too - HeaderWarningLoggerTests", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421980330", "createdAt": "2020-05-08T07:06:47Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.tasks.Task;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.\n+ * Warning values are formatted according to RFC7234.\n+ */\n+public class HeaderWarningLogger {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgxNDY1Mg=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjAxNjYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjowMDozN1rOGSR2dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMzowOTo0NVrOGSk9pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyMDAyMw==", "bodyText": "can you remove this TODO to add a more meaningful message.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421820023", "createdAt": "2020-05-07T22:00:37Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzMzE1Nw==", "bodyText": "apologies. It was meant to be a reminder to myself that ESLoggerUsageChecker has to be extended to verify the correct usage of this.\nThis can be used in code and someone might forget about passing all required parameters. So ESLoggerUsageChecker can detect this.\nlogger.info(\"msg {} {}\" ,1 ) ;// will fail\nthrottlingANdHeaderWarning.logAndAddWarning(\"msg {} {}, 1); // has to fail too", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422133157", "createdAt": "2020-05-08T13:09:45Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyMDAyMw=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjAxNjg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjowMDo0MlrOGSR2pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMzoxMjoxMlrOGSlCKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyMDA3MA==", "bodyText": "can you remove this TODO to add a more meaningful message.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421820070", "createdAt": "2020-05-07T22:00:42Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {\n+        HeaderWarningLogger.addWarning(msg, params);\n+        Message message = new ParameterizedMessage(msg, params);\n+        throttlingLogger.log(message);\n+    }\n+\n+    /**\n+     * Adds a formatted warning message as a response header on the thread context, and logs a message if the associated key has\n+     * not recently been seen.\n+     *\n+     * @param key    the key used to determine if this message should be logged\n+     * @param msg    the message to log\n+     * @param params parameters to the message\n+     */\n+    //TODO fix this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzNDMxNA==", "bodyText": "fixed this - ESLoggerChecker had to be extended", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422134314", "createdAt": "2020-05-08T13:12:12Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {\n+        HeaderWarningLogger.addWarning(msg, params);\n+        Message message = new ParameterizedMessage(msg, params);\n+        throttlingLogger.log(message);\n+    }\n+\n+    /**\n+     * Adds a formatted warning message as a response header on the thread context, and logs a message if the associated key has\n+     * not recently been seen.\n+     *\n+     * @param key    the key used to determine if this message should be logged\n+     * @param msg    the message to log\n+     * @param params parameters to the message\n+     */\n+    //TODO fix this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyMDA3MA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjAyMjcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjowMzowNlrOGSR6VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjowMzowNlrOGSR6VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyMTAxMg==", "bodyText": "not sure this TODO makes sense ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421821012", "createdAt": "2020-05-07T22:03:06Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjA5MDk5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjoyOTo0N1rOGSSisA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxNDo1NlrOGU5RaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTM0NA==", "bodyText": "can we pull out the requirement for a user provided key ?\ni.e. add a key(String key) as an optional method.\nIf it is not present can we resolve the msg/params and use that as the key ?  It would be minor change to the signature of DeprecratedMessage.of(opaqueId,message). Where message = ParameterizedMessage.format(msg, params), and key = message;\nI think this would simplify the API devs need to work with so they don't need to ensure a unique key (unless thats required).", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421831344", "createdAt": "2020-05-07T22:29:47Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()\n+            .withDeprecation(key, msg, params);\n     }\n \n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n-\n-    /**\n-     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n-     *\n-     * @param s the string to encode\n-     * @return the encoded string\n-     */\n-    static String encode(final String s) {\n-        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n-        boolean encodingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            int current = s.charAt(i);\n-            if (doesNotNeedEncoding.get(current) == false) {\n-                encodingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (encodingNeeded == false) {\n-            return s;\n-        }\n+    public class DeprecationLoggerBuilder {\n \n-        final StringBuilder sb = new StringBuilder(s.length());\n-        for (int i = 0; i < s.length();) {\n-            int current = s.charAt(i);\n-            /*\n-             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n-             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n-             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n-             */\n-            if (doesNotNeedEncoding.get(current)) {\n-                // append directly and move to the next character\n-                sb.append((char) current);\n-                i++;\n-            } else {\n-                int startIndex = i;\n-                do {\n-                    i++;\n-                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n+        private String deprecationKey;\n+        private ESLogMessage deprecationMessage;\n \n-                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n-                // noinspection ForLoopReplaceableByForEach\n-                for (int j = 0; j < bytes.length; j++) {\n-                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n-                }\n-            }\n+        public DeprecationLoggerBuilder withDeprecation(String key, String msg, Object[] params) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk4ODkzNw==", "bodyText": "This is a good idea. Still sometimes provided key might be useful - if someone calls deprecation logger twice but with different message. (can't find that in codebase quickly)\nBut do you think we should iterate all usages of DeprecationLogger and remove the use of deprecate(key,message,params) in favour of deprecate(message,params) ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421988937", "createdAt": "2020-05-08T07:26:48Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()\n+            .withDeprecation(key, msg, params);\n     }\n \n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n-\n-    /**\n-     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n-     *\n-     * @param s the string to encode\n-     * @return the encoded string\n-     */\n-    static String encode(final String s) {\n-        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n-        boolean encodingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            int current = s.charAt(i);\n-            if (doesNotNeedEncoding.get(current) == false) {\n-                encodingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (encodingNeeded == false) {\n-            return s;\n-        }\n+    public class DeprecationLoggerBuilder {\n \n-        final StringBuilder sb = new StringBuilder(s.length());\n-        for (int i = 0; i < s.length();) {\n-            int current = s.charAt(i);\n-            /*\n-             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n-             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n-             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n-             */\n-            if (doesNotNeedEncoding.get(current)) {\n-                // append directly and move to the next character\n-                sb.append((char) current);\n-                i++;\n-            } else {\n-                int startIndex = i;\n-                do {\n-                    i++;\n-                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n+        private String deprecationKey;\n+        private ESLogMessage deprecationMessage;\n \n-                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n-                // noinspection ForLoopReplaceableByForEach\n-                for (int j = 0; j < bytes.length; j++) {\n-                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n-                }\n-            }\n+        public DeprecationLoggerBuilder withDeprecation(String key, String msg, Object[] params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTM0NA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NjY4Mw==", "bodyText": "another interesting idea might to instead of using a message as a key would be to use a call site as a key.\na call site would be a place in code that is more unique then a message (unlikely but sitll)\nthis can be taken simply from a stacktrace from a newly created exception.\nflogger does this https://github.com/google/flogger/blob/b081bc6f209065aea11a797db3ea833bed0ad4b3/api/src/main/java/com/google/common/flogger/util/CallerFinder.java#L43\nbut that should be a different refactoring", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422056683", "createdAt": "2020-05-08T09:59:02Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()\n+            .withDeprecation(key, msg, params);\n     }\n \n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n-\n-    /**\n-     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n-     *\n-     * @param s the string to encode\n-     * @return the encoded string\n-     */\n-    static String encode(final String s) {\n-        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n-        boolean encodingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            int current = s.charAt(i);\n-            if (doesNotNeedEncoding.get(current) == false) {\n-                encodingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (encodingNeeded == false) {\n-            return s;\n-        }\n+    public class DeprecationLoggerBuilder {\n \n-        final StringBuilder sb = new StringBuilder(s.length());\n-        for (int i = 0; i < s.length();) {\n-            int current = s.charAt(i);\n-            /*\n-             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n-             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n-             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n-             */\n-            if (doesNotNeedEncoding.get(current)) {\n-                // append directly and move to the next character\n-                sb.append((char) current);\n-                i++;\n-            } else {\n-                int startIndex = i;\n-                do {\n-                    i++;\n-                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n+        private String deprecationKey;\n+        private ESLogMessage deprecationMessage;\n \n-                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n-                // noinspection ForLoopReplaceableByForEach\n-                for (int j = 0; j < bytes.length; j++) {\n-                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n-                }\n-            }\n+        public DeprecationLoggerBuilder withDeprecation(String key, String msg, Object[] params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTM0NA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2MzA0OQ==", "bodyText": "I like the idea of eliminating the need of a key by caching by the call site. https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html might help here.\nalso, agree future refactoring.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424563049", "createdAt": "2020-05-13T16:14:56Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()\n+            .withDeprecation(key, msg, params);\n     }\n \n-    private static final Charset UTF_8 = StandardCharsets.UTF_8;\n-\n-    /**\n-     * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.\n-     *\n-     * @param s the string to encode\n-     * @return the encoded string\n-     */\n-    static String encode(final String s) {\n-        // first check if the string needs any encoding; this is the fast path and we want to avoid creating a string builder and copying\n-        boolean encodingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            int current = s.charAt(i);\n-            if (doesNotNeedEncoding.get(current) == false) {\n-                encodingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (encodingNeeded == false) {\n-            return s;\n-        }\n+    public class DeprecationLoggerBuilder {\n \n-        final StringBuilder sb = new StringBuilder(s.length());\n-        for (int i = 0; i < s.length();) {\n-            int current = s.charAt(i);\n-            /*\n-             * Either the character does not need encoding or it does; when the character does not need encoding we append the character to\n-             * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible\n-             * which we encode using UTF-8 until we encounter another character that does not need encoding.\n-             */\n-            if (doesNotNeedEncoding.get(current)) {\n-                // append directly and move to the next character\n-                sb.append((char) current);\n-                i++;\n-            } else {\n-                int startIndex = i;\n-                do {\n-                    i++;\n-                } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false);\n+        private String deprecationKey;\n+        private ESLogMessage deprecationMessage;\n \n-                final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8);\n-                // noinspection ForLoopReplaceableByForEach\n-                for (int j = 0; j < bytes.length; j++) {\n-                    sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j]));\n-                }\n-            }\n+        public DeprecationLoggerBuilder withDeprecation(String key, String msg, Object[] params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTM0NA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 401}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjEwMjMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjozNToyN1rOGSSp8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxMzozN1rOGU5NyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMzIwMQ==", "bodyText": "are there any concerns about high volume allocation for this builder object (and other objects created by this builder ?)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421833201", "createdAt": "2020-05-07T22:35:27Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5MTg1Mw==", "bodyText": "fair point. I was expecting the builder to be eligible for escape analysis.. not sure though if the use of fluent builder and objects we will create with withDeprecation or similar won't prevent this.\nIt is safe to log directly from within withDeprectaion though.. we could have only one instance of a builder, with no state. Logging can be done directly when withDeprecationis called.log()` method could be removed.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421991853", "createdAt": "2020-05-08T07:33:28Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMzIwMQ=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzM1Mw==", "bodyText": "but then again there is a nice lib flogger from google. They follow a similar pattern - not sure if they suffer from any performance issues though\nhttps://github.com/google/flogger - they actually refer to this problem in the last paragraph https://github.com/google/flogger/blob/master/docs/anatomy.md", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422013353", "createdAt": "2020-05-08T08:21:21Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMzIwMQ=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2MjEyMQ==", "bodyText": "ok .. i don't want to pre-maturely optimize to avoid the creation of the object here.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424562121", "createdAt": "2020-05-13T16:13:37Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -102,316 +36,50 @@ public static void removeThreadContext(ThreadContext threadContext) {\n      * the \"org.elasticsearch\" namespace.\n      */\n     public DeprecationLogger(Logger parentLogger) {\n+        deprecationLogger = new ThrottlingAndHeaderWarningLogger(deprecatedLoggerName(parentLogger));\n+    }\n+\n+    private static Logger deprecatedLoggerName(Logger parentLogger) {\n         String name = parentLogger.getName();\n         if (name.startsWith(\"org.elasticsearch\")) {\n             name = name.replace(\"org.elasticsearch.\", \"org.elasticsearch.deprecation.\");\n         } else {\n             name = \"deprecation.\" + name;\n         }\n-        this.logger = LogManager.getLogger(name);\n-    }\n-\n-    // LRU set of keys used to determine if a deprecation message should be emitted to the deprecation logs\n-    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<>() {\n-        @Override\n-        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n-            return size() > 128;\n-        }\n-    }));\n-\n-    /**\n-     * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has\n-     * not recently been seen.\n-     *\n-     * @param key    the key used to determine if this deprecation should be logged\n-     * @param msg    the message to log\n-     * @param params parameters to the message\n-     */\n-    public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {\n-        String xOpaqueId = getXOpaqueId(THREAD_CONTEXT);\n-        boolean shouldLog = keys.add(xOpaqueId + key);\n-        deprecated(THREAD_CONTEXT, msg, shouldLog, params);\n-    }\n-\n-    /*\n-     * RFC7234 specifies the warning format as warn-code <space> warn-agent <space> \"warn-text\" [<space> \"warn-date\"]. Here, warn-code is a\n-     * three-digit number with various standard warn codes specified. The warn code 299 is apt for our purposes as it represents a\n-     * miscellaneous persistent warning (can be presented to a human, or logged, and must not be removed by a cache). The warn-agent is an\n-     * arbitrary token; here we use the Elasticsearch version and build hash. The warn text must be quoted. The warn-date is an optional\n-     * quoted field that can be in a variety of specified date formats; here we use RFC 1123 format.\n-     */\n-    private static final String WARNING_PREFIX =\n-            String.format(\n-                    Locale.ROOT,\n-                    \"299 Elasticsearch-%s%s-%s\",\n-                    Version.CURRENT.toString(),\n-                    Build.CURRENT.isSnapshot() ? \"-SNAPSHOT\" : \"\",\n-                    Build.CURRENT.hash());\n-\n-    /**\n-     * Regular expression to test if a string matches the RFC7234 specification for warning headers. This pattern assumes that the warn code\n-     * is always 299. Further, this pattern assumes that the warn agent represents a version of Elasticsearch including the build hash.\n-     */\n-    public static final Pattern WARNING_HEADER_PATTERN = Pattern.compile(\n-            \"299 \" + // warn code\n-                    \"Elasticsearch-\" + // warn agent\n-                    \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+(?:-(?:alpha|beta|rc)\\\\d+)?(?:-SNAPSHOT)?-\" + // warn agent\n-                    \"(?:[a-f0-9]{7}(?:[a-f0-9]{33})?|unknown) \" + // warn agent\n-                    \"\\\"((?:\\t| |!|[\\\\x23-\\\\x5B]|[\\\\x5D-\\\\x7E]|[\\\\x80-\\\\xFF]|\\\\\\\\|\\\\\\\\\\\")*)\\\"( \" + // quoted warning value, captured\n-                    // quoted RFC 1123 date format\n-                    \"\\\"\" + // opening quote\n-                    \"(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \" + // weekday\n-                    \"\\\\d{2} \" + // 2-digit day\n-                    \"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \" + // month\n-                    \"\\\\d{4} \" + // 4-digit year\n-                    \"\\\\d{2}:\\\\d{2}:\\\\d{2} \" + // (two-digit hour):(two-digit minute):(two-digit second)\n-                    \"GMT\" + // GMT\n-                    \"\\\")?\"); // closing quote (optional, since an older version can still send a warn-date)\n-\n-    public static final Pattern WARNING_XCONTENT_LOCATION_PATTERN = Pattern.compile(\"^\\\\[.*?]\\\\[-?\\\\d+:-?\\\\d+] \");\n-\n-    /**\n-     * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string\n-     * {@code 299 Elasticsearch-6.0.0 \"warning value\"}, the return value of this method would be {@code warning value}.\n-     *\n-     * @param s the value of a warning header formatted according to RFC 7234.\n-     * @return the extracted warning value\n-     */\n-    public static String extractWarningValueFromWarningHeader(final String s, boolean stripXContentPosition) {\n-        /*\n-         * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first\n-         * quote and we know the last quote is at the end of the string\n-         *\n-         *   299 Elasticsearch-6.0.0 \"warning value\"\n-         *                           ^             ^\n-         *                           firstQuote    lastQuote\n-         *\n-         * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of\n-         * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to\n-         * verify that we are maintaining the warning header format.\n-         */\n-        final int firstQuote = s.indexOf('\\\"');\n-        final int lastQuote = s.length() - 1;\n-        String warningValue = s.substring(firstQuote + 1, lastQuote);\n-        assert assertWarningValue(s, warningValue);\n-        if (stripXContentPosition) {\n-            Matcher matcher = WARNING_XCONTENT_LOCATION_PATTERN.matcher(warningValue);\n-            if (matcher.find()) {\n-                warningValue = warningValue.substring(matcher.end());\n-            }\n-        }\n-        return warningValue;\n-    }\n-\n-    /**\n-     * Assert that the specified string has the warning value equal to the provided warning value.\n-     *\n-     * @param s            the string representing a full warning header\n-     * @param warningValue the expected warning header\n-     * @return {@code true} if the specified string has the expected warning value\n-     */\n-    private static boolean assertWarningValue(final String s, final String warningValue) {\n-        final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s);\n-        final boolean matches = matcher.matches();\n-        assert matches;\n-        return matcher.group(1).equals(warningValue);\n-    }\n-\n-    /**\n-     * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.\n-     *\n-     * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).\n-     * @param message The deprecation message.\n-     * @param params The parameters used to fill in the message, if any exist.\n-     */\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {\n-        deprecated(threadContexts, message, true, params);\n-    }\n-\n-    void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean shouldLog, final Object... params) {\n-        final Iterator<ThreadContext> iterator = threadContexts.iterator();\n-        if (iterator.hasNext()) {\n-            final String formattedMessage = LoggerMessageFormat.format(message, params);\n-            final String warningHeaderValue = formatWarning(formattedMessage);\n-            assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches();\n-            assert extractWarningValueFromWarningHeader(warningHeaderValue, false).equals(escapeAndEncode(formattedMessage));\n-            while (iterator.hasNext()) {\n-                try {\n-                    final ThreadContext next = iterator.next();\n-                    next.addResponseHeader(\"Warning\", warningHeaderValue);\n-                } catch (final IllegalStateException e) {\n-                    // ignored; it should be removed shortly\n-                }\n-            }\n-        }\n-\n-        if (shouldLog) {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n-                @Override\n-                public Void run() {\n-                    /*\n-                     * There should be only one threadContext (in prod env), @see DeprecationLogger#setThreadContext\n-                     */\n-                    String opaqueId = getXOpaqueId(threadContexts);\n-\n-                    logger.warn(DeprecatedMessage.of(opaqueId, message, params));\n-                    return null;\n-                }\n-            });\n-        }\n+        return LogManager.getLogger(name);\n     }\n \n-    public String getXOpaqueId(Set<ThreadContext> threadContexts) {\n-        return threadContexts.stream()\n-                             .filter(t -> t.getHeader(Task.X_OPAQUE_ID) != null)\n-                             .findFirst()\n-                             .map(t -> t.getHeader(Task.X_OPAQUE_ID))\n-                             .orElse(\"\");\n-    }\n-\n-    /**\n-     * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,\n-     * and appending the RFC 7231 date.\n-     *\n-     * @param s the warning string to format\n-     * @return a warning value formatted according to RFC 7234\n-     */\n-    public static String formatWarning(final String s) {\n-        // Assume that the common scenario won't have a string to escape and encode.\n-        int length = WARNING_PREFIX.length() + s.length() + 3;\n-        final StringBuilder sb = new StringBuilder(length);\n-        sb.append(WARNING_PREFIX).append(\" \\\"\").append(escapeAndEncode(s)).append(\"\\\"\");\n-        return sb.toString();\n+    public static void setThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.setThreadContext(threadContext);\n     }\n \n-    /**\n-     * Escape and encode a string as a valid RFC 7230 quoted-string.\n-     *\n-     * @param s the string to escape and encode\n-     * @return the escaped and encoded string\n-     */\n-    public static String escapeAndEncode(final String s) {\n-        return encode(escapeBackslashesAndQuotes(s));\n+    public static void removeThreadContext(ThreadContext threadContext) {\n+        HeaderWarningLogger.removeThreadContext(threadContext);\n     }\n \n     /**\n-     * Escape backslashes and quotes in the specified string.\n-     *\n-     * @param s the string to escape\n-     * @return the escaped string\n+     * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.\n      */\n-    static String escapeBackslashesAndQuotes(final String s) {\n-        /*\n-         * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking\n-         * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and\n-         */\n-        boolean escapingNeeded = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            final char c = s.charAt(i);\n-            if (c == '\\\\' || c == '\"') {\n-                escapingNeeded = true;\n-                break;\n-            }\n-        }\n-\n-        if (escapingNeeded) {\n-            final StringBuilder sb = new StringBuilder();\n-            for (final char c : s.toCharArray()) {\n-                if (c == '\\\\' || c == '\"') {\n-                    sb.append(\"\\\\\");\n-                }\n-                sb.append(c);\n-            }\n-            return sb.toString();\n-        } else {\n-            return s;\n-        }\n-    }\n-\n-    private static BitSet doesNotNeedEncoding;\n-\n-    static {\n-        doesNotNeedEncoding = new BitSet(1 + 0xFF);\n-        doesNotNeedEncoding.set('\\t');\n-        doesNotNeedEncoding.set(' ');\n-        doesNotNeedEncoding.set('!');\n-        doesNotNeedEncoding.set('\\\\');\n-        doesNotNeedEncoding.set('\"');\n-        // we have to skip '%' which is 0x25 so that it is percent-encoded too\n-        for (int i = 0x23; i <= 0x24; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x26; i <= 0x5B; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x5D; i <= 0x7E; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        for (int i = 0x80; i <= 0xFF; i++) {\n-            doesNotNeedEncoding.set(i);\n-        }\n-        assert doesNotNeedEncoding.get('%') == false : doesNotNeedEncoding;\n+    //TODO fix logger usage check\n+    public DeprecationLoggerBuilder deprecate(final String key, final String msg, final Object... params) {\n+        return new DeprecationLoggerBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMzIwMQ=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjEzMjE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ESLogMessage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo0Nzo0MlrOGSS7DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxNzowMlrOGU5WxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzU4MA==", "bodyText": "similar to my other comment about resolving the patterns for the deprecation key ... should we try to resolve the pattern as early as possible to avoid having to pass the pattern and args around and possibly resolving it once of the log and again for the header ?\nThat would require this signature to change, or add another constructor to accept just a String message, and who ever calls this to resolve it themselves. A quick look at the code and there is only 1 place outside of this review (not in tests) that calls this constructor.\n(Also I think you won't need to expose the new getArguments, getMessagePatterns)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421837580", "createdAt": "2020-05-07T22:47:42Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ESLogMessage.java", "diffHunk": "@@ -36,10 +36,13 @@\n  */\n public class ESLogMessage extends MapMessage<ESLogMessage, Object> {\n     private final List<Object> arguments = new ArrayList<>();\n+    private String messagePattern;\n \n     public ESLogMessage(String messagePattern, Object... args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5Mzg5OQ==", "bodyText": "I think we don't want this. In log4j you no longer have to use if(isDebug) guard style. THat means when someone calls\nlogger.debug(\"some message {}\", objectWithExpensiveToString)\n\nit does not require to execute the toString and create an expensive string unless the debug level (or any other) is actually set.\nThe messagePattern and arguments getters are needed because we use the same object to format message to a header (different formatting then in logs)\nFor json logging I do similar think. I make sure that I store an object that lazily evaluates to \"message\" json field. https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/logging/ESLogMessage.java#L46", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421993899", "createdAt": "2020-05-08T07:38:05Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ESLogMessage.java", "diffHunk": "@@ -36,10 +36,13 @@\n  */\n public class ESLogMessage extends MapMessage<ESLogMessage, Object> {\n     private final List<Object> arguments = new ArrayList<>();\n+    private String messagePattern;\n \n     public ESLogMessage(String messagePattern, Object... args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzU4MA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3MDg0Nw==", "bodyText": "The messagePattern and arguments getters are needed because we use the same object to format message to a header (different formatting then in logs)\n\nit is actually something that should be cleaned up", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422170847", "createdAt": "2020-05-08T14:20:25Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ESLogMessage.java", "diffHunk": "@@ -36,10 +36,13 @@\n  */\n public class ESLogMessage extends MapMessage<ESLogMessage, Object> {\n     private final List<Object> arguments = new ArrayList<>();\n+    private String messagePattern;\n \n     public ESLogMessage(String messagePattern, Object... args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzU4MA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NDQyMA==", "bodyText": "I forgot about he lazy evaluation, thanks for the reminder.  You are right we probably don't want to eagerly resolve. We would have to if we wanted to use the message for key, but having an explicit key is fine for now (that has it has always worked) and in the future we may explore using he call site.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424564420", "createdAt": "2020-05-13T16:17:02Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ESLogMessage.java", "diffHunk": "@@ -36,10 +36,13 @@\n  */\n public class ESLogMessage extends MapMessage<ESLogMessage, Object> {\n     private final List<Object> arguments = new ArrayList<>();\n+    private String messagePattern;\n \n     public ESLogMessage(String messagePattern, Object... args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzU4MA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE0NDIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1MzoxOVrOGSTCUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzo0MDozMVrOGSch9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzOTQ0MQ==", "bodyText": "should this be .deprecate(...).log() ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421839441", "createdAt": "2020-05-07T22:53:19Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -367,7 +366,7 @@ public ClusterState addIndexTemplateV2(final ClusterState currentState, final bo\n                     .collect(Collectors.joining(\",\")),\n                 name);\n             logger.warn(warning);\n-            deprecationLogger.deprecatedAndMaybeLog(\"index_template_pattern_overlap\", warning);\n+            deprecationLogger.logAndAddWarning(\"index_template_pattern_overlap\", warning);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5NDk5OA==", "bodyText": "the field name is probably confusing - should be renamed.\nThis is actually always sending a log message to a server and adding a header warning.\ngood point if there should be a builder in ThrottlingAndHeaderWarningLogger (and some hierarchy with DeprecationLoggerBuilder )", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421994998", "createdAt": "2020-05-08T07:40:31Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -367,7 +366,7 @@ public ClusterState addIndexTemplateV2(final ClusterState currentState, final bo\n                     .collect(Collectors.joining(\",\")),\n                 name);\n             logger.warn(warning);\n-            deprecationLogger.deprecatedAndMaybeLog(\"index_template_pattern_overlap\", warning);\n+            deprecationLogger.logAndAddWarning(\"index_template_pattern_overlap\", warning);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzOTQ0MQ=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE0NDMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1MzoyM1rOGSTCaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzo0MDo0NlrOGSciaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzOTQ2NA==", "bodyText": "should this be .deprecate(...).log() ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421839464", "createdAt": "2020-05-07T22:53:23Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -601,7 +600,7 @@ static ClusterState innerPutTemplate(final ClusterState currentState, PutRequest\n                         .collect(Collectors.joining(\",\")),\n                     request.name);\n                 logger.warn(warning);\n-                deprecationLogger.deprecatedAndMaybeLog(\"index_template_pattern_overlap\", warning);\n+                deprecationLogger.logAndAddWarning(\"index_template_pattern_overlap\", warning);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5NTExMw==", "bodyText": "as per my comment #55941 (comment)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421995113", "createdAt": "2020-05-08T07:40:46Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -601,7 +600,7 @@ static ClusterState innerPutTemplate(final ClusterState currentState, PutRequest\n                         .collect(Collectors.joining(\",\")),\n                     request.name);\n                 logger.warn(warning);\n-                deprecationLogger.deprecatedAndMaybeLog(\"index_template_pattern_overlap\", warning);\n+                deprecationLogger.logAndAddWarning(\"index_template_pattern_overlap\", warning);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzOTQ2NA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE1MjM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1Njo1M1rOGSTHFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoyMDo1N1rOGU5g3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDY2MA==", "bodyText": "Can we remove this method ? I think there is only 2 usages of this (and commented that I think they are wrong)\nIts kinda weird to have the throtlling logger not actually throttle.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421840660", "createdAt": "2020-05-07T22:56:53Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NzkzNQ==", "bodyText": "true, it might be a bit odd. but the alternative is to another 'combination class' that would always log and emit a header warning.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422047935", "createdAt": "2020-05-08T09:39:05Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDY2MA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NzAwNQ==", "bodyText": "as discussed in person, i think this can be removed since we only want to expose the Deprecation logger and the Header warning logger. We want to avoid general usaage of this class and if a user wants to always header warn they can use that method and throttling to the main server log is something that that requires more consideration.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424567005", "createdAt": "2020-05-13T16:20:57Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDY2MA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE1MzEzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingLogger.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1NzoxM1rOGSTHhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoyMTo0MlrOGU5irA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDc3Mg==", "bodyText": "can this be private ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421840772", "createdAt": "2020-05-07T22:57:13Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingLogger.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * TODO wrapping logging this way limits the usage of %location. It will think this is used from that class.\n+ * <p>\n+ * This is a wrapper around a logger that allows to throttle log messages.\n+ * In order to throttle a key has to be used and throttling happens per each key combined with X-Opaque-Id.\n+ * X-Opaque-Id allows throttling per user. This value is set in ThreadContext from X-Opaque-Id HTTP header.\n+ * <p>\n+ * The throttling algorithm is relying on LRU set of keys which evicts entries when its size is &gt; 128.\n+ * When a log with a key is emitted, it won't be logged again until the set reaches size 128 and the key is removed from the set.\n+ *\n+ * @see HeaderWarningLogger\n+ */\n+class ThrottlingLogger {\n+\n+    // LRU set of keys used to determine if a message should be emitted to the logs\n+    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<String, Boolean>() {\n+        @Override\n+        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n+            return size() > 128;\n+        }\n+    }));\n+\n+    private final Logger logger;\n+\n+    ThrottlingLogger(Logger logger) {\n+        this.logger = logger;\n+    }\n+\n+    void throttleLog(String key, Message message) {\n+        String xOpaqueId = HeaderWarningLogger.getXOpaqueId();\n+        boolean shouldLog = keys.add(xOpaqueId + key);\n+        if (shouldLog) {\n+            log(message);\n+        }\n+    }\n+\n+    void log(Message message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzMzk4MA==", "bodyText": "actually as long as ThrottlingAndHeaderWarningLogger is using this, it should still be package scope.\nhttps://github.com/elastic/elasticsearch/pull/55941/files#r422048662", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422133980", "createdAt": "2020-05-08T13:11:30Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingLogger.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * TODO wrapping logging this way limits the usage of %location. It will think this is used from that class.\n+ * <p>\n+ * This is a wrapper around a logger that allows to throttle log messages.\n+ * In order to throttle a key has to be used and throttling happens per each key combined with X-Opaque-Id.\n+ * X-Opaque-Id allows throttling per user. This value is set in ThreadContext from X-Opaque-Id HTTP header.\n+ * <p>\n+ * The throttling algorithm is relying on LRU set of keys which evicts entries when its size is &gt; 128.\n+ * When a log with a key is emitted, it won't be logged again until the set reaches size 128 and the key is removed from the set.\n+ *\n+ * @see HeaderWarningLogger\n+ */\n+class ThrottlingLogger {\n+\n+    // LRU set of keys used to determine if a message should be emitted to the logs\n+    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<String, Boolean>() {\n+        @Override\n+        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n+            return size() > 128;\n+        }\n+    }));\n+\n+    private final Logger logger;\n+\n+    ThrottlingLogger(Logger logger) {\n+        this.logger = logger;\n+    }\n+\n+    void throttleLog(String key, Message message) {\n+        String xOpaqueId = HeaderWarningLogger.getXOpaqueId();\n+        boolean shouldLog = keys.add(xOpaqueId + key);\n+        if (shouldLog) {\n+            log(message);\n+        }\n+    }\n+\n+    void log(Message message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDc3Mg=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NzQ2OA==", "bodyText": "I think with the following comment: https://github.com/elastic/elasticsearch/pull/55941/files#r421840660 we can make this private.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424567468", "createdAt": "2020-05-13T16:21:42Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingLogger.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * TODO wrapping logging this way limits the usage of %location. It will think this is used from that class.\n+ * <p>\n+ * This is a wrapper around a logger that allows to throttle log messages.\n+ * In order to throttle a key has to be used and throttling happens per each key combined with X-Opaque-Id.\n+ * X-Opaque-Id allows throttling per user. This value is set in ThreadContext from X-Opaque-Id HTTP header.\n+ * <p>\n+ * The throttling algorithm is relying on LRU set of keys which evicts entries when its size is &gt; 128.\n+ * When a log with a key is emitted, it won't be logged again until the set reaches size 128 and the key is removed from the set.\n+ *\n+ * @see HeaderWarningLogger\n+ */\n+class ThrottlingLogger {\n+\n+    // LRU set of keys used to determine if a message should be emitted to the logs\n+    private final Set<String> keys = Collections.newSetFromMap(Collections.synchronizedMap(new LinkedHashMap<String, Boolean>() {\n+        @Override\n+        protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {\n+            return size() > 128;\n+        }\n+    }));\n+\n+    private final Logger logger;\n+\n+    ThrottlingLogger(Logger logger) {\n+        this.logger = logger;\n+    }\n+\n+    void throttleLog(String key, Message message) {\n+        String xOpaqueId = HeaderWarningLogger.getXOpaqueId();\n+        boolean shouldLog = keys.add(xOpaqueId + key);\n+        if (shouldLog) {\n+            log(message);\n+        }\n+    }\n+\n+    void log(Message message) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDc3Mg=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE2MTA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowMDo1OFrOGSTMTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo0MDozOVrOGSfzlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MTk5OA==", "bodyText": "can this be package private ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421841998", "createdAt": "2020-05-07T23:00:58Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {\n+        HeaderWarningLogger.addWarning(msg, params);\n+        Message message = new ParameterizedMessage(msg, params);\n+        throttlingLogger.log(message);\n+    }\n+\n+    /**\n+     * Adds a formatted warning message as a response header on the thread context, and logs a message if the associated key has\n+     * not recently been seen.\n+     *\n+     * @param key    the key used to determine if this message should be logged\n+     * @param msg    the message to log\n+     * @param params parameters to the message\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void throttleLogAndAddWarning(final String key, final String msg, final Object... params) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0ODY2Mg==", "bodyText": "actually as per discussion earlier, we should prevent accidental throttling to server log. I will only leave the second method\nvoid throttleLogAndAddWarning(final String key, ESLogMessage message)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r422048662", "createdAt": "2020-05-08T09:40:39Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {\n+        HeaderWarningLogger.addWarning(msg, params);\n+        Message message = new ParameterizedMessage(msg, params);\n+        throttlingLogger.log(message);\n+    }\n+\n+    /**\n+     * Adds a formatted warning message as a response header on the thread context, and logs a message if the associated key has\n+     * not recently been seen.\n+     *\n+     * @param key    the key used to determine if this message should be logged\n+     * @param msg    the message to log\n+     * @param params parameters to the message\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void throttleLogAndAddWarning(final String key, final String msg, final Object... params) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MTk5OA=="}, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE2MjEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowMToyM1rOGSTM5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowMToyM1rOGSTM5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MjE0OQ==", "bodyText": "can this be pacakge private", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421842149", "createdAt": "2020-05-07T23:01:23Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {\n+    private final HeaderWarningLogger headerWarningLogger = new HeaderWarningLogger();\n+    private final ThrottlingLogger throttlingLogger;\n+\n+    public ThrottlingAndHeaderWarningLogger(Logger loggerName) {\n+        this.throttlingLogger = new ThrottlingLogger(LogManager.getLogger(loggerName));\n+    }\n+\n+    /**\n+     * Logs a message, adding a formatted warning message as a response header on the thread context.\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void logAndAddWarning(String msg, Object... params) {\n+        HeaderWarningLogger.addWarning(msg, params);\n+        Message message = new ParameterizedMessage(msg, params);\n+        throttlingLogger.log(message);\n+    }\n+\n+    /**\n+     * Adds a formatted warning message as a response header on the thread context, and logs a message if the associated key has\n+     * not recently been seen.\n+     *\n+     * @param key    the key used to determine if this message should be logged\n+     * @param msg    the message to log\n+     * @param params parameters to the message\n+     */\n+    //TODO fix this\n+    @SuppressLoggerChecks(reason = \"safely delegates to logger\")\n+    public void throttleLogAndAddWarning(final String key, final String msg, final Object... params) {\n+        HeaderWarningLogger.addWarning(msg, params);\n+        ESLogMessage message = new ESLogMessage(msg, params);\n+        throttlingLogger.throttleLog(key, message);\n+    }\n+\n+    public void throttleLogAndAddWarning(final String key, ESLogMessage message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE2OTgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowNTowM1rOGSTRYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowNTowM1rOGSTRYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MzI5Nw==", "bodyText": "nit: Can this be named HeaderWarning to avoid the word logger.  IMO, a logger sends data to a log file. (also the class level doc s/logger/class)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421843297", "createdAt": "2020-05-07T23:05:03Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.tasks.Task;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.\n+ * Warning values are formatted according to RFC7234.\n+ */\n+public class HeaderWarningLogger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjE3MzcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowNjo1OFrOGSTTtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzowNjo1OFrOGSTTtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0Mzg5Mw==", "bodyText": "Can you provide a usage example ?\nIs there anything special the consumer neededs to do for the x-opaqueId ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r421843893", "createdAt": "2020-05-07T23:06:58Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.tasks.Task;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.\n+ * Warning values are formatted according to RFC7234.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408cc80c09d3fc1e2ddc7a1473963199d7e932f8"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDk2Mzg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNToyODoyOFrOGThc6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjowNzoyNFrOGU49dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEyNDIwMw==", "bodyText": "this is the usage of the refactoring from this PR.\nthis log line always log  - to server - and adds a warning.\nThe type might be a bit confusing. Maybe this should 2 lines:\n\nto log to a server file - regular logger\nadd a warning to a headers\n@jakelandis wdyt?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r423124203", "createdAt": "2020-05-11T15:28:28Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -367,8 +366,7 @@ public ClusterState addIndexTemplateV2(final ClusterState currentState, final bo\n                     .map(e -> e.getKey() + \" => \" + e.getValue())\n                     .collect(Collectors.joining(\",\")),\n                 name);\n-            logger.warn(warning);\n-            deprecationLogger.deprecatedAndMaybeLog(\"index_template_pattern_overlap\", warning);\n+            warningLogger.logAndAddWarning(warning);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65a67bcd6af164249ea3c0d5199ed85700a70005"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU1Nzk0Mw==", "bodyText": "++ for 2 lines.  We should also probably make ThrottlingAndHeaderWarningLogger package private.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424557943", "createdAt": "2020-05-13T16:07:24Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -367,8 +366,7 @@ public ClusterState addIndexTemplateV2(final ClusterState currentState, final bo\n                     .map(e -> e.getKey() + \" => \" + e.getValue())\n                     .collect(Collectors.joining(\",\")),\n                 name);\n-            logger.warn(warning);\n-            deprecationLogger.deprecatedAndMaybeLog(\"index_template_pattern_overlap\", warning);\n+            warningLogger.logAndAddWarning(warning);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEyNDIwMw=="}, "originalCommit": {"oid": "65a67bcd6af164249ea3c0d5199ed85700a70005"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Mzc0ODYzOnYy", "diffSide": "RIGHT", "path": "qa/evil-tests/src/test/java/org/elasticsearch/common/logging/EvilLoggerTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo0Nzo0N1rOGU4Fjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMDowNTo0NFrOGVVPnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0MzYzMQ==", "bodyText": "did this slip in, or is it intentional ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424543631", "createdAt": "2020-05-13T15:47:47Z", "author": {"login": "jakelandis"}, "path": "qa/evil-tests/src/test/java/org/elasticsearch/common/logging/EvilLoggerTests.java", "diffHunk": "@@ -67,6 +67,7 @@\n \n     @Override\n     public void setUp() throws Exception {\n+        assert \"false\".equals(System.getProperty(\"tests.security.manager\")) : \"-Dtests.security.manager=false has to be set\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48a3234ba30cdee91bc6c05ab242af030e8e067"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAyMTM0MQ==", "bodyText": "probably not directly related to the refactoring, but it is useful when running this test from intellij to get that reminder. not obvious from just a failure message why the test failed", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r425021341", "createdAt": "2020-05-14T10:05:44Z", "author": {"login": "pgomulka"}, "path": "qa/evil-tests/src/test/java/org/elasticsearch/common/logging/EvilLoggerTests.java", "diffHunk": "@@ -67,6 +67,7 @@\n \n     @Override\n     public void setUp() throws Exception {\n+        assert \"false\".equals(System.getProperty(\"tests.security.manager\")) : \"-Dtests.security.manager=false has to be set\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0MzYzMQ=="}, "originalCommit": {"oid": "d48a3234ba30cdee91bc6c05ab242af030e8e067"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Mzg4MTExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxODoxOFrOGU5aMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoxODoxOFrOGU5aMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NTI5OQ==", "bodyText": "can we make this package private ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424565299", "createdAt": "2020-05-13T16:18:18Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/ThrottlingAndHeaderWarningLogger.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.SuppressLoggerChecks;\n+\n+/**\n+ * This class wraps both <code>HeaderWarningLogger</code> and <code>ThrottlingLogger</code>\n+ * which is a common use case across Elasticsearch\n+ */\n+public class ThrottlingAndHeaderWarningLogger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48a3234ba30cdee91bc6c05ab242af030e8e067"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzkwNzYzOnYy", "diffSide": "RIGHT", "path": "test/logger-usage/src/test/java/org/elasticsearch/test/loggerusage/ESLoggerUsageTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoyNDo1NVrOGU5rQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjoyNDo1NVrOGU5rQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2OTY2Nw==", "bodyText": "don't forget to uncomment :)", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r424569667", "createdAt": "2020-05-13T16:24:55Z", "author": {"login": "jakelandis"}, "path": "test/logger-usage/src/test/java/org/elasticsearch/test/loggerusage/ESLoggerUsageTests.java", "diffHunk": "@@ -119,144 +118,150 @@ public void testLoggerUsageCheckerCompatibilityWithLog4j2Logger() throws NoSuchM\n         assertEquals(5, ParameterizedMessage.class.getConstructors().length);\n     }\n \n-    public void checkArgumentsProvidedInConstructor() {\n-        logger.debug(new ESLogMessage(\"message {}\", \"some-arg\")\n-            .field(\"x-opaque-id\", \"some-value\"));\n-    }\n-\n-    public void checkWithUsage() {\n-        logger.debug(new ESLogMessage(\"message {}\")\n-            .argAndField(\"x-opaque-id\", \"some-value\")\n-            .field(\"field\", \"value\")\n-            .with(\"field2\", \"value2\"));\n-    }\n-\n-    public void checkFailArraySizeForSubclasses(Object... arr) {\n-        logger.debug(new ESLogMessage(\"message {}\", arr));\n-    }\n-\n-    public void checkFailForTooManyArgumentsInConstr() {\n-        logger.debug(new ESLogMessage(\"message {}\", \"arg1\", \"arg2\"));\n-    }\n-\n-    public void checkFailForTooManyArgumentsWithChain() {\n-        logger.debug(new ESLogMessage(\"message {}\").argAndField(\"x-opaque-id\", \"some-value\")\n-                                                   .argAndField(\"too-many-arg\", \"xxx\"));\n-    }\n-\n-    public void checkFailArraySize(String... arr) {\n-        logger.debug(new ParameterizedMessage(\"text {}\", (Object[])arr));\n-    }\n-\n-    public void checkNumberOfArguments1() {\n-        logger.info(\"Hello {}\", \"world\");\n-    }\n-\n-    public void checkFailNumberOfArguments1() {\n-        logger.info(\"Hello {}\");\n-    }\n-\n-    @SuppressLoggerChecks(reason = \"test ignore functionality\")\n-    public void checkIgnoreWhenAnnotationPresent() {\n-        logger.info(\"Hello {}\");\n-    }\n-\n-    public void checkNumberOfArguments2() {\n-        logger.info(\"Hello {}, {}, {}\", \"world\", 2, \"third argument\");\n-    }\n-\n-    public void checkFailNumberOfArguments2() {\n-        logger.info(\"Hello {}, {}\", \"world\", 2, \"third argument\");\n-    }\n-\n-    public void checkNumberOfArguments3() {\n-        logger.info(\"Hello {}, {}, {}, {}, {}, {}, {}\", \"world\", 2, \"third argument\", 4, 5, 6, new String(\"last arg\"));\n-    }\n-\n-    public void checkFailNumberOfArguments3() {\n-        logger.info(\"Hello {}, {}, {}, {}, {}, {}, {}\", \"world\", 2, \"third argument\", 4, 5, 6, 7, new String(\"last arg\"));\n-    }\n-\n-    public void checkNumberOfArgumentsParameterizedMessage1() {\n-        logger.info(new ParameterizedMessage(\"Hello {}, {}, {}\", \"world\", 2, \"third argument\"));\n-    }\n-\n-    public void checkFailNumberOfArgumentsParameterizedMessage1() {\n-        logger.info(new ParameterizedMessage(\"Hello {}, {}\", \"world\", 2, \"third argument\"));\n-    }\n-\n-    public void checkNumberOfArgumentsParameterizedMessage2() {\n-        logger.info(new ParameterizedMessage(\"Hello {}, {}\", \"world\", 2));\n-    }\n-\n-    public void checkFailNumberOfArgumentsParameterizedMessage2() {\n-        logger.info(new ParameterizedMessage(\"Hello {}, {}, {}\", \"world\", 2));\n-    }\n-\n-    public void checkNumberOfArgumentsParameterizedMessage3() {\n-        logger.info((Supplier<?>) () -> new ParameterizedMessage(\"Hello {}, {}, {}\", \"world\", 2, \"third argument\"));\n-    }\n-\n-    public void checkFailNumberOfArgumentsParameterizedMessage3() {\n-        logger.info((Supplier<?>) () -> new ParameterizedMessage(\"Hello {}, {}\", \"world\", 2, \"third argument\"));\n-    }\n-\n-    public void checkOrderOfExceptionArgument() {\n-        logger.info(\"Hello\", new Exception());\n-    }\n-\n-    public void checkOrderOfExceptionArgument1() {\n-        logger.info((Supplier<?>) () -> new ParameterizedMessage(\"Hello {}\", \"world\"), new Exception());\n-    }\n-\n-    public void checkFailOrderOfExceptionArgument1() {\n-        logger.info(\"Hello {}\", \"world\", new Exception());\n-    }\n-\n-    public void checkOrderOfExceptionArgument2() {\n-        logger.info((Supplier<?>) () -> new ParameterizedMessage(\"Hello {}, {}\", \"world\", 42), new Exception());\n-    }\n-\n-    public void checkFailOrderOfExceptionArgument2() {\n-        logger.info(\"Hello {}, {}\", \"world\", 42, new Exception());\n-    }\n-\n-    public void checkNonConstantMessageWithZeroArguments(boolean b) {\n-        logger.info(Boolean.toString(b), new Exception());\n-    }\n-\n-    public void checkFailNonConstantMessageWithArguments(boolean b) {\n-        logger.info((Supplier<?>) () -> new ParameterizedMessage(Boolean.toString(b), 42), new Exception());\n-    }\n-\n-    public void checkComplexUsage(boolean b) {\n-        String message = \"Hello {}, {}\";\n-        Object[] args = new Object[] { \"world\", 42 };\n-        if (b) {\n-            message = \"also two args {}{}\";\n-            args = new Object[] { \"world\", 43 };\n-        }\n-        logger.info(message, args);\n-    }\n-\n-    public void checkFailComplexUsage1(boolean b) {\n-        String message = \"Hello {}, {}\";\n-        Object[] args = new Object[] { \"world\", 42 };\n-        if (b) {\n-            message = \"just one arg {}\";\n-            args = new Object[] { \"world\", 43 };\n-        }\n-        logger.info(message, args);\n-    }\n-\n-    public void checkFailComplexUsage2(boolean b) {\n-        String message = \"Hello {}, {}\";\n-        Object[] args = new Object[] { \"world\", 42 };\n-        if (b) {\n-            message = \"also two args {}{}\";\n-            args = new Object[] { \"world\", 43, \"another argument\" };\n-        }\n-        logger.info(message, args);\n+//    public void checkArgumentsProvidedInConstructor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d48a3234ba30cdee91bc6c05ab242af030e8e067"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzAwMTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarning.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMDo0MDoyMlrOGc7I7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToxMjozNFrOGdG7cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MjI1Mg==", "bodyText": "This comment (uses ThreadContext ...) is abit confusing.  What do I need to do with that knowledge ?\nCan you add a usage section to the doc ?", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r432982252", "createdAt": "2020-05-31T20:40:22Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarning.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.tasks.Task;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa22a54098838ba1403861eea4e3666d6d4cf0e5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NTQxMA==", "bodyText": "agree, ThreadContext is an implementation detail. I will reword that javadoc", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r433175410", "createdAt": "2020-06-01T11:12:34Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/HeaderWarning.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.logging;\n+\n+import org.elasticsearch.Build;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.tasks.Task;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This is a simplistic logger that adds warning messages to HTTP headers.\n+ * It uses ThreadContext - which is assumed to be one per JVM (except for tests) - to store warning headers.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MjI1Mg=="}, "originalCommit": {"oid": "aa22a54098838ba1403861eea4e3666d6d4cf0e5"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzAwNTIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMDo0NjoxNlrOGc7KmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToyNjozOVrOGdHQag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MjY4MA==", "bodyText": "Can you beef up the class level doc a little bit ?   Just a quick mention that it does a throttle log (and what it throttling ..or link to the throttling class) and a warning message. Also a small usage in the description would be great.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r432982680", "createdAt": "2020-05-31T20:46:16Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -21,79 +21,13 @@\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Build;\n-import org.elasticsearch.Version;\n-import org.elasticsearch.common.SuppressLoggerChecks;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n-import org.elasticsearch.tasks.Task;\n-\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.BitSet;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n /**\n  * A logger that logs deprecation notices.\n  */\n public class DeprecationLogger {\n-\n-    private final Logger logger;\n-\n-    /**\n-     * This is set once by the {@code Node} constructor, but it uses {@link CopyOnWriteArraySet} to ensure that tests can run in parallel.\n-     * <p>\n-     * Integration tests will create separate nodes within the same classloader, thus leading to a shared, {@code static} state.\n-     * In order for all tests to appropriately be handled, this must be able to remember <em>all</em> {@link ThreadContext}s that it is\n-     * given in a thread safe manner.\n-     * <p>\n-     * For actual usage, multiple nodes do not share the same JVM and therefore this will only be set once in practice.\n-     */\n-    private static final CopyOnWriteArraySet<ThreadContext> THREAD_CONTEXT = new CopyOnWriteArraySet<>();\n-\n-    /**\n-     * Set the {@link ThreadContext} used to add deprecation headers to network responses.\n-     * <p>\n-     * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).\n-     *\n-     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n-     * @throws IllegalStateException if this {@code threadContext} has already been set\n-     */\n-    public static void setThreadContext(ThreadContext threadContext) {\n-        Objects.requireNonNull(threadContext, \"Cannot register a null ThreadContext\");\n-\n-        // add returning false means it _did_ have it already\n-        if (THREAD_CONTEXT.add(threadContext) == false) {\n-            throw new IllegalStateException(\"Double-setting ThreadContext not allowed!\");\n-        }\n-    }\n-\n-    /**\n-     * Remove the {@link ThreadContext} used to add deprecation headers to network responses.\n-     * <p>\n-     * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).\n-     *\n-     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n-     * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)\n-     */\n-    public static void removeThreadContext(ThreadContext threadContext) {\n-        assert threadContext != null;\n-\n-        // remove returning false means it did not have it already\n-        if (THREAD_CONTEXT.remove(threadContext) == false) {\n-            throw new IllegalStateException(\"Removing unknown ThreadContext not allowed!\");\n-        }\n-    }\n+    private final ThrottlingAndHeaderWarningLogger deprecationLogger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa22a54098838ba1403861eea4e3666d6d4cf0e5"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MDc3OA==", "bodyText": "good idea, added usage and more detailed javadoc.", "url": "https://github.com/elastic/elasticsearch/pull/55941#discussion_r433180778", "createdAt": "2020-06-01T11:26:39Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java", "diffHunk": "@@ -21,79 +21,13 @@\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.Build;\n-import org.elasticsearch.Version;\n-import org.elasticsearch.common.SuppressLoggerChecks;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n-import org.elasticsearch.tasks.Task;\n-\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.BitSet;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n /**\n  * A logger that logs deprecation notices.\n  */\n public class DeprecationLogger {\n-\n-    private final Logger logger;\n-\n-    /**\n-     * This is set once by the {@code Node} constructor, but it uses {@link CopyOnWriteArraySet} to ensure that tests can run in parallel.\n-     * <p>\n-     * Integration tests will create separate nodes within the same classloader, thus leading to a shared, {@code static} state.\n-     * In order for all tests to appropriately be handled, this must be able to remember <em>all</em> {@link ThreadContext}s that it is\n-     * given in a thread safe manner.\n-     * <p>\n-     * For actual usage, multiple nodes do not share the same JVM and therefore this will only be set once in practice.\n-     */\n-    private static final CopyOnWriteArraySet<ThreadContext> THREAD_CONTEXT = new CopyOnWriteArraySet<>();\n-\n-    /**\n-     * Set the {@link ThreadContext} used to add deprecation headers to network responses.\n-     * <p>\n-     * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).\n-     *\n-     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n-     * @throws IllegalStateException if this {@code threadContext} has already been set\n-     */\n-    public static void setThreadContext(ThreadContext threadContext) {\n-        Objects.requireNonNull(threadContext, \"Cannot register a null ThreadContext\");\n-\n-        // add returning false means it _did_ have it already\n-        if (THREAD_CONTEXT.add(threadContext) == false) {\n-            throw new IllegalStateException(\"Double-setting ThreadContext not allowed!\");\n-        }\n-    }\n-\n-    /**\n-     * Remove the {@link ThreadContext} used to add deprecation headers to network responses.\n-     * <p>\n-     * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).\n-     *\n-     * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})\n-     * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)\n-     */\n-    public static void removeThreadContext(ThreadContext threadContext) {\n-        assert threadContext != null;\n-\n-        // remove returning false means it did not have it already\n-        if (THREAD_CONTEXT.remove(threadContext) == false) {\n-            throw new IllegalStateException(\"Removing unknown ThreadContext not allowed!\");\n-        }\n-    }\n+    private final ThrottlingAndHeaderWarningLogger deprecationLogger;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MjY4MA=="}, "originalCommit": {"oid": "aa22a54098838ba1403861eea4e3666d6d4cf0e5"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2526, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}