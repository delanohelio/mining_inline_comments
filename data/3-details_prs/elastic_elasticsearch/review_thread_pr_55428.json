{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NTM2Mjg1", "number": 55428, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo1MTo0M1rODzmAsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo1MTo0M1rODzmAsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDI2NzM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzo1MTo0M1rOGIHr3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0ODoxNVrOGJGsmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ==", "bodyText": "Do we also need to check whether there are changes that have not been refreshed? Otherwise this change will have a terrible effiect on the warm tier by returning can_match=true up to once per second even though no changes are being made to indices? Or are we already protected against this?", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r411167709", "createdAt": "2020-04-20T07:51:43Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTQ4OA==", "bodyText": "Good catch. I pushed 0e7f976.", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r411425488", "createdAt": "2020-04-20T14:30:12Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNzM0OQ==", "bodyText": "I wonder if we can still extract the min/max values of the primary sort since we don't need the values to be accurate and use it only to order the shards execution. If indices are in the warm tier they should contain some recent data that we'd like to visit first if the query is sorted by timestamp.", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r411637349", "createdAt": "2020-04-20T19:34:19Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA4NA==", "bodyText": "This sounds potentially dangerous to me. I wouldn't think of the special case of search-idle indices if someone raised an idea that would leverage min/max values and rely on the fact that the max value to be an upper bound and the min value to be a lower bound?", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r411660084", "createdAt": "2020-04-20T20:12:18Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4OTg4NQ==", "bodyText": "We don't have this guarantee today either, the reader of the query phase can be different from the one used in the can match phase. I can update the comments to make it more clear in the code that we don't create a point in time reader during the can match phase.", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r411689885", "createdAt": "2020-04-20T21:02:16Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkzNTA2NQ==", "bodyText": "I agree that the can_match phase might get a different reader from the query phase, but I'm less concerned by this since the reader we get in the can_match phase would also be a legal reader to run the query phase on, which isn't the case here? I don't feel strongly about this, ok to return the min/max values and +1 to document this.", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r411935065", "createdAt": "2020-04-21T07:21:17Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0NTI4OA==", "bodyText": "Right, I also thought about this because having these guarantees would mean that we can filter shards on the coord node based on these values. We don't do this today because of search-idle shards so we delay the skipping when verifying the values locally during the query phase.\nThe other option that was proposed by Nhat in this pr was to perform the refresh of search-idle shards during the can_match phase. It has the advantage of making all min/max values accurate for the search request but could make the phase much slower.\n\nI don't feel strongly about this, ok to return the min/max values and +1 to document this.\n\n++, thanks", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r412045288", "createdAt": "2020-04-21T09:56:36Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMDA5MA==", "bodyText": "Thanks Adrien and Jim for the discussion here. I pushed 80f492f.", "url": "https://github.com/elastic/elasticsearch/pull/55428#discussion_r412200090", "createdAt": "2020-04-21T13:48:15Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1113,6 +1113,9 @@ public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n         IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+        if (indexShard.isSearchIdle()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE2NzcwOQ=="}, "originalCommit": {"oid": "09c7e66169a3b432ede53cb273ec8f502d8a941e"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1014, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}