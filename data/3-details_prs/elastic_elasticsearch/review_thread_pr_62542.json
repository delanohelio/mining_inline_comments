{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4NjU4OTk5", "number": 62542, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxNDowNlrOEkjvxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxNDowNlrOEkjvxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzY5ODYwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/InternalCardinalityTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxNDowNlrOHTkXig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoyMDo1NVrOHTksTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MDg0Mg==", "bodyText": "Haven't looked closely at the test, but is there a way to ensure we add new values that weren't previously added?  Maybe by picking from a different range of random values or something?  Or keeping a set?\nMaybe it's a non-issue and random enough to not matter... might be a problem for a different day :)", "url": "https://github.com/elastic/elasticsearch/pull/62542#discussion_r490280842", "createdAt": "2020-09-17T14:14:06Z", "author": {"login": "polyfractal"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/InternalCardinalityTests.java", "diffHunk": "@@ -99,9 +99,7 @@ protected InternalCardinality mutateInstance(InternalCardinality instance) {\n         case 1:\n             HyperLogLogPlusPlus newState = new HyperLogLogPlusPlus(state.precision(),\n                     new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService()), 0);\n-            newState.merge(0, state, 0);\n-            int extraValues = between(10, 100);\n-            for (int i = 0; i < extraValues; i++) {\n+            for (int i = 0; i < 10; i++) {\n                 newState.collect(0, BitMixer.mix64(randomIntBetween(500, 10000)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c762173b75c0a4fd08d96ef4e20be4e23800dacc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MzA1Nw==", "bodyText": "It does use a different range of values, Still for precision 4 in the previous approach you could get the same sketch at the end :( I think this way is very very unlikely.", "url": "https://github.com/elastic/elasticsearch/pull/62542#discussion_r490283057", "createdAt": "2020-09-17T14:16:49Z", "author": {"login": "iverase"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/InternalCardinalityTests.java", "diffHunk": "@@ -99,9 +99,7 @@ protected InternalCardinality mutateInstance(InternalCardinality instance) {\n         case 1:\n             HyperLogLogPlusPlus newState = new HyperLogLogPlusPlus(state.precision(),\n                     new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService()), 0);\n-            newState.merge(0, state, 0);\n-            int extraValues = between(10, 100);\n-            for (int i = 0; i < extraValues; i++) {\n+            for (int i = 0; i < 10; i++) {\n                 newState.collect(0, BitMixer.mix64(randomIntBetween(500, 10000)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MDg0Mg=="}, "originalCommit": {"oid": "c762173b75c0a4fd08d96ef4e20be4e23800dacc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4NjE1OQ==", "bodyText": "Ah gotcha.  Sounds good!", "url": "https://github.com/elastic/elasticsearch/pull/62542#discussion_r490286159", "createdAt": "2020-09-17T14:20:55Z", "author": {"login": "polyfractal"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/InternalCardinalityTests.java", "diffHunk": "@@ -99,9 +99,7 @@ protected InternalCardinality mutateInstance(InternalCardinality instance) {\n         case 1:\n             HyperLogLogPlusPlus newState = new HyperLogLogPlusPlus(state.precision(),\n                     new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService()), 0);\n-            newState.merge(0, state, 0);\n-            int extraValues = between(10, 100);\n-            for (int i = 0; i < extraValues; i++) {\n+            for (int i = 0; i < 10; i++) {\n                 newState.collect(0, BitMixer.mix64(randomIntBetween(500, 10000)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MDg0Mg=="}, "originalCommit": {"oid": "c762173b75c0a4fd08d96ef4e20be4e23800dacc"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3547, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}