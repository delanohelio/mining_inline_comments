{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMjY0Njc1", "number": 65210, "title": "Make document parsing aware of runtime fields", "bodyText": "Runtime fields are defined in a separate runtime section in the mappings. Since the runtime section was introduced, runtime fields are not taken into account when parsing documents. That means that if a document gets indexed that holds a field that's already defined as a runtime field, the field gets dynamically mapped as a concrete field although it will always be shadowed by the runtime field defined with the same name.\nA more sensible default would be to instead consider runtime fields like ordinary mapped fields, so a dynamic update is not necessary whenever a field is defined as part of the runtime section. As a consequence, the field does not get indexed. If users prefer to keep indexing the field although it is shadowed, we consider this an exception, and they can do so by mapping the field under properties explicitly.\nRelates to #62906", "createdAt": "2020-11-18T15:26:41Z", "url": "https://github.com/elastic/elasticsearch/pull/65210", "merged": true, "mergeCommit": {"oid": "3aef5862200d853b402b5a6b4cc35ac37d1b50b7"}, "closed": true, "closedAt": "2020-11-19T19:13:56Z", "author": {"login": "javanna"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddv1A8gH2gAyNTIzMjY0Njc1OjRhODcxZmZhMzJjMGFmZmU5MmQ2MGIzOGRiZjA4OTkwYzg5Yjc4MDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeD285AFqTUzNDUxNjQ0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a871ffa32c0affe92d60b38dbf08990c89b7800", "committedDate": "2020-11-18T15:24:29Z", "message": "Make document parsing aware of runtime fields\n\nRuntime fields are defined in a separate runtime section in the mappings. Since the runtime section was introduced, runtime fields are not taken into account when parsing documents. That means that if a document gets indexed that holds a field that's already defined as a runtime field, the field gets dynamically mapped as a concrete field although it will always be shadowed by the runtime field defined with the same name.\n\nA more sensible default would be to instead consider runtime fields like ordinary mapped fields, so a dynamic update is not necessary whenever a field is defined as part of the runtime section. As a consequence, the field does not get indexed. If users prefer to keep indexing the field although it is shadowed, we consider this an exception, and they can do so by mapping the field under properties explicitly.\n\nRelates to #62906"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNTYyMTI1", "url": "https://github.com/elastic/elasticsearch/pull/65210#pullrequestreview-533562125", "createdAt": "2020-11-18T15:27:41Z", "commit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNToyNzo0MVrOH1zRhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNToyNzo0MVrOH1zRhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NjY0NA==", "bodyText": "It is quite a shame to have to define all these methods (not all of them are abstract but I wanted to make sure that none of them is called), as only two are effectively needed: parseCreateField and copyTo.", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526176644", "createdAt": "2020-11-18T15:27:41Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNTgzMzAz", "url": "https://github.com/elastic/elasticsearch/pull/65210#pullrequestreview-533583303", "createdAt": "2020-11-18T15:47:18Z", "commit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo0NzoxOVrOH10QHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo0OToxMFrOH10Vlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MjY3MA==", "bodyText": "When we hit this file with the formatter one day it'll make this look like garbage. Would you be ok running the formatter on this now and playing with the output some to make it look ok when the formatter runs?", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526192670", "createdAt": "2020-11-18T15:47:19Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java", "diffHunk": "@@ -59,20 +60,50 @@\n         return List.of(new DocumentParserTestsPlugin(), new TestRuntimeField.Plugin());\n     }\n \n-    public void testDynamicUpdateWithRuntimeField() throws Exception {\n+    public void testParseWithRuntimeField() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n-        ParsedDocument doc = mapper.parse(source(b -> b.field(\"test\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"test\"));\n+        ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n+        //field defined as runtime field but not under properties: no dynamic updates, the field does not get indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNull(doc.rootDoc().getField(\"field\"));\n     }\n \n-    public void testDynamicUpdateWithRuntimeFieldSameName() throws Exception {\n-        DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n+    public void testParseWithShadowedField() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n+                .endObject()\n+            .endObject().endObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NDA3MQ==", "bodyText": "It is, but \ud83e\udd37. I think there are worse things.", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526194071", "createdAt": "2020-11-18T15:49:10Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NjY0NA=="}, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNTg3OTE5", "url": "https://github.com/elastic/elasticsearch/pull/65210#pullrequestreview-533587919", "createdAt": "2020-11-18T15:51:37Z", "commit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1MTozN1rOH10dhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1MTozN1rOH10dhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NjEwMA==", "bodyText": "What happens if enabled isn't set? I think we should continue to do nothing if enabled is actually true.", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526196100", "createdAt": "2020-11-18T15:51:37Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java", "diffHunk": "@@ -59,20 +60,50 @@\n         return List.of(new DocumentParserTestsPlugin(), new TestRuntimeField.Plugin());\n     }\n \n-    public void testDynamicUpdateWithRuntimeField() throws Exception {\n+    public void testParseWithRuntimeField() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n-        ParsedDocument doc = mapper.parse(source(b -> b.field(\"test\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"test\"));\n+        ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n+        //field defined as runtime field but not under properties: no dynamic updates, the field does not get indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNull(doc.rootDoc().getField(\"field\"));\n     }\n \n-    public void testDynamicUpdateWithRuntimeFieldSameName() throws Exception {\n-        DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n+    public void testParseWithShadowedField() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n+                .endObject()\n+            .endObject().endObject();\n+\n+        DocumentMapper mapper = createDocumentMapper(builder);\n         ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"field\"));\n+        //field defined as runtime field as well as under properties: no dynamic updates, the field gets indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNotNull(doc.rootDoc().getField(\"field\"));\n+    }\n+\n+    public void testParseWithRuntimeFieldDottedNameDisabledObject() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                    .startObject(\"path1.path2.path3.field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                    .startObject(\"path1\").field(\"type\", \"object\").field(\"enabled\", false).endObject()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNjQxMzgy", "url": "https://github.com/elastic/elasticsearch/pull/65210#pullrequestreview-533641382", "createdAt": "2020-11-18T16:41:25Z", "commit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo0MToyNVrOH126kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo0MToyNVrOH126kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjMwNg==", "bodyText": "Is this going to cause problems if there is a dynamic mapper added elsewhere?  Let's say we send a document with two fields, one of which gets mapped by the dynamic template as a keyword, and the other as a runtime field. In that case, there will be a call back to the master with the new Mapping which will contain the new dynamic mapper, plus this NoOpFieldMapper, and it will blow up when we try to serialize it I think?", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526236306", "createdAt": "2020-11-18T16:41:25Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {\n+        NoOpFieldMapper(String simpleName, RuntimeFieldType runtimeField) {\n+            super(simpleName, new MappedFieldType(runtimeField.name(), false, false, false, TextSearchInfo.NONE, Collections.emptyMap()) {\n+                @Override\n+                public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup searchLookup, String format) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String typeName() {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public Query termQuery(Object value, QueryShardContext context) {\n+                    throw new UnsupportedOperationException();\n+                }\n+            }, MultiFields.empty(), CopyTo.empty());\n+        }\n+\n+        @Override\n+        protected void parseCreateField(ParseContext context) throws IOException {\n+            //field defined as runtime field, don't index anything\n+        }\n+\n+        @Override\n+        public String name() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MappedFieldType fieldType() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MultiFields multiFields() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Iterator<Mapper> iterator() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void doValidate(MappingLookup mappers) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void checkIncomingMergeType(FieldMapper mergeWith) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Builder getMergeBuilder() {\n+            throw new UnsupportedOperationException();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0Mjg2ODA5", "url": "https://github.com/elastic/elasticsearch/pull/65210#pullrequestreview-534286809", "createdAt": "2020-11-19T10:38:59Z", "commit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDozOTowMFrOH2W0wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDo0MTo0MFrOH2W7jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1OTEwNg==", "bodyText": "Yeah it would be nice to somehow build an interface here but I can't see how that would easily work with ObjectMappers.  For the future.", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526759106", "createdAt": "2020-11-19T10:39:00Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NjY0NA=="}, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1OTM2MQ==", "bodyText": "Gotcha, I had misunderstood where we were creating these.", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526759361", "createdAt": "2020-11-19T10:39:26Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {\n+        NoOpFieldMapper(String simpleName, RuntimeFieldType runtimeField) {\n+            super(simpleName, new MappedFieldType(runtimeField.name(), false, false, false, TextSearchInfo.NONE, Collections.emptyMap()) {\n+                @Override\n+                public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup searchLookup, String format) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String typeName() {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public Query termQuery(Object value, QueryShardContext context) {\n+                    throw new UnsupportedOperationException();\n+                }\n+            }, MultiFields.empty(), CopyTo.empty());\n+        }\n+\n+        @Override\n+        protected void parseCreateField(ParseContext context) throws IOException {\n+            //field defined as runtime field, don't index anything\n+        }\n+\n+        @Override\n+        public String name() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MappedFieldType fieldType() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MultiFields multiFields() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Iterator<Mapper> iterator() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void doValidate(MappingLookup mappers) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void checkIncomingMergeType(FieldMapper mergeWith) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Builder getMergeBuilder() {\n+            throw new UnsupportedOperationException();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjMwNg=="}, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MDg0Nw==", "bodyText": "You can do something like:\ncreateDocumentMapper(topMapping(b -> {\n    b.startObject(\"runtime\");\n    {\n        b.startObject(\"field\").field(\"type\", \"test\").endObject();\n    }\n    b.endObject();\n    b.startObject(\"properties\");\n    {\n        b.startObject(\"field\").field(\"type\", \"keyword\").endObject();\n    }\n    b.endObject();\n});\n\nKeeps the formatter happy and there's a bit less ceremony around builders.", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526760847", "createdAt": "2020-11-19T10:41:40Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java", "diffHunk": "@@ -59,20 +60,50 @@\n         return List.of(new DocumentParserTestsPlugin(), new TestRuntimeField.Plugin());\n     }\n \n-    public void testDynamicUpdateWithRuntimeField() throws Exception {\n+    public void testParseWithRuntimeField() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n-        ParsedDocument doc = mapper.parse(source(b -> b.field(\"test\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"test\"));\n+        ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n+        //field defined as runtime field but not under properties: no dynamic updates, the field does not get indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNull(doc.rootDoc().getField(\"field\"));\n     }\n \n-    public void testDynamicUpdateWithRuntimeFieldSameName() throws Exception {\n-        DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n+    public void testParseWithShadowedField() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n+                .endObject()\n+            .endObject().endObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MjY3MA=="}, "originalCommit": {"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6ce5a89c5f1bec8926ca2c8b14238f3a20fbe95", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/e6ce5a89c5f1bec8926ca2c8b14238f3a20fbe95", "committedDate": "2020-11-19T11:14:46Z", "message": "formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "542fa16bab08bd936ec62cdee804b9a72a3d290a", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/542fa16bab08bd936ec62cdee804b9a72a3d290a", "committedDate": "2020-11-19T12:33:20Z", "message": "Merge branch 'master' into enhancement/runtime_fields_document_parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40ff98662625260ca0ff79d8a1a7349f2022cd82", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/40ff98662625260ca0ff79d8a1a7349f2022cd82", "committedDate": "2020-11-19T12:56:28Z", "message": "more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NTE2NDQ5", "url": "https://github.com/elastic/elasticsearch/pull/65210#pullrequestreview-534516449", "createdAt": "2020-11-19T14:44:42Z", "commit": {"oid": "40ff98662625260ca0ff79d8a1a7349f2022cd82"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 848, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}