{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDI2MTYz", "number": 53009, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToyMjo1MlrODkTpyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTozMDozN1rODkT2wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mzk3MzIyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/AbstractTransportSearchableSnapshotsAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToyMjo1MlrOFwjglQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTo1Njo0NVrOFwk61Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1Nzc0OQ==", "bodyText": "Maybe unwrapCacheDirectory to be a bit more specific about how far we are unwrapping?\n(I realise this code existed beforehand, but I only just thought of this)", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386457749", "createdAt": "2020-03-02T15:22:52Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/AbstractTransportSearchableSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.broadcast.BroadcastRequest;\n+import org.elasticsearch.action.support.broadcast.BroadcastResponse;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_CACHE_ENABLED_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public abstract class AbstractTransportSearchableSnapshotsAction\n+    <Request extends BroadcastRequest<Request>, Response extends BroadcastResponse, ShardOperationResult extends Writeable>\n+    extends TransportBroadcastByNodeAction<Request, Response, ShardOperationResult> {\n+\n+    private final IndicesService indicesService;\n+\n+    AbstractTransportSearchableSnapshotsAction(String actionName, ClusterService clusterService, TransportService transportService,\n+                                               ActionFilters actionFilters, IndexNameExpressionResolver resolver,\n+                                               Writeable.Reader<Request> request, String executor, IndicesService indicesService) {\n+        super(actionName, clusterService, transportService, actionFilters, resolver, request, executor);\n+        this.indicesService = indicesService;\n+    }\n+\n+    AbstractTransportSearchableSnapshotsAction(String actionName, ClusterService clusterService, TransportService transportService,\n+                                               ActionFilters actionFilters, IndexNameExpressionResolver resolver,\n+                                               Writeable.Reader<Request> request, String executor, IndicesService indicesService,\n+                                               boolean canTripCircuitBreaker) {\n+        super(actionName, clusterService, transportService, actionFilters, resolver, request, executor, canTripCircuitBreaker);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, Request request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, Request request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, Request request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    if (SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings)) {\n+                        searchableSnapshotIndices.add(concreteIndex);\n+                    }\n+                }\n+            }\n+        }\n+        if (searchableSnapshotIndices.isEmpty()) {\n+            throw new ResourceNotFoundException(\"No searchable snapshots indices found\");\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    protected ShardOperationResult shardOperation(Request request, ShardRouting shardRouting) throws IOException {\n+        final IndexShard indexShard = indicesService.indexServiceSafe(shardRouting.index()).getShard(shardRouting.id());\n+        final CacheDirectory cacheDirectory = unwrap(indexShard.store().directory());\n+        assert cacheDirectory != null;\n+        assert cacheDirectory.getShardId().equals(shardRouting.shardId());\n+        return executeShardOperation(request, shardRouting, cacheDirectory);\n+    }\n+\n+    protected abstract ShardOperationResult executeShardOperation(Request request, ShardRouting shardRouting,\n+                                                                  CacheDirectory cacheDirectory) throws IOException;\n+\n+    @Nullable\n+    private static CacheDirectory unwrap(Directory dir) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4MDg1Mw==", "bodyText": "Sure, I pushed 544f056", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386480853", "createdAt": "2020-03-02T15:56:45Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/AbstractTransportSearchableSnapshotsAction.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.broadcast.BroadcastRequest;\n+import org.elasticsearch.action.support.broadcast.BroadcastResponse;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_CACHE_ENABLED_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public abstract class AbstractTransportSearchableSnapshotsAction\n+    <Request extends BroadcastRequest<Request>, Response extends BroadcastResponse, ShardOperationResult extends Writeable>\n+    extends TransportBroadcastByNodeAction<Request, Response, ShardOperationResult> {\n+\n+    private final IndicesService indicesService;\n+\n+    AbstractTransportSearchableSnapshotsAction(String actionName, ClusterService clusterService, TransportService transportService,\n+                                               ActionFilters actionFilters, IndexNameExpressionResolver resolver,\n+                                               Writeable.Reader<Request> request, String executor, IndicesService indicesService) {\n+        super(actionName, clusterService, transportService, actionFilters, resolver, request, executor);\n+        this.indicesService = indicesService;\n+    }\n+\n+    AbstractTransportSearchableSnapshotsAction(String actionName, ClusterService clusterService, TransportService transportService,\n+                                               ActionFilters actionFilters, IndexNameExpressionResolver resolver,\n+                                               Writeable.Reader<Request> request, String executor, IndicesService indicesService,\n+                                               boolean canTripCircuitBreaker) {\n+        super(actionName, clusterService, transportService, actionFilters, resolver, request, executor, canTripCircuitBreaker);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, Request request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, Request request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, Request request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    if (SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings)) {\n+                        searchableSnapshotIndices.add(concreteIndex);\n+                    }\n+                }\n+            }\n+        }\n+        if (searchableSnapshotIndices.isEmpty()) {\n+            throw new ResourceNotFoundException(\"No searchable snapshots indices found\");\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    protected ShardOperationResult shardOperation(Request request, ShardRouting shardRouting) throws IOException {\n+        final IndexShard indexShard = indicesService.indexServiceSafe(shardRouting.index()).getShard(shardRouting.id());\n+        final CacheDirectory cacheDirectory = unwrap(indexShard.store().directory());\n+        assert cacheDirectory != null;\n+        assert cacheDirectory.getShardId().equals(shardRouting.shardId());\n+        return executeShardOperation(request, shardRouting, cacheDirectory);\n+    }\n+\n+    protected abstract ShardOperationResult executeShardOperation(Request request, ShardRouting shardRouting,\n+                                                                  CacheDirectory cacheDirectory) throws IOException;\n+\n+    @Nullable\n+    private static CacheDirectory unwrap(Directory dir) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1Nzc0OQ=="}, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mzk4ODA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/rest/RestClearSearchableSnapshotsCacheAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToyNjoxNFrOFwjplQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTo1NzoxMlrOFwk8CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2MDA1Mw==", "bodyText": "I think we should have cache in the  name here somewhere. I tried a couple of different word orders and none was perfect. Maybe this?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return \"clear_searchable_snapshots_indices_action\";\n          \n          \n            \n                    return \"clear_indices_searchable_snapshots_cache_action\";", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386460053", "createdAt": "2020-03-02T15:26:14Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/rest/RestClearSearchableSnapshotsCacheAction.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.rest;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+import org.elasticsearch.xpack.searchablesnapshots.action.ClearSearchableSnapshotsCacheAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.ClearSearchableSnapshotsCacheRequest;\n+\n+import java.util.List;\n+\n+public class RestClearSearchableSnapshotsCacheAction extends BaseRestHandler {\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(RestRequest.Method.POST, \"/_searchable_snapshots/cache/clear\"),\n+            new Route(RestRequest.Method.POST, \"/{index}/_searchable_snapshots/cache/clear\")\n+        );\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"clear_searchable_snapshots_indices_action\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4MTE2MA==", "bodyText": "Thanks for spotting this. I pushed f1ce506 to use your suggestion.", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386481160", "createdAt": "2020-03-02T15:57:12Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/rest/RestClearSearchableSnapshotsCacheAction.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.rest;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+import org.elasticsearch.xpack.searchablesnapshots.action.ClearSearchableSnapshotsCacheAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.ClearSearchableSnapshotsCacheRequest;\n+\n+import java.util.List;\n+\n+public class RestClearSearchableSnapshotsCacheAction extends BaseRestHandler {\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(RestRequest.Method.POST, \"/_searchable_snapshots/cache/clear\"),\n+            new Route(RestRequest.Method.POST, \"/{index}/_searchable_snapshots/cache/clear\")\n+        );\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"clear_searchable_snapshots_indices_action\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2MDA1Mw=="}, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mzk5MjY5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToyNzoxNlrOFwjsWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTo1NzoyOVrOFwk8yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2MDc2MQ==", "bodyText": "nit: seems unnecessary,  and we use the fully-qualified  name below.", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386460761", "createdAt": "2020-03-02T15:27:16Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "diffHunk": "@@ -61,7 +64,7 @@ private void runSearchableSnapshotsTest(SearchableSnapshotsTestCaseBody testCase\n \n         logger.info(\"creating index [{}]\", indexName);\n         createIndex(indexName, Settings.builder()\n-            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numberOfShards)\n+            .put(SETTING_NUMBER_OF_SHARDS, numberOfShards)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4MTM1Mw==", "bodyText": "I reverted this change in 244b89e", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386481353", "createdAt": "2020-03-02T15:57:29Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "diffHunk": "@@ -61,7 +64,7 @@ private void runSearchableSnapshotsTest(SearchableSnapshotsTestCaseBody testCase\n \n         logger.info(\"creating index [{}]\", indexName);\n         createIndex(indexName, Settings.builder()\n-            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numberOfShards)\n+            .put(SETTING_NUMBER_OF_SHARDS, numberOfShards)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2MDc2MQ=="}, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDAwNjQyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTozMDozN1rOFwj0-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjozMDozM1rOFwmR0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2Mjk3MA==", "bodyText": "I wonder whether it'd be better to do this whole test in the YAML suite. I think that's possible. WDYT?", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386462970", "createdAt": "2020-03-02T15:30:37Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "diffHunk": "@@ -162,6 +161,51 @@ public void testCloseAndReopen() throws Exception {\n         });\n     }\n \n+    public void testStats() throws Exception {\n+        runSearchableSnapshotsTest((restoredIndexName, numDocs) -> {\n+            final Map<String, Object> stats = searchableSnapshotStats(restoredIndexName);\n+            assertThat(\"Expected searchable snapshots stats for [\" + restoredIndexName + ']', stats.size(), greaterThan(0));\n+\n+            final int nbShards = Integer.valueOf(extractValue(indexSettings(restoredIndexName), IndexMetaData.SETTING_NUMBER_OF_SHARDS));\n+            assertThat(\"Expected searchable snapshots stats for \" + nbShards + \" shards but got \" + stats, stats.size(), equalTo(nbShards));\n+        });\n+    }\n+\n+    public void testClearCache() throws Exception {\n+        @SuppressWarnings(\"unchecked\")\n+        final Function<Map<?, ?>, Long> sumCachedBytesWritten = stats -> stats.values().stream()\n+            .filter(o -> o instanceof List)\n+            .flatMap(o -> ((List) o).stream())\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"files\"))\n+            .filter(o -> o instanceof List)\n+            .flatMap(o -> ((List) o).stream())\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"cached_bytes_written\"))\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"sum\"))\n+            .mapToLong(o -> ((Number) o).longValue())\n+            .sum();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NjQzOA==", "bodyText": "I'm not sure I can do it in YAML: this test computes the total bytes written in cache (the stats API does not compute total among all shards and files) after a given query, then clear the cache and run the query again to verify that more data has been written in cache gain.\nI pushed 587819a to run the same query before/after the cache clearance.", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386486438", "createdAt": "2020-03-02T16:05:08Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "diffHunk": "@@ -162,6 +161,51 @@ public void testCloseAndReopen() throws Exception {\n         });\n     }\n \n+    public void testStats() throws Exception {\n+        runSearchableSnapshotsTest((restoredIndexName, numDocs) -> {\n+            final Map<String, Object> stats = searchableSnapshotStats(restoredIndexName);\n+            assertThat(\"Expected searchable snapshots stats for [\" + restoredIndexName + ']', stats.size(), greaterThan(0));\n+\n+            final int nbShards = Integer.valueOf(extractValue(indexSettings(restoredIndexName), IndexMetaData.SETTING_NUMBER_OF_SHARDS));\n+            assertThat(\"Expected searchable snapshots stats for \" + nbShards + \" shards but got \" + stats, stats.size(), equalTo(nbShards));\n+        });\n+    }\n+\n+    public void testClearCache() throws Exception {\n+        @SuppressWarnings(\"unchecked\")\n+        final Function<Map<?, ?>, Long> sumCachedBytesWritten = stats -> stats.values().stream()\n+            .filter(o -> o instanceof List)\n+            .flatMap(o -> ((List) o).stream())\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"files\"))\n+            .filter(o -> o instanceof List)\n+            .flatMap(o -> ((List) o).stream())\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"cached_bytes_written\"))\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"sum\"))\n+            .mapToLong(o -> ((Number) o).longValue())\n+            .sum();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2Mjk3MA=="}, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMzEyMQ==", "bodyText": "Oh yes so it does. Let's not add  .sum() to the YAML test runner :)", "url": "https://github.com/elastic/elasticsearch/pull/53009#discussion_r386503121", "createdAt": "2020-03-02T16:30:33Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/AbstractSearchableSnapshotsRestTestCase.java", "diffHunk": "@@ -162,6 +161,51 @@ public void testCloseAndReopen() throws Exception {\n         });\n     }\n \n+    public void testStats() throws Exception {\n+        runSearchableSnapshotsTest((restoredIndexName, numDocs) -> {\n+            final Map<String, Object> stats = searchableSnapshotStats(restoredIndexName);\n+            assertThat(\"Expected searchable snapshots stats for [\" + restoredIndexName + ']', stats.size(), greaterThan(0));\n+\n+            final int nbShards = Integer.valueOf(extractValue(indexSettings(restoredIndexName), IndexMetaData.SETTING_NUMBER_OF_SHARDS));\n+            assertThat(\"Expected searchable snapshots stats for \" + nbShards + \" shards but got \" + stats, stats.size(), equalTo(nbShards));\n+        });\n+    }\n+\n+    public void testClearCache() throws Exception {\n+        @SuppressWarnings(\"unchecked\")\n+        final Function<Map<?, ?>, Long> sumCachedBytesWritten = stats -> stats.values().stream()\n+            .filter(o -> o instanceof List)\n+            .flatMap(o -> ((List) o).stream())\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"files\"))\n+            .filter(o -> o instanceof List)\n+            .flatMap(o -> ((List) o).stream())\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"cached_bytes_written\"))\n+            .filter(o -> o instanceof Map)\n+            .map(o -> ((Map<?,?>)o).get(\"sum\"))\n+            .mapToLong(o -> ((Number) o).longValue())\n+            .sum();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2Mjk3MA=="}, "originalCommit": {"oid": "57937a31c781c8625e6d5618a7862b4357ca7c1f"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3481, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}