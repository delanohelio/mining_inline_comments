{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMzMyNzk5", "number": 52822, "title": "Implement Cancellable DirectoryReader", "bodyText": "Implement a Cancellable DirectoryReader that wraps the original\nDirectoryReader so that when a search task is cancelled the\nDirectoryReaders also stop their work fast. This is usuful for\nexpensive operations like wilcard/prefix queries where the\nDirectoryReaders can spend lots of time and consume resources,\nas previously their work wouldn't stop even though the original\nsearch task was cancelled (e.g. because of timeout or dropped client\nconnection).", "createdAt": "2020-02-26T15:01:43Z", "url": "https://github.com/elastic/elasticsearch/pull/52822", "merged": true, "mergeCommit": {"oid": "67acaf61f33bc5f54e26541514d07e375c202e03"}, "closed": true, "closedAt": "2020-03-05T11:50:32Z", "author": {"login": "matriv"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIH_GYAH2gAyMzgwMzMyNzk5OmUyZWJmYjQ4ZmFiNWQ4NmRlOTEzN2RmZTYyNDk2N2MwNzhjZDg4YmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKpIfBAH2gAyMzgwMzMyNzk5OmViMTU4ZTU0YTM2M2VkYTkyZjNlNzgzMGU2MTU4ZjVlOGRhNTU1ZWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2ebfb48fab5d86de9137dfe624967c078cd88bf", "committedDate": "2020-02-26T14:55:44Z", "message": "Implement Cancellable DirectoryReader\n\nImplement a Cancellable DirectoryReader that wraps the original\nDirectoryReader so that when a search task is cancelled the\nDirectoryReaders also stop their work fast. This is usuful for\nexpensive operations like wilcard/prefix queries where the\nDirectoryReaders can spend lots of time and consume resources,\nas previously their work wouldn't stop even though the original\nsearch task was cancelled (e.g. because of timeout or dropped client\nconnection)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTc4NDMw", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-364978430", "createdAt": "2020-02-26T15:10:02Z", "commit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToxMDowMlrOFuvUcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToxODoyNlrOFuvrmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NDA5Nw==", "bodyText": "this leniency looks dangerous?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384554097", "createdAt": "2020-02-26T15:10:02Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -708,6 +708,8 @@ private DefaultSearchContext createSearchContext(SearchRewriteContext rewriteCon\n                 searcher, clusterService, indexService, indexShard, bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase);\n             success = true;\n             return searchContext;\n+        } catch (IOException e) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw==", "bodyText": "This implementation feels a bit awkward, I'd rather like to fork ExitableDirectoryReader entirely to not inherit from its QueryTimeout abstraction.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384556337", "createdAt": "2020-02-26T15:13:21Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {\n+\n+        private final Cancellable checkCancelled;\n+\n+        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, checkCancelled);\n+                }\n+            });\n+            this.checkCancelled = checkCancelled;\n+        }\n+\n+        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n+            this.checkCancelled.setCancellable(checkCancelled);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a leaf reader with a cancellable task\n+     */\n+    private static class CancellableLeafReader extends ExitableDirectoryReader.ExitableFilterAtomicReader {\n+\n+        private CancellableLeafReader(LeafReader leafReader, Cancellable checkCancelled)  {\n+            super(leafReader, checkCancelled);\n+        }\n+\n+        @Override\n+        public NumericDocValues getNumericDocValues(String field) throws IOException {\n+            return in.getNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n+            return in.getBinaryDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedDocValues getSortedDocValues(String field) throws IOException {\n+            return in.getSortedDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n+            return in.getSortedNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n+            return in.getSortedSetDocValues(field);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of {@link QueryTimeout} with a Runnable task.\n+     */\n+    private static class Cancellable implements QueryTimeout {\n+\n+        private Supplier<Runnable> cancellable;\n+\n+        public void setCancellable(Supplier<Runnable> cancellable) {\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public boolean shouldExit() {\n+            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n+            if (cancellable.get() == null) {\n+                return false;\n+            }\n+            cancellable.get().run();\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzgzOQ==", "bodyText": "use try-with-resources?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384557839", "createdAt": "2020-02-26T15:15:24Z", "author": {"login": "jpountz"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java", "diffHunk": "@@ -62,13 +61,19 @@ public void testEmpty() throws IOException {\n                 .method(PercentilesMethod.TDIGEST);\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);\n         fieldType.setName(\"field\");\n-        try (IndexReader reader = new MultiReader()) {\n+\n+        Directory directory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), directory);\n+        try (IndexReader reader = unmappedIndexWriter.getReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n             PercentileRanks ranks = search(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n             assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks)ranks)));\n+        } finally {\n+            unmappedIndexWriter.close();\n+            directory.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTU0Ng==", "bodyText": "CancellableIndexReader shouldn't have any overhead, so it might be simpler to wrap all the time here.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384559546", "createdAt": "2020-02-26T15:17:49Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -79,8 +89,18 @@\n     private QueryProfiler profiler;\n     private Runnable checkCancelled;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+    }\n+\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                boolean shouldWrap) throws IOException {\n+        super(shouldWrap? new CancellableIndexReader((DirectoryReader) reader, new Cancellable()) : reader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MDAyNQ==", "bodyText": "Let's call it CancellableDirectoryReader if it extends DirectoryReader.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384560025", "createdAt": "2020-02-26T15:18:26Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8901426c48505594b333392bc7d41008644f11e", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/c8901426c48505594b333392bc7d41008644f11e", "committedDate": "2020-02-26T15:49:41Z", "message": "fix compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e38cfa0b5dc885e6540d0433138fa0a8cc796bfe", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/e38cfa0b5dc885e6540d0433138fa0a8cc796bfe", "committedDate": "2020-02-26T16:10:27Z", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "committedDate": "2020-02-26T16:20:54Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "committedDate": "2020-02-26T16:44:09Z", "message": "Fix behaviour by properly handling cancellable.run()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/add7dd448fb6c219ab3788c338ab169b7716d2a4", "committedDate": "2020-02-27T17:07:22Z", "message": "split query timeout and cancellation to be able to unset query timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d74edb27f06729b1f299c20b6b5d19284c012578", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/d74edb27f06729b1f299c20b6b5d19284c012578", "committedDate": "2020-02-27T17:07:34Z", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "committedDate": "2020-02-27T21:45:40Z", "message": "Custom implementation of ExitableDirReader to overcome casting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d10c51a9ea4ca8d2e2813b0c854f679ad8cc3dc8", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/d10c51a9ea4ca8d2e2813b0c854f679ad8cc3dc8", "committedDate": "2020-02-27T22:18:03Z", "message": "revert changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5fdf477933856da0877b81737c1d77640d01d54", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/e5fdf477933856da0877b81737c1d77640d01d54", "committedDate": "2020-02-27T22:20:34Z", "message": "revert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248ee5159f39ad7e00dde8490407c6ce858e12d2", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/248ee5159f39ad7e00dde8490407c6ce858e12d2", "committedDate": "2020-02-27T22:35:58Z", "message": "revert unrelated changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc8519367323b9a0ce4c2bf98c6df17bd0aee0cb", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/bc8519367323b9a0ce4c2bf98c6df17bd0aee0cb", "committedDate": "2020-02-27T22:36:10Z", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce2d557d56d860402220bb64cfbca16c100eef25", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/ce2d557d56d860402220bb64cfbca16c100eef25", "committedDate": "2020-02-28T02:08:40Z", "message": "Fix issues after splitting to cancelation and timeout"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MjQ0MTU5", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-366244159", "createdAt": "2020-02-28T09:00:20Z", "commit": {"oid": "ce2d557d56d860402220bb64cfbca16c100eef25"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTowMDoyMFrOFvtwNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTowMDoyMFrOFvtwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ==", "bodyText": "Why do we need to do this?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385577015", "createdAt": "2020-02-28T09:00:20Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -310,6 +297,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n                 queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n             }\n+            // Search phase has finished, no longer need to check for timeout\n+            searcher.unsetCheckTimeout();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2d557d56d860402220bb64cfbca16c100eef25"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "committedDate": "2020-02-28T13:09:14Z", "message": "Add unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c3183f14eefbec43885c33b4b47839c6ed1bf95", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c3183f14eefbec43885c33b4b47839c6ed1bf95", "committedDate": "2020-02-28T13:59:30Z", "message": "re-enable MultiReader Tests, fix cancellation tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b38977ffd8682adad31a1063049c42f436b2cce", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/8b38977ffd8682adad31a1063049c42f436b2cce", "committedDate": "2020-02-28T14:24:26Z", "message": "fix checkstyle - enhance comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "committedDate": "2020-02-28T14:53:17Z", "message": "Fix NPE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDczNjU0", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-366473654", "createdAt": "2020-02-28T15:20:00Z", "commit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToyMDowMFrOFv4iKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToyNzo0OFrOFv40Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MzY0MQ==", "bodyText": "The implementation should live on the QueryPhase imo. This way you don't need to expose the checkDirReaderCancelled and checkDirReaderCancelled  in the searcher.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385753641", "createdAt": "2020-02-28T15:20:00Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Mzk2OQ==", "bodyText": "These two functions should not be part of the interface, checkCancelled should be enough", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385753969", "createdAt": "2020-02-28T15:20:38Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDE5Ng==", "bodyText": "Can you call QueryCancellable ?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385754196", "createdAt": "2020-02-28T15:20:58Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA==", "bodyText": "why do you need to use a custom Holder ? Now that cancellable directory reader is forked, you should be able to set the cancellable lazily ? So instead of passing the Cancellable here you'd set it in ContextIndexSearcher#setCancellable ?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385756200", "createdAt": "2020-02-28T15:24:34Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,10 +89,27 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private Holder<Cancellable> cancellable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjcxMA==", "bodyText": "+1 to copy", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385756710", "createdAt": "2020-02-28T15:25:23Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {\n+\n+        private final Cancellable checkCancelled;\n+\n+        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, checkCancelled);\n+                }\n+            });\n+            this.checkCancelled = checkCancelled;\n+        }\n+\n+        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n+            this.checkCancelled.setCancellable(checkCancelled);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a leaf reader with a cancellable task\n+     */\n+    private static class CancellableLeafReader extends ExitableDirectoryReader.ExitableFilterAtomicReader {\n+\n+        private CancellableLeafReader(LeafReader leafReader, Cancellable checkCancelled)  {\n+            super(leafReader, checkCancelled);\n+        }\n+\n+        @Override\n+        public NumericDocValues getNumericDocValues(String field) throws IOException {\n+            return in.getNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n+            return in.getBinaryDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedDocValues getSortedDocValues(String field) throws IOException {\n+            return in.getSortedDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n+            return in.getSortedNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n+            return in.getSortedSetDocValues(field);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of {@link QueryTimeout} with a Runnable task.\n+     */\n+    private static class Cancellable implements QueryTimeout {\n+\n+        private Supplier<Runnable> cancellable;\n+\n+        public void setCancellable(Supplier<Runnable> cancellable) {\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public boolean shouldExit() {\n+            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n+            if (cancellable.get() == null) {\n+                return false;\n+            }\n+            cancellable.get().run();\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}, "originalCommit": {"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NzIwOQ==", "bodyText": "We should do this on the cancellable object directly. The searcher shouldn't be able to unset this way. See my comment on the context searcher.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385757209", "createdAt": "2020-02-28T15:26:10Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -310,6 +297,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n                 queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n             }\n+            // Search phase has finished, no longer need to check for timeout\n+            searcher.unsetCheckTimeout();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ=="}, "originalCommit": {"oid": "ce2d557d56d860402220bb64cfbca16c100eef25"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Nzg2Mg==", "bodyText": "Can you revert this change ? It should work without this modification so I'd like to keep this for a different pr since the issue is not related to the exitable directory reader.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385757862", "createdAt": "2020-02-28T15:27:11Z", "author": {"login": "jimczi"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java", "diffHunk": "@@ -611,14 +611,8 @@ public void testCacheAggregation() throws IOException {\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODE0NQ==", "bodyText": "Same here, this shouldn't be needed with the extra constructor.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385758145", "createdAt": "2020-02-28T15:27:37Z", "author": {"login": "jimczi"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java", "diffHunk": "@@ -920,14 +920,8 @@ public void testCacheAggregation() throws IOException {\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODI2Mw==", "bodyText": "Here too ;)", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385758263", "createdAt": "2020-02-28T15:27:48Z", "author": {"login": "jimczi"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java", "diffHunk": "@@ -22,7 +22,6 @@\n import org.apache.lucene.document.Document;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTQzMDg2", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-366543086", "createdAt": "2020-02-28T16:54:41Z", "commit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjo1NDo0MVrOFv718w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzowMToyMFrOFv8DoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzg1OQ==", "bodyText": "can you check that the argument is not null since we seem to assume it's never null in some places?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385807859", "createdAt": "2020-02-28T16:54:41Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -92,10 +121,14 @@ public void setProfiler(QueryProfiler profiler) {\n \n     /**\n      * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * collecting documents and check for query cancellation or timeout\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public void setCancellable(Cancellable cancellable) {\n+        this.cancellable.set(cancellable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODYwNQ==", "bodyText": "Let's do the get() call once for all instead of forcing the bulk scorer to do it every time it wants to check whether the request has been cancelled?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());\n          \n          \n            \n                                    Runnable checkCancelled = cancellable.get();\n          \n          \n            \n                                    return new CancellableBulkScorer(in, checkCancelled);", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385808605", "createdAt": "2020-02-28T16:56:12Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -244,7 +270,7 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, checkCancelled);\n+                        return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDAyMg==", "bodyText": "let's throw an UnsupportedOperationException? (this is only used when asking a DirectoryReader to take into account some new changes in a directory, which should never happen with this impl)", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385810022", "createdAt": "2020-02-28T16:58:48Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {\n+\n+        private Runnable checkCancelled;\n+        private Runnable checkTimeout;\n+\n+        private CancellableImpl() {\n+        }\n+\n+        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+            this.checkTimeout = checkTimeout;\n+        }\n+\n+        @Override\n+        public boolean isEnabled() {\n+            return checkCancelled != null || checkTimeout != null;\n+        }\n+\n+        @Override\n+        public void checkCancelled() {\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n+            }\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n+            }\n+        }\n+\n+        @Override\n+        public void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellable);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA==", "bodyText": "If we want to reduce the overhead to a minimum, we could make MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK a power of two minus 1 (e.g. (1 << 4) - 1, ie. 15, and use a mask instead of a remainder: (calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385811360", "createdAt": "2020-02-28T17:01:20Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {\n+\n+        private Runnable checkCancelled;\n+        private Runnable checkTimeout;\n+\n+        private CancellableImpl() {\n+        }\n+\n+        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+            this.checkTimeout = checkTimeout;\n+        }\n+\n+        @Override\n+        public boolean isEnabled() {\n+            return checkCancelled != null || checkTimeout != null;\n+        }\n+\n+        @Override\n+        public void checkCancelled() {\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n+            }\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n+            }\n+        }\n+\n+        @Override\n+        public void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellable);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<Cancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n+                    new ExitableTerms(terms, cancellable.get()) : terms;\n+        }\n+\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+            return in.getCoreCacheHelper();\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Helper class to be used as an immutable reference so that the underlying\n+     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n+     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n+     */\n+    private static class Holder<T> {\n+\n+        private T in;\n+\n+        private Holder(T in) {\n+            this.in = in;\n+        }\n+\n+        private void set(T in) {\n+            this.in = in;\n+        }\n+\n+        private T get() {\n+            return in;\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n+     */\n+    private static class ExitableTerms extends FilterTerms {\n+\n+        private final Cancellable cancellable;\n+\n+        private ExitableTerms(Terms terms, Cancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n+     * implementing an exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterTermsEnum {\n+\n+        private final Cancellable cancellable;\n+\n+        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkDirReaderCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkDirReaderCancelled();\n+            return in.next();\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n+     */\n+    private static class ExitablePointValues extends PointValues {\n+\n+        private final PointValues in;\n+        private final Cancellable cancellable;\n+\n+        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+            this.cancellable.checkDirReaderCancelled();\n+        }\n+\n+        @Override\n+        public void intersect(IntersectVisitor visitor) throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n+        }\n+\n+        @Override\n+        public long estimatePointCount(IntersectVisitor visitor) {\n+            cancellable.checkDirReaderCancelled();\n+            return in.estimatePointCount(visitor);\n+        }\n+\n+        @Override\n+        public byte[] getMinPackedValue() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getMinPackedValue();\n+        }\n+\n+        @Override\n+        public byte[] getMaxPackedValue() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getMaxPackedValue();\n+        }\n+\n+        @Override\n+        public int getNumDimensions() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getNumDimensions();\n+        }\n+\n+        @Override\n+        public int getNumIndexDimensions() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getNumIndexDimensions();\n+        }\n+\n+        @Override\n+        public int getBytesPerDimension() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getBytesPerDimension();\n+        }\n+\n+        @Override\n+        public long size() {\n+            cancellable.checkDirReaderCancelled();\n+            return in.size();\n+        }\n+\n+        @Override\n+        public int getDocCount() {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getDocCount();\n+        }\n+    }\n+\n+    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n+\n+        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n+\n+        private final PointValues.IntersectVisitor in;\n+        private final Cancellable cancellable;\n+        private int calls;\n+\n+        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+        }\n+\n+        private void checkAndThrowWithSampling() {\n+            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff"}, "originalPosition": 409}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "committedDate": "2020-02-29T11:42:57Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3936a05c6adb5c38bb33d370d6e05db93dd3d872", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/3936a05c6adb5c38bb33d370d6e05db93dd3d872", "committedDate": "2020-02-29T16:00:24Z", "message": "fix revert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bf0fe3d64f140fc2e534257a6eae073ea1b5c95", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/9bf0fe3d64f140fc2e534257a6eae073ea1b5c95", "committedDate": "2020-02-29T16:01:31Z", "message": "fix revert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce51935a96c3d59af66205144924f3ff1b32d17e", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/ce51935a96c3d59af66205144924f3ff1b32d17e", "committedDate": "2020-02-29T17:26:42Z", "message": "move impl to QueryPhase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/9695114f3028f98ae59dc5ff7481aab3251bce9f", "committedDate": "2020-03-01T12:10:26Z", "message": "unit test wrapping and exit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3OTAxMDk1", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-367901095", "createdAt": "2020-03-03T11:28:03Z", "commit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMToyODowNFrOFxCD8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMTozMzo1NlrOFxCP5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1ODMyMg==", "bodyText": "Let's use a method ref instead in order to avoid creating an anonymous class\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return new CancellableBulkScorer(in, () -> checkCancelled());\n          \n          \n            \n                                    return new CancellableBulkScorer(in, cancellable::checkCancelled);", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386958322", "createdAt": "2020-03-03T11:28:04Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -244,7 +269,7 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, checkCancelled);\n+                        return new CancellableBulkScorer(in, () -> checkCancelled());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1ODU4OA==", "bodyText": "can you avoid doing a null check every time we check whether the request should be cancelled, like the code did before?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386958588", "createdAt": "2020-03-03T11:28:40Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -207,8 +233,7 @@ private void searchLeaf(LeafReaderContext ctx, Weight weight, Collector collecto\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                        checkCancelled == null ? () -> { } : checkCancelled);\n+                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector, () -> checkCancelled());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA==", "bodyText": "this constructor seems to always be called with a Holder around a null, so let's remove it from the ctor arguments and just set cancellableHolder = new Holder<>(null);?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386959490", "createdAt": "2020-03-03T11:30:32Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MDY4Nw==", "bodyText": "can you add a comment about why we're not wrapping CompletionTerms? I also wonder that this instanceof logic might be fragile as terms may be wrapped e.g. if document-level security is used?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386960687", "createdAt": "2020-03-03T11:32:44Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n+                }\n+            });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<QueryCancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MTM4MA==", "bodyText": "Can we do it on a regular interval (like in ExitableIntersectVisitor) instead of for every term, I worry that this might add noticeable overhead.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386961380", "createdAt": "2020-03-03T11:33:56Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n+                }\n+            });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<QueryCancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n+                    new ExitableTerms(terms, cancellable.get()) : terms;\n+        }\n+\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+            return in.getCoreCacheHelper();\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Helper class to be used as an immutable reference so that the underlying\n+     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n+     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n+     */\n+    private static class Holder<T> {\n+\n+        private T in;\n+\n+        private Holder(T in) {\n+            this.in = in;\n+        }\n+\n+        private void set(T in) {\n+            this.in = in;\n+        }\n+\n+        private T get() {\n+            return in;\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n+     */\n+    static class ExitableTerms extends FilterTerms {\n+\n+        private final QueryCancellable cancellable;\n+\n+        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n+     * implementing an exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterTermsEnum {\n+\n+        private final QueryCancellable cancellable;\n+\n+        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "originalPosition": 281}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d562cf1d4a23d023685095dfa18a1448574dd475", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/d562cf1d4a23d023685095dfa18a1448574dd475", "committedDate": "2020-03-03T12:32:42Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/6243ceddaf39089ce8fef6c14da6d22608099f3f", "committedDate": "2020-03-03T12:52:02Z", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MTcxMTA2", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-368171106", "createdAt": "2020-03-03T17:17:44Z", "commit": {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNzoxNzo0NFrOFxPHNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNzoyODozM1rOFxPfSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MjE0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        this.cancellable == null ? () -> {} : this::checkCancelled);\n          \n          \n            \n                                        this.cancellable == null ? () -> {} : cancellable::checkCancelled);", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387172149", "createdAt": "2020-03-03T17:17:44Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -208,7 +235,7 @@ private void searchLeaf(LeafReaderContext ctx, Weight weight, Collector collecto\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                        checkCancelled == null ? () -> { } : checkCancelled);\n+                            this.cancellable == null ? () -> {} : this::checkCancelled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3NzAxMw==", "bodyText": "I tend to prefer fully-qualified calls to TestUtil#nextInt instead of adding a static import, given that this method name is quite generic.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387177013", "createdAt": "2020-03-03T17:26:14Z", "author": {"login": "jpountz"}, "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -53,17 +57,19 @@ public static void setup() throws IOException {\n         // we need at least 2 segments - so no merges should be allowed\n         w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE);\n         w.setDoRandomForceMerge(false);\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 2, 20));\n+        int numDocs = nextInt(random(), 2, 20);\n+        indexRandomDocuments(w, numDocs, 0);\n         w.flush();\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20));\n+        indexRandomDocuments(w, nextInt(random(), 1, 20), numDocs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3ODMxMw==", "bodyText": "let's also test that it can interrupt iteration over the terms/points?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387178313", "createdAt": "2020-03-03T17:28:33Z", "author": {"login": "jpountz"}, "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -92,4 +98,22 @@ public void testCancellableCollector() throws IOException {\n             () -> searcher.search(new MatchAllDocsQuery(), collector));\n     }\n \n+    public void testCancellableDirectoryReader() throws IOException {\n+        AtomicBoolean cancelled = new AtomicBoolean();\n+        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n+                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n+        searcher.setCancellable(() -> {\n+            if (cancelled.get()) {\n+                throw new TaskCancelledException(\"cancelled\");\n+            }\n+        });\n+        searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator();\n+        searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount();\n+\n+        cancelled.set(true);\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator());\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "committedDate": "2020-03-03T19:58:40Z", "message": "improve tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MzYxNjgz", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-368361683", "createdAt": "2020-03-03T22:07:39Z", "commit": {"oid": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowNzo0MFrOFxYXUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjoxOTo0NlrOFxYtZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ==", "bodyText": "nit: This class deserves its own file. Is there a specific reason to rename from ExitableDirectoryReader ?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387323729", "createdAt": "2020-03-03T22:07:40Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +347,278 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNzA0OA==", "bodyText": "I also wonder if we can replace the Holder with a mutable QueryTimeout implementation:\nSomething like:\n   private static class MutableQueryTimeout implements QueryTimeout {\n        private final Set<Runnable> runnables = new HashSet<>();\n\n        Object add(Runnable action) {\n            if (runnables.add(action) == false) {\n                throw new IllegalArgumentException(\"already added\");\n            }\n            return action;\n        }\n\n        boolean remove(Runnable action) {\n            return runnables.remove(action);\n        }\n\n        @Override\n        public boolean shouldExit() {\n            for (Runnable timeout : runnables) {\n                timeout.run();\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isTimeoutEnabled() {\n            return runnables.size() > 0;\n        }\n    }\n\nThis way you can expose a simple QueryTimeout in the wrapped reader and keep the logic simple there ?\nThe ContextIndexSearcher could then expose the addQueryTimeout, removeQueryTimeout directly for the QueryPhase modification.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387327048", "createdAt": "2020-03-03T22:14:52Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}, "originalCommit": {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyOTM4Mg==", "bodyText": "See my comment below, I think this could be simplified into:\n            boolean timeoutSet = scrollContext == null && searchContext.timeout() != null &&\n                searchContext.timeout().equals(SearchService.NO_TIMEOUT) == false;\n            final Runnable timeoutRunnable;\n            if (timeoutSet) {\n                final long startTime = searchContext.getRelativeTimeInMillis();\n                final long timeout = searchContext.timeout().millis();\n                final long maxTime = startTime + timeout;\n                timeoutRunnable = searcher.addQueryTimeout(() -> {\n                    final long time = searchContext.getRelativeTimeInMillis();\n                    if (time > maxTime) {\n                        throw new TimeExceededException();\n                    }\n                });\n            } else {\n                timeoutRunnable = null;\n            }\n\n            if (searchContext.lowLevelCancellation()) {\n                SearchShardTask task = searchContext.getTask();\n                searcher.addQueryTimeout(() -> {\n                    if (task.isCancelled()) {\n                        throw new TaskCancelledException(\"cancelled\");\n                    }\n                });\n            }\n            try {\n                ...\n            } finally {\n              if (timeoutRunnable != null) {\n                 searcher.removeQueryTimeout(timeoutRunnable);\n              }\n           }", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387329382", "createdAt": "2020-03-03T22:19:46Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -272,20 +273,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 cancellationRunnable = null;\n             }\n \n-            final Runnable checkCancelled;\n-            if (timeoutRunnable != null && cancellationRunnable != null) {\n-                checkCancelled = () -> {\n-                    timeoutRunnable.run();\n-                    cancellationRunnable.run();\n-                };\n-            } else if (timeoutRunnable != null) {\n-                checkCancelled = timeoutRunnable;\n-            } else if (cancellationRunnable != null) {\n-                checkCancelled = cancellationRunnable;\n-            } else {\n-                checkCancelled = null;\n-            }\n-            searcher.setCheckCancelled(checkCancelled);\n+            QueryCancellableImpl cancellable = new QueryCancellableImpl(timeoutRunnable, cancellationRunnable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/b446dfd16c6de533f1ccc2a552407e6df03f3376", "committedDate": "2020-03-04T11:36:21Z", "message": "extract wrapper classes to another file, use more elegant approach for cancellable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "183da1740e1380abba936dd676eba04694717bb5", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/183da1740e1380abba936dd676eba04694717bb5", "committedDate": "2020-03-04T13:07:03Z", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQ3MDA0", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-368847004", "createdAt": "2020-03-04T14:57:04Z", "commit": {"oid": "183da1740e1380abba936dd676eba04694717bb5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NzowNVrOFxwiGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1ODo1N1rOFxwnaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg==", "bodyText": "nit: the naming of the add is inconsistent with the remove. I wonder how to expose the name here, [add/remove]CheckExitReader ?\nIn any case the javadocs should be adapted to mention the fact that these checks run when we access the reader so not only when collecting document. This makes me think that we may want to wrap the task cancellation check before we rewrite the Lucene query for instance. I am fine if we do this in a follow up since it should be fairly easy to add.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387719706", "createdAt": "2020-03-04T14:57:05Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +80,42 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while\n+     * collecting documents and check for query cancellation or timeout.\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public Runnable addQueryCancellation(Runnable action) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "183da1740e1380abba936dd676eba04694717bb5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMTA2Nw==", "bodyText": "Can you also test the removal of the runnable ?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387721067", "createdAt": "2020-03-04T14:58:57Z", "author": {"login": "jimczi"}, "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -92,4 +98,22 @@ public void testCancellableCollector() throws IOException {\n             () -> searcher.search(new MatchAllDocsQuery(), collector));\n     }\n \n+    public void testCancellableDirectoryReader() throws IOException {\n+        AtomicBoolean cancelled = new AtomicBoolean();\n+        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n+                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n+        searcher.setCancellable(() -> {\n+            if (cancelled.get()) {\n+                throw new TaskCancelledException(\"cancelled\");\n+            }\n+        });\n+        searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator();\n+        searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount();\n+\n+        cancelled.set(true);\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator());\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3ODMxMw=="}, "originalCommit": {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "committedDate": "2020-03-04T15:37:23Z", "message": "rename method, add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTUzODg1", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-368953885", "createdAt": "2020-03-04T16:57:25Z", "commit": {"oid": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNjo1NzoyNVrOFx1jIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNjo1NzoyNVrOFx1jIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTg5MQ==", "bodyText": "Please don't implement QueryTimeout, I think this introduces more issues than it helps, since its contract is that shouldExit should return true once the timeout is hit, while we instead use runnables that throw exceptions.", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387801891", "createdAt": "2020-03-04T16:57:25Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +338,34 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    private static class MutableQueryTimeout implements QueryTimeout {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/23c3adc7129b3ca912e5c19a4828dd01c26364bb", "committedDate": "2020-03-04T17:10:55Z", "message": "replace QueryTimeout with our own iface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTY1OTMx", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-368965931", "createdAt": "2020-03-04T17:13:24Z", "commit": {"oid": "23c3adc7129b3ca912e5c19a4828dd01c26364bb"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzoxMzoyNFrOFx2HRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzoxMzoyNFrOFx2HRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMTE0MA==", "bodyText": "Can you document the contract?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387811140", "createdAt": "2020-03-04T17:13:24Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.internal;\n+\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.FilterDirectoryReader;\n+import org.apache.lucene.index.FilterLeafReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.index.TermsEnum;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Wraps an {@link IndexReader} with a {@link QueryCancellation}\n+ * which checks for cancelled or timed-out query.\n+ */\n+class ExitableDirectoryReader extends FilterDirectoryReader {\n+\n+    interface QueryCancellation {\n+\n+        boolean isEnabled();\n+\n+        void checkCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23c3adc7129b3ca912e5c19a4828dd01c26364bb"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "committedDate": "2020-03-04T17:19:38Z", "message": "document iface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "committedDate": "2020-03-04T17:19:49Z", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDU1NzQ2", "url": "https://github.com/elastic/elasticsearch/pull/52822#pullrequestreview-369455746", "createdAt": "2020-03-05T10:31:09Z", "commit": {"oid": "183da1740e1380abba936dd676eba04694717bb5"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozMTowOVrOFyONXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNDo1MFrOFyOVGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNTkxOA==", "bodyText": "ok fine with me", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r388205918", "createdAt": "2020-03-05T10:31:09Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +80,42 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while\n+     * collecting documents and check for query cancellation or timeout.\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public Runnable addQueryCancellation(Runnable action) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg=="}, "originalCommit": {"oid": "183da1740e1380abba936dd676eba04694717bb5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzg5Ng==", "bodyText": "nit: s/while accessing/while fetching document/ this is confusing since we don't check the cancellation when visiting the stored fields ?", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r388207896", "createdAt": "2020-03-05T10:34:50Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +79,46 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df0da4c8c45aa49ebeceb276ec871c6f4d03d4de"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "author": {"user": {"login": "matriv", "name": "Marios Trivyzas"}}, "url": "https://github.com/elastic/elasticsearch/commit/eb158e54a363eda92f3e7830e6158f5e8da555eb", "committedDate": "2020-03-05T10:40:42Z", "message": "fix comment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1968, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}