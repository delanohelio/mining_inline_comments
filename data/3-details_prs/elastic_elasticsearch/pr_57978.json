{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyOTgyNTgy", "number": 57978, "title": "[ML] Add categorizer stats ML result type", "bodyText": "This type of result will store stats about how well categorization\nis performing.  When per-partition categorization is in use, separate\ndocuments will be written for every partition so that it is possible\nto see if categorization is working well for some partitions but not\nothers.\nThis PR is a minimal implementation to allow the C++ side changes to\nbe made.  More Java side changes related to per-partition\ncategorization will be in followup PRs.  However, even in the long\nterm I do not see a major benefit in introducing dedicated APIs for\nquerying categorizer stats.  Like forecast request stats the\ncategorizer stats can be read directly from the job's results alias.", "createdAt": "2020-06-11T10:23:47Z", "url": "https://github.com/elastic/elasticsearch/pull/57978", "merged": true, "mergeCommit": {"oid": "355958f0a4171d480ce887c1068f1280e1b9b7dc"}, "closed": true, "closedAt": "2020-06-11T16:59:36Z", "author": {"login": "droberts195"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqLnSPAH2gAyNDMyOTgyNTgyOjZmMjE2ZWIxZjkxNDBkMTY0OWRmYzdjMDAxMjM4OTE4Mzg5ZWI1ZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqNLLygH2gAyNDMyOTgyNTgyOjhjMGJjNWFjYjIzN2M4ZjJmNGUwOTIzMGUwZmQwMDVkN2QzZWM4NzY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2", "author": {"user": {"login": "droberts195", "name": "David Roberts"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f216eb1f9140d1649dfc7c001238918389eb5f2", "committedDate": "2020-06-11T10:22:46Z", "message": "[ML] Add categorizer stats ML result type\n\nThis type of result will store stats about how well categorization\nis performing.  When per-partition categorization is in use, separate\ndocuments will be written for every partition so that it is possible\nto see if categorization is working well for some partitions but not\nothers.\n\nThis PR is a minimal implementation to allow the C++ side changes to\nbe made.  More Java side changes related to per-partition\ncategorization will be in followup PRs.  However, even in the long\nterm I do not see a major benefit in introducing dedicated APIs for\nquerying categorizer stats.  Like forecast request stats the\ncategorizer stats can be read directly from the job's results alias."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4ODI4MzQw", "url": "https://github.com/elastic/elasticsearch/pull/57978#pullrequestreview-428828340", "createdAt": "2020-06-11T11:40:24Z", "commit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0MDoyNFrOGiZhYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo1MDo1NFrOGiZ0TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMjkxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        &&Objects.equals(this.partitionFieldName, that.partitionFieldName)\n          \n          \n            \n                        && Objects.equals(this.partitionFieldName, that.partitionFieldName)\n          \n      \n    \n    \n  \n\n\"obsessive formatting disorder\" :D", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438722914", "createdAt": "2020-06-11T11:40:24Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;\n+        this.categorizationStatus = Objects.requireNonNull(categorizationStatus);\n+        this.timestamp = Instant.ofEpochMilli(timestamp.toEpochMilli());\n+        this.logTime = Instant.ofEpochMilli(logTime.toEpochMilli());\n+    }\n+\n+    public CategorizerStats(StreamInput in) throws IOException {\n+        jobId = in.readString();\n+        partitionFieldName = in.readOptionalString();\n+        partitionFieldValue = in.readOptionalString();\n+        categorizedDocCount = in.readVLong();\n+        totalCategoryCount = in.readVLong();\n+        frequentCategoryCount = in.readVLong();\n+        rareCategoryCount = in.readVLong();\n+        deadCategoryCount = in.readVLong();\n+        failedCategoryCount = in.readVLong();\n+        categorizationStatus = CategorizationStatus.readFromStream(in);\n+        logTime = in.readInstant();\n+        timestamp = in.readInstant();\n+    }\n+\n+    public String getId() {\n+        return documentIdPrefix(jobId) + logTime.toEpochMilli();\n+    }\n+\n+    public static String documentIdPrefix(String jobId) {\n+        return jobId + \"_categorizer_stats_\";\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(jobId);\n+        out.writeOptionalString(partitionFieldName);\n+        out.writeOptionalString(partitionFieldValue);\n+        out.writeVLong(categorizedDocCount);\n+        out.writeVLong(totalCategoryCount);\n+        out.writeVLong(frequentCategoryCount);\n+        out.writeVLong(rareCategoryCount);\n+        out.writeVLong(deadCategoryCount);\n+        out.writeVLong(failedCategoryCount);\n+        categorizationStatus.writeTo(out);\n+        out.writeInstant(logTime);\n+        out.writeInstant(timestamp);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(Job.ID.getPreferredName(), jobId);\n+        builder.field(Result.RESULT_TYPE.getPreferredName(), RESULT_TYPE_VALUE);\n+        if (partitionFieldName != null) {\n+            builder.field(PARTITION_FIELD_NAME.getPreferredName(), partitionFieldName);\n+            builder.field(PARTITION_FIELD_VALUE.getPreferredName(), partitionFieldValue);\n+            if (ReservedFieldNames.isValidFieldName(partitionFieldName)) {\n+                builder.field(partitionFieldName, partitionFieldValue);\n+            }\n+        }\n+        builder.field(CATEGORIZED_DOC_COUNT_FIELD.getPreferredName(), categorizedDocCount);\n+        builder.field(TOTAL_CATEGORY_COUNT_FIELD.getPreferredName(), totalCategoryCount);\n+        builder.field(FREQUENT_CATEGORY_COUNT_FIELD.getPreferredName(), frequentCategoryCount);\n+        builder.field(RARE_CATEGORY_COUNT_FIELD.getPreferredName(), rareCategoryCount);\n+        builder.field(DEAD_CATEGORY_COUNT_FIELD.getPreferredName(), deadCategoryCount);\n+        builder.field(FAILED_CATEGORY_COUNT_FIELD.getPreferredName(), failedCategoryCount);\n+        builder.field(CATEGORIZATION_STATUS_FIELD.getPreferredName(), categorizationStatus);\n+        builder.timeField(LOG_TIME_FIELD.getPreferredName(), LOG_TIME_FIELD.getPreferredName() + \"_string\", logTime.toEpochMilli());\n+        builder.timeField(TIMESTAMP_FIELD.getPreferredName(), TIMESTAMP_FIELD.getPreferredName() + \"_string\", timestamp.toEpochMilli());\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public String getJobId() {\n+        return jobId;\n+    }\n+\n+    public String getPartitionFieldName() {\n+        return partitionFieldName;\n+    }\n+\n+    public String getPartitionFieldValue() {\n+        return partitionFieldValue;\n+    }\n+\n+    public long getCategorizedDocCount() {\n+        return categorizedDocCount;\n+    }\n+\n+    public long getTotalCategoryCount() {\n+        return totalCategoryCount;\n+    }\n+\n+    public long getFrequentCategoryCount() {\n+        return frequentCategoryCount;\n+    }\n+\n+    public long getRareCategoryCount() {\n+        return rareCategoryCount;\n+    }\n+\n+    public long getDeadCategoryCount() {\n+        return deadCategoryCount;\n+    }\n+\n+    public long getFailedCategoryCount() {\n+        return deadCategoryCount;\n+    }\n+\n+    public CategorizationStatus getCategorizationStatus() {\n+        return categorizationStatus;\n+    }\n+\n+    /**\n+     * The model timestamp when these stats were created.\n+     * @return The model time\n+     */\n+    public Instant getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    /**\n+     * The wall clock time at the point when this instance was created.\n+     * @return The wall clock time\n+     */\n+    public Instant getLogTime() {\n+        return logTime;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(jobId, partitionFieldName, partitionFieldValue, categorizedDocCount, totalCategoryCount,\n+            frequentCategoryCount, rareCategoryCount, deadCategoryCount, failedCategoryCount, categorizationStatus, timestamp, logTime);\n+    }\n+\n+    /**\n+     * Compare all the fields.\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof CategorizerStats == false) {\n+            return false;\n+        }\n+\n+        CategorizerStats that = (CategorizerStats) other;\n+\n+        return Objects.equals(this.jobId, that.jobId)\n+            &&Objects.equals(this.partitionFieldName, that.partitionFieldName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMzg5OQ==", "bodyText": "We don't check that all of these are > 0. This is probably OK since we are getting this data from C++ and there is an implicit trust.", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438723899", "createdAt": "2020-06-11T11:42:33Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNjM5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0) && in.readBoolean()) {\n          \n          \n            \n                        this.categorizerStats = new CategorizerStats(in);\n          \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n          \n          \n            \n                        this.categorizerStats = in.readOptionalWriteable(CategorizerStats::new);", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438726398", "createdAt": "2020-06-11T11:47:55Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "diffHunk": "@@ -136,12 +143,16 @@ public AutodetectResult(StreamInput in) throws IOException {\n         } else {\n             this.categoryDefinition = null;\n         }\n+        if (in.getVersion().onOrAfter(Version.V_8_0_0) && in.readBoolean()) {\n+            this.categorizerStats = new CategorizerStats(in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNzc1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        writeNullable(categorizerStats, out);\n          \n          \n            \n                        out.writeOptionalWriteable(categorizerStats);\n          \n      \n    \n    \n  \n\nI wonder if this writeNullable method could just be removed? The down side is that there is no StreamOutput#writeOptionalList. Maybe there should be?", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438727756", "createdAt": "2020-06-11T11:50:54Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "diffHunk": "@@ -165,6 +176,9 @@ public void writeTo(StreamOutput out) throws IOException {\n         writeNullable(modelPlot, out);\n         writeNullable(annotation, out);\n         writeNullable(categoryDefinition, out);\n+        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            writeNullable(categorizerStats, out);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c0bc5acb237c8f2f4e09230e0fd005d7d3ec876", "author": {"user": {"login": "droberts195", "name": "David Roberts"}}, "url": "https://github.com/elastic/elasticsearch/commit/8c0bc5acb237c8f2f4e09230e0fd005d7d3ec876", "committedDate": "2020-06-11T12:11:53Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Benjamin Trent <ben.w.trent@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 785, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}