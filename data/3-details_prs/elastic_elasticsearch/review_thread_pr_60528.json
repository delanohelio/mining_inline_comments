{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMjY5MDA0", "number": 60528, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo1NToyOVrOEUG7Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToyMTo0MlrOEYAlzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTIwNDM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo1NToyOVrOG6NmNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMjo1NDo0MlrOG64Xkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MzM2Nw==", "bodyText": "@dimitris-athanasiou I am torn with what to do here.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r463693367", "createdAt": "2020-07-31T15:55:29Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -304,22 +368,42 @@ private ExtractedFields detectExtractedFields(Set<String> fields, Set<FieldSelec\n         return extractedFields;\n     }\n \n-    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields, boolean preferSource,\n+    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields,\n+                                                   boolean preferSource,\n                                                    Set<FieldSelection> fieldSelection) {\n-        Set<String> requiredFields = config.getAnalysis().getRequiredFields().stream().map(RequiredField::getName)\n+        Set<String> requiredFields = config.getAnalysis()\n+            .getRequiredFields()\n+            .stream()\n+            .map(RequiredField::getName)\n             .collect(Collectors.toSet());\n         Map<String, ExtractedField> nameOrParentToField = new LinkedHashMap<>();\n         for (ExtractedField currentField : extractedFields.getAllFields()) {\n+            // If this field or its parent is processed ONLY, then its fine. We don't need to deduplicate it as it won't be sent\n+            // directly to the native process\n+            if (extractedFields.getProcessedOnlyFields().contains(currentField.getName())) {\n+                nameOrParentToField.put(currentField.getName(), currentField);\n+                continue;\n+            }\n+            if (currentField.isMultiField() && extractedFields.getProcessedOnlyFields().contains(currentField.getParentField())) {\n+                nameOrParentToField.put(currentField.getParentField(), currentField);\n+                continue;\n+            }\n             String nameOrParent = currentField.isMultiField() ? currentField.getParentField() : currentField.getName();\n             ExtractedField existingField = nameOrParentToField.putIfAbsent(nameOrParent, currentField);\n+            // TODO, there is an issue where the processed field references the field `foo.keyword` but an included field references `foo`\n+            // The included field might only be `foo`. How should we adjust the `foo.keyword` inclusion?\n+            // It seems to me that we should disallow users from asking for a `foo.keyword` field in the processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5530aa4cd2648789d12c341101d05fff8b186aa3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2Mjc0Mg==", "bodyText": "Well, if we prevent folks from including a \"organically\" AND via a feature_processor, we could skirt this issue.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r464362742", "createdAt": "2020-08-03T11:47:33Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -304,22 +368,42 @@ private ExtractedFields detectExtractedFields(Set<String> fields, Set<FieldSelec\n         return extractedFields;\n     }\n \n-    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields, boolean preferSource,\n+    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields,\n+                                                   boolean preferSource,\n                                                    Set<FieldSelection> fieldSelection) {\n-        Set<String> requiredFields = config.getAnalysis().getRequiredFields().stream().map(RequiredField::getName)\n+        Set<String> requiredFields = config.getAnalysis()\n+            .getRequiredFields()\n+            .stream()\n+            .map(RequiredField::getName)\n             .collect(Collectors.toSet());\n         Map<String, ExtractedField> nameOrParentToField = new LinkedHashMap<>();\n         for (ExtractedField currentField : extractedFields.getAllFields()) {\n+            // If this field or its parent is processed ONLY, then its fine. We don't need to deduplicate it as it won't be sent\n+            // directly to the native process\n+            if (extractedFields.getProcessedOnlyFields().contains(currentField.getName())) {\n+                nameOrParentToField.put(currentField.getName(), currentField);\n+                continue;\n+            }\n+            if (currentField.isMultiField() && extractedFields.getProcessedOnlyFields().contains(currentField.getParentField())) {\n+                nameOrParentToField.put(currentField.getParentField(), currentField);\n+                continue;\n+            }\n             String nameOrParent = currentField.isMultiField() ? currentField.getParentField() : currentField.getName();\n             ExtractedField existingField = nameOrParentToField.putIfAbsent(nameOrParent, currentField);\n+            // TODO, there is an issue where the processed field references the field `foo.keyword` but an included field references `foo`\n+            // The included field might only be `foo`. How should we adjust the `foo.keyword` inclusion?\n+            // It seems to me that we should disallow users from asking for a `foo.keyword` field in the processors.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MzM2Nw=="}, "originalCommit": {"oid": "5530aa4cd2648789d12c341101d05fff8b186aa3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM5NDEzMQ==", "bodyText": "I am going to implement the following restriction:\n\nIf the field is referenced in a feature_processor it cannot be included directly in analytics.\nWe will provide an identity processor so that folks can do this themselves in the future if necessary.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r464394131", "createdAt": "2020-08-03T12:54:42Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -304,22 +368,42 @@ private ExtractedFields detectExtractedFields(Set<String> fields, Set<FieldSelec\n         return extractedFields;\n     }\n \n-    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields, boolean preferSource,\n+    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields,\n+                                                   boolean preferSource,\n                                                    Set<FieldSelection> fieldSelection) {\n-        Set<String> requiredFields = config.getAnalysis().getRequiredFields().stream().map(RequiredField::getName)\n+        Set<String> requiredFields = config.getAnalysis()\n+            .getRequiredFields()\n+            .stream()\n+            .map(RequiredField::getName)\n             .collect(Collectors.toSet());\n         Map<String, ExtractedField> nameOrParentToField = new LinkedHashMap<>();\n         for (ExtractedField currentField : extractedFields.getAllFields()) {\n+            // If this field or its parent is processed ONLY, then its fine. We don't need to deduplicate it as it won't be sent\n+            // directly to the native process\n+            if (extractedFields.getProcessedOnlyFields().contains(currentField.getName())) {\n+                nameOrParentToField.put(currentField.getName(), currentField);\n+                continue;\n+            }\n+            if (currentField.isMultiField() && extractedFields.getProcessedOnlyFields().contains(currentField.getParentField())) {\n+                nameOrParentToField.put(currentField.getParentField(), currentField);\n+                continue;\n+            }\n             String nameOrParent = currentField.isMultiField() ? currentField.getParentField() : currentField.getName();\n             ExtractedField existingField = nameOrParentToField.putIfAbsent(nameOrParent, currentField);\n+            // TODO, there is an issue where the processed field references the field `foo.keyword` but an included field references `foo`\n+            // The included field might only be `foo`. How should we adjust the `foo.keyword` inclusion?\n+            // It seems to me that we should disallow users from asking for a `foo.keyword` field in the processors.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MzM2Nw=="}, "originalCommit": {"oid": "5530aa4cd2648789d12c341101d05fff8b186aa3"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDY1NzI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/analyses/Regression.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzo1NDoyMVrOG7hcLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMToxODo0NFrOG-zTwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2NzA1NA==", "bodyText": "if we want to address this TODO, it will require transform this into a Builder format of parsing.\nSince that would be a ton more churn for this PR, I suggest doing that at a later time", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r465067054", "createdAt": "2020-08-04T13:54:21Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/analyses/Regression.java", "diffHunk": "@@ -59,14 +66,21 @@\n                 (Double) a[8],\n                 (Long) a[9],\n                 (LossFunction) a[10],\n-                (Double) a[11]));\n+                (Double) a[11],\n+                (List<PreProcessor>) a[12]));\n         parser.declareString(constructorArg(), DEPENDENT_VARIABLE);\n         BoostedTreeParams.declareFields(parser);\n         parser.declareString(optionalConstructorArg(), PREDICTION_FIELD_NAME);\n         parser.declareDouble(optionalConstructorArg(), TRAINING_PERCENT);\n         parser.declareLong(optionalConstructorArg(), RANDOMIZE_SEED);\n         parser.declareString(optionalConstructorArg(), LossFunction::fromString, LOSS_FUNCTION);\n         parser.declareDouble(optionalConstructorArg(), LOSS_FUNCTION_PARAMETER);\n+        parser.declareNamedObjects(optionalConstructorArg(),\n+            (p, c, n) -> lenient ?\n+                p.namedObject(LenientlyParsedPreProcessor.class, n, new PreProcessor.PreProcessorParseContext(true)) :\n+                p.namedObject(StrictlyParsedPreProcessor.class, n, new PreProcessor.PreProcessorParseContext(true)),\n+            (regression) -> {/*TODO should we throw if this is not set?*/},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53730cd3641f46c038ffd5263634397efaad8514"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1NjE4NA==", "bodyText": "There is another version of declareNamedObjects that doesn't need the Consumer<Value> argument. Could we not just use that instead?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468456184", "createdAt": "2020-08-11T09:42:04Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/analyses/Regression.java", "diffHunk": "@@ -59,14 +66,21 @@\n                 (Double) a[8],\n                 (Long) a[9],\n                 (LossFunction) a[10],\n-                (Double) a[11]));\n+                (Double) a[11],\n+                (List<PreProcessor>) a[12]));\n         parser.declareString(constructorArg(), DEPENDENT_VARIABLE);\n         BoostedTreeParams.declareFields(parser);\n         parser.declareString(optionalConstructorArg(), PREDICTION_FIELD_NAME);\n         parser.declareDouble(optionalConstructorArg(), TRAINING_PERCENT);\n         parser.declareLong(optionalConstructorArg(), RANDOMIZE_SEED);\n         parser.declareString(optionalConstructorArg(), LossFunction::fromString, LOSS_FUNCTION);\n         parser.declareDouble(optionalConstructorArg(), LOSS_FUNCTION_PARAMETER);\n+        parser.declareNamedObjects(optionalConstructorArg(),\n+            (p, c, n) -> lenient ?\n+                p.namedObject(LenientlyParsedPreProcessor.class, n, new PreProcessor.PreProcessorParseContext(true)) :\n+                p.namedObject(StrictlyParsedPreProcessor.class, n, new PreProcessor.PreProcessorParseContext(true)),\n+            (regression) -> {/*TODO should we throw if this is not set?*/},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2NzA1NA=="}, "originalCommit": {"oid": "53730cd3641f46c038ffd5263634397efaad8514"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwNTUzNw==", "bodyText": "No. That method assumes a JSON object of JSON objects. Which is not what we want. Order is important for these, at least we do want the order to be deterministic.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468505537", "createdAt": "2020-08-11T11:18:44Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/dataframe/analyses/Regression.java", "diffHunk": "@@ -59,14 +66,21 @@\n                 (Double) a[8],\n                 (Long) a[9],\n                 (LossFunction) a[10],\n-                (Double) a[11]));\n+                (Double) a[11],\n+                (List<PreProcessor>) a[12]));\n         parser.declareString(constructorArg(), DEPENDENT_VARIABLE);\n         BoostedTreeParams.declareFields(parser);\n         parser.declareString(optionalConstructorArg(), PREDICTION_FIELD_NAME);\n         parser.declareDouble(optionalConstructorArg(), TRAINING_PERCENT);\n         parser.declareLong(optionalConstructorArg(), RANDOMIZE_SEED);\n         parser.declareString(optionalConstructorArg(), LossFunction::fromString, LOSS_FUNCTION);\n         parser.declareDouble(optionalConstructorArg(), LOSS_FUNCTION_PARAMETER);\n+        parser.declareNamedObjects(optionalConstructorArg(),\n+            (p, c, n) -> lenient ?\n+                p.namedObject(LenientlyParsedPreProcessor.class, n, new PreProcessor.PreProcessorParseContext(true)) :\n+                p.namedObject(StrictlyParsedPreProcessor.class, n, new PreProcessor.PreProcessorParseContext(true)),\n+            (regression) -> {/*TODO should we throw if this is not set?*/},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2NzA1NA=="}, "originalCommit": {"oid": "53730cd3641f46c038ffd5263634397efaad8514"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDczMDYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/AnalyticsProcessManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoxMDowNVrOG7iJoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNDoxMDowNVrOG7iJoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA3ODY4OQ==", "bodyText": "I think this would be helpful to keep for future debugging purposes.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r465078689", "createdAt": "2020-08-04T14:10:05Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/AnalyticsProcessManager.java", "diffHunk": "@@ -268,8 +268,11 @@ private void writeDataRows(DataFrameDataExtractor dataExtractor, AnalyticsProces\n         }\n     }\n \n-    private void writeHeaderRecord(DataFrameDataExtractor dataExtractor, AnalyticsProcess<AnalyticsResult> process) throws IOException {\n+    private void writeHeaderRecord(DataFrameDataExtractor dataExtractor,\n+                                   AnalyticsProcess<AnalyticsResult> process,\n+                                   DataFrameAnalyticsTask task) throws IOException {\n         List<String> fieldNames = dataExtractor.getFieldNames();\n+        LOGGER.debug(() -> new ParameterizedMessage(\"[{}] header row fields {}\", task.getParams().getId(), fieldNames));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53730cd3641f46c038ffd5263634397efaad8514"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk1MjYyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/preprocessing/PreProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0NTo1M1rOG-wbpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo0NTo1M1rOG-wbpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1ODQwNA==", "bodyText": "May I suggest we rename this to isCustomByDefault? I think it'd make reading it easier.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468458404", "createdAt": "2020-08-11T09:45:53Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/preprocessing/PreProcessor.java", "diffHunk": "@@ -18,6 +18,18 @@\n  */\n public interface PreProcessor extends NamedXContentObject, NamedWriteable, Accountable {\n \n+    class PreProcessorParseContext {\n+        public static final PreProcessorParseContext DEFAULT = new PreProcessorParseContext(false);\n+        final boolean defaultIsCustomValue;\n+        public PreProcessorParseContext(boolean defaultIsCustomValue) {\n+            this.defaultIsCustomValue = defaultIsCustomValue;\n+        }\n+\n+        public boolean isDefaultIsCustomValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk2OTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ExtractedFields.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo1MDozMFrOG-wmAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo1MDozMFrOG-wmAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2MTA1OA==", "bodyText": "Should we handle null here by setting it to an empty list?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468461058", "createdAt": "2020-08-11T09:50:30Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ExtractedFields.java", "diffHunk": "@@ -21,27 +21,39 @@\n import java.util.stream.Collectors;\n \n /**\n- * The fields the datafeed has to extract\n+ * The fields the data[feed|frame] has to extract\n  */\n public class ExtractedFields {\n \n     private final List<ExtractedField> allFields;\n     private final List<ExtractedField> docValueFields;\n+    private final List<ProcessedField> processedFields;\n     private final String[] sourceFields;\n     private final Map<String, Long> cardinalitiesForFieldsWithConstraints;\n \n-    public ExtractedFields(List<ExtractedField> allFields, Map<String, Long> cardinalitiesForFieldsWithConstraints) {\n-        this.allFields = Collections.unmodifiableList(allFields);\n+    public ExtractedFields(List<ExtractedField> allFields,\n+                           List<ProcessedField> processedFields,\n+                           Map<String, Long> cardinalitiesForFieldsWithConstraints) {\n+        this.allFields = new ArrayList<>(allFields);\n         this.docValueFields = filterFields(ExtractedField.Method.DOC_VALUE, allFields);\n         this.sourceFields = filterFields(ExtractedField.Method.SOURCE, allFields).stream().map(ExtractedField::getSearchField)\n             .toArray(String[]::new);\n         this.cardinalitiesForFieldsWithConstraints = Collections.unmodifiableMap(cardinalitiesForFieldsWithConstraints);\n+        this.processedFields = processedFields;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjk3Nzk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ProcessedField.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo1Mjo1MlrOG-wrUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTo1Mjo1MlrOG-wrUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2MjQxOQ==", "bodyText": "nit: make inputs type just Map<String, Object>", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468462419", "createdAt": "2020-08-11T09:52:52Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ProcessedField.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.extractor;\n+\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.core.ml.inference.preprocessing.PreProcessor;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+public class ProcessedField {\n+    private final PreProcessor preProcessor;\n+\n+    public ProcessedField(PreProcessor processor) {\n+        this.preProcessor = Objects.requireNonNull(processor);\n+    }\n+\n+    public List<String> getInputFieldNames() {\n+        return preProcessor.inputFields();\n+    }\n+\n+    public List<String> getOutputFieldNames() {\n+        return preProcessor.outputFields();\n+    }\n+\n+    public Set<String> getOutputFieldType(String outputField) {\n+        return Collections.singleton(preProcessor.getOutputFieldType(outputField));\n+    }\n+\n+    public Object[] value(SearchHit hit, Function<String, ExtractedField> fieldExtractor) {\n+        HashMap<String, Object> inputs = new HashMap<>(preProcessor.inputFields().size(), 1.0f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzAwOTUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDowMTo1MVrOG-w-ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDowMTo1MVrOG-w-ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2NzM2Mw==", "bodyText": "Should we simplify by calling these 2 variables organicFeatures, processedFeatures?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468467363", "createdAt": "2020-08-11T10:01:51Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "diffHunk": "@@ -67,10 +72,29 @@\n     private boolean hasNext;\n     private boolean searchHasShardFailure;\n     private final CachedSupplier<TrainTestSplitter> trainTestSplitter;\n+    // These are fields that are sent directly to the analytics process\n+    // They are not passed through a feature_processor\n+    private final List<String> organicExtractedFeatures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzAxMTAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDowMjoxOVrOG-w_hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDowNjoyMFrOG-xHwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2NzU5MQ==", "bodyText": "nit: use Map<String, ExtractedField>", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468467591", "createdAt": "2020-08-11T10:02:19Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "diffHunk": "@@ -67,10 +72,29 @@\n     private boolean hasNext;\n     private boolean searchHasShardFailure;\n     private final CachedSupplier<TrainTestSplitter> trainTestSplitter;\n+    // These are fields that are sent directly to the analytics process\n+    // They are not passed through a feature_processor\n+    private final List<String> organicExtractedFeatures;\n+    // These are the output field names for the feature_processors\n+    private final List<String> processedOutputFields;\n+    private final HashMap<String, ExtractedField> extractedFieldHashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2OTY5Ng==", "bodyText": "May I suggest renaming variable to extractedFieldsByName?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468469696", "createdAt": "2020-08-11T10:06:20Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "diffHunk": "@@ -67,10 +72,29 @@\n     private boolean hasNext;\n     private boolean searchHasShardFailure;\n     private final CachedSupplier<TrainTestSplitter> trainTestSplitter;\n+    // These are fields that are sent directly to the analytics process\n+    // They are not passed through a feature_processor\n+    private final List<String> organicExtractedFeatures;\n+    // These are the output field names for the feature_processors\n+    private final List<String> processedOutputFields;\n+    private final HashMap<String, ExtractedField> extractedFieldHashMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2NzU5MQ=="}, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzA3ODM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoyMzowMlrOG-xomQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTo1Mzo0M1rOG-0X-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3ODEwNQ==", "bodyText": "I wonder if we could simplify this and avoid the need for lastIndex. The way I have understood we write the organic features first. Could we have here something along the following lines:\nfor i in [0, extractedValues.length)\n    if i < len(organic_features)\n      add organic value in position i\n    else\n      get processed values\n      copy them into position i + processed_values_length", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468478105", "createdAt": "2020-08-11T10:23:02Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "diffHunk": "@@ -188,26 +212,78 @@ private void setFetchSource(SearchRequestBuilder searchRequestBuilder) {\n         return rows;\n     }\n \n-    private Row createRow(SearchHit hit) {\n-        String[] extractedValues = new String[context.extractedFields.getAllFields().size()];\n-        for (int i = 0; i < extractedValues.length; ++i) {\n-            ExtractedField field = context.extractedFields.getAllFields().get(i);\n+    private int extractNonProcessedValues(SearchHit hit, String[] extractedValues) {\n+        int lastIndex = 0;\n+        for (String organicFeature : organicExtractedFeatures) {\n+            ExtractedField field = extractedFieldHashMap.get(organicFeature);\n             Object[] values = field.value(hit);\n             if (values.length == 1 && (values[0] instanceof Number || values[0] instanceof String)) {\n-                extractedValues[i] = Objects.toString(values[0]);\n+                extractedValues[lastIndex++] = Objects.toString(values[0]);\n             } else {\n                 if (values.length == 0 && context.supportsRowsWithMissingValues) {\n                     // if values is empty then it means it's a missing value\n-                    extractedValues[i] = NULL_VALUE;\n+                    extractedValues[lastIndex++] = NULL_VALUE;\n+                } else {\n+                    // we are here if we have a missing value but the analysis does not support those\n+                    // or the value type is not supported (e.g. arrays, etc.)\n+                    return -1;\n+                }\n+            }\n+        }\n+        return lastIndex;\n+    }\n+\n+    private int extractProcessedValue(ProcessedField processedField, SearchHit hit, String[] extractedValues, int start) {\n+        int lastIndex = start;\n+        Object[] values = processedField.value(hit, extractedFieldHashMap::get);\n+        if (values.length == 0) {\n+            if (context.supportsRowsWithMissingValues == false) {\n+                return -1;\n+            }\n+            for (String ignored : processedField.getOutputFieldNames()) {\n+                // if values is empty then it means it's a missing value\n+                extractedValues[lastIndex++] = NULL_VALUE;\n+            }\n+            return lastIndex;\n+        }\n+        if (values.length != processedField.getOutputFieldNames().size()) {\n+            throw ExceptionsHelper.badRequestException(\n+                \"field_processor [{}] output size expected to be [{}], instead it was [{}]\",\n+                processedField.getProcessorName(),\n+                processedField.getOutputFieldNames().size(),\n+                values.length);\n+        }\n+        for (int k = 0; k < processedField.getOutputFieldNames().size(); ++k) {\n+            Object value = values[k];\n+            if (value instanceof Number || value instanceof String) {\n+                extractedValues[lastIndex++] = Objects.toString(value);\n+            } else {\n+                if (value == null && context.supportsRowsWithMissingValues) {\n+                    // if values is null then it means it's a missing value\n+                    extractedValues[lastIndex++] = NULL_VALUE;\n                 } else {\n                     // we are here if we have a missing value but the analysis does not support those\n                     // or the value type is not supported (e.g. arrays, etc.)\n-                    extractedValues = null;\n-                    break;\n+                    return -1;\n                 }\n             }\n         }\n-        boolean isTraining = extractedValues == null ? false : trainTestSplitter.get().isTraining(extractedValues);\n+        return lastIndex;\n+    }\n+\n+    private Row createRow(SearchHit hit) {\n+        String[] extractedValues = new String[organicExtractedFeatures.size() + processedOutputFields.size()];\n+        int lastIndex = extractNonProcessedValues(hit, extractedValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMzAwMw==", "bodyText": "@dimitris-athanasiou this does not end up making it any simpler. I will see what I can do.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468523003", "createdAt": "2020-08-11T11:53:43Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractor.java", "diffHunk": "@@ -188,26 +212,78 @@ private void setFetchSource(SearchRequestBuilder searchRequestBuilder) {\n         return rows;\n     }\n \n-    private Row createRow(SearchHit hit) {\n-        String[] extractedValues = new String[context.extractedFields.getAllFields().size()];\n-        for (int i = 0; i < extractedValues.length; ++i) {\n-            ExtractedField field = context.extractedFields.getAllFields().get(i);\n+    private int extractNonProcessedValues(SearchHit hit, String[] extractedValues) {\n+        int lastIndex = 0;\n+        for (String organicFeature : organicExtractedFeatures) {\n+            ExtractedField field = extractedFieldHashMap.get(organicFeature);\n             Object[] values = field.value(hit);\n             if (values.length == 1 && (values[0] instanceof Number || values[0] instanceof String)) {\n-                extractedValues[i] = Objects.toString(values[0]);\n+                extractedValues[lastIndex++] = Objects.toString(values[0]);\n             } else {\n                 if (values.length == 0 && context.supportsRowsWithMissingValues) {\n                     // if values is empty then it means it's a missing value\n-                    extractedValues[i] = NULL_VALUE;\n+                    extractedValues[lastIndex++] = NULL_VALUE;\n+                } else {\n+                    // we are here if we have a missing value but the analysis does not support those\n+                    // or the value type is not supported (e.g. arrays, etc.)\n+                    return -1;\n+                }\n+            }\n+        }\n+        return lastIndex;\n+    }\n+\n+    private int extractProcessedValue(ProcessedField processedField, SearchHit hit, String[] extractedValues, int start) {\n+        int lastIndex = start;\n+        Object[] values = processedField.value(hit, extractedFieldHashMap::get);\n+        if (values.length == 0) {\n+            if (context.supportsRowsWithMissingValues == false) {\n+                return -1;\n+            }\n+            for (String ignored : processedField.getOutputFieldNames()) {\n+                // if values is empty then it means it's a missing value\n+                extractedValues[lastIndex++] = NULL_VALUE;\n+            }\n+            return lastIndex;\n+        }\n+        if (values.length != processedField.getOutputFieldNames().size()) {\n+            throw ExceptionsHelper.badRequestException(\n+                \"field_processor [{}] output size expected to be [{}], instead it was [{}]\",\n+                processedField.getProcessorName(),\n+                processedField.getOutputFieldNames().size(),\n+                values.length);\n+        }\n+        for (int k = 0; k < processedField.getOutputFieldNames().size(); ++k) {\n+            Object value = values[k];\n+            if (value instanceof Number || value instanceof String) {\n+                extractedValues[lastIndex++] = Objects.toString(value);\n+            } else {\n+                if (value == null && context.supportsRowsWithMissingValues) {\n+                    // if values is null then it means it's a missing value\n+                    extractedValues[lastIndex++] = NULL_VALUE;\n                 } else {\n                     // we are here if we have a missing value but the analysis does not support those\n                     // or the value type is not supported (e.g. arrays, etc.)\n-                    extractedValues = null;\n-                    break;\n+                    return -1;\n                 }\n             }\n         }\n-        boolean isTraining = extractedValues == null ? false : trainTestSplitter.get().isTraining(extractedValues);\n+        return lastIndex;\n+    }\n+\n+    private Row createRow(SearchHit hit) {\n+        String[] extractedValues = new String[organicExtractedFeatures.size() + processedOutputFields.size()];\n+        int lastIndex = extractNonProcessedValues(hit, extractedValues);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3ODEwNQ=="}, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzIyNDA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTowNzo1MVrOG-zAVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTowNzo1MVrOG-zAVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMDU2NA==", "bodyText": "wrap {} in square brackets", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468500564", "createdAt": "2020-08-11T11:07:51Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -69,44 +77,101 @@\n     }\n \n     public Tuple<ExtractedFields, List<FieldSelection>> detect() {\n+        List<ProcessedField> processedFields = extractFeatureProcessors()\n+            .stream()\n+            .map(ProcessedField::new)\n+            .collect(Collectors.toList());\n         TreeSet<FieldSelection> fieldSelection = new TreeSet<>(Comparator.comparing(FieldSelection::getName));\n-        Set<String> fields = getIncludedFields(fieldSelection);\n+        Set<String> fields = getIncludedFields(fieldSelection,\n+            processedFields.stream()\n+                .map(ProcessedField::getInputFieldNames)\n+                .flatMap(List::stream)\n+                .collect(Collectors.toSet()));\n         checkFieldsHaveCompatibleTypes(fields);\n         checkRequiredFields(fields);\n         checkFieldsWithCardinalityLimit();\n-        ExtractedFields extractedFields = detectExtractedFields(fields, fieldSelection);\n+        ExtractedFields extractedFields = detectExtractedFields(fields, fieldSelection, processedFields);\n         addIncludedFields(extractedFields, fieldSelection);\n \n         return Tuple.tuple(extractedFields, Collections.unmodifiableList(new ArrayList<>(fieldSelection)));\n     }\n \n-    private Set<String> getIncludedFields(Set<FieldSelection> fieldSelection) {\n+    private Set<String> getIncludedFields(Set<FieldSelection> fieldSelection, Set<String> requiredFieldsForProcessors) {\n         Set<String> fields = new TreeSet<>(fieldCapabilitiesResponse.get().keySet());\n+        validateFieldsRequireForProcessors(requiredFieldsForProcessors);\n         fields.removeAll(IGNORE_FIELDS);\n         removeFieldsUnderResultsField(fields);\n         removeObjects(fields);\n         applySourceFiltering(fields);\n+        if (fields.containsAll(requiredFieldsForProcessors) == false) {\n+            throw ExceptionsHelper.badRequestException(\n+                \"fields {} required by field_processors are not included in source filtering.\",\n+                Sets.difference(requiredFieldsForProcessors, fields));\n+        }\n         FetchSourceContext analyzedFields = config.getAnalyzedFields();\n \n         // If the user has not explicitly included fields we'll include all compatible fields\n         if (analyzedFields == null || analyzedFields.includes().length == 0) {\n             removeFieldsWithIncompatibleTypes(fields, fieldSelection);\n         }\n         includeAndExcludeFields(fields, fieldSelection);\n+        if (fields.containsAll(requiredFieldsForProcessors) == false) {\n+            throw ExceptionsHelper.badRequestException(\n+                \"fields {} required by field_processors are not included in the analyzed_fields.\",\n+                Sets.difference(requiredFieldsForProcessors, fields));\n+        }\n \n         return fields;\n     }\n \n+    private void validateFieldsRequireForProcessors(Set<String> processorFields) {\n+        Set<String> fieldsForProcessor = new HashSet<>(processorFields);\n+        removeFieldsUnderResultsField(fieldsForProcessor);\n+        if (fieldsForProcessor.size() < processorFields.size()) {\n+            throw ExceptionsHelper.badRequestException(\"fields contained in results field {} cannot be used in a feature_processor\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzIzNzg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMToxMjoyNlrOG-zIcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMToxMjoyNlrOG-zIcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMjY0Mw==", "bodyText": "add a ; after \"analysis\"?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468502643", "createdAt": "2020-08-11T11:12:26Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -304,26 +383,52 @@ private ExtractedFields detectExtractedFields(Set<String> fields, Set<FieldSelec\n         return extractedFields;\n     }\n \n-    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields, boolean preferSource,\n+    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields,\n+                                                   boolean preferSource,\n                                                    Set<FieldSelection> fieldSelection) {\n-        Set<String> requiredFields = config.getAnalysis().getRequiredFields().stream().map(RequiredField::getName)\n+        Set<String> requiredFields = config.getAnalysis()\n+            .getRequiredFields()\n+            .stream()\n+            .map(RequiredField::getName)\n             .collect(Collectors.toSet());\n+        Set<String> processorInputFields = extractedFields.getProcessedFieldInputs();\n         Map<String, ExtractedField> nameOrParentToField = new LinkedHashMap<>();\n         for (ExtractedField currentField : extractedFields.getAllFields()) {\n             String nameOrParent = currentField.isMultiField() ? currentField.getParentField() : currentField.getName();\n             ExtractedField existingField = nameOrParentToField.putIfAbsent(nameOrParent, currentField);\n             if (existingField != null) {\n                 ExtractedField parent = currentField.isMultiField() ? existingField : currentField;\n                 ExtractedField multiField = currentField.isMultiField() ? currentField : existingField;\n+                // If required fields contains parent or multifield and the processor input fields reference the other, that is an error\n+                // we should not allow processing of data that is required.\n+                if ((requiredFields.contains(parent.getName()) && processorInputFields.contains(multiField.getName()))\n+                    || (requiredFields.contains(multiField.getName()) && processorInputFields.contains(parent.getName()))) {\n+                    throw ExceptionsHelper.badRequestException(\n+                        \"feature_processors cannot be applied to required fields for analysis multi-field [{}] parent [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzI0MTgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMToxMzo1MlrOG-zK3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoyMToyNVrOG-1SiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMzI2Mw==", "bodyText": "Doesn't that lead to complexity? Could we error here and request that a field is always referred to in the same way?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468503263", "createdAt": "2020-08-11T11:13:52Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -304,26 +383,52 @@ private ExtractedFields detectExtractedFields(Set<String> fields, Set<FieldSelec\n         return extractedFields;\n     }\n \n-    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields, boolean preferSource,\n+    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields,\n+                                                   boolean preferSource,\n                                                    Set<FieldSelection> fieldSelection) {\n-        Set<String> requiredFields = config.getAnalysis().getRequiredFields().stream().map(RequiredField::getName)\n+        Set<String> requiredFields = config.getAnalysis()\n+            .getRequiredFields()\n+            .stream()\n+            .map(RequiredField::getName)\n             .collect(Collectors.toSet());\n+        Set<String> processorInputFields = extractedFields.getProcessedFieldInputs();\n         Map<String, ExtractedField> nameOrParentToField = new LinkedHashMap<>();\n         for (ExtractedField currentField : extractedFields.getAllFields()) {\n             String nameOrParent = currentField.isMultiField() ? currentField.getParentField() : currentField.getName();\n             ExtractedField existingField = nameOrParentToField.putIfAbsent(nameOrParent, currentField);\n             if (existingField != null) {\n                 ExtractedField parent = currentField.isMultiField() ? existingField : currentField;\n                 ExtractedField multiField = currentField.isMultiField() ? currentField : existingField;\n+                // If required fields contains parent or multifield and the processor input fields reference the other, that is an error\n+                // we should not allow processing of data that is required.\n+                if ((requiredFields.contains(parent.getName()) && processorInputFields.contains(multiField.getName()))\n+                    || (requiredFields.contains(multiField.getName()) && processorInputFields.contains(parent.getName()))) {\n+                    throw ExceptionsHelper.badRequestException(\n+                        \"feature_processors cannot be applied to required fields for analysis multi-field [{}] parent [{}]\",\n+                        multiField.getName(),\n+                        parent.getName());\n+                }\n+                // If processor input fields have BOTH, we need to keep both.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzk5Mg==", "bodyText": "For sure, we can error here. It would be weird that the same user chooses separate multi-fields for different processed fields.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468537992", "createdAt": "2020-08-11T12:21:25Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -304,26 +383,52 @@ private ExtractedFields detectExtractedFields(Set<String> fields, Set<FieldSelec\n         return extractedFields;\n     }\n \n-    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields, boolean preferSource,\n+    private ExtractedFields deduplicateMultiFields(ExtractedFields extractedFields,\n+                                                   boolean preferSource,\n                                                    Set<FieldSelection> fieldSelection) {\n-        Set<String> requiredFields = config.getAnalysis().getRequiredFields().stream().map(RequiredField::getName)\n+        Set<String> requiredFields = config.getAnalysis()\n+            .getRequiredFields()\n+            .stream()\n+            .map(RequiredField::getName)\n             .collect(Collectors.toSet());\n+        Set<String> processorInputFields = extractedFields.getProcessedFieldInputs();\n         Map<String, ExtractedField> nameOrParentToField = new LinkedHashMap<>();\n         for (ExtractedField currentField : extractedFields.getAllFields()) {\n             String nameOrParent = currentField.isMultiField() ? currentField.getParentField() : currentField.getName();\n             ExtractedField existingField = nameOrParentToField.putIfAbsent(nameOrParent, currentField);\n             if (existingField != null) {\n                 ExtractedField parent = currentField.isMultiField() ? existingField : currentField;\n                 ExtractedField multiField = currentField.isMultiField() ? currentField : existingField;\n+                // If required fields contains parent or multifield and the processor input fields reference the other, that is an error\n+                // we should not allow processing of data that is required.\n+                if ((requiredFields.contains(parent.getName()) && processorInputFields.contains(multiField.getName()))\n+                    || (requiredFields.contains(multiField.getName()) && processorInputFields.contains(parent.getName()))) {\n+                    throw ExceptionsHelper.badRequestException(\n+                        \"feature_processors cannot be applied to required fields for analysis multi-field [{}] parent [{}]\",\n+                        multiField.getName(),\n+                        parent.getName());\n+                }\n+                // If processor input fields have BOTH, we need to keep both.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUwMzI2Mw=="}, "originalCommit": {"oid": "517cd851a23b416483de6a45c811c42d413ff6f2"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDM3MDY1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDowMTowNVrOG_Q-WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNDowMTowNVrOG_Q-WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5MTU3Nw==", "bodyText": "nit: space after if", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r468991577", "createdAt": "2020-08-12T04:01:05Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetector.java", "diffHunk": "@@ -525,6 +527,37 @@ private void addIncludedFields(ExtractedFields extractedFields, Set<FieldSelecti\n         }\n     }\n \n+    static void checkOutputFeatureUniqueness(List<ProcessedField> processedFields, Set<String> selectedFields) {\n+        Set<String> processInputs = processedFields.stream()\n+            .map(ProcessedField::getInputFieldNames)\n+            .flatMap(List::stream)\n+            .collect(Collectors.toSet());\n+        // All analysis fields that we include that are NOT processed\n+        // This indicates that they are sent as is\n+        Set<String> organicFields = Sets.difference(selectedFields, processInputs);\n+\n+        Set<String> processedFeatures = new HashSet<>();\n+        Set<String> duplicatedFields = new HashSet<>();\n+        for (ProcessedField processedField : processedFields) {\n+            for (String output : processedField.getOutputFieldNames()) {\n+                if(processedFeatures.add(output) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d419dfc817beff45cfd1a819aaa92294f366b97e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjA5MDg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ProcessedField.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToxNToyM1rOHAHB9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzo0Njo0MlrOHAW0_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg3NzIzNw==", "bodyText": "Does this work correctly? If we filter out null objects, won't we mess the correspondence of the values to the output fields?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r469877237", "createdAt": "2020-08-13T11:15:23Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ProcessedField.java", "diffHunk": "@@ -52,7 +52,7 @@ public ProcessedField(PreProcessor processor) {\n             }\n         }\n         preProcessor.process(inputs);\n-        return preProcessor.outputFields().stream().map(inputs::get).toArray();\n+        return preProcessor.outputFields().stream().map(inputs::get).filter(Objects::nonNull).toArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c6999837269394643d13bdd683c4772de1ee75"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzNjA2MA==", "bodyText": "Let me think on this more.\nWe don't want to return partial lists, for sure. But we also don't want to put empty/missing unless the caller supports missing values...", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r470136060", "createdAt": "2020-08-13T17:46:42Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/extractor/ProcessedField.java", "diffHunk": "@@ -52,7 +52,7 @@ public ProcessedField(PreProcessor processor) {\n             }\n         }\n         preProcessor.process(inputs);\n-        return preProcessor.outputFields().stream().map(inputs::get).toArray();\n+        return preProcessor.outputFields().stream().map(inputs::get).filter(Objects::nonNull).toArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg3NzIzNw=="}, "originalCommit": {"oid": "21c6999837269394643d13bdd683c4772de1ee75"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjA5ODY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractorTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToxODowN1rOHAHGvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToxODowN1rOHAHGvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg3ODQ2Mg==", "bodyText": "rename to testGetFieldNames_GivenProcessesFeatures ?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r469878462", "createdAt": "2020-08-13T11:18:07Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractorTests.java", "diffHunk": "@@ -472,12 +479,100 @@ public void testGetCategoricalFields() {\n             containsInAnyOrder(\"field_keyword\", \"field_text\", \"field_boolean\"));\n     }\n \n+    public void testWithProcessedFeatures_FieldInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c6999837269394643d13bdd683c4772de1ee75"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjEwMTAwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractorTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToxODo1MVrOHAHIHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToxODo1MVrOHAHIHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg3ODgxNA==", "bodyText": "shall we make this private?", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r469878814", "createdAt": "2020-08-13T11:18:51Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/DataFrameDataExtractorTests.java", "diffHunk": "@@ -551,4 +646,70 @@ protected SearchResponse executeSearchScrollRequest(String scrollId) {\n             return searchResponse;\n         }\n     }\n+\n+    static class CategoricalPreProcessor implements PreProcessor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c6999837269394643d13bdd683c4772de1ee75"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjEwOTU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetectorTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMToyMTo0MlrOHAHNTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzo0ODo1MFrOHAW6GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4MDE0MQ==", "bodyText": "I think there is a lot of value on keeping the unit tests targeting a very specific piece of functionality when possible. The reason for that is that when a test fails, it is really helpful it if makes it clear what the problem was. I would suggest splitting this test into individual tests with names that indicate the validation that is tested. It also makes the tests serve as live documentation.\nI realise this is a subjective preference. If you are not convinced by the argument, you can of course leave it as is :-)", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r469880141", "createdAt": "2020-08-13T11:21:42Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetectorTests.java", "diffHunk": "@@ -943,6 +949,196 @@ public void testDetect_GivenAnalyzedFieldExcludesObjectField() {\n         assertThat(e.getMessage(), equalTo(\"analyzed_fields must not include or exclude object fields: [object_field]\"));\n     }\n \n+    public void testDetect_givenFeatureProcessorsFailures() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21c6999837269394643d13bdd683c4772de1ee75"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzNzM2OA==", "bodyText": "\ud83d\ude2d\nThis PR is going to end up being near 2k lines.", "url": "https://github.com/elastic/elasticsearch/pull/60528#discussion_r470137368", "createdAt": "2020-08-13T17:48:50Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/extractor/ExtractedFieldsDetectorTests.java", "diffHunk": "@@ -943,6 +949,196 @@ public void testDetect_GivenAnalyzedFieldExcludesObjectField() {\n         assertThat(e.getMessage(), equalTo(\"analyzed_fields must not include or exclude object fields: [object_field]\"));\n     }\n \n+    public void testDetect_givenFeatureProcessorsFailures() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4MDE0MQ=="}, "originalCommit": {"oid": "21c6999837269394643d13bdd683c4772de1ee75"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2686, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}