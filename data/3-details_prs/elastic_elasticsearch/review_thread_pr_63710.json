{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzIzNzc3", "number": 63710, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNjowNTo1NFrOEzJPug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo0OTozMVrOE1NbEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMDY0MzE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNjowNTo1NFrOHqMSCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNDozMDo1OFrOHqenZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwMzQ2NQ==", "bodyText": "Please revert. The PRs should contain the minimal number of changes needed and not affect the rest of the code", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514003465", "createdAt": "2020-10-29T06:05:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -956,8 +956,7 @@ private boolean hasUnresolvedAliases(List<? extends NamedExpression> expressions\n \n         private List<NamedExpression> assignAliases(List<? extends NamedExpression> exprs) {\n             List<NamedExpression> newExpr = new ArrayList<>(exprs.size());\n-            for (int i = 0; i < exprs.size(); i++) {\n-                NamedExpression expr = exprs.get(i);\n+            for (NamedExpression expr : exprs) {\n                 NamedExpression transformed = (NamedExpression) expr.transformUp(ua -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMwMzg0NQ==", "bodyText": "Thanks, leftover from prev commits.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514303845", "createdAt": "2020-10-29T14:30:58Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -956,8 +956,7 @@ private boolean hasUnresolvedAliases(List<? extends NamedExpression> expressions\n \n         private List<NamedExpression> assignAliases(List<? extends NamedExpression> exprs) {\n             List<NamedExpression> newExpr = new ArrayList<>(exprs.size());\n-            for (int i = 0; i < exprs.size(); i++) {\n-                NamedExpression expr = exprs.get(i);\n+            for (NamedExpression expr : exprs) {\n                 NamedExpression transformed = (NamedExpression) expr.transformUp(ua -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwMzQ2NQ=="}, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMDY2MjM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNjoxMTo0NFrOHqMeug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDoyNDowNlrOHqVVDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwNjcxNA==", "bodyText": "Incorrect style (use == false instead of !).\nI'm not sure what this check tries to prevent...", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514006714", "createdAt": "2020-10-29T06:11:44Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java", "diffHunk": "@@ -767,6 +777,16 @@ private SqlTypedParamValue param(TerminalNode node) {\n         return params.get(token);\n     }\n \n+    private SqlParser.SqlParameter param(ParserRuleContext ctx) {\n+        if (!ctx.getStart().equals(ctx.getStop())) {\n+            throw new ParsingException(source(ctx), \"Single PARAM literal expected\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MTY5NQ==", "bodyText": "style: any reason why this is not part of checkStyle and the precommit checks?\nI will remove this check, it was more like a sanity check (during unit & integ test) for me to see if there are any possibility where the start and stop token won't be the same. This should never happen.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514151695", "createdAt": "2020-10-29T10:24:06Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java", "diffHunk": "@@ -767,6 +777,16 @@ private SqlTypedParamValue param(TerminalNode node) {\n         return params.get(token);\n     }\n \n+    private SqlParser.SqlParameter param(ParserRuleContext ctx) {\n+        if (!ctx.getStart().equals(ctx.getStop())) {\n+            throw new ParsingException(source(ctx), \"Single PARAM literal expected\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwNjcxNA=="}, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMDY2NjA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/SqlParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNjoxMjo1OFrOHqMhGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDoyNToxN1rOHqVYAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwNzMyMA==", "bodyText": "incorrect formatting paramIndex + 1", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514007320", "createdAt": "2020-10-29T06:12:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/SqlParser.java", "diffHunk": "@@ -240,26 +261,28 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int\n     private static class ParametrizedTokenSource implements TokenSource {\n \n         private TokenSource delegate;\n-        private Map<Token, SqlTypedParamValue> paramTokens;\n-        private int param;\n+        private Map<Token, SqlParameter> paramTokens;\n+        private int paramIndex;\n         private List<SqlTypedParamValue> params;\n \n-        ParametrizedTokenSource(TokenSource delegate, Map<Token, SqlTypedParamValue> paramTokens, List<SqlTypedParamValue> params) {\n+        ParametrizedTokenSource(TokenSource delegate,\n+                                Map<Token, SqlParameter> paramTokens,\n+                                List<SqlTypedParamValue> params) {\n             this.delegate = delegate;\n             this.paramTokens = paramTokens;\n             this.params = params;\n-            param = 0;\n+            paramIndex = 0;\n         }\n \n         @Override\n         public Token nextToken() {\n             Token token = delegate.nextToken();\n             if (token.getType() == SqlBaseLexer.PARAM) {\n-                if (param >= params.size()) {\n+                if (paramIndex >= params.size()) {\n                     throw new ParsingException(\"Not enough actual parameters {} \", params.size());\n                 }\n-                paramTokens.put(token, params.get(param));\n-                param++;\n+                paramTokens.put(token, new SqlParameter(paramIndex+1, params.get(paramIndex)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjQ0OA==", "bodyText": "style: will do, again would be great to add it to checkStyle", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514152448", "createdAt": "2020-10-29T10:25:17Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/SqlParser.java", "diffHunk": "@@ -240,26 +261,28 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int\n     private static class ParametrizedTokenSource implements TokenSource {\n \n         private TokenSource delegate;\n-        private Map<Token, SqlTypedParamValue> paramTokens;\n-        private int param;\n+        private Map<Token, SqlParameter> paramTokens;\n+        private int paramIndex;\n         private List<SqlTypedParamValue> params;\n \n-        ParametrizedTokenSource(TokenSource delegate, Map<Token, SqlTypedParamValue> paramTokens, List<SqlTypedParamValue> params) {\n+        ParametrizedTokenSource(TokenSource delegate,\n+                                Map<Token, SqlParameter> paramTokens,\n+                                List<SqlTypedParamValue> params) {\n             this.delegate = delegate;\n             this.paramTokens = paramTokens;\n             this.params = params;\n-            param = 0;\n+            paramIndex = 0;\n         }\n \n         @Override\n         public Token nextToken() {\n             Token token = delegate.nextToken();\n             if (token.getType() == SqlBaseLexer.PARAM) {\n-                if (param >= params.size()) {\n+                if (paramIndex >= params.size()) {\n                     throw new ParsingException(\"Not enough actual parameters {} \", params.size());\n                 }\n-                paramTokens.put(token, params.get(param));\n-                param++;\n+                paramTokens.put(token, new SqlParameter(paramIndex+1, params.get(paramIndex)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwNzMyMA=="}, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjM4NDU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/parser/ParamLiteralTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMzo1ODo0OFrOHqdHdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNDo0NjozNFrOHqfYXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3OTI4Nw==", "bodyText": "In *QL (and Elasticsearch) codebase, the general style for these assertions is either assertThat(X, instanceof(Y)) (more in ES) or assertTrue(X instanceof Y) (more in *QL). Mockito isA seems to be used in the x-pack Security plugin only. I'd suggest going with a *QL-wide consistent approach and use the assertTrue variant, if it's not too much trouble.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514279287", "createdAt": "2020-10-29T13:58:48Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/parser/ParamLiteralTests.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Alias;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.NamedExpression;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.plan.logical.Filter;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.plan.logical.Project;\n+import org.elasticsearch.xpack.sql.proto.SqlTypedParamValue;\n+\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.everyItem;\n+import static org.hamcrest.Matchers.isA;\n+import static org.hamcrest.Matchers.startsWith;\n+\n+public class ParamLiteralTests extends ESTestCase {\n+\n+    private final SqlParser parser = new SqlParser();\n+\n+    private LogicalPlan parse(String sql, SqlTypedParamValue... parameters) {\n+        return parser.createStatement(sql, List.of(parameters), UTC);\n+    }\n+\n+    public void testMultipleParamLiteralsWithUnresolvedAliases() {\n+        LogicalPlan logicalPlan = parse(\"SELECT ?, ? FROM test\",\n+            new SqlTypedParamValue(\"integer\", 100),\n+            new SqlTypedParamValue(\"integer\", 200)\n+        );\n+        List<? extends NamedExpression> projections = ((Project) logicalPlan.children().get(0)).projections();\n+        assertThat(projections, everyItem(isA(Alias.class)));\n+        assertThat(projections.get(0).toString(), startsWith(\"100 AS ?1#\"));\n+        assertThat(projections.get(1).toString(), startsWith(\"200 AS ?2#\"));\n+    }\n+\n+    public void testMultipleParamLiteralsWithUnresolvedAliasesAndWhereClause() {\n+        LogicalPlan logicalPlan = parse(\"SELECT ?, ? FROM test WHERE 1 < ?\",\n+            new SqlTypedParamValue(\"integer\", 100),\n+            new SqlTypedParamValue(\"integer\", 200),\n+            new SqlTypedParamValue(\"integer\", 300)\n+        );\n+        Project project = (Project) logicalPlan.children().get(0);\n+        List<? extends NamedExpression> projections = project.projections();\n+        assertThat(projections, everyItem(isA(Alias.class)));\n+        assertThat(projections.get(0).toString(), startsWith(\"100 AS ?1#\"));\n+        assertThat(projections.get(1).toString(), startsWith(\"200 AS ?2#\"));\n+        assertThat(project.children().get(0), isA(Filter.class));\n+        Filter filter = (Filter) project.children().get(0);\n+        assertThat(filter.condition(), isA(LessThan.class));\n+        LessThan condition = (LessThan) filter.condition();\n+        assertThat(condition.left(), isA(Literal.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMxNjM4MQ==", "bodyText": "or assertEquals(Literal.class, condition.left().getClass()", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r514316381", "createdAt": "2020-10-29T14:46:34Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/parser/ParamLiteralTests.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Alias;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.NamedExpression;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.plan.logical.Filter;\n+import org.elasticsearch.xpack.ql.plan.logical.LogicalPlan;\n+import org.elasticsearch.xpack.ql.plan.logical.Project;\n+import org.elasticsearch.xpack.sql.proto.SqlTypedParamValue;\n+\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.everyItem;\n+import static org.hamcrest.Matchers.isA;\n+import static org.hamcrest.Matchers.startsWith;\n+\n+public class ParamLiteralTests extends ESTestCase {\n+\n+    private final SqlParser parser = new SqlParser();\n+\n+    private LogicalPlan parse(String sql, SqlTypedParamValue... parameters) {\n+        return parser.createStatement(sql, List.of(parameters), UTC);\n+    }\n+\n+    public void testMultipleParamLiteralsWithUnresolvedAliases() {\n+        LogicalPlan logicalPlan = parse(\"SELECT ?, ? FROM test\",\n+            new SqlTypedParamValue(\"integer\", 100),\n+            new SqlTypedParamValue(\"integer\", 200)\n+        );\n+        List<? extends NamedExpression> projections = ((Project) logicalPlan.children().get(0)).projections();\n+        assertThat(projections, everyItem(isA(Alias.class)));\n+        assertThat(projections.get(0).toString(), startsWith(\"100 AS ?1#\"));\n+        assertThat(projections.get(1).toString(), startsWith(\"200 AS ?2#\"));\n+    }\n+\n+    public void testMultipleParamLiteralsWithUnresolvedAliasesAndWhereClause() {\n+        LogicalPlan logicalPlan = parse(\"SELECT ?, ? FROM test WHERE 1 < ?\",\n+            new SqlTypedParamValue(\"integer\", 100),\n+            new SqlTypedParamValue(\"integer\", 200),\n+            new SqlTypedParamValue(\"integer\", 300)\n+        );\n+        Project project = (Project) logicalPlan.children().get(0);\n+        List<? extends NamedExpression> projections = project.projections();\n+        assertThat(projections, everyItem(isA(Alias.class)));\n+        assertThat(projections.get(0).toString(), startsWith(\"100 AS ?1#\"));\n+        assertThat(projections.get(1).toString(), startsWith(\"200 AS ?2#\"));\n+        assertThat(project.children().get(0), isA(Filter.class));\n+        Filter filter = (Filter) project.children().get(0);\n+        assertThat(filter.condition(), isA(LessThan.class));\n+        LessThan condition = (LessThan) filter.condition();\n+        assertThat(condition.left(), isA(Literal.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3OTI4Nw=="}, "originalCommit": {"oid": "c205e9d2d14405b17b26f111a0e5263bd70e1fb9"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODkxMDU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozMjo1N1rOHs2-wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDowNzowMlrOHs-sMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMDE5Mg==", "bodyText": "Will merge these two lines before squash.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r516800192", "createdAt": "2020-11-03T16:32:57Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java", "diffHunk": "@@ -189,11 +189,12 @@ public Verifier(Metrics metrics) {\n             plan.forEachExpressionsUp(e -> {\n                 if (e instanceof Alias) {\n                     Alias a = (Alias) e;\n-                    collectRefs.put(a.toAttribute(), a.child());\n+                    Attribute attr = a.toAttribute();\n+                    collectRefs.put(attr, a.child());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7fead3119f0d0ea7d8c3c90f1d75930d7a739ed"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNjUxMw==", "bodyText": "You need the checks to pass before merging so you'll have to do it anyway, better do it sooner rather than later.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r516926513", "createdAt": "2020-11-03T20:07:02Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java", "diffHunk": "@@ -189,11 +189,12 @@ public Verifier(Metrics metrics) {\n             plan.forEachExpressionsUp(e -> {\n                 if (e instanceof Alias) {\n                     Alias a = (Alias) e;\n-                    collectRefs.put(a.toAttribute(), a.child());\n+                    Attribute attr = a.toAttribute();\n+                    collectRefs.put(attr, a.child());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMDE5Mg=="}, "originalCommit": {"oid": "f7fead3119f0d0ea7d8c3c90f1d75930d7a739ed"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzOTcwNTgzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/select.sql-spec", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDowNTo1MFrOHs-pOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDowNTo1MFrOHs-pOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNTc1NA==", "bodyText": "Work adding a few more variations here:\nSELECT 3, 5, 3, SELECT 5, 3, 3, 3 with and without FROM.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r516925754", "createdAt": "2020-11-03T20:05:50Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/select.sql-spec", "diffHunk": "@@ -48,6 +48,8 @@ SELECT salary, first_name, salary AS x, salary y FROM test_emp ORDER BY y LIMIT\n \n constantWithLimit\n SELECT 3 FROM \"test_emp\" LIMIT 5;\n+sameConstantsWithLimit\n+SELECT 3, 3, 5 FROM \"test_emp\" LIMIT 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7fead3119f0d0ea7d8c3c90f1d75930d7a739ed"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MDIyOTIyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/expression/AttributeMapTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzowMTo0MlrOHtDiiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzowMTo0MlrOHtDiiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAwNTk2MQ==", "bodyText": "Maybe also check the returned values with get() from the map, can be done in the next PR though.", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r517005961", "createdAt": "2020-11-03T23:01:42Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/expression/AttributeMapTests.java", "diffHunk": "@@ -37,6 +38,47 @@ private static Attribute a(String name) {\n         return new AttributeMap<>(map);\n     }\n \n+    public void testAttributeMapWithSameAliasesCanResolveAttributes() {\n+        Alias param1 = createIntParameterAlias(1, 100);\n+        Alias param2 = createIntParameterAlias(2, 100);\n+        assertTrue(param1.equals(param2));\n+        assertTrue(param1.semanticEquals(param2));\n+        // equality on literals\n+        assertTrue(param1.child().equals(param2.child()));\n+        assertTrue(param1.child().semanticEquals(param2.child()));\n+        assertTrue(param1.toAttribute().equals(param2.toAttribute()));\n+        assertFalse(param1.toAttribute().semanticEquals(param2.toAttribute()));\n+\n+        Map<Attribute, Expression> collectRefs = new LinkedHashMap<>();\n+        for (Alias a : List.of(param1, param2)) {\n+            collectRefs.put(a.toAttribute(), a.child());\n+        }\n+        // we can look up the same item by both attributes\n+        assertNotNull(collectRefs.get(param1.toAttribute()));\n+        assertNotNull(collectRefs.get(param2.toAttribute()));\n+        AttributeMap<Expression> attributeMap = new AttributeMap<>(collectRefs);\n+\n+        // validate that all Alias can be e\n+        assertTrue(attributeMap.containsKey(param1.toAttribute()));\n+        assertFalse(attributeMap.containsKey(param2.toAttribute())); // results in unknown attribute exception\n+\n+        AttributeMap.Builder<Expression> mapBuilder = AttributeMap.builder();\n+        for (Alias a : List.of(param1, param2)) {\n+            mapBuilder.put(a.toAttribute(), a.child());\n+        }\n+        AttributeMap<Expression> newAttributeMap = mapBuilder.build();\n+\n+        assertTrue(newAttributeMap.containsKey(param1.toAttribute()));\n+        assertTrue(newAttributeMap.containsKey(param2.toAttribute())); // no more unknown attribute exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bee8a7dd25ed44fbf719471786fa4238fda66b14"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjI5OTA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/expression/AttributeMapTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo0OTozMVrOHtWq7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo0OTozMVrOHtWq7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTQwNQ==", "bodyText": "nit: \"~ wrapper collided\" or some other comment correction (can be the next PR, obv.)", "url": "https://github.com/elastic/elasticsearch/pull/63710#discussion_r517319405", "createdAt": "2020-11-04T12:49:31Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/expression/AttributeMapTests.java", "diffHunk": "@@ -37,6 +38,47 @@ private static Attribute a(String name) {\n         return new AttributeMap<>(map);\n     }\n \n+    public void testAttributeMapWithSameAliasesCanResolveAttributes() {\n+        Alias param1 = createIntParameterAlias(1, 100);\n+        Alias param2 = createIntParameterAlias(2, 100);\n+        assertTrue(param1.equals(param2));\n+        assertTrue(param1.semanticEquals(param2));\n+        // equality on literals\n+        assertTrue(param1.child().equals(param2.child()));\n+        assertTrue(param1.child().semanticEquals(param2.child()));\n+        assertTrue(param1.toAttribute().equals(param2.toAttribute()));\n+        assertFalse(param1.toAttribute().semanticEquals(param2.toAttribute()));\n+\n+        Map<Attribute, Expression> collectRefs = new LinkedHashMap<>();\n+        for (Alias a : List.of(param1, param2)) {\n+            collectRefs.put(a.toAttribute(), a.child());\n+        }\n+        // we can look up the same item by both attributes\n+        assertNotNull(collectRefs.get(param1.toAttribute()));\n+        assertNotNull(collectRefs.get(param2.toAttribute()));\n+        AttributeMap<Expression> attributeMap = new AttributeMap<>(collectRefs);\n+\n+        // validate that all Alias can be e", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bee8a7dd25ed44fbf719471786fa4238fda66b14"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2880, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}