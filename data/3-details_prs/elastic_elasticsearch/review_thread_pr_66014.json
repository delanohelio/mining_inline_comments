{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0Mzk2NzY4", "number": 66014, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzozMDo1OFrOFCVhSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzozMDo1OFrOFCVhSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTk0MDU3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/MappingsMergerTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzozMDo1OFrOIBbi9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzozMDo1OFrOIBbi9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM3MDgwNA==", "bodyText": "If you flipped the order of these assertions you'd get better diagnostics if the test ever failed.  As it stands you'll just get something like expected:3 but was: 4, which isn't enough to fix it.\nThere are several other places in the changes where the same thing applies.", "url": "https://github.com/elastic/elasticsearch/pull/66014#discussion_r538370804", "createdAt": "2020-12-08T13:30:58Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/MappingsMergerTests.java", "diffHunk": "@@ -99,8 +100,145 @@ public void testMergeMappings_GivenIndicesWithDifferentMappingsButNoConflicts()\n         assertThat(fieldMappings.get(\"field_3\"), equalTo(\"field_3_mappings\"));\n     }\n \n+    public void testMergeMappings_GivenIndicesWithIdenticalRuntimeFields() {\n+        Map<String, Object> index1Mappings = Map.of(\"runtime\", Map.of(\"field_1\", \"field_1_mappings\", \"field_2\", \"field_2_mappings\"));\n+        MappingMetadata index1MappingMetadata = new MappingMetadata(\"_doc\", index1Mappings);\n+\n+        Map<String, Object> index2Mappings = Map.of(\"runtime\", Map.of(\"field_1\", \"field_1_mappings\", \"field_2\", \"field_2_mappings\"));\n+        MappingMetadata index2MappingMetadata = new MappingMetadata(\"_doc\", index2Mappings);\n+\n+        ImmutableOpenMap.Builder<String, MappingMetadata> mappings = ImmutableOpenMap.builder();\n+        mappings.put(\"index_1\", index1MappingMetadata);\n+        mappings.put(\"index_2\", index2MappingMetadata);\n+\n+        GetMappingsResponse getMappingsResponse = new GetMappingsResponse(mappings.build());\n+\n+        MappingMetadata mergedMappings = MappingsMerger.mergeMappings(newSource(), getMappingsResponse);\n+\n+        Map<String, Object> expectedMappings = new HashMap<>();\n+        expectedMappings.put(\"dynamic\", false);\n+        expectedMappings.put(\"runtime\", index1Mappings.get(\"runtime\"));\n+        assertThat(mergedMappings.getSourceAsMap(), equalTo(expectedMappings));\n+    }\n+\n+    public void testMergeMappings_GivenRuntimeFieldWithDifferentMapping() {\n+        Map<String, Object> index1Mappings = Map.of(\"runtime\", Map.of(\"field_1\", \"field_1_mappings\"));\n+        MappingMetadata index1MappingMetadata = new MappingMetadata(\"_doc\", index1Mappings);\n+\n+        Map<String, Object> index2Mappings = Map.of(\"runtime\", Map.of(\"field_1\", \"different_field_1_mappings\"));\n+        MappingMetadata index2MappingMetadata = new MappingMetadata(\"_doc\", index2Mappings);\n+\n+        ImmutableOpenMap.Builder<String, MappingMetadata> mappings = ImmutableOpenMap.builder();\n+        mappings.put(\"index_1\", index1MappingMetadata);\n+        mappings.put(\"index_2\", index2MappingMetadata);\n+\n+        GetMappingsResponse getMappingsResponse = new GetMappingsResponse(mappings.build());\n+\n+        ElasticsearchStatusException e = expectThrows(ElasticsearchStatusException.class,\n+            () -> MappingsMerger.mergeMappings(newSource(), getMappingsResponse));\n+        assertThat(e.status(), equalTo(RestStatus.BAD_REQUEST));\n+        assertThat(e.getMessage(),\n+            containsString(\"cannot merge [runtime] mappings because of differences for field [field_1]; \"));\n+        assertThat(e.getMessage(), containsString(\"mapped as [different_field_1_mappings] in index [index_2]\"));\n+        assertThat(e.getMessage(), containsString(\"mapped as [field_1_mappings] in index [index_1]\"));\n+    }\n+\n+    public void testMergeMappings_GivenIndicesWithDifferentRuntimeFieldsButNoConflicts() {\n+        Map<String, Object> index1Mappings = Map.of(\"runtime\",\n+            Map.of(\"field_1\", \"field_1_mappings\", \"field_2\", \"field_2_mappings\"));\n+        MappingMetadata index1MappingMetadata = new MappingMetadata(\"_doc\", index1Mappings);\n+\n+        Map<String, Object> index2Mappings = Map.of(\"runtime\",\n+            Map.of(\"field_1\", \"field_1_mappings\", \"field_3\", \"field_3_mappings\"));\n+        MappingMetadata index2MappingMetadata = new MappingMetadata(\"_doc\", index2Mappings);\n+\n+        ImmutableOpenMap.Builder<String, MappingMetadata> mappings = ImmutableOpenMap.builder();\n+        mappings.put(\"index_1\", index1MappingMetadata);\n+        mappings.put(\"index_2\", index2MappingMetadata);\n+\n+        GetMappingsResponse getMappingsResponse = new GetMappingsResponse(mappings.build());\n+\n+        MappingMetadata mergedMappings = MappingsMerger.mergeMappings(newSource(), getMappingsResponse);\n+\n+        Map<String, Object> mappingsAsMap = mergedMappings.getSourceAsMap();\n+        assertThat(mappingsAsMap.size(), equalTo(2));\n+        assertThat(mappingsAsMap.containsKey(\"dynamic\"), is(true));\n+        assertThat(mappingsAsMap.containsKey(\"runtime\"), is(true));\n+\n+        assertThat(mappingsAsMap.get(\"dynamic\"), is(false));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> fieldMappings = (Map<String, Object>) mappingsAsMap.get(\"runtime\");\n+\n+        assertThat(fieldMappings.size(), equalTo(3));\n+        assertThat(fieldMappings.keySet(), containsInAnyOrder(\"field_1\", \"field_2\", \"field_3\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee2cb8b8b3a0c71d62e8251e758391300c39ea5b"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4752, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}