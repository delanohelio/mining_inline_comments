{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyNTk0NzM0", "number": 63634, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODoyMDowNVrOEtKxvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxOToyOTo1NlrOEtMQRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Nzk3OTQ4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODoyMDowNVrOHgz2_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTo1OToyNVrOHhLhgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2NjE0MQ==", "bodyText": "Maybe instead of adding a helper (it's also strange that it's called \"NoAlias\" since the default should always be no alias), we should change the other createIndexWithSettings to make the alias @Nullable?", "url": "https://github.com/elastic/elasticsearch/pull/63634#discussion_r504166141", "createdAt": "2020-10-13T18:20:05Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java", "diffHunk": "@@ -228,6 +242,15 @@ public static void createIndexWithSettings(RestClient client, String index, Stri\n         ensureGreen(index);\n     }\n \n+    public static void createIndexWithSettingsNoAlias(RestClient client, String index, Settings.Builder settings) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24cbd490c11d5618269eb6466f1aa5a44b8e7409"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1Mzg1Ng==", "bodyText": "I've renamed the method createIndexWithSettings (c399088) with signature:\n    public static void createIndexWithSettings(RestClient client, String index, Settings.Builder settings) throws IOException {\n\nI think piggybacking this use case on the helper that has the alias and useWriteIndex parameters by making both @Nullable over complicates the logic (and we'd end up passing 2 null parameters).\nWhat do you think?", "url": "https://github.com/elastic/elasticsearch/pull/63634#discussion_r504553856", "createdAt": "2020-10-14T09:59:25Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java", "diffHunk": "@@ -228,6 +242,15 @@ public static void createIndexWithSettings(RestClient client, String index, Stri\n         ensureGreen(index);\n     }\n \n+    public static void createIndexWithSettingsNoAlias(RestClient client, String index, Settings.Builder settings) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2NjE0MQ=="}, "originalCommit": {"oid": "24cbd490c11d5618269eb6466f1aa5a44b8e7409"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Nzk4MTgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODoyMDo0NFrOHgz4YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODoyMDo0NFrOHgz4YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2NjQ5Nw==", "bodyText": "Super minor, but probably no need for a newline here :)", "url": "https://github.com/elastic/elasticsearch/pull/63634#discussion_r504166497", "createdAt": "2020-10-13T18:20:44Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java", "diffHunk": "@@ -228,6 +242,15 @@ public static void createIndexWithSettings(RestClient client, String index, Stri\n         ensureGreen(index);\n     }\n \n+    public static void createIndexWithSettingsNoAlias(RestClient client, String index, Settings.Builder settings) throws IOException {\n+        Request request = new Request(\"PUT\", \"/\" + index);\n+        request.setJsonEntity(\"{\\n \\\"settings\\\": \" + Strings.toString(settings.build())\n+            + \"}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24cbd490c11d5618269eb6466f1aa5a44b8e7409"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1ODIyMTQ5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxOToyOTo1NlrOHg2MDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTo1MjoyNVrOHhLQYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIwNDMwMA==", "bodyText": "I think we could probably put this one is a second assertBusy so that we don't end up doing two explains when we only need to do one", "url": "https://github.com/elastic/elasticsearch/pull/63634#discussion_r504204300", "createdAt": "2020-10-13T19:29:56Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.core.ilm.DeleteAction;\n+import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.Phase;\n+import org.elasticsearch.xpack.core.ilm.RolloverAction;\n+import org.elasticsearch.xpack.core.ilm.ShrinkAction;\n+import org.junit.Before;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createFullPolicy;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettings;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettingsNoAlias;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.explain;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.explainIndex;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.hasKey;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExplainLifecycleIT extends ESRestTestCase {\n+    private static final Logger logger = LogManager.getLogger(ExplainLifecycleIT.class);\n+    private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n+    private static final String IS_AUTO_RETRYABLE_ERROR_FIELD = \"is_auto_retryable_error\";\n+\n+    private String policy;\n+    private String index;\n+    private String alias;\n+\n+    @Before\n+    public void refreshIndex() {\n+        index = \"index-\" + randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        policy = \"policy-\" + randomAlphaOfLength(5);\n+        alias = \"alias-\" + randomAlphaOfLength(5);\n+    }\n+\n+    public void testExplainFilters() throws Exception {\n+        String goodIndex = index + \"-good-000001\";\n+        String errorIndex = index + \"-error\";\n+        String nonexistantPolicyIndex = index + \"-nonexistant-policy\";\n+        String unmanagedIndex = index + \"-unmanaged\";\n+\n+        createFullPolicy(client(), policy, TimeValue.ZERO);\n+\n+        {\n+            // Create a \"shrink-only-policy\"\n+            Map<String, LifecycleAction> warmActions = new HashMap<>();\n+            warmActions.put(ShrinkAction.NAME, new ShrinkAction(17));\n+            Map<String, Phase> phases = new HashMap<>();\n+            phases.put(\"warm\", new Phase(\"warm\", TimeValue.ZERO, warmActions));\n+            LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(\"shrink-only-policy\", phases);\n+            // PUT policy\n+            XContentBuilder builder = jsonBuilder();\n+            lifecyclePolicy.toXContent(builder, null);\n+            final StringEntity entity = new StringEntity(\n+                \"{ \\\"policy\\\":\" + Strings.toString(builder) + \"}\", ContentType.APPLICATION_JSON);\n+            Request request = new Request(\"PUT\", \"_ilm/policy/shrink-only-policy\");\n+            request.setEntity(entity);\n+            assertOK(client().performRequest(request));\n+        }\n+\n+        createIndexWithSettings(client(), goodIndex, alias, Settings.builder()\n+            .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n+        );\n+        createIndexWithSettingsNoAlias(client(), errorIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, \"shrink-only-policy\")\n+        );\n+        createIndexWithSettingsNoAlias(client(), nonexistantPolicyIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, randomValueOtherThan(policy, () -> randomAlphaOfLengthBetween(3, 10))));\n+        createIndexWithSettingsNoAlias(client(), unmanagedIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0));\n+\n+        assertBusy(() -> {\n+            Map<String, Map<String, Object>> explainResponse = explain(client(), index + \"*\", false, false);\n+            assertNotNull(explainResponse);\n+            assertThat(explainResponse,\n+                allOf(hasKey(goodIndex), hasKey(errorIndex), hasKey(nonexistantPolicyIndex), hasKey(unmanagedIndex)));\n+\n+            Map<String, Map<String, Object>> onlyManagedResponse = explain(client(), index + \"*\", false, true);\n+            assertNotNull(onlyManagedResponse);\n+            assertThat(onlyManagedResponse, allOf(hasKey(goodIndex), hasKey(errorIndex), hasKey(nonexistantPolicyIndex)));\n+            assertThat(onlyManagedResponse, not(hasKey(unmanagedIndex)));\n+\n+            Map<String, Map<String, Object>> onlyErrorsResponse = explain(client(), index + \"*\", true, true);\n+            assertNotNull(onlyErrorsResponse);\n+            assertThat(onlyErrorsResponse, allOf(hasKey(errorIndex), hasKey(nonexistantPolicyIndex)));\n+            assertThat(onlyErrorsResponse, allOf(not(hasKey(goodIndex)), not(hasKey(unmanagedIndex))));\n+        });\n+    }\n+\n+    public void testExplainIndexContainsAutomaticRetriesInformation() throws Exception {\n+        createFullPolicy(client(), policy, TimeValue.ZERO);\n+\n+        // create index without alias so the rollover action fails and is retried\n+        createIndexWithSettingsNoAlias(client(), index, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n+        );\n+\n+        assertBusy(() -> {\n+            Map<String, Object> explainIndex = explainIndex(client(), index);\n+            assertThat((Integer) explainIndex.get(FAILED_STEP_RETRY_COUNT_FIELD), greaterThanOrEqualTo(1));\n+            assertThat(explainIndex.get(IS_AUTO_RETRYABLE_ERROR_FIELD), is(true));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testExplainIndicesWildcard() throws Exception {\n+        createNewSingletonPolicy(client(), policy, \"delete\", new DeleteAction(), TimeValue.timeValueDays(100));\n+        String firstIndex = this.index + \"-first\";\n+        String secondIndex = this.index + \"-second\";\n+        String unmanagedIndex = this.index + \"-unmanaged\";\n+        String indexWithMissingPolicy = this.index + \"-missing_policy\";\n+        createIndexWithSettings(client(), firstIndex, alias + firstIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy));\n+        createIndexWithSettings(client(), secondIndex, alias + secondIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy));\n+        createIndexWithSettings(client(), unmanagedIndex, alias + unmanagedIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0));\n+        String missingPolicyName = \"missing_policy_\";\n+        createIndexWithSettings(client(), indexWithMissingPolicy, alias + indexWithMissingPolicy, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, missingPolicyName));\n+\n+        assertBusy(() -> {\n+            Map<String, Map<String, Object>> explain = explain(client(), this.index + \"*\", false, false);\n+            assertManagedIndex(explain.get(firstIndex));\n+            assertManagedIndex(explain.get(secondIndex));\n+            assertUnmanagedIndex(explain.get(unmanagedIndex));\n+\n+            Map<String, Object> explainIndexWithMissingPolicy = explain.get(indexWithMissingPolicy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24cbd490c11d5618269eb6466f1aa5a44b8e7409"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU0OTQ3NQ==", "bodyText": "There's only one explain API call in this assertBusy. I believe it's ok to leave it in one assertBusy call.", "url": "https://github.com/elastic/elasticsearch/pull/63634#discussion_r504549475", "createdAt": "2020-10-14T09:52:25Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.core.ilm.DeleteAction;\n+import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.Phase;\n+import org.elasticsearch.xpack.core.ilm.RolloverAction;\n+import org.elasticsearch.xpack.core.ilm.ShrinkAction;\n+import org.junit.Before;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createFullPolicy;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettings;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettingsNoAlias;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.explain;\n+import static org.elasticsearch.xpack.TimeSeriesRestDriver.explainIndex;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.hasKey;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExplainLifecycleIT extends ESRestTestCase {\n+    private static final Logger logger = LogManager.getLogger(ExplainLifecycleIT.class);\n+    private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n+    private static final String IS_AUTO_RETRYABLE_ERROR_FIELD = \"is_auto_retryable_error\";\n+\n+    private String policy;\n+    private String index;\n+    private String alias;\n+\n+    @Before\n+    public void refreshIndex() {\n+        index = \"index-\" + randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        policy = \"policy-\" + randomAlphaOfLength(5);\n+        alias = \"alias-\" + randomAlphaOfLength(5);\n+    }\n+\n+    public void testExplainFilters() throws Exception {\n+        String goodIndex = index + \"-good-000001\";\n+        String errorIndex = index + \"-error\";\n+        String nonexistantPolicyIndex = index + \"-nonexistant-policy\";\n+        String unmanagedIndex = index + \"-unmanaged\";\n+\n+        createFullPolicy(client(), policy, TimeValue.ZERO);\n+\n+        {\n+            // Create a \"shrink-only-policy\"\n+            Map<String, LifecycleAction> warmActions = new HashMap<>();\n+            warmActions.put(ShrinkAction.NAME, new ShrinkAction(17));\n+            Map<String, Phase> phases = new HashMap<>();\n+            phases.put(\"warm\", new Phase(\"warm\", TimeValue.ZERO, warmActions));\n+            LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(\"shrink-only-policy\", phases);\n+            // PUT policy\n+            XContentBuilder builder = jsonBuilder();\n+            lifecyclePolicy.toXContent(builder, null);\n+            final StringEntity entity = new StringEntity(\n+                \"{ \\\"policy\\\":\" + Strings.toString(builder) + \"}\", ContentType.APPLICATION_JSON);\n+            Request request = new Request(\"PUT\", \"_ilm/policy/shrink-only-policy\");\n+            request.setEntity(entity);\n+            assertOK(client().performRequest(request));\n+        }\n+\n+        createIndexWithSettings(client(), goodIndex, alias, Settings.builder()\n+            .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n+        );\n+        createIndexWithSettingsNoAlias(client(), errorIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, \"shrink-only-policy\")\n+        );\n+        createIndexWithSettingsNoAlias(client(), nonexistantPolicyIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, randomValueOtherThan(policy, () -> randomAlphaOfLengthBetween(3, 10))));\n+        createIndexWithSettingsNoAlias(client(), unmanagedIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0));\n+\n+        assertBusy(() -> {\n+            Map<String, Map<String, Object>> explainResponse = explain(client(), index + \"*\", false, false);\n+            assertNotNull(explainResponse);\n+            assertThat(explainResponse,\n+                allOf(hasKey(goodIndex), hasKey(errorIndex), hasKey(nonexistantPolicyIndex), hasKey(unmanagedIndex)));\n+\n+            Map<String, Map<String, Object>> onlyManagedResponse = explain(client(), index + \"*\", false, true);\n+            assertNotNull(onlyManagedResponse);\n+            assertThat(onlyManagedResponse, allOf(hasKey(goodIndex), hasKey(errorIndex), hasKey(nonexistantPolicyIndex)));\n+            assertThat(onlyManagedResponse, not(hasKey(unmanagedIndex)));\n+\n+            Map<String, Map<String, Object>> onlyErrorsResponse = explain(client(), index + \"*\", true, true);\n+            assertNotNull(onlyErrorsResponse);\n+            assertThat(onlyErrorsResponse, allOf(hasKey(errorIndex), hasKey(nonexistantPolicyIndex)));\n+            assertThat(onlyErrorsResponse, allOf(not(hasKey(goodIndex)), not(hasKey(unmanagedIndex))));\n+        });\n+    }\n+\n+    public void testExplainIndexContainsAutomaticRetriesInformation() throws Exception {\n+        createFullPolicy(client(), policy, TimeValue.ZERO);\n+\n+        // create index without alias so the rollover action fails and is retried\n+        createIndexWithSettingsNoAlias(client(), index, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n+        );\n+\n+        assertBusy(() -> {\n+            Map<String, Object> explainIndex = explainIndex(client(), index);\n+            assertThat((Integer) explainIndex.get(FAILED_STEP_RETRY_COUNT_FIELD), greaterThanOrEqualTo(1));\n+            assertThat(explainIndex.get(IS_AUTO_RETRYABLE_ERROR_FIELD), is(true));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testExplainIndicesWildcard() throws Exception {\n+        createNewSingletonPolicy(client(), policy, \"delete\", new DeleteAction(), TimeValue.timeValueDays(100));\n+        String firstIndex = this.index + \"-first\";\n+        String secondIndex = this.index + \"-second\";\n+        String unmanagedIndex = this.index + \"-unmanaged\";\n+        String indexWithMissingPolicy = this.index + \"-missing_policy\";\n+        createIndexWithSettings(client(), firstIndex, alias + firstIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy));\n+        createIndexWithSettings(client(), secondIndex, alias + secondIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, policy));\n+        createIndexWithSettings(client(), unmanagedIndex, alias + unmanagedIndex, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0));\n+        String missingPolicyName = \"missing_policy_\";\n+        createIndexWithSettings(client(), indexWithMissingPolicy, alias + indexWithMissingPolicy, Settings.builder()\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(LifecycleSettings.LIFECYCLE_NAME, missingPolicyName));\n+\n+        assertBusy(() -> {\n+            Map<String, Map<String, Object>> explain = explain(client(), this.index + \"*\", false, false);\n+            assertManagedIndex(explain.get(firstIndex));\n+            assertManagedIndex(explain.get(secondIndex));\n+            assertUnmanagedIndex(explain.get(unmanagedIndex));\n+\n+            Map<String, Object> explainIndexWithMissingPolicy = explain.get(indexWithMissingPolicy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIwNDMwMA=="}, "originalCommit": {"oid": "24cbd490c11d5618269eb6466f1aa5a44b8e7409"}, "originalPosition": 168}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2989, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}