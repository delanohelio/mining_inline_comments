{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTE2MDU1", "number": 65501, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxODowMFrOE9Rmrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTozODoxMVrOE9SJNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjg3MDIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxODowMFrOH54Hiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTozMDozNlrOH54rIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1MDMxNQ==", "bodyText": "Since ranges is a SortedSet we're iterating through them in order, so can we just remember the previous range we added?", "url": "https://github.com/elastic/elasticsearch/pull/65501#discussion_r530450315", "createdAt": "2020-11-25T15:18:00Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -37,12 +37,56 @@\n \n     private final long length;\n \n+    /**\n+     * Creates a new empty {@link SparseFileTracker}\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     */\n     public SparseFileTracker(String description, long length) {\n+        this(description, length, Collections.emptySortedSet());\n+    }\n+\n+    /**\n+     * Creates a {@link SparseFileTracker} with some ranges already present\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     * @param ranges      the set of ranges to be considered present\n+     */\n+    public SparseFileTracker(String description, long length, SortedSet<Tuple<Long, Long>> ranges) {\n         this.description = description;\n         this.length = length;\n         if (length < 0) {\n             throw new IllegalArgumentException(\"Length [\" + length + \"] must be equal to or greater than 0 for [\" + description + \"]\");\n         }\n+        if (ranges.isEmpty() == false) {\n+            synchronized (mutex) {\n+                for (Tuple<Long, Long> next : ranges) {\n+                    final Range range = new Range(next.v1(), next.v2(), null);\n+                    if (range.end <= range.start) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" cannot be empty\");\n+                    }\n+                    if (length < range.end) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" is exceeding maximum length [\" + length + ']');\n+                    }\n+\n+                    final SortedSet<Range> previousRanges = this.ranges.headSet(range);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1187ab6819ecb6dc9fdaa1e57eb90e49def7b41"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1OTQyNg==", "bodyText": "Makes sense.", "url": "https://github.com/elastic/elasticsearch/pull/65501#discussion_r530459426", "createdAt": "2020-11-25T15:30:36Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -37,12 +37,56 @@\n \n     private final long length;\n \n+    /**\n+     * Creates a new empty {@link SparseFileTracker}\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     */\n     public SparseFileTracker(String description, long length) {\n+        this(description, length, Collections.emptySortedSet());\n+    }\n+\n+    /**\n+     * Creates a {@link SparseFileTracker} with some ranges already present\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     * @param ranges      the set of ranges to be considered present\n+     */\n+    public SparseFileTracker(String description, long length, SortedSet<Tuple<Long, Long>> ranges) {\n         this.description = description;\n         this.length = length;\n         if (length < 0) {\n             throw new IllegalArgumentException(\"Length [\" + length + \"] must be equal to or greater than 0 for [\" + description + \"]\");\n         }\n+        if (ranges.isEmpty() == false) {\n+            synchronized (mutex) {\n+                for (Tuple<Long, Long> next : ranges) {\n+                    final Range range = new Range(next.v1(), next.v2(), null);\n+                    if (range.end <= range.start) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" cannot be empty\");\n+                    }\n+                    if (length < range.end) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" is exceeding maximum length [\" + length + ']');\n+                    }\n+\n+                    final SortedSet<Range> previousRanges = this.ranges.headSet(range);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1MDMxNQ=="}, "originalCommit": {"oid": "f1187ab6819ecb6dc9fdaa1e57eb90e49def7b41"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjg3NzEzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxOTozOFrOH54L7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTozMDo0NlrOH54rrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1MTQzNw==", "bodyText": "I think this is impossible, so we may as well just assert added.", "url": "https://github.com/elastic/elasticsearch/pull/65501#discussion_r530451437", "createdAt": "2020-11-25T15:19:38Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -37,12 +37,56 @@\n \n     private final long length;\n \n+    /**\n+     * Creates a new empty {@link SparseFileTracker}\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     */\n     public SparseFileTracker(String description, long length) {\n+        this(description, length, Collections.emptySortedSet());\n+    }\n+\n+    /**\n+     * Creates a {@link SparseFileTracker} with some ranges already present\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     * @param ranges      the set of ranges to be considered present\n+     */\n+    public SparseFileTracker(String description, long length, SortedSet<Tuple<Long, Long>> ranges) {\n         this.description = description;\n         this.length = length;\n         if (length < 0) {\n             throw new IllegalArgumentException(\"Length [\" + length + \"] must be equal to or greater than 0 for [\" + description + \"]\");\n         }\n+        if (ranges.isEmpty() == false) {\n+            synchronized (mutex) {\n+                for (Tuple<Long, Long> next : ranges) {\n+                    final Range range = new Range(next.v1(), next.v2(), null);\n+                    if (range.end <= range.start) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" cannot be empty\");\n+                    }\n+                    if (length < range.end) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" is exceeding maximum length [\" + length + ']');\n+                    }\n+\n+                    final SortedSet<Range> previousRanges = this.ranges.headSet(range);\n+                    if (previousRanges.isEmpty() == false) {\n+                        final Range previous = previousRanges.last();\n+                        if (range.start <= previous.end) {\n+                            throw new IllegalArgumentException(\"Range \" + range + \" is overlapping a previous range \" + previous);\n+                        }\n+                    }\n+                    final boolean added = this.ranges.add(range);\n+                    if (added == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1187ab6819ecb6dc9fdaa1e57eb90e49def7b41"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1OTU2Ng==", "bodyText": "Right", "url": "https://github.com/elastic/elasticsearch/pull/65501#discussion_r530459566", "createdAt": "2020-11-25T15:30:46Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -37,12 +37,56 @@\n \n     private final long length;\n \n+    /**\n+     * Creates a new empty {@link SparseFileTracker}\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     */\n     public SparseFileTracker(String description, long length) {\n+        this(description, length, Collections.emptySortedSet());\n+    }\n+\n+    /**\n+     * Creates a {@link SparseFileTracker} with some ranges already present\n+     *\n+     * @param description a description for the sparse file tracker\n+     * @param length      the length of the file tracked by the sparse file tracker\n+     * @param ranges      the set of ranges to be considered present\n+     */\n+    public SparseFileTracker(String description, long length, SortedSet<Tuple<Long, Long>> ranges) {\n         this.description = description;\n         this.length = length;\n         if (length < 0) {\n             throw new IllegalArgumentException(\"Length [\" + length + \"] must be equal to or greater than 0 for [\" + description + \"]\");\n         }\n+        if (ranges.isEmpty() == false) {\n+            synchronized (mutex) {\n+                for (Tuple<Long, Long> next : ranges) {\n+                    final Range range = new Range(next.v1(), next.v2(), null);\n+                    if (range.end <= range.start) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" cannot be empty\");\n+                    }\n+                    if (length < range.end) {\n+                        throw new IllegalArgumentException(\"Range \" + range + \" is exceeding maximum length [\" + length + ']');\n+                    }\n+\n+                    final SortedSet<Range> previousRanges = this.ranges.headSet(range);\n+                    if (previousRanges.isEmpty() == false) {\n+                        final Range previous = previousRanges.last();\n+                        if (range.start <= previous.end) {\n+                            throw new IllegalArgumentException(\"Range \" + range + \" is overlapping a previous range \" + previous);\n+                        }\n+                    }\n+                    final boolean added = this.ranges.add(range);\n+                    if (added == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1MTQzNw=="}, "originalCommit": {"oid": "f1187ab6819ecb6dc9fdaa1e57eb90e49def7b41"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjk1ODYyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/SparseFileTrackerTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTozODoxMVrOH54_-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MDo0NVrOH55kQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NDc2Mg==", "bodyText": "Think this is off-by-one \ud83d\ude01\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        i = end + 2L + randomLongBetween(0L, Math.max(0L, length - end)); // +2 for non contiguous ranges\n          \n          \n            \n                        i = end + 1L + randomLongBetween(0L, Math.max(0L, length - end)); // +1 for non contiguous ranges", "url": "https://github.com/elastic/elasticsearch/pull/65501#discussion_r530464762", "createdAt": "2020-11-25T15:38:11Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/SparseFileTrackerTests.java", "diffHunk": "@@ -536,4 +563,18 @@ private static boolean processGap(byte[] fileContents, SparseFileTracker.Gap gap\n             return true;\n         }\n     }\n+\n+    /**\n+     * Generates a sorted set of non-empty and non-contiguous random ranges that could fit into a file of a given maximum length.\n+     */\n+    private static SortedSet<Tuple<Long, Long>> randomRanges(long length) {\n+        final SortedSet<Tuple<Long, Long>> randomRanges = new TreeSet<>(Comparator.comparingLong(Tuple::v1));\n+        for (long i = 0L; i < length;) {\n+            long start = randomLongBetween(i, Math.max(0L, length - 1L));\n+            long end = randomLongBetween(start + 1L, length); // +1 for non empty ranges\n+            randomRanges.add(Tuple.tuple(start, end));\n+            i = end + 2L + randomLongBetween(0L, Math.max(0L, length - end)); // +2 for non contiguous ranges", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf845b7597456d3f01f1ccc3e3dce98f1339575"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDA0OQ==", "bodyText": "A tradition, I told you", "url": "https://github.com/elastic/elasticsearch/pull/65501#discussion_r530474049", "createdAt": "2020-11-25T15:50:45Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/SparseFileTrackerTests.java", "diffHunk": "@@ -536,4 +563,18 @@ private static boolean processGap(byte[] fileContents, SparseFileTracker.Gap gap\n             return true;\n         }\n     }\n+\n+    /**\n+     * Generates a sorted set of non-empty and non-contiguous random ranges that could fit into a file of a given maximum length.\n+     */\n+    private static SortedSet<Tuple<Long, Long>> randomRanges(long length) {\n+        final SortedSet<Tuple<Long, Long>> randomRanges = new TreeSet<>(Comparator.comparingLong(Tuple::v1));\n+        for (long i = 0L; i < length;) {\n+            long start = randomLongBetween(i, Math.max(0L, length - 1L));\n+            long end = randomLongBetween(start + 1L, length); // +1 for non empty ranges\n+            randomRanges.add(Tuple.tuple(start, end));\n+            i = end + 2L + randomLongBetween(0L, Math.max(0L, length - end)); // +2 for non contiguous ranges", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NDc2Mg=="}, "originalCommit": {"oid": "aaf845b7597456d3f01f1ccc3e3dce98f1339575"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1930, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}