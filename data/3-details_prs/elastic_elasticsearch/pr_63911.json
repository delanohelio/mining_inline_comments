{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2NTkyNjQ4", "number": 63911, "title": "Make Searchable Snapshot's CacheFile Lock less", "bodyText": "Replacing the mechanism for eviction and listener references via a read-write lock by\na reference counting implementation.\nThis fixes a bug that caused test failure #63586 in which concurrently trying to acquire or release\nan eviction listener while doing a file operation would sometimes lead to throwing an exception\nsince the tryLock call on the read lock would fail in this case.\nAlso this removes the possibility of blocking cluster state updates as a result of them waiting\non the write-lock which might take a long time if a slow read operation executes concurrently.\nCloses #63586\nNOTE: I ran almost 10k iterations of all searchable snapshot integ tests over this one without failure, this change also visibly speeds up tests.", "createdAt": "2020-10-20T08:34:29Z", "url": "https://github.com/elastic/elasticsearch/pull/63911", "merged": true, "mergeCommit": {"oid": "e2e01ed317693f6defa78e103ea47d4eab4414d9"}, "closed": true, "closedAt": "2020-10-23T09:23:15Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUUjPjgH2gAyNTA2NTkyNjQ4OmYwMTI3ZmViMTlhMzhjNGE5ZTllN2VjYzA5YzNhNDRkZDU4Y2QxOTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVSVTIAH2gAyNTA2NTkyNjQ4OmE5ZTU4MDA4YzJmOTdlNjdmY2Q1ODExYmY3ZTQ0YmY3MDVkYTdiNGM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f0127feb19a38c4a9e9e7ecc09c3a44dd58cd190", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0127feb19a38c4a9e9e7ecc09c3a44dd58cd190", "committedDate": "2020-10-20T08:32:19Z", "message": "Make Searchable Snapshot's CacheFile Lock less\n\nReplacing the mechanism for eviction and listener references via a read-write lock by\na reference counting implementation.\nThis fixes a bug that caused test failure #63586 in which concurrently trying to acquire or release\nan eviction listener while doing a file operation would sometimes lead to throwing an exception\nsince the `tryLock` call on the read lock would fail in this case.\nAlso this removes the possibility of blocking cluster state updates as a result of them waiting\non the write-lock which might take a long time if a slow read operation executes concurrently.\n\nCloses #63586"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb98de30e1bb7f80b57b695c802b75520639306a", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bb98de30e1bb7f80b57b695c802b75520639306a", "committedDate": "2020-10-20T09:17:43Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b9e909544ab8e3fe245e22b87f6e48310ae29d49", "committedDate": "2020-10-20T09:21:32Z", "message": "nicer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTEzNzgz", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512513783", "createdAt": "2020-10-20T09:32:26Z", "commit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTozMjoyNlrOHkzW5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTozMjoyNlrOHkzW5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjIyOA==", "bodyText": "By moving access to the file channel to a ref-counted basis and giving the channel its own life-cycle, we can remove all need for locking when dealing with file closing and opening.\nBackground operations running for index inputs that get closed concurrently are tied to a specific instance of this reference and will simply fail once all references to the channel have been released since they won't be able to acquire a reference to the channel again.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508352228", "createdAt": "2020-10-20T09:32:26Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -42,37 +40,60 @@\n         StandardOpenOption.CREATE,\n         StandardOpenOption.SPARSE };\n \n+    /**\n+     * Reference counter that counts the number of eviction listeners referencing to this cache file. Once this instance has been evicted\n+     * and all listeners notified it makes sure to delete the physical file backing this cache.\n+     */\n     private final AbstractRefCounted refCounter = new AbstractRefCounted(\"CacheFile\") {\n         @Override\n         protected void closeInternal() {\n-            CacheFile.this.finishEviction();\n+            assert assertNoPendingListeners();\n+            try {\n+                Files.deleteIfExists(file);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n         }\n     };\n \n-    private final ReentrantReadWriteLock.WriteLock evictionLock;\n-    private final ReentrantReadWriteLock.ReadLock readLock;\n-\n     private final SparseFileTracker tracker;\n     private final String description;\n     private final Path file;\n \n-    private volatile Set<EvictionListener> listeners;\n-    private volatile boolean evicted;\n+    private final Set<EvictionListener> listeners = new HashSet<>();\n+\n+    /**\n+     * A reference counted holder for the current channel to the physical file backing this cache file instance.\n+     */\n+    private static final class FileChannelReference extends AbstractRefCounted {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTE2MTc4", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512516178", "createdAt": "2020-10-20T09:35:15Z", "commit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTozNToxNlrOHkzeKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTozNToxNlrOHkzeKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1NDA5MQ==", "bodyText": "There's no need for a volatile and immutable set of listeners here. We never accessed the listeners outside of the lock so we can simply mutate them in place.\nI made this clearer now by using the listeners set as the mutex for all operations that apply to the set and the channel opening/closing that is a result of the set size.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508354091", "createdAt": "2020-10-20T09:35:16Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -113,22 +117,20 @@ public boolean acquire(final EvictionListener listener) throws IOException {\n         ensureOpen();\n         boolean success = false;\n         if (refCounter.tryIncRef()) {\n-            evictionLock.lock();\n             try {\n-                ensureOpen();\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean added = newListeners.add(listener);\n-                assert added : \"listener already exists \" + listener;\n-                maybeOpenFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n+                synchronized (listeners) {\n+                    ensureOpen();\n+                    final boolean added = listeners.add(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTE3NzAz", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512517703", "createdAt": "2020-10-20T09:37:00Z", "commit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTozNzowMFrOHkziqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTozNzowMFrOHkziqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1NTI0Mg==", "bodyText": "I found this a lot cleaner and easier to reason about than checking the value of this boolean twice with tricky locking and the cost of the atomic reference relative to the volatile boolean should be trivial.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508355242", "createdAt": "2020-10-20T09:37:00Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +142,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;\n                 }\n             }\n+            success = true;\n         } finally {\n-            evictionLock.unlock();\n+            if (success) {\n+                refCounter.decRef();\n+            }\n         }\n         assert invariant();\n         return success;\n     }\n \n-    private void finishEviction() {\n-        assert evictionLock.isHeldByCurrentThread();\n-        assert listeners.isEmpty();\n-        assert channel == null;\n-        try {\n-            Files.deleteIfExists(file);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+    private boolean assertNoPendingListeners() {\n+        synchronized (listeners) {\n+            assert listeners.isEmpty();\n+            assert channelRef == null;\n         }\n+        return true;\n     }\n \n+    /**\n+     * Evicts this file from the cache. Once this method has been called, subsequent use of this class with throw exceptions.\n+     */\n     public void startEviction() {\n-        if (evicted == false) {\n-            final Set<EvictionListener> evictionListeners = new HashSet<>();\n-            evictionLock.lock();\n-            try {\n-                if (evicted == false) {\n-                    evicted = true;\n-                    evictionListeners.addAll(listeners);\n-                    refCounter.decRef();\n-                }\n-            } finally {\n-                evictionLock.unlock();\n+        if (evicted.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0b02e74c58d86017c46495aab1536cc97955c2fb", "committedDate": "2020-10-20T09:39:20Z", "message": "missing comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTIyMjQw", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512522240", "createdAt": "2020-10-20T09:42:13Z", "commit": {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0MjoxM1rOHkzv6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0MjoxM1rOHkzv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1ODYzMw==", "bodyText": "This lock seems pointless to me and was causing trouble. If an eviction of the current file is concurrently started, all that happened here was that we would block that eviction when as far as I can tell we should simply fail the cache population as it's just wasted effort anyway as soon as the eviction hits?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508358633", "createdAt": "2020-10-20T09:42:13Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -498,34 +496,19 @@ public void prefetchPart(final int part) throws IOException {\n                     // We do not actually read anything, but we want to wait for the write to complete before proceeding.\n                     // noinspection UnnecessaryLocalVariable\n                     final Tuple<Long, Long> rangeToRead = rangeToWrite;\n-\n-                    try (Releasable ignored = cacheFile.fileLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb"}, "originalPosition": 362}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTIzMjM1", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512523235", "createdAt": "2020-10-20T09:43:21Z", "commit": {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0MzoyMlrOHkzy5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo0MzoyMlrOHkzy5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTM5OA==", "bodyText": "Same argument as in the other spot where I removed use of this method, what's the point of locking here when all we do is make the cache file be used after eviction has already been started, meaning all the writes going into it are wasted anyway?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508359398", "createdAt": "2020-10-20T09:43:22Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -164,193 +164,191 @@ protected void readInternal(ByteBuffer b) throws IOException {\n \n         try {\n             final CacheFile cacheFile = getCacheFileSafe();\n-            try (Releasable ignored = cacheFile.fileLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b90b9cba3e54eb130575ad1f2548dae1df4aba1b", "committedDate": "2020-10-20T09:54:56Z", "message": "even better"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNjE0MDMw", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512614030", "createdAt": "2020-10-20T11:40:47Z", "commit": {"oid": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo0MDo0N1rOHk4G1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoyNzowMlrOHk5w0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMDAzNw==", "bodyText": "Would you like to add your comment to the Javadoc?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508430037", "createdAt": "2020-10-20T11:40:47Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -42,37 +40,60 @@\n         StandardOpenOption.CREATE,\n         StandardOpenOption.SPARSE };\n \n+    /**\n+     * Reference counter that counts the number of eviction listeners referencing to this cache file. Once this instance has been evicted\n+     * and all listeners notified it makes sure to delete the physical file backing this cache.\n+     */\n     private final AbstractRefCounted refCounter = new AbstractRefCounted(\"CacheFile\") {\n         @Override\n         protected void closeInternal() {\n-            CacheFile.this.finishEviction();\n+            assert assertNoPendingListeners();\n+            try {\n+                Files.deleteIfExists(file);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n         }\n     };\n \n-    private final ReentrantReadWriteLock.WriteLock evictionLock;\n-    private final ReentrantReadWriteLock.ReadLock readLock;\n-\n     private final SparseFileTracker tracker;\n     private final String description;\n     private final Path file;\n \n-    private volatile Set<EvictionListener> listeners;\n-    private volatile boolean evicted;\n+    private final Set<EvictionListener> listeners = new HashSet<>();\n+\n+    /**\n+     * A reference counted holder for the current channel to the physical file backing this cache file instance.\n+     */\n+    private static final class FileChannelReference extends AbstractRefCounted {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjIyOA=="}, "originalCommit": {"oid": "b9e909544ab8e3fe245e22b87f6e48310ae29d49"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMDQ2Nw==", "bodyText": "Can you add the current file path to the description?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508430467", "createdAt": "2020-10-20T11:41:35Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -42,37 +40,60 @@\n         StandardOpenOption.CREATE,\n         StandardOpenOption.SPARSE };\n \n+    /**\n+     * Reference counter that counts the number of eviction listeners referencing to this cache file. Once this instance has been evicted\n+     * and all listeners notified it makes sure to delete the physical file backing this cache.\n+     */\n     private final AbstractRefCounted refCounter = new AbstractRefCounted(\"CacheFile\") {\n         @Override\n         protected void closeInternal() {\n-            CacheFile.this.finishEviction();\n+            assert assertNoPendingListeners();\n+            try {\n+                Files.deleteIfExists(file);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n         }\n     };\n \n-    private final ReentrantReadWriteLock.WriteLock evictionLock;\n-    private final ReentrantReadWriteLock.ReadLock readLock;\n-\n     private final SparseFileTracker tracker;\n     private final String description;\n     private final Path file;\n \n-    private volatile Set<EvictionListener> listeners;\n-    private volatile boolean evicted;\n+    private final Set<EvictionListener> listeners = new HashSet<>();\n+\n+    /**\n+     * A reference counted holder for the current channel to the physical file backing this cache file instance.\n+     */\n+    private static final class FileChannelReference extends AbstractRefCounted {\n+\n+        private final FileChannel fileChannel;\n+\n+        FileChannelReference(Path file) throws IOException {\n+            super(\"FileChannel\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMTE2MQ==", "bodyText": "Can you make this method package protected and add a comment indicating that it is just used in test now?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508431161", "createdAt": "2020-10-20T11:42:52Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -84,27 +105,10 @@ public Path getFile() {\n         return file;\n     }\n \n-    Releasable fileLock() {\n-        boolean success = false;\n-        readLock.lock();\n-        try {\n-            ensureOpen();\n-            // check if we have a channel while holding the read lock\n-            if (channel == null) {\n-                throw new AlreadyClosedException(\"Cache file channel has been released and closed\");\n-            }\n-            success = true;\n-            return readLock::unlock;\n-        } finally {\n-            if (success == false) {\n-                readLock.unlock();\n-            }\n-        }\n-    }\n-\n     @Nullable\n     public FileChannel getChannel() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODI3OQ==", "bodyText": "I'm not sure why this ensureOpen() has been added here? It could be added before the for loop so that we fail all gaps directly, otherwise it should be included within the next try/catch block but it's already present there.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508438279", "createdAt": "2020-10-20T11:55:29Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -306,21 +276,18 @@ private void ensureOpen() {\n                     @Override\n                     protected void doRun() {\n                         for (SparseFileTracker.Gap gap : gaps) {\n+                            ensureOpen();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b90b9cba3e54eb130575ad1f2548dae1df4aba1b"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NzE3MQ==", "bodyText": "The point was to keep the file around in order to be able to process any concurrent read operation (if any) that would have required a gap to be filled. But there was no reason to prevent other listeners to be acquired nor an eviction to kick in. Your change improves all of that.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508457171", "createdAt": "2020-10-20T12:27:02Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInput.java", "diffHunk": "@@ -164,193 +164,191 @@ protected void readInternal(ByteBuffer b) throws IOException {\n \n         try {\n             final CacheFile cacheFile = getCacheFileSafe();\n-            try (Releasable ignored = cacheFile.fileLock()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTM5OA=="}, "originalCommit": {"oid": "0b02e74c58d86017c46495aab1536cc97955c2fb"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5046e52484462c64372f0c66ee63c80fa299a2cd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5046e52484462c64372f0c66ee63c80fa299a2cd", "committedDate": "2020-10-20T14:22:55Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84331a07ec617e8f7574b23d5579f76f28ca7b44", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/84331a07ec617e8f7574b23d5579f76f28ca7b44", "committedDate": "2020-10-20T14:31:56Z", "message": "CR: comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODUxODg0", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-512851884", "createdAt": "2020-10-20T15:19:37Z", "commit": {"oid": "84331a07ec617e8f7574b23d5579f76f28ca7b44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNToxOTozOFrOHlCfHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNToxOTozOFrOHlCfHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMDA5NQ==", "bodyText": "Add assert channelRef.recCount() == 0?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r508600095", "createdAt": "2020-10-20T15:19:38Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +149,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84331a07ec617e8f7574b23d5579f76f28ca7b44"}, "originalPosition": 196}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41b2c2fd0d93eb9aa1dd3ba5e95a676737263c8f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/41b2c2fd0d93eb9aa1dd3ba5e95a676737263c8f", "committedDate": "2020-10-21T02:36:22Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/3c3756af25dbf5e0ad629e6809e3aa852e011fe1", "committedDate": "2020-10-21T04:57:22Z", "message": "better test and fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMzY3OTU1", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-513367955", "createdAt": "2020-10-21T07:11:43Z", "commit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzoxMTo0NFrOHldUDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwOToyNzowMVrOHlivRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzOTYyOQ==", "bodyText": "This could potentially be a stale value since we read it un-synchronized.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509039629", "createdAt": "2020-10-21T07:11:44Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -244,7 +227,7 @@ public String toString() {\n             + \", length=\"\n             + tracker.getLength()\n             + \", channel=\"\n-            + (channel != null ? \"yes\" : \"no\")\n+            + (channelRef != null ? \"yes\" : \"no\")\n             + \", listeners=\"\n             + listeners.size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0ODAyOQ==", "bodyText": "I believe this will silently ignore exceptions from reference.decRef. While that is currently only fileChannel.close(), it does look trappy, in particular because we keenly rethrow IOException in FileChannelReference.closeInternal.\nI wonder if it was more intuitive to \"just\" ensure we decRef the FileChannelReference appropriately in the two call-sites?\nAs a side-note, it would be nice to let populateAndRead just return a Future, makes it more easy to reason about the code, since then the callers cannot complete the future.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509048029", "createdAt": "2020-10-21T07:26:43Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -374,6 +356,27 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    /**\n+     * Get the reference to the currently open file channel for this cache file for a read operation\n+     *\n+     * @param future completable future to complete after the read operation finished\n+     * @return file channel reference\n+     */\n+    private FileChannelReference getFileChannelReference(CompletableFuture<Integer> future) {\n+        final FileChannelReference reference;\n+        synchronized (listeners) {\n+            ensureOpen();\n+            reference = channelRef;\n+            assert reference.refCount() > 0 : \"impossible to run into a fully released channel reference under the listeners mutex\";\n+            reference.incRef();\n+            future.handle((res, t) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTI0OA==", "bodyText": "nit: This is already checked inside getFileChannelReference (and must be).\nHaving it twice means we could get the exception either directly or on the future. I would prefer to just leave it out here, but is a small thing.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509055248", "createdAt": "2020-10-21T07:38:52Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -285,11 +268,12 @@ private void ensureOpen() {\n         final RangeMissingHandler writer,\n         final Executor executor\n     ) {\n+        ensureOpen();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA2NDkyMw==", "bodyText": "also assert that reference != null and refCounter.refCount() > 0?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509064923", "createdAt": "2020-10-21T07:54:35Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -374,6 +356,27 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    /**\n+     * Get the reference to the currently open file channel for this cache file for a read operation\n+     *\n+     * @param future completable future to complete after the read operation finished\n+     * @return file channel reference\n+     */\n+    private FileChannelReference getFileChannelReference(CompletableFuture<Integer> future) {\n+        final FileChannelReference reference;\n+        synchronized (listeners) {\n+            ensureOpen();\n+            reference = channelRef;\n+            assert reference.refCount() > 0 : \"impossible to run into a fully released channel reference under the listeners mutex\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 399}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNjE4Nw==", "bodyText": "Thanks, I wonder if we should then just change the comment a few lines up to not say \"close\" (or just remove the comment), at least that is what confused me.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509116187", "createdAt": "2020-10-21T09:09:01Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +149,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMDA5NQ=="}, "originalCommit": {"oid": "84331a07ec617e8f7574b23d5579f76f28ca7b44"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNzg0NA==", "bodyText": "nit: I think this can go outside the synchronized block? Not that I have a case where it makes a difference though...", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509117844", "createdAt": "2020-10-21T09:11:39Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -140,96 +156,63 @@ public boolean release(final EvictionListener listener) {\n         assert listener != null;\n \n         boolean success = false;\n-        evictionLock.lock();\n         try {\n-            try {\n-                final Set<EvictionListener> newListeners = new HashSet<>(listeners);\n-                final boolean removed = newListeners.remove(Objects.requireNonNull(listener));\n+            synchronized (listeners) {\n+                final boolean removed = listeners.remove(Objects.requireNonNull(listener));\n                 assert removed : \"listener does not exist \" + listener;\n                 if (removed == false) {\n                     throw new IllegalStateException(\"Cannot remove an unknown listener\");\n                 }\n-                maybeCloseFileChannel(newListeners);\n-                listeners = Collections.unmodifiableSet(newListeners);\n-                success = true;\n-            } finally {\n-                if (success) {\n-                    refCounter.decRef();\n+                if (listeners.isEmpty()) {\n+                    // nobody is using this file so we close the channel\n+                    channelRef.decRef();\n+                    channelRef = null;\n                 }\n             }\n+            success = true;\n         } finally {\n-            evictionLock.unlock();\n+            if (success) {\n+                refCounter.decRef();\n+            }\n         }\n         assert invariant();\n         return success;\n     }\n \n-    private void finishEviction() {\n-        assert evictionLock.isHeldByCurrentThread();\n-        assert listeners.isEmpty();\n-        assert channel == null;\n-        try {\n-            Files.deleteIfExists(file);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+    private boolean assertNoPendingListeners() {\n+        synchronized (listeners) {\n+            assert listeners.isEmpty();\n+            assert channelRef == null;\n         }\n+        return true;\n     }\n \n+    /**\n+     * Evicts this file from the cache. Once this method has been called, subsequent use of this class with throw exceptions.\n+     */\n     public void startEviction() {\n-        if (evicted == false) {\n-            final Set<EvictionListener> evictionListeners = new HashSet<>();\n-            evictionLock.lock();\n-            try {\n-                if (evicted == false) {\n-                    evicted = true;\n-                    evictionListeners.addAll(listeners);\n-                    refCounter.decRef();\n-                }\n-            } finally {\n-                evictionLock.unlock();\n+        if (evicted.compareAndSet(false, true)) {\n+            final Set<EvictionListener> evictionListeners;\n+            synchronized (listeners) {\n+                evictionListeners = new HashSet<>(listeners);\n+                refCounter.decRef();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNTI2NQ==", "bodyText": "This seems unchanged, but I find it slightly odd to have both the option of returning false from this method as well as throwing AlreadyClosedException when this CacheFile is being evicted. Am I missing something here?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509125265", "createdAt": "2020-10-21T09:22:16Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -113,22 +131,20 @@ public boolean acquire(final EvictionListener listener) throws IOException {\n         ensureOpen();\n         boolean success = false;\n         if (refCounter.tryIncRef()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyODUxNg==", "bodyText": "Can we also (sometimes, randomly) call readIfAvailableOrPending?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r509128516", "createdAt": "2020-10-21T09:27:01Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -124,9 +130,40 @@ public void testDeleteOnCloseAfterLastRelease() throws Exception {\n         assertFalse(Files.exists(file));\n     }\n \n-    class TestEvictionListener implements EvictionListener {\n+    public void testConcurrentAccess() throws Exception {\n+        final Path file = createTempDir().resolve(\"file.cache\");\n+        final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(1, 100), file);\n+\n+        final TestEvictionListener evictionListener = new TestEvictionListener();\n+        assertTrue(cacheFile.acquire(evictionListener));\n+        final long length = cacheFile.getLength();\n+        final DeterministicTaskQueue deterministicTaskQueue = new DeterministicTaskQueue(\n+            builder().put(NODE_NAME_SETTING.getKey(), getTestName()).build(),\n+            random()\n+        );\n+        final ThreadPool threadPool = deterministicTaskQueue.getThreadPool();\n+        final CompletableFuture<Integer> readFuture = cacheFile.populateAndRead(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3756af25dbf5e0ad629e6809e3aa852e011fe1"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfa669f91c6a80bd10d0791e97d00f9bdd89b62f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bfa669f91c6a80bd10d0791e97d00f9bdd89b62f", "committedDate": "2020-10-21T10:59:57Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb4d8805ddfe111a0de930d1f72964ed11f8ef85", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/fb4d8805ddfe111a0de930d1f72964ed11f8ef85", "committedDate": "2020-10-21T11:18:40Z", "message": "drop pointless check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5eb341a775fdb05f9cb8f3c07e81dd07252e034", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d5eb341a775fdb05f9cb8f3c07e81dd07252e034", "committedDate": "2020-10-21T12:17:03Z", "message": "CR: comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bd547ee8aeeca878340d34b10119eed33f34600f", "committedDate": "2020-10-21T12:18:55Z", "message": "spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODM3NTc3", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-514837577", "createdAt": "2020-10-22T15:11:48Z", "commit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToxMTo0OFrOHmmuLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToxMTo0OFrOHmmuLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjM1MA==", "bodyText": "Looking at this again I think that gap.onCompletion(); should be executed within the try/finally block, before the reference is decremented, as completing the gap might trigger the execution of some listeners.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510242350", "createdAt": "2020-10-22T15:11:48Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -307,20 +289,16 @@ private void ensureOpen() {\n                     protected void doRun() {\n                         for (SparseFileTracker.Gap gap : gaps) {\n                             try {\n-                                ensureOpen();\n-                                if (readLock.tryLock() == false) {\n-                                    throw new AlreadyClosedException(\"Cache file channel is being evicted, writing attempt cancelled\");\n+                                if (reference.tryIncRef() == false) {\n+                                    throw new AlreadyClosedException(\"Cache file channel has been released and closed\");\n                                 }\n                                 try {\n                                     ensureOpen();\n-                                    if (channel == null) {\n-                                        throw new AlreadyClosedException(\"Cache file channel has been released and closed\");\n-                                    }\n-                                    writer.fillCacheRange(channel, gap.start(), gap.end(), gap::onProgress);\n-                                    gap.onCompletion();\n+                                    writer.fillCacheRange(reference.fileChannel, gap.start(), gap.end(), gap::onProgress);\n                                 } finally {\n-                                    readLock.unlock();\n+                                    reference.decRef();\n                                 }\n+                                gap.onCompletion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "originalPosition": 382}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDcwNDk5", "url": "https://github.com/elastic/elasticsearch/pull/63911#pullrequestreview-515070499", "createdAt": "2020-10-22T19:55:13Z", "commit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo1NToxM1rOHmxheA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDozNjowOVrOHmy2mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxOTMyMA==", "bodyText": "nit: Maybe we should call this acquireFileChannelReference to make it excplicit that it does incRef, requiring the caller to decRef?", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510419320", "createdAt": "2020-10-22T19:55:13Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -349,31 +327,72 @@ public void onFailure(Exception e) {\n      *         target range is neither available nor pending.\n      */\n     @Nullable\n-    CompletableFuture<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n+    Future<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n         final CompletableFuture<Integer> future = new CompletableFuture<>();\n+        Releasable decrementRef = null;\n         try {\n-            ensureOpen();\n-            if (tracker.waitForRangeIfPending(rangeToRead, ActionListener.wrap(success -> {\n-                final int read = reader.onRangeAvailable(channel);\n-                assert read == rangeToRead.v2() - rangeToRead.v1() : \"partial read [\"\n-                    + read\n-                    + \"] does not match the range to read [\"\n-                    + rangeToRead.v2()\n-                    + '-'\n-                    + rangeToRead.v1()\n-                    + ']';\n-                future.complete(read);\n-            }, future::completeExceptionally))) {\n+            final FileChannelReference reference = getFileChannelReference();\n+            decrementRef = Releasables.releaseOnce(reference::decRef);\n+            if (tracker.waitForRangeIfPending(rangeToRead, rangeListener(rangeToRead, reader, future, reference, decrementRef))) {\n                 return future;\n             } else {\n+                // complete the future to release the channel reference\n+                decrementRef.close();\n                 return null;\n             }\n         } catch (Exception e) {\n-            future.completeExceptionally(e);\n+            releaseAndFail(future, decrementRef, e);\n             return future;\n         }\n     }\n \n+    private static void releaseAndFail(CompletableFuture<Integer> future, Releasable decrementRef, Exception e) {\n+        try {\n+            Releasables.close(decrementRef);\n+        } catch (Exception ex) {\n+            e.addSuppressed(ex);\n+        }\n+        future.completeExceptionally(e);\n+    }\n+\n+    private static ActionListener<Void> rangeListener(\n+        Tuple<Long, Long> rangeToRead,\n+        RangeAvailableHandler reader,\n+        CompletableFuture<Integer> future,\n+        FileChannelReference reference,\n+        Releasable releasable\n+    ) {\n+        return ActionListener.runAfter(ActionListener.wrap(success -> {\n+            final int read = reader.onRangeAvailable(reference.fileChannel);\n+            assert read == rangeToRead.v2() - rangeToRead.v1() : \"partial read [\"\n+                + read\n+                + \"] does not match the range to read [\"\n+                + rangeToRead.v2()\n+                + '-'\n+                + rangeToRead.v1()\n+                + ']';\n+            future.complete(read);\n+        }, future::completeExceptionally), releasable::close);\n+    }\n+\n+    /**\n+     * Get the reference to the currently open file channel for this cache file for a read operation\n+     *\n+     * @return file channel reference\n+     */\n+    private FileChannelReference getFileChannelReference() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxOTY4Mg==", "bodyText": "This comment should be removed now.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510419682", "createdAt": "2020-10-22T19:55:57Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -349,31 +327,72 @@ public void onFailure(Exception e) {\n      *         target range is neither available nor pending.\n      */\n     @Nullable\n-    CompletableFuture<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n+    Future<Integer> readIfAvailableOrPending(final Tuple<Long, Long> rangeToRead, final RangeAvailableHandler reader) {\n         final CompletableFuture<Integer> future = new CompletableFuture<>();\n+        Releasable decrementRef = null;\n         try {\n-            ensureOpen();\n-            if (tracker.waitForRangeIfPending(rangeToRead, ActionListener.wrap(success -> {\n-                final int read = reader.onRangeAvailable(channel);\n-                assert read == rangeToRead.v2() - rangeToRead.v1() : \"partial read [\"\n-                    + read\n-                    + \"] does not match the range to read [\"\n-                    + rangeToRead.v2()\n-                    + '-'\n-                    + rangeToRead.v1()\n-                    + ']';\n-                future.complete(read);\n-            }, future::completeExceptionally))) {\n+            final FileChannelReference reference = getFileChannelReference();\n+            decrementRef = Releasables.releaseOnce(reference::decRef);\n+            if (tracker.waitForRangeIfPending(rangeToRead, rangeListener(rangeToRead, reader, future, reference, decrementRef))) {\n                 return future;\n             } else {\n+                // complete the future to release the channel reference", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzMjU2NQ==", "bodyText": "It would be nice in this case to randomly first invoke populateAndRead too - in order to get into the more interesting part of readIfAvailableOrPending involving the listener callback.", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510432565", "createdAt": "2020-10-22T20:19:41Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CacheFileTests.java", "diffHunk": "@@ -124,9 +130,47 @@ public void testDeleteOnCloseAfterLastRelease() throws Exception {\n         assertFalse(Files.exists(file));\n     }\n \n-    class TestEvictionListener implements EvictionListener {\n+    public void testConcurrentAccess() throws Exception {\n+        final Path file = createTempDir().resolve(\"file.cache\");\n+        final CacheFile cacheFile = new CacheFile(\"test\", randomLongBetween(1, 100), file);\n+\n+        final TestEvictionListener evictionListener = new TestEvictionListener();\n+        assertTrue(cacheFile.acquire(evictionListener));\n+        final long length = cacheFile.getLength();\n+        final DeterministicTaskQueue deterministicTaskQueue = new DeterministicTaskQueue(\n+            builder().put(NODE_NAME_SETTING.getKey(), getTestName()).build(),\n+            random()\n+        );\n+        final ThreadPool threadPool = deterministicTaskQueue.getThreadPool();\n+        final Future<Integer> readFuture;\n+        if (randomBoolean()) {\n+            readFuture = cacheFile.readIfAvailableOrPending(Tuple.tuple(0L, length), channel -> Math.toIntExact(length));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MTExMw==", "bodyText": "Related to your discussion below I believe we could add:\nassert false : \"expected a non-closed channel reference\"", "url": "https://github.com/elastic/elasticsearch/pull/63911#discussion_r510441113", "createdAt": "2020-10-22T20:36:09Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/CacheFile.java", "diffHunk": "@@ -307,20 +289,16 @@ private void ensureOpen() {\n                     protected void doRun() {\n                         for (SparseFileTracker.Gap gap : gaps) {\n                             try {\n-                                ensureOpen();\n-                                if (readLock.tryLock() == false) {\n-                                    throw new AlreadyClosedException(\"Cache file channel is being evicted, writing attempt cancelled\");\n+                                if (reference.tryIncRef() == false) {\n+                                    throw new AlreadyClosedException(\"Cache file channel has been released and closed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd547ee8aeeca878340d34b10119eed33f34600f"}, "originalPosition": 368}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2a66df5c05366f0d01f63fd1ee5a1cececbeefb", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d2a66df5c05366f0d01f63fd1ee5a1cececbeefb", "committedDate": "2020-10-23T05:50:11Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-cache-file-locking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9e58008c2f97e67fcd5811bf7e44bf705da7b4c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a9e58008c2f97e67fcd5811bf7e44bf705da7b4c", "committedDate": "2020-10-23T08:31:12Z", "message": "CR: comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1166, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}