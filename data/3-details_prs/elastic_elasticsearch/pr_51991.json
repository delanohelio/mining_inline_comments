{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxODI4ODYw", "number": 51991, "title": "Cache completion stats between refreshes", "bodyText": "Computing the stats for completion fields may involve a significant amount of\nwork since it walks every field of every segment looking for completion fields.\nInnocuous-looking APIs like GET _stats or GET _cluster/stats do this for\nevery shard in the cluster. This repeated work is unnecessary since these stats\ndo not change between refreshes; in many indices they remain constant for a\nlong time.\nThis commit introduces a cache for these stats which is invalidated on a\nrefresh, allowing most stats calls to bypass the work needed to compute them on\nmost shards.\nCloses #51915", "createdAt": "2020-02-06T10:43:40Z", "url": "https://github.com/elastic/elasticsearch/pull/51991", "merged": true, "mergeCommit": {"oid": "a3a98c7003e19ce0040a9946e0a255e802943bdb"}, "closed": true, "closedAt": "2020-02-27T07:33:17Z", "author": {"login": "DaveCTurner"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBoR93AH2gAyMzcxODI4ODYwOjViZTBkODM3MDllYzMxZTNmNmQ2NDM4YTg0MTEwYjU5ZWE3ZWE4MWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHz_BkgFqTM2NDI0MDgyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/5be0d83709ec31e3f6d6438a84110b59ea7ea81b", "committedDate": "2020-02-06T10:35:50Z", "message": "Cache completion stats between refreshes\n\nComputing the stats for completion fields may involve a significant amount of\nwork since it walks every field of every segment looking for completion fields.\nInnocuous-looking APIs like `GET _stats` or `GET _cluster/stats` do this for\nevery shard in the cluster. This repeated work is unnecessary since these stats\ndo not change between refreshes; in many indices they remain constant for a\nlong time.\n\nThis commit introduces a cache for these stats which is invalidated on a\nrefresh, allowing most stats calls to bypass the work needed to compute them on\nmost shards.\n\nCloses #51915"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MzU2Mjk2", "url": "https://github.com/elastic/elasticsearch/pull/51991#pullrequestreview-354356296", "createdAt": "2020-02-06T10:47:39Z", "commit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDo0NzozOVrOFmWxxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDo0ODo1NVrOFmW0cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA==", "bodyText": "I don't like this. These stats live at the Engine level, but the reference managers live down here, and we need to register the cache as a refresh listener; if there were any other implementations of Engine then they would also need to do the same (except ReadOnlyEngines of course, they don't refresh so don't need to update these stats).\nWe can't do this in the Engine constructor since these reference managers haven't been created when that runs, but I can't see another obvious place in the Engine lifecycle to do this. Suggestions welcome.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375763398", "createdAt": "2020-02-06T10:47:39Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -247,6 +247,7 @@ public InternalEngine(EngineConfig engineConfig) {\n             }\n             this.lastRefreshedCheckpointListener = new LastRefreshedCheckpointListener(localCheckpointTracker.getProcessedCheckpoint());\n             this.internalReaderManager.addListener(lastRefreshedCheckpointListener);\n+            this.externalReaderManager.addListener(completionStatsCache);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ==", "bodyText": "NB this moves the stats back to the EXTERNAL searcher scope. Prior to #33847 they used the EXTERNAL searcher as here but since then they have been using the INTERNAL one. I think EXTERNAL is more appropriate.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375764081", "createdAt": "2020-02-06T10:48:55Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a590d74e14df890e0d7e12da73e68f28363b2e7d", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/a590d74e14df890e0d7e12da73e68f28363b2e7d", "committedDate": "2020-02-06T10:51:11Z", "message": "Merge branch 'master' into 2020-02-05-CompletionStatsCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/db5be3a794c5560a8fd534bfb7fc5fc28472aac9", "committedDate": "2020-02-06T11:01:59Z", "message": "Imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NTQ1NDY2", "url": "https://github.com/elastic/elasticsearch/pull/51991#pullrequestreview-354545466", "createdAt": "2020-02-06T15:34:55Z", "commit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNTozNDo1NlrOFmfgHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNTozNDo1NlrOFmfgHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwNjMzNQ==", "bodyText": "Instead of invalidating the entire current cache, we can mark the current cache as outdated (i.e., need to refresh), then we can reuse the stats of some LeafReader that haven't changed between refreshes.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375906335", "createdAt": "2020-02-06T15:34:56Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {\n+            long sizeInBytes = 0;\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>();\n+\n+            try (Engine.Searcher currentSearcher = searcherSupplier.get()) {\n+                for (LeafReaderContext atomicReaderContext : currentSearcher.getIndexReader().leaves()) {\n+                    LeafReader atomicReader = atomicReaderContext.reader();\n+                    for (FieldInfo info : atomicReader.getFieldInfos()) {\n+                        Terms terms = atomicReader.terms(info.name);\n+                        if (terms instanceof CompletionTerms) {\n+                            // TODO: currently we load up the suggester for reporting its size\n+                            final long fstSize = ((CompletionTerms) terms).suggester().ramBytesUsed();\n+                            completionFields.addTo(info.name, fstSize);\n+                            sizeInBytes += fstSize;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return new CompletionStats(sizeInBytes, new FieldMemoryStats(completionFields));\n+        });\n+\n+        return filterCompletionStatsByFieldName(fieldNamePatterns, newFuture.actionGet());\n+    }\n+\n+    private static CompletionStats filterCompletionStatsByFieldName(String[] fieldNamePatterns, CompletionStats fullCompletionStats) {\n+        final FieldMemoryStats fieldMemoryStats;\n+        if (fieldNamePatterns != null && fieldNamePatterns.length > 0) {\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>(fieldNamePatterns.length);\n+            for (ObjectLongCursor<String> fieldCursor : fullCompletionStats.getFields()) {\n+                if (Regex.simpleMatch(fieldNamePatterns, fieldCursor.key)) {\n+                    completionFields.addTo(fieldCursor.key, fieldCursor.value);\n+                }\n+            }\n+            fieldMemoryStats = new FieldMemoryStats(completionFields);\n+        } else {\n+            fieldMemoryStats = null;\n+        }\n+        return new CompletionStats(fullCompletionStats.getSizeInBytes(), fieldMemoryStats);\n+    }\n+\n+    @Override\n+    public void beforeRefresh() {\n+    }\n+\n+    @Override\n+    public void afterRefresh(boolean didRefresh) {\n+        if (didRefresh) {\n+            completionStatsFutureRef.set(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NDU1Mjg1", "url": "https://github.com/elastic/elasticsearch/pull/51991#pullrequestreview-354455285", "createdAt": "2020-02-06T13:40:33Z", "commit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzo0MDozNFrOFmbWOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzowMTozOFrOFmz2vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzODI2NQ==", "bodyText": "I think I would prefer to not cache an exception result (or at least clear the ref further down if newFuture.actionGet() throws an exception) in order to not stick to a bad result forever.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375838265", "createdAt": "2020-02-06T13:40:34Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg0MDA5Nw==", "bodyText": "Thanks for highlighting this. My hunch is that internal is more appropriate due to refreshIfNeeded, which can in some cases refresh the internal scope. This is out of a preference for returning as recent stats information as we can. Can you elaborate on why you find EXTERNAL more appropriate?", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375840097", "createdAt": "2020-02-06T13:43:53Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg1NTA3OA==", "bodyText": "I think I would prefer to move the completionStatsCache field down to this level instead (and repeat it in ReadOnlyEngine for now). That would make the completionStats method abstract in Engine.\nI see no need to specialize the caching in ReadOnlyEngine, but in theory, we could pick a different strategy there...", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375855078", "createdAt": "2020-02-06T14:12:03Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -247,6 +247,7 @@ public InternalEngine(EngineConfig engineConfig) {\n             }\n             this.lastRefreshedCheckpointListener = new LastRefreshedCheckpointListener(localCheckpointTracker.getProcessedCheckpoint());\n             this.internalReaderManager.addListener(lastRefreshedCheckpointListener);\n+            this.externalReaderManager.addListener(completionStatsCache);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzOTgwNQ==", "bodyText": "Do we need the wait_for_events: languid hack here to guard against a relocation completing but delayed reroute causing a short period before the next relocation happens (in case more relocations are necessary to balance cluster)?", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r376239805", "createdAt": "2020-02-07T07:01:38Z", "author": {"login": "henningandersen"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.stats/40_updates_on_refresh.yml", "diffHunk": "@@ -0,0 +1,66 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+          index:  test1\n+          wait_for_active_shards: all\n+          body:\n+              settings:\n+                # Limit the number of shards so that shards are unlikely\n+                # to be relocated or being initialized between the test\n+                # set up and the test execution\n+                index.number_of_shards: 3\n+                index.number_of_replicas: 0\n+              mappings:\n+                  properties:\n+                      bar:\n+                          type: text\n+                          fielddata: true\n+                          fields:\n+                              completion:\n+                                  type: completion\n+\n+  - do:\n+      cluster.health:\n+        wait_for_no_relocating_shards: true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2adb2b9fbaca83f7ad435085167697c38367c8d3", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/2adb2b9fbaca83f7ad435085167697c38367c8d3", "committedDate": "2020-02-10T16:33:41Z", "message": "Merge branch 'master' into 2020-02-05-CompletionStatsCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3ae2725aa2a470fccf6b222eae6afbdc557d5c4", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3ae2725aa2a470fccf6b222eae6afbdc557d5c4", "committedDate": "2020-02-10T16:41:24Z", "message": "Push down"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e9a3ab3cbc6ffd28939ef3435912cab62acb963", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/5e9a3ab3cbc6ffd28939ef3435912cab62acb963", "committedDate": "2020-02-10T16:53:23Z", "message": "Don't cache exceptional results"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3262eb8ae5d6e1dd59fcc84cfabafea3be58d06", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/e3262eb8ae5d6e1dd59fcc84cfabafea3be58d06", "committedDate": "2020-02-10T16:55:57Z", "message": "wait_for_events"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5d200e310b4d31ca6572759834ebe6e1c1b1656", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/a5d200e310b4d31ca6572759834ebe6e1c1b1656", "committedDate": "2020-02-10T17:23:27Z", "message": "Impors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f19cd763dcec085b4625ffb0d17eb914e27226e3", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/f19cd763dcec085b4625ffb0d17eb914e27226e3", "committedDate": "2020-02-21T16:29:56Z", "message": "Merge branch 'master' into 2020-02-05-CompletionStatsCache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzI2NTEw", "url": "https://github.com/elastic/elasticsearch/pull/51991#pullrequestreview-363726510", "createdAt": "2020-02-24T21:50:07Z", "commit": {"oid": "f19cd763dcec085b4625ffb0d17eb914e27226e3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MjQwODI5", "url": "https://github.com/elastic/elasticsearch/pull/51991#pullrequestreview-364240829", "createdAt": "2020-02-25T15:37:33Z", "commit": {"oid": "f19cd763dcec085b4625ffb0d17eb914e27226e3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2876, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}