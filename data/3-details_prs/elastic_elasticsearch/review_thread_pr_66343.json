{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMjcxNjg4", "number": 66343, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToxMDo1N1rOFFpOAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToxNDo1MlrOFFpWxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDYyNTMxOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/job/process/DataCounts.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToxMDo1N1rOIGQTQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToxODoyNVrOIGQsOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQyOTQ0MQ==", "bodyText": "unsure the rounding to epoch ms this is really needed. The only time that users will be using this object with actual data is when it is deserialized from the server.", "url": "https://github.com/elastic/elasticsearch/pull/66343#discussion_r543429441", "createdAt": "2020-12-15T15:10:57Z", "author": {"login": "benwtrent"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/job/process/DataCounts.java", "diffHunk": "@@ -138,31 +145,13 @@ public DataCounts(String jobId, long processedRecordCount, long processedFieldCo\n         this.lastDataTimeStamp = lastDataTimeStamp;\n         this.latestEmptyBucketTimeStamp = latestEmptyBucketTimeStamp;\n         this.latestSparseBucketTimeStamp = latestSparseBucketTimeStamp;\n+        this.logTime = logTime == null ? null : Instant.ofEpochMilli(logTime.toEpochMilli());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cabe50ad2b083056c2570b3773ae61811ffdd"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzNTgzNA==", "bodyText": "We need it for tests. We use Instant.now() in tests and that includes nanos. We do that everywhere we use Instant.", "url": "https://github.com/elastic/elasticsearch/pull/66343#discussion_r543435834", "createdAt": "2020-12-15T15:18:25Z", "author": {"login": "dimitris-athanasiou"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/job/process/DataCounts.java", "diffHunk": "@@ -138,31 +145,13 @@ public DataCounts(String jobId, long processedRecordCount, long processedFieldCo\n         this.lastDataTimeStamp = lastDataTimeStamp;\n         this.latestEmptyBucketTimeStamp = latestEmptyBucketTimeStamp;\n         this.latestSparseBucketTimeStamp = latestSparseBucketTimeStamp;\n+        this.logTime = logTime == null ? null : Instant.ofEpochMilli(logTime.toEpochMilli());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQyOTQ0MQ=="}, "originalCommit": {"oid": "152cabe50ad2b083056c2570b3773ae61811ffdd"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDY0NzcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToxNDo1MlrOIGQgYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNToyNTo1M1rOIGRG4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMjgwMw==", "bodyText": "Do we have to worry about unmapped type errors?", "url": "https://github.com/elastic/elasticsearch/pull/66343#discussion_r543432803", "createdAt": "2020-12-15T15:14:52Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsProvider.java", "diffHunk": "@@ -445,6 +445,10 @@ private SearchRequestBuilder createLatestDataCountsSearch(String indexName, Stri\n                 .setIndicesOptions(IndicesOptions.lenientExpandOpen())\n                 // look for both old and new formats\n                 .setQuery(QueryBuilders.idsQuery().addIds(DataCounts.documentId(jobId), DataCounts.v54DocumentId(jobId)))\n+                // We want to sort on log_time. However, this was added a long time later and before that we used to\n+                // sort on latest_record_time. Thus we handle older data counts where no log_time exists and we fall back\n+                // to the prior behaviour.\n+                .addSort(SortBuilders.fieldSort(DataCounts.LOG_TIME.getPreferredName()).order(SortOrder.DESC).missing(0L))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cabe50ad2b083056c2570b3773ae61811ffdd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MTkwNQ==", "bodyText": "Definitely. I tricked myself thinking missing was doing the job unmapped needs to do. Will fix that, thanks for spotting it!", "url": "https://github.com/elastic/elasticsearch/pull/66343#discussion_r543441905", "createdAt": "2020-12-15T15:25:07Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsProvider.java", "diffHunk": "@@ -445,6 +445,10 @@ private SearchRequestBuilder createLatestDataCountsSearch(String indexName, Stri\n                 .setIndicesOptions(IndicesOptions.lenientExpandOpen())\n                 // look for both old and new formats\n                 .setQuery(QueryBuilders.idsQuery().addIds(DataCounts.documentId(jobId), DataCounts.v54DocumentId(jobId)))\n+                // We want to sort on log_time. However, this was added a long time later and before that we used to\n+                // sort on latest_record_time. Thus we handle older data counts where no log_time exists and we fall back\n+                // to the prior behaviour.\n+                .addSort(SortBuilders.fieldSort(DataCounts.LOG_TIME.getPreferredName()).order(SortOrder.DESC).missing(0L))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMjgwMw=="}, "originalCommit": {"oid": "152cabe50ad2b083056c2570b3773ae61811ffdd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MjY1OA==", "bodyText": "Funny thing, I tested this. I created manually an index .ml-anomalies-fake. It all worked. But I didn't think that that index would pick our mappings due to the template being the new one.", "url": "https://github.com/elastic/elasticsearch/pull/66343#discussion_r543442658", "createdAt": "2020-12-15T15:25:53Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsProvider.java", "diffHunk": "@@ -445,6 +445,10 @@ private SearchRequestBuilder createLatestDataCountsSearch(String indexName, Stri\n                 .setIndicesOptions(IndicesOptions.lenientExpandOpen())\n                 // look for both old and new formats\n                 .setQuery(QueryBuilders.idsQuery().addIds(DataCounts.documentId(jobId), DataCounts.v54DocumentId(jobId)))\n+                // We want to sort on log_time. However, this was added a long time later and before that we used to\n+                // sort on latest_record_time. Thus we handle older data counts where no log_time exists and we fall back\n+                // to the prior behaviour.\n+                .addSort(SortBuilders.fieldSort(DataCounts.LOG_TIME.getPreferredName()).order(SortOrder.DESC).missing(0L))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQzMjgwMw=="}, "originalCommit": {"oid": "152cabe50ad2b083056c2570b3773ae61811ffdd"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4608, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}