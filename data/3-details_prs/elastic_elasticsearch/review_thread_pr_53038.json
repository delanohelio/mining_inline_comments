{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNjU0ODE3", "number": 53038, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjoxNzowMFrODk1iIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjoxNzowMFrODk1iIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTUyNDE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjoxNzowMFrOFxYoZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo0OToxNVrOFxwN6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyODEwMg==", "bodyText": "Should this be private, since it uses a private interface (FieldResolver) and looks to be an internal thing anyway?", "url": "https://github.com/elastic/elasticsearch/pull/53038#discussion_r387328102", "createdAt": "2020-03-03T22:17:00Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceConfig.java", "diffHunk": "@@ -61,6 +65,50 @@ public static ValuesSourceConfig resolve(QueryShardContext context,\n                                              String format,\n                                              ValuesSourceType defaultValueSourceType,\n                                              String aggregationName) {\n+\n+        return internalResolve(context, userValueTypeHint, field, script, missing, timeZone, format, defaultValueSourceType,\n+            aggregationName, ValuesSourceConfig::getMappingFromRegistry);\n+    }\n+\n+    /**\n+     * AKA legacy resolve.  This method should be called by aggregations not supported by the {@link ValuesSourceRegistry}, to use the\n+     * pre-registry logic to decide on the {@link ValuesSourceType}.  New aggregations which extend from\n+     * {@link ValuesSourceAggregationBuilder} should not use this method, preferring {@link ValuesSourceConfig#resolve} instead.\n+     *\n+     * @param context - the query context\n+     * @param userValueTypeHint - User specified value type; used for missing values and scripts\n+     * @param field - The field being aggregated over.  At least one of field and script must not be null\n+     * @param script - The script the user specified.  At least one of field and script must not be null\n+     * @param missing - A user specified value to apply when the field is missing.  Should be of type userValueTypeHint\n+     * @param timeZone - Used to generate a format for dates\n+     * @param format - The format string to apply to this field.  Confusingly, this is used for input parsing as well as output formatting\n+     *               See https://github.com/elastic/elasticsearch/issues/47469\n+     * @param defaultValueSourceType - per-aggregation {@link ValuesSource} of last resort.\n+     * @return - An initialized {@link ValuesSourceConfig} that will yield the appropriate {@link ValuesSourceType}\n+     */\n+    public static ValuesSourceConfig resolveUnregistered(QueryShardContext context,\n+                                                         ValueType userValueTypeHint,\n+                                                         String field,\n+                                                         Script script,\n+                                                         Object missing,\n+                                                         ZoneId timeZone,\n+                                                         String format,\n+                                                         ValuesSourceType defaultValueSourceType) {\n+        return internalResolve(context, userValueTypeHint, field, script, missing, timeZone, format, defaultValueSourceType, null,\n+            ValuesSourceConfig::getLegacyMapping);\n+    }\n+\n+    public static ValuesSourceConfig internalResolve(QueryShardContext context,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11f2ce6adc9a0e093e938683e6692cf1277f1d3a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNDUzNg==", "bodyText": "yes, yes it should.  Will fix before merging.  Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/53038#discussion_r387714536", "createdAt": "2020-03-04T14:49:15Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceConfig.java", "diffHunk": "@@ -61,6 +65,50 @@ public static ValuesSourceConfig resolve(QueryShardContext context,\n                                              String format,\n                                              ValuesSourceType defaultValueSourceType,\n                                              String aggregationName) {\n+\n+        return internalResolve(context, userValueTypeHint, field, script, missing, timeZone, format, defaultValueSourceType,\n+            aggregationName, ValuesSourceConfig::getMappingFromRegistry);\n+    }\n+\n+    /**\n+     * AKA legacy resolve.  This method should be called by aggregations not supported by the {@link ValuesSourceRegistry}, to use the\n+     * pre-registry logic to decide on the {@link ValuesSourceType}.  New aggregations which extend from\n+     * {@link ValuesSourceAggregationBuilder} should not use this method, preferring {@link ValuesSourceConfig#resolve} instead.\n+     *\n+     * @param context - the query context\n+     * @param userValueTypeHint - User specified value type; used for missing values and scripts\n+     * @param field - The field being aggregated over.  At least one of field and script must not be null\n+     * @param script - The script the user specified.  At least one of field and script must not be null\n+     * @param missing - A user specified value to apply when the field is missing.  Should be of type userValueTypeHint\n+     * @param timeZone - Used to generate a format for dates\n+     * @param format - The format string to apply to this field.  Confusingly, this is used for input parsing as well as output formatting\n+     *               See https://github.com/elastic/elasticsearch/issues/47469\n+     * @param defaultValueSourceType - per-aggregation {@link ValuesSource} of last resort.\n+     * @return - An initialized {@link ValuesSourceConfig} that will yield the appropriate {@link ValuesSourceType}\n+     */\n+    public static ValuesSourceConfig resolveUnregistered(QueryShardContext context,\n+                                                         ValueType userValueTypeHint,\n+                                                         String field,\n+                                                         Script script,\n+                                                         Object missing,\n+                                                         ZoneId timeZone,\n+                                                         String format,\n+                                                         ValuesSourceType defaultValueSourceType) {\n+        return internalResolve(context, userValueTypeHint, field, script, missing, timeZone, format, defaultValueSourceType, null,\n+            ValuesSourceConfig::getLegacyMapping);\n+    }\n+\n+    public static ValuesSourceConfig internalResolve(QueryShardContext context,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyODEwMg=="}, "originalCommit": {"oid": "11f2ce6adc9a0e093e938683e6692cf1277f1d3a"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3495, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}