{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MTA3MDEx", "number": 52250, "title": "Resolve application privileges to SP access", "bodyText": "Identity Provider\nAdds a new UserPrivilegeResolver class that determines whether a user\nhas access to a service, and with what groups, based on an application\nresource model that represents the service.", "createdAt": "2020-02-12T04:55:08Z", "url": "https://github.com/elastic/elasticsearch/pull/52250", "merged": true, "mergeCommit": {"oid": "749c3c47122a40ef860c7343864be99fec32680d"}, "closed": true, "closedAt": "2020-02-18T22:55:49Z", "author": {"login": "tvernum"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDeO1ygH2gAyMzc0MTA3MDExOmQ4NWQ0YmFhYTgyMWJhZmNhYjIzYTc0NGQxOWYzNjU3M2E2Zjg4Y2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFaN2nAH2gAyMzc0MTA3MDExOjgwZWMyNWI5N2FlYjRhNzdmZjNmNWM0YTI3OWYwMGMzZmNhZGM5MGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d85d4baaa821bafcab23a744d19f36573a6f88ca", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/d85d4baaa821bafcab23a744d19f36573a6f88ca", "committedDate": "2020-02-12T04:01:13Z", "message": "Resolve application privileges to SP access\n\nAdds a new UserPrivilegeResolver class that determines whether a user\nhas access to a service, and with what groups, based on an application\nresource model that represents the service."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/9f727f8fc5024bee6f4f759fac99a30336ee8fb9", "committedDate": "2020-02-12T06:01:12Z", "message": "Merge branch 'feature-internal-idp' into idp/privileges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MDY1Mjc4", "url": "https://github.com/elastic/elasticsearch/pull/52250#pullrequestreview-358065278", "createdAt": "2020-02-13T09:28:17Z", "commit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwOToyODoxN1rOFpMi4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwOTo0Mzo0MFrOFpND2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MTQ3NA==", "bodyText": "Wondering if we can short-circuit here and not check for group actions. If the user can't sso then the groups will never be \"released\" as attributes to the SP so why check them and not return an empty list ? Do we foresee exposing this externally where such answers \"Can't login, but if they could they would be a viewer \" would be useful?", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378741474", "createdAt": "2020-02-13T09:28:17Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Determines what privileges a user has within a given {@link ServiceProviderPrivileges service}.\n+ */\n+public class UserPrivilegeResolver {\n+\n+    public class UserPrivileges {\n+        public final String principal;\n+        public final boolean hasAccess;\n+        public final Set<String> groups;\n+\n+        public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n+            this.principal = principal;\n+            this.hasAccess = hasAccess;\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"{\" + principal + \", \" + hasAccess + \", \" + groups + \"}\";\n+        }\n+    }\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final Client client;\n+    private final SecurityContext securityContext;\n+\n+    public UserPrivilegeResolver(Client client, SecurityContext securityContext) {\n+        this.client = client;\n+        this.securityContext = securityContext;\n+    }\n+\n+    /**\n+     * Resolves the user's privileges for the specified service.\n+     * Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n+     */\n+    public void resolve(ServiceProviderPrivileges service, ActionListener<UserPrivileges> listener) {\n+        HasPrivilegesRequest request = new HasPrivilegesRequest();\n+        final String username = securityContext.getUser().principal();\n+        request.username(username);\n+        request.applicationPrivileges(buildResourcePrivilege(service));\n+        client.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(\n+            response -> {\n+                logger.debug(\"Checking access for user [{}] to application [{}] resource [{}]\",\n+                    username, service.getApplicationName(), service.getResource());\n+                UserPrivileges privileges = buildResult(response, service);\n+                logger.debug(\"Resolved service privileges [{}]\", privileges);\n+                listener.onResponse(privileges);\n+            },\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private UserPrivileges buildResult(HasPrivilegesResponse response, ServiceProviderPrivileges service) {\n+        final Set<ResourcePrivileges> appPrivileges = response.getApplicationPrivileges().get(service.getApplicationName());\n+        if (appPrivileges == null || appPrivileges.isEmpty()) {\n+            return new UserPrivileges(response.getUsername(), false, Set.of());\n+        }\n+        final boolean hasAccess = checkAccess(appPrivileges, service.getLoginAction(), service.getResource());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MzMxMQ==", "bodyText": "Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n\nShould we also check here so that we don't throw an NPE on .principal() ?", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378743311", "createdAt": "2020-02-13T09:31:31Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Determines what privileges a user has within a given {@link ServiceProviderPrivileges service}.\n+ */\n+public class UserPrivilegeResolver {\n+\n+    public class UserPrivileges {\n+        public final String principal;\n+        public final boolean hasAccess;\n+        public final Set<String> groups;\n+\n+        public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n+            this.principal = principal;\n+            this.hasAccess = hasAccess;\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"{\" + principal + \", \" + hasAccess + \", \" + groups + \"}\";\n+        }\n+    }\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final Client client;\n+    private final SecurityContext securityContext;\n+\n+    public UserPrivilegeResolver(Client client, SecurityContext securityContext) {\n+        this.client = client;\n+        this.securityContext = securityContext;\n+    }\n+\n+    /**\n+     * Resolves the user's privileges for the specified service.\n+     * Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n+     */\n+    public void resolve(ServiceProviderPrivileges service, ActionListener<UserPrivileges> listener) {\n+        HasPrivilegesRequest request = new HasPrivilegesRequest();\n+        final String username = securityContext.getUser().principal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0ODY3MA==", "bodyText": "Duplicate of testResolveSsoWithNoGroups", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378748670", "createdAt": "2020-02-13T09:41:24Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/test/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolverTests.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.junit.Before;\n+import org.mockito.Mockito;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.emptyIterable;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.same;\n+\n+public class UserPrivilegeResolverTests extends ESTestCase {\n+\n+    private Client client;\n+    private SecurityContext securityContext;\n+    private UserPrivilegeResolver resolver;\n+\n+    @Before\n+    public void setupTest() {\n+        client = Mockito.mock(Client.class);\n+        securityContext = new SecurityContext(Settings.EMPTY, new ThreadContext(Settings.EMPTY));\n+        resolver = new UserPrivilegeResolver(client, securityContext);\n+    }\n+\n+    public void testResolveZeroAccess() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        setupUser(username);\n+        setupHasPrivileges(username, app);\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, \"cluster:\" + randomLong(), \"action:idp:sso\",\n+            Map.of(\"viewer\", \"role:cluster:view\", \"admin\", \"role:cluster:admin\")), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(false));\n+        assertThat(privileges.groups, emptyIterable());\n+    }\n+\n+    public void testResolveSsoWithNoGroupsDefined() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app, access(resource, loginAction, true));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of()), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, emptyIterable());\n+    }\n+\n+    public void testResolveSsoWithNoGroupAccess() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, true), access(resource, viewerAction, false), access(resource, adminAction, false));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of(\"viewer\", viewerAction, \"admin\", adminAction)), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, emptyIterable());\n+    }\n+\n+    public void testResolveSsoWithSingleGroup() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, true), access(resource, viewerAction, true), access(resource, adminAction, false));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of(\"viewer\", viewerAction, \"admin\", adminAction)), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, containsInAnyOrder(\"viewer\"));\n+    }\n+\n+    public void testResolveSsoWithMultipleGroup() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+        final String operatorAction = \"role:cluster:operator\";\n+        final String monitorAction = \"role:cluster:monitor\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, true),\n+            access(resource, viewerAction, false),\n+            access(resource, adminAction, false),\n+            access(resource, operatorAction, true),\n+            access(resource, monitorAction, true)\n+        );\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction,\n+            Map.of(\"viewer\", viewerAction, \"admin\", adminAction, \"operator\", operatorAction, \"monitor\", monitorAction)),\n+            future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(true));\n+        assertThat(privileges.groups, containsInAnyOrder(\"operator\", \"monitor\"));\n+    }\n+\n+    public void testResolveGroupAccessButNoSsoPrivilege() throws Exception {\n+        final String username = randomAlphaOfLengthBetween(4, 12);\n+        final String app = randomAlphaOfLengthBetween(3, 8);\n+        final String resource = \"cluster:\" + MessageDigests.toHexString(randomByteArrayOfLength(16));\n+        final String loginAction = \"action:idp:sso\";\n+        final String viewerAction = \"role:cluster:view\";\n+        final String adminAction = \"role:cluster:admin\";\n+\n+        setupUser(username);\n+        setupHasPrivileges(username, app,\n+            access(resource, loginAction, false), access(resource, viewerAction, true), access(resource, adminAction, false));\n+\n+        final PlainActionFuture<UserPrivilegeResolver.UserPrivileges> future = new PlainActionFuture<>();\n+        resolver.resolve(service(app, resource, loginAction, Map.of(\"viewer\", viewerAction, \"admin\", adminAction)), future);\n+        final UserPrivilegeResolver.UserPrivileges privileges = future.get();\n+        assertThat(privileges.principal, equalTo(username));\n+        assertThat(privileges.hasAccess, equalTo(false));\n+        assertThat(privileges.groups, containsInAnyOrder(\"viewer\"));\n+    }\n+\n+    public void testResolveSsoWithNoGroups() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0OTkxMw==", "bodyText": "Possibly add a test where the user is allowed an action in a resource and we check for the same action in another resource.", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r378749913", "createdAt": "2020-02-13T09:43:40Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/test/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolverTests.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.junit.Before;\n+import org.mockito.Mockito;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.emptyIterable;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.same;\n+\n+public class UserPrivilegeResolverTests extends ESTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8768552a7484b4cc5bc38b692b8f9181f527b74c", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/8768552a7484b4cc5bc38b692b8f9181f527b74c", "committedDate": "2020-02-14T03:42:13Z", "message": "Address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTEyNjA0", "url": "https://github.com/elastic/elasticsearch/pull/52250#pullrequestreview-359912604", "createdAt": "2020-02-17T18:30:51Z", "commit": {"oid": "8768552a7484b4cc5bc38b692b8f9181f527b74c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxODozMDo1MVrOFqtFMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxODozNToxOFrOFqtKIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMzEyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.groups = Set.copyOf(Objects.requireNonNull(groups, \"groups may not br null\"));\n          \n          \n            \n                        this.groups = Set.copyOf(Objects.requireNonNull(groups, \"groups may not be null\"));", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r380323120", "createdAt": "2020-02-17T18:30:51Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -28,20 +29,37 @@\n  */\n public class UserPrivilegeResolver {\n \n-    public class UserPrivileges {\n+    public static class UserPrivileges {\n         public final String principal;\n         public final boolean hasAccess;\n         public final Set<String> groups;\n \n         public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n-            this.principal = principal;\n+            this.principal = Objects.requireNonNull(principal, \"principal may not be null\");\n+            if (hasAccess == false && groups.isEmpty() == false) {\n+                throw new IllegalArgumentException(\"a user without access ([\" + hasAccess + \"]) may not have groups ([\" + groups + \"])\");\n+            }\n             this.hasAccess = hasAccess;\n-            this.groups = groups;\n+            this.groups = Set.copyOf(Objects.requireNonNull(groups, \"groups may not br null\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8768552a7484b4cc5bc38b692b8f9181f527b74c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyNDM4NQ==", "bodyText": "I agree that we need to be explicit and somewhat descriptive in the logs eitherway. Even if we did return the group actions we would need to be explicit that the issue is with the login action otherwise the user/admin might think that they just miss the \"necessary\" group", "url": "https://github.com/elastic/elasticsearch/pull/52250#discussion_r380324385", "createdAt": "2020-02-17T18:35:18Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/privileges/UserPrivilegeResolver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.privileges;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Determines what privileges a user has within a given {@link ServiceProviderPrivileges service}.\n+ */\n+public class UserPrivilegeResolver {\n+\n+    public class UserPrivileges {\n+        public final String principal;\n+        public final boolean hasAccess;\n+        public final Set<String> groups;\n+\n+        public UserPrivileges(String principal, boolean hasAccess, Set<String> groups) {\n+            this.principal = principal;\n+            this.hasAccess = hasAccess;\n+            this.groups = groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"{\" + principal + \", \" + hasAccess + \", \" + groups + \"}\";\n+        }\n+    }\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final Client client;\n+    private final SecurityContext securityContext;\n+\n+    public UserPrivilegeResolver(Client client, SecurityContext securityContext) {\n+        this.client = client;\n+        this.securityContext = securityContext;\n+    }\n+\n+    /**\n+     * Resolves the user's privileges for the specified service.\n+     * Requires that the active user is set in the {@link org.elasticsearch.xpack.core.security.SecurityContext}.\n+     */\n+    public void resolve(ServiceProviderPrivileges service, ActionListener<UserPrivileges> listener) {\n+        HasPrivilegesRequest request = new HasPrivilegesRequest();\n+        final String username = securityContext.getUser().principal();\n+        request.username(username);\n+        request.applicationPrivileges(buildResourcePrivilege(service));\n+        client.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(\n+            response -> {\n+                logger.debug(\"Checking access for user [{}] to application [{}] resource [{}]\",\n+                    username, service.getApplicationName(), service.getResource());\n+                UserPrivileges privileges = buildResult(response, service);\n+                logger.debug(\"Resolved service privileges [{}]\", privileges);\n+                listener.onResponse(privileges);\n+            },\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private UserPrivileges buildResult(HasPrivilegesResponse response, ServiceProviderPrivileges service) {\n+        final Set<ResourcePrivileges> appPrivileges = response.getApplicationPrivileges().get(service.getApplicationName());\n+        if (appPrivileges == null || appPrivileges.isEmpty()) {\n+            return new UserPrivileges(response.getUsername(), false, Set.of());\n+        }\n+        final boolean hasAccess = checkAccess(appPrivileges, service.getLoginAction(), service.getResource());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0MTQ3NA=="}, "originalCommit": {"oid": "9f727f8fc5024bee6f4f759fac99a30336ee8fb9"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80ec25b97aeb4a77ff3f5c4a279f00c3fcadc90a", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/80ec25b97aeb4a77ff3f5c4a279f00c3fcadc90a", "committedDate": "2020-02-18T04:28:22Z", "message": "Fix typo in error message\n\nCo-Authored-By: Ioannis Kakavas <ikakavas@protonmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2601, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}