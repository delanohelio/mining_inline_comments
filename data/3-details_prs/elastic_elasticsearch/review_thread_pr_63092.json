{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NjY2NzE2", "number": 63092, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNToyMzowNVrOEpUYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzozMTowMFrOEpWY3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzYwOTk2OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/GetDataFrameAnalyticsRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNToyMzowNVrOHa65kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTo0Njo1NlrOHbGmrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MDAzNA==", "bodyText": "BTW, is there any reason for ALLOW_NO_MATCH to be ParseField rather than String?", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497990034", "createdAt": "2020-10-01T05:23:05Z", "author": {"login": "przemekwitek"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/GetDataFrameAnalyticsRequest.java", "diffHunk": "@@ -33,10 +33,12 @@\n public class GetDataFrameAnalyticsRequest implements Validatable {\n \n     public static final ParseField ALLOW_NO_MATCH = new ParseField(\"allow_no_match\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MTgwNQ==", "bodyText": "probably not, but just didn't touch the existing field :)", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498181805", "createdAt": "2020-10-01T11:46:56Z", "author": {"login": "benwtrent"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/GetDataFrameAnalyticsRequest.java", "diffHunk": "@@ -33,10 +33,12 @@\n public class GetDataFrameAnalyticsRequest implements Validatable {\n \n     public static final ParseField ALLOW_NO_MATCH = new ParseField(\"allow_no_match\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MDAzNA=="}, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzYyNTQ5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNTozMTo0NlrOHa7Cgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNTozMTo0NlrOHa7Cgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MjMyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else { // Don't include random defaults or unnecessary defauls in export\n          \n          \n            \n                    } else { // Don't include random defaults or unnecessary defaults in export", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497992322", "createdAt": "2020-10-01T05:31:46Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzYzNjY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNTozNzozMFrOHa7Iug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMjo0ODoyN1rOHbIwpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA==", "bodyText": "So this else block is not for making the retrieved config \"puttable\" but it does something more (clears defaults).\nI'm wondering what happens when we ever change the code for generating the default. Then the config is indexed with default D1, then in the subsequent version we change the default to be D2 and then we retrieve the config for export and the default is not cleared (as it was the default in the past but no longer is). Is that a good behavior?", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497993914", "createdAt": "2020-10-01T05:37:30Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4Mjk0Mw==", "bodyText": "@przemekwitek a related question.\nWhat if the user didn't set their own chunking_config but when they cloned the datafeed, they DID change the aggregation information (maybe the date_histogram bucket size). Then when they try to PUT, the chunking config is now illegal.\nShould we allow this behavior?", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498182943", "createdAt": "2020-10-01T11:49:11Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA=="}, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxNzEyNg==", "bodyText": "Tough question. I guess it's better to stick to the promise that we are able to PUT the config obtained via GET with for_export...", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498217126", "createdAt": "2020-10-01T12:48:27Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA=="}, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzg0NTE2OnYy", "diffSide": "LEFT", "path": "docs/reference/ml/anomaly-detection/apis/get-datafeed.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzowMzoyN1rOHa9BOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzowMzoyN1rOHa9BOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAyNDc2Mg==", "bodyText": "It seems your editor auto-formatted the asciidoc files you touched. I've had it happen to me too when opening the asciidoc files in intelliJ, so I know edit them with other editors. I think it's worth reverting those unchanged lines to protect git history.", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498024762", "createdAt": "2020-10-01T07:03:27Z", "author": {"login": "dimitris-athanasiou"}, "path": "docs/reference/ml/anomaly-detection/apis/get-datafeed.asciidoc", "diffHunk": "@@ -19,7 +19,7 @@ Retrieves configuration information for {dfeeds}.\n \n `GET _ml/datafeeds/` +\n \n-`GET _ml/datafeeds/_all` ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzkxMTU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzoyMzoyMFrOHa9n0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzoyMzoyMFrOHa9n0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNDY0MA==", "bodyText": "We should have a single method that calculates the default query delay between this one and Builder.setDefaultQueryDelay", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498034640", "createdAt": "2020-10-01T07:23:20Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -473,26 +505,36 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n         builder.field(SCROLL_SIZE.getPreferredName(), scrollSize);\n-        if (chunkingConfig != null) {\n-            builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n-        }\n-        if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(HEADERS.getPreferredName(), headers);\n-        }\n         if (delayedDataCheckConfig != null) {\n             builder.field(DELAYED_DATA_CHECK_CONFIG.getPreferredName(), delayedDataCheckConfig);\n         }\n         if (maxEmptySearches != null) {\n             builder.field(MAX_EMPTY_SEARCHES.getPreferredName(), maxEmptySearches);\n         }\n-        builder.startObject(INDICES_OPTIONS.getPreferredName());\n-        indicesOptions.toXContent(builder, params);\n-        builder.endObject();\n-\n         builder.endObject();\n         return builder;\n     }\n \n+    private TimeValue defaultRandomQueryDelay() {\n+        Random random = new Random(jobId.hashCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzkyNjMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzoyNzozMVrOHa9wjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo0NTowMVrOHbN4nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw==", "bodyText": "Is there a benefit to not always return the query? The query is integral to the behaviour of the datafeed. Even in the improbable scenario where we change the default query in a future release, it'd be a weird surprise to get a datafeed for_export from a previous version cluster and put it in a newer version to find out different docs are picked because the default query changed.", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498036877", "createdAt": "2020-10-01T07:27:31Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export\n+            if (queryDelay.equals(defaultRandomQueryDelay()) == false) {\n+                builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            }\n+            // This is always \"match_all\"\n+            if (queryProvider.equals(QueryProvider.defaultQuery()) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MzkxNw==", "bodyText": "put it in a newer version to find out different docs are picked because the default query changed.\n\nIf we change the default query to EXCLUDE docs, I think that is a huge thing and should probably never be done.\nI can happily include the query here, but it did seem unnecessary to me.", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498183917", "createdAt": "2020-10-01T11:50:58Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export\n+            if (queryDelay.equals(defaultRandomQueryDelay()) == false) {\n+                builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            }\n+            // This is always \"match_all\"\n+            if (queryProvider.equals(QueryProvider.defaultQuery()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw=="}, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwMTA4NQ==", "bodyText": "Agreed that changing the default query sounds hard to justify :-)\nBut I do think we should include the query. We return it in get, so we might as well also return it for_export.", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498301085", "createdAt": "2020-10-01T14:45:01Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export\n+            if (queryDelay.equals(defaultRandomQueryDelay()) == false) {\n+                builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            }\n+            // This is always \"match_all\"\n+            if (queryProvider.equals(QueryProvider.defaultQuery()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw=="}, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzkzODg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzozMTowMFrOHa934Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzozMTowMFrOHa934Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzODc1Mw==", "bodyText": "Same here, let's avoid duplication on the default calculation. We can reuse this in the Builder.setDefaultChunkingConfig.", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498038753", "createdAt": "2020-10-01T07:31:00Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -473,26 +505,36 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n         builder.field(SCROLL_SIZE.getPreferredName(), scrollSize);\n-        if (chunkingConfig != null) {\n-            builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n-        }\n-        if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(HEADERS.getPreferredName(), headers);\n-        }\n         if (delayedDataCheckConfig != null) {\n             builder.field(DELAYED_DATA_CHECK_CONFIG.getPreferredName(), delayedDataCheckConfig);\n         }\n         if (maxEmptySearches != null) {\n             builder.field(MAX_EMPTY_SEARCHES.getPreferredName(), maxEmptySearches);\n         }\n-        builder.startObject(INDICES_OPTIONS.getPreferredName());\n-        indicesOptions.toXContent(builder, params);\n-        builder.endObject();\n-\n         builder.endObject();\n         return builder;\n     }\n \n+    private TimeValue defaultRandomQueryDelay() {\n+        Random random = new Random(jobId.hashCode());\n+        long delayMillis = random.longs(Builder.MIN_DEFAULT_QUERY_DELAY.millis(), Builder.MAX_DEFAULT_QUERY_DELAY.millis())\n+            .findFirst().getAsLong();\n+        return TimeValue.timeValueMillis(delayMillis);\n+    }\n+\n+    private ChunkingConfig defaultChunkingConfig() {\n+        if (aggProvider == null || aggProvider.getParsedAggs() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3330, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}