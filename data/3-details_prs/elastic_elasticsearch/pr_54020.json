{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNjIwMDc0", "number": 54020, "title": "EQL: Add wildcard function", "bodyText": "Resolves #53999\n\nAdded wildcard variadic function\nAdded variadic builder QL for single argument + variadic\nAdded method to wildcard function to convert to an Or of Likes, and updated Optimizer rule to uses that.\nUsing makePipe, doProcess, etc on the converted Or of Likes.", "createdAt": "2020-03-23T20:23:35Z", "url": "https://github.com/elastic/elasticsearch/pull/54020", "merged": true, "mergeCommit": {"oid": "f04fb68b43313420ed1f419da80c1c756ee95d7e"}, "closed": true, "closedAt": "2020-04-03T16:14:33Z", "author": {"login": "rw-access"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQkMW2gH2gAyMzkyNjIwMDc0OmMwYzc5OTVlZDVhMDEyNjliY2QyOGZlNjhlZmQyOGUwMTU0OTRmYjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTx7DzAFqTM4Njc1MjczMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0c7995ed5a01269bcd28fe68efd28e015494fb0", "committedDate": "2020-03-23T20:18:57Z", "message": "EQL: Add wildcard function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODQxMTc2", "url": "https://github.com/elastic/elasticsearch/pull/54020#pullrequestreview-379841176", "createdAt": "2020-03-23T21:37:02Z", "commit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozNzowMlrOF6ZB0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyODo1MVrOF6acuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw==", "bodyText": "java.* packages should be imported - the only reason when a class should be fully qualified if there's a class name clash.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396771793", "createdAt": "2020-03-23T21:37:02Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA==", "bodyText": "Easier to do Arrays.asList(args..) directly in the constructor", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772168", "createdAt": "2020-03-23T21:37:52Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(source, getArguments(field, patterns));\n          \n          \n            \n                    super(source, Arrays.asList(field, patterns));\n          \n      \n    \n    \n  \n\nlike the rest of the subclasses.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772806", "createdAt": "2020-03-23T21:39:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MjgxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean foldable = field.foldable();\n          \n          \n            \n                    for (Expression p : patterns) {\n          \n          \n            \n                        foldable = foldable && p.foldable();\n          \n          \n            \n                    }\n          \n          \n            \n                    return foldable;\n          \n          \n            \n                    return Expressions.foldable(arguments());", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396782812", "createdAt": "2020-03-23T22:00:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        boolean foldable = field.foldable();\n+        for (Expression p : patterns) {\n+            foldable = foldable && p.foldable();\n+        }\n+        return foldable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Expression asLikes = asLikes();\n          \n          \n            \n                    if (asLikes instanceof Like) {\n          \n          \n            \n                        return ((Like) asLikes).makePipe();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return ((Or) asLikes).makePipe();\n          \n          \n            \n                    }\n          \n          \n            \n                return asLike().makePipe();", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396783925", "createdAt": "2020-03-23T22:03:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ==", "bodyText": "Since it's always a Like or an Or, return a ScalarFunction instead. Also the method should be private.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784265", "createdAt": "2020-03-23T22:04:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDM5NQ==", "bodyText": "Extra new line.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784395", "createdAt": "2020-03-23T22:04:29Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4ODc4Mg==", "bodyText": "Please implement the methods in the order of the super class (which is not alphabetical) which roughly is:\nconstructor\nnodeInfo/replaceChildren\ntype resolution\ngetters\ndatatype/nullable\nfoldable/fold\nscripting & co\nequals/hash", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396788782", "createdAt": "2020-03-23T22:14:36Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjI1MA==", "bodyText": "Since the optimizer is replacing this function, this method will never be called but rather Like and Or directly", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792250", "createdAt": "2020-03-23T22:22:23Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjUxMw==", "bodyText": "This doesn't seem to be needed and in fact the implementation should be throw new EqlIllegalArgumentException(\"should not call this method\")", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792513", "createdAt": "2020-03-23T22:22:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MzEwMA==", "bodyText": "Make the class abstract or better yet final + private constructor to prevent instantiation/inheritance.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396793100", "createdAt": "2020-03-23T22:24:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/utils/StringUtils.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.utils;\n+\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.LikePattern;\n+\n+public class StringUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA==", "bodyText": "How many arguments does wildcard expect?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795034", "createdAt": "2020-03-23T22:28:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -421,4 +421,26 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     protected interface CastFunctionBuilder<T> {\n         T build(Source source, Expression expression, DataType dataType);\n     }\n+\n+    @SuppressWarnings(\"overloads\")  // These are ambiguous if you aren't using ctor references but we always do\n+    public static <T extends Function> FunctionDefinition def(Class<T> function,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA==", "bodyText": "Why?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795064", "createdAt": "2020-03-23T22:28:51Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/logical/BinaryLogic.java", "diffHunk": "@@ -34,7 +34,7 @@ protected TypeResolution resolveInputType(Expression e, Expressions.ParamOrdinal\n     }\n \n     @Override\n-    protected Pipe makePipe() {\n+    public Pipe makePipe() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dea1f7baa1fe1cac55fc65e5246af907cb446894", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/dea1f7baa1fe1cac55fc65e5246af907cb446894", "committedDate": "2020-03-23T22:59:54Z", "message": "EQL: Cleanup Wildcard.getArguments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d87361de121acfc972776d8c173531a40fe7a8a7", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/d87361de121acfc972776d8c173531a40fe7a8a7", "committedDate": "2020-03-23T23:20:48Z", "message": "EQL: Cleanup Wildcard and rearrange methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3826eac1904ef22a57b15fa0243fd5fcb497af3e", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/3826eac1904ef22a57b15fa0243fd5fcb497af3e", "committedDate": "2020-03-23T23:23:43Z", "message": "EQL: Wildcard newline lint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f93d2975112e81d513b6ed835eded45485220846", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/f93d2975112e81d513b6ed835eded45485220846", "committedDate": "2020-03-23T23:37:51Z", "message": "EQL: Make StringUtils function final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78f4fbdb1c342c729a684e9758994e14c18d367c", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/78f4fbdb1c342c729a684e9758994e14c18d367c", "committedDate": "2020-03-23T23:43:45Z", "message": "EQL: Make Wildcard.asLikes return ScalarFunction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c93b67c11694dcd2f10cdf5854e00a17192a1b74", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/c93b67c11694dcd2f10cdf5854e00a17192a1b74", "committedDate": "2020-03-24T15:02:59Z", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcard-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/169245d5d956f6ef65a598cecae15a4b5352a4a3", "committedDate": "2020-03-24T15:04:06Z", "message": "QL: Restore BinaryLogic.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDE3MTY1", "url": "https://github.com/elastic/elasticsearch/pull/54020#pullrequestreview-380417165", "createdAt": "2020-03-24T15:21:11Z", "commit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNToyMToxMVrOF61bDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzowNDo1MVrOF66XFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw==", "bodyText": "Isn't wildcard a \"string function\"? If so, it should belong to the FunctionDefinition array that, also, has substring in it. In SQL we were grouping these functions by their type: string, grouping, math, conditional, date etc.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397237007", "createdAt": "2020-03-24T15:21:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -17,14 +18,17 @@\n     public EqlFunctionRegistry() {\n         super(functions());\n     }\n-    \n+\n     private static FunctionDefinition[][] functions() {\n         return new FunctionDefinition[][] {\n         // Scalar functions\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n             },\n+            new FunctionDefinition[] {\n+                def(Wildcard.class, Wildcard::new, \"wildcard\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzODU4MQ==", "bodyText": "childrenResolved() == false", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397238581", "createdAt": "2020-03-24T15:23:16Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ==", "bodyText": "Shouldn't the field be, also, foldable? (ie return Expressions.foldable(children());)", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397243661", "createdAt": "2020-03-24T15:29:36Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Mjg5MA==", "bodyText": "I don't think isStringAndExact is correct here... \"exact\" refers to a field being of type keyword or having a sub-field of type keyword basically. isString should be enough imo.\nAlso, shouldn't the p.foldable() == false (comparison against variables basically) check be before this one?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397292890", "createdAt": "2020-03-24T16:31:28Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Njc5Ng==", "bodyText": "Since wildcard is converted to a bunch of LIKEs, I'm wondering if foldable() shouldn't fall back to the result of the wildcard -> LIKEs transformation foldable() functionality. Basically the Or.foldable().", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397296796", "createdAt": "2020-03-24T16:36:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw==", "bodyText": "Maybe move this method to org.elasticsearch.xpack.ql.util.CollectionUtils and make it more generic?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397303377", "createdAt": "2020-03-24T16:45:23Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asLikes().fold();\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.makePipe() should not be called directly\");\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.asScript() should not be called directly\");\n+    }\n+\n+    public ScalarFunction asLikes() {\n+        ScalarFunction result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static List<Expression> toArguments(Expression src, List<Expression> patterns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNDcwNQ==", "bodyText": "return e instanceof Wildcard ? ((Wildcard) e).asLikes() : e; as a shorter (hopefully more elegant) variant?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397304705", "createdAt": "2020-03-24T16:46:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -60,6 +62,20 @@ public LogicalPlan optimize(LogicalPlan verified) {\n     }\n \n \n+    private static class ReplaceWildcardFunction extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                if (e instanceof Wildcard) {\n+                    e = ((Wildcard) e).asLikes();\n+                }\n+\n+                return e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzkxMQ==", "bodyText": "I think there are other error messages to check with wildcard: the fact that the field needs to be string and exact and, also, that the \"patterns\" should be all strings, no?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397317911", "createdAt": "2020-03-24T17:04:51Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -22,4 +24,19 @@ public void testPropertyEquationInClauseFilterUnsupported() {\n         String msg = e.getMessage();\n         assertEquals(\"Line 1:52: Comparisons against variables are not (currently) supported; offender [parent_process_name] in [==]\", msg);\n     }\n+\n+    public void testWildcardNotEnoughArguments() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c7e1475a2962cb62776fe4897f6222dba390cc2", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/5c7e1475a2962cb62776fe4897f6222dba390cc2", "committedDate": "2020-03-24T20:13:15Z", "message": "Merge branch 'master' into eql/wildcard-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e12a60c5f36e263062a7ed6679e75b122f93c721", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/e12a60c5f36e263062a7ed6679e75b122f93c721", "committedDate": "2020-03-24T20:27:15Z", "message": "EQL: Add Wildcard PR feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f818f35330e0be8e9066ccfb47d95846975abd6", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/9f818f35330e0be8e9066ccfb47d95846975abd6", "committedDate": "2020-03-24T20:24:11Z", "message": "EQL: Add Wildcard PR feedback"}, "afterCommit": {"oid": "e12a60c5f36e263062a7ed6679e75b122f93c721", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/e12a60c5f36e263062a7ed6679e75b122f93c721", "committedDate": "2020-03-24T20:27:15Z", "message": "EQL: Add Wildcard PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "502ca88d0430d8c252e0c7c2b63d1d259f9dd4e0", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/502ca88d0430d8c252e0c7c2b63d1d259f9dd4e0", "committedDate": "2020-03-24T21:03:44Z", "message": "EQL: Add Wildcard verification tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90dc8e035aed864c4dbd247b94301412f1ae4fb1", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/90dc8e035aed864c4dbd247b94301412f1ae4fb1", "committedDate": "2020-03-24T21:25:10Z", "message": "EQL: Switch wildcard to isFoldable test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d482c472d05af7220ce1896e323deb30769b05f8", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/d482c472d05af7220ce1896e323deb30769b05f8", "committedDate": "2020-03-24T21:52:53Z", "message": "EQL: Change wildcard test to numeric field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "285582f53796dbbafda6c55e5fde528c6bffa740", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/285582f53796dbbafda6c55e5fde528c6bffa740", "committedDate": "2020-03-25T14:53:06Z", "message": "EQL: Remove Wildcard.get_arguments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzOTU5MzUx", "url": "https://github.com/elastic/elasticsearch/pull/54020#pullrequestreview-383959351", "createdAt": "2020-03-30T15:15:22Z", "commit": {"oid": "d482c472d05af7220ce1896e323deb30769b05f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167c13a954a21809fce72c602d1c9aee0efa1790", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/167c13a954a21809fce72c602d1c9aee0efa1790", "committedDate": "2020-03-30T20:21:20Z", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcard-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7", "committedDate": "2020-04-02T14:36:38Z", "message": "Merge branch 'master' into eql/wildcard-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NzUyNzMw", "url": "https://github.com/elastic/elasticsearch/pull/54020#pullrequestreview-386752730", "createdAt": "2020-04-02T20:00:30Z", "commit": {"oid": "d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1818, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}