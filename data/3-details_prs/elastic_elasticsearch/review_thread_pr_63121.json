{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2MTkyMDAz", "number": 63121, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDowNjoxMlrOEpfbMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo0NDoyOVrOEpiO9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTQxOTM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/predicate/operator/comparison/InsensitiveBinaryComparisonProcessorTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDowNjoxMlrOHbMEjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMDozMTowN1rOHbZ2Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MTM3Mw==", "bodyText": "Does it make sense to test String against numeric?", "url": "https://github.com/elastic/elasticsearch/pull/63121#discussion_r498271373", "createdAt": "2020-10-01T14:06:12Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/predicate/operator/comparison/InsensitiveBinaryComparisonProcessorTests.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.predicate.operator.comparison;\n+\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.common.io.stream.Writeable.Reader;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+import org.elasticsearch.xpack.ql.TestUtils;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.ConstantProcessor;\n+import org.elasticsearch.xpack.ql.expression.processor.Processors;\n+\n+import static org.elasticsearch.xpack.eql.EqlTestUtils.seq;\n+import static org.elasticsearch.xpack.eql.EqlTestUtils.sneq;\n+import static org.elasticsearch.xpack.ql.tree.Source.EMPTY;\n+\n+public class InsensitiveBinaryComparisonProcessorTests extends AbstractWireSerializingTestCase<InsensitiveBinaryComparisonProcessor> {\n+    public static InsensitiveBinaryComparisonProcessor randomProcessor() {\n+        return new InsensitiveBinaryComparisonProcessor(\n+            new ConstantProcessor(randomLong()),\n+            new ConstantProcessor(randomLong()),\n+            randomFrom(InsensitiveBinaryComparisonProcessor.InsensitiveBinaryComparisonOperation.values()));\n+    }\n+\n+    @Override\n+    protected InsensitiveBinaryComparisonProcessor createTestInstance() {\n+        return randomProcessor();\n+    }\n+\n+    @Override\n+    protected Reader<InsensitiveBinaryComparisonProcessor> instanceReader() {\n+        return InsensitiveBinaryComparisonProcessor::new;\n+    }\n+\n+    @Override\n+    protected NamedWriteableRegistry getNamedWriteableRegistry() {\n+        return new NamedWriteableRegistry(Processors.getNamedWriteables());\n+    }\n+\n+    public void testStringEq() {\n+        assertEquals(true, p(seq(l(\"a\"), l(\"a\"))));\n+        assertEquals(true, p(seq(l(\"A\"), l(\"a\"))));\n+        assertEquals(true, p(seq(l(\"aBcD\"), l(\"AbCd\"))));\n+        assertEquals(true, p(seq(l(\"abc\"), l(\"abc\"))));\n+\n+        assertEquals(false, p(seq(l(\"abc\"), l(\"cba\"))));\n+    }\n+\n+    public void testRegularEquals() {\n+        assertEquals(true, p(seq(l(12), l(12))));\n+        assertEquals(true, p(seq(l(2f), l(2f))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17b485242d5bc5c6ca5b98f505c083baaa7b0ca"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5NzA5MQ==", "bodyText": "Not really since the validation would fail. Yet I've added a test for it and put another check inside the operation just in case.", "url": "https://github.com/elastic/elasticsearch/pull/63121#discussion_r498497091", "createdAt": "2020-10-01T20:31:07Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/expression/predicate/operator/comparison/InsensitiveBinaryComparisonProcessorTests.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.predicate.operator.comparison;\n+\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.common.io.stream.Writeable.Reader;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+import org.elasticsearch.xpack.ql.TestUtils;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.ConstantProcessor;\n+import org.elasticsearch.xpack.ql.expression.processor.Processors;\n+\n+import static org.elasticsearch.xpack.eql.EqlTestUtils.seq;\n+import static org.elasticsearch.xpack.eql.EqlTestUtils.sneq;\n+import static org.elasticsearch.xpack.ql.tree.Source.EMPTY;\n+\n+public class InsensitiveBinaryComparisonProcessorTests extends AbstractWireSerializingTestCase<InsensitiveBinaryComparisonProcessor> {\n+    public static InsensitiveBinaryComparisonProcessor randomProcessor() {\n+        return new InsensitiveBinaryComparisonProcessor(\n+            new ConstantProcessor(randomLong()),\n+            new ConstantProcessor(randomLong()),\n+            randomFrom(InsensitiveBinaryComparisonProcessor.InsensitiveBinaryComparisonOperation.values()));\n+    }\n+\n+    @Override\n+    protected InsensitiveBinaryComparisonProcessor createTestInstance() {\n+        return randomProcessor();\n+    }\n+\n+    @Override\n+    protected Reader<InsensitiveBinaryComparisonProcessor> instanceReader() {\n+        return InsensitiveBinaryComparisonProcessor::new;\n+    }\n+\n+    @Override\n+    protected NamedWriteableRegistry getNamedWriteableRegistry() {\n+        return new NamedWriteableRegistry(Processors.getNamedWriteables());\n+    }\n+\n+    public void testStringEq() {\n+        assertEquals(true, p(seq(l(\"a\"), l(\"a\"))));\n+        assertEquals(true, p(seq(l(\"A\"), l(\"a\"))));\n+        assertEquals(true, p(seq(l(\"aBcD\"), l(\"AbCd\"))));\n+        assertEquals(true, p(seq(l(\"abc\"), l(\"abc\"))));\n+\n+        assertEquals(false, p(seq(l(\"abc\"), l(\"cba\"))));\n+    }\n+\n+    public void testRegularEquals() {\n+        assertEquals(true, p(seq(l(12), l(12))));\n+        assertEquals(true, p(seq(l(2f), l(2f))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MTM3Mw=="}, "originalCommit": {"oid": "b17b485242d5bc5c6ca5b98f505c083baaa7b0ca"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTg3NTkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryTranslator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo0MzozN1rOHbQhpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo0MzozN1rOHbQhpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0NDM1OQ==", "bodyText": "Only if you make any other changes to this PR, I think this method should be placed after doTranslate.", "url": "https://github.com/elastic/elasticsearch/pull/63121#discussion_r498344359", "createdAt": "2020-10-01T15:43:37Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryTranslator.java", "diffHunk": "@@ -64,6 +72,50 @@ public static Query toQuery(Expression e, TranslatorHandler handler) {\n         throw new QlIllegalArgumentException(\"Don't know how to translate {} {}\", e.nodeName(), e);\n     }\n \n+    public static class InsensitiveBinaryComparisons extends ExpressionTranslator<InsensitiveBinaryComparison> {\n+\n+        @Override\n+        protected Query asQuery(InsensitiveBinaryComparison bc, TranslatorHandler handler) {\n+            return doTranslate(bc, handler);\n+        }\n+\n+        public static void checkInsensitiveComparison(InsensitiveBinaryComparison bc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17b485242d5bc5c6ca5b98f505c083baaa7b0ca"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTg3OTU3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryTranslator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo0NDoyOVrOHbQkEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo0NDoyOVrOHbQkEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0NDk3Ng==", "bodyText": "Query query = new TermQuery..... (meaning, these two lines should be placed on a single one instead.", "url": "https://github.com/elastic/elasticsearch/pull/63121#discussion_r498344976", "createdAt": "2020-10-01T15:44:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryTranslator.java", "diffHunk": "@@ -64,6 +72,50 @@ public static Query toQuery(Expression e, TranslatorHandler handler) {\n         throw new QlIllegalArgumentException(\"Don't know how to translate {} {}\", e.nodeName(), e);\n     }\n \n+    public static class InsensitiveBinaryComparisons extends ExpressionTranslator<InsensitiveBinaryComparison> {\n+\n+        @Override\n+        protected Query asQuery(InsensitiveBinaryComparison bc, TranslatorHandler handler) {\n+            return doTranslate(bc, handler);\n+        }\n+\n+        public static void checkInsensitiveComparison(InsensitiveBinaryComparison bc) {\n+            Check.isTrue(bc.right().foldable(),\n+                \"Line {}:{}: Comparisons against fields are not (currently) supported; offender [{}] in [{}]\",\n+                bc.right().sourceLocation().getLineNumber(), bc.right().sourceLocation().getColumnNumber(),\n+                Expressions.name(bc.right()), bc.symbol());\n+        }\n+\n+        public static Query doTranslate(InsensitiveBinaryComparison bc, TranslatorHandler handler) {\n+            checkInsensitiveComparison(bc);\n+            return handler.wrapFunctionQuery(bc, bc.left(), translate(bc, handler));\n+        }\n+\n+        private static Query translate(InsensitiveBinaryComparison bc, TranslatorHandler handler) {\n+            Source source = bc.source();\n+            String name = handler.nameOf(bc.left());\n+            Object value = valueOf(bc.right());\n+\n+            if (bc instanceof InsensitiveEquals || bc instanceof InsensitiveNotEquals) {\n+                if (bc.left() instanceof FieldAttribute) {\n+                    // equality should always be against an exact match\n+                    // (which is important for strings)\n+                    name = ((FieldAttribute) bc.left()).exactAttribute().name();\n+                }\n+                Query query;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17b485242d5bc5c6ca5b98f505c083baaa7b0ca"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3216, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}