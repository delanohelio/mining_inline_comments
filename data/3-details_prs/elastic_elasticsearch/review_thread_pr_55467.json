{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MTE3NDk4", "number": 55467, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoyMDozNlrOD5hkBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDo1NTozM1rOEE2KgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjQ1MzE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoyMDozNlrOGQ197w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowMzoxMFrOGSow7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw==", "bodyText": "The call to checkCompilationLimit() is no longer locked on the ScriptCache, we'll have to make this call safe.", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r420314607", "createdAt": "2020-05-05T18:20:36Z", "author": {"login": "stu-elastic"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae24c668a68496080b9990b978503590b79d9aca"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NTQzOQ==", "bodyText": "Yeah noticed that too that's why I added commit b55e8e3", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r422195439", "createdAt": "2020-05-08T15:03:10Z", "author": {"login": "mjmbischoff"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw=="}, "originalCommit": {"oid": "ae24c668a68496080b9990b978503590b79d9aca"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTE3MTg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDo1NTozM1rOGiudLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNDo0Nzo0N1rOGj1jaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ==", "bodyText": "Let's clean this up a bit by moving the try/catch from inside the lambda out to this level and avoid checking for RuntimeException.\ngit diff\ndiff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5..5d59a91b207 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.breaker.CircuitBreaker;\n import org.elasticsearch.common.breaker.CircuitBreakingException;\n import org.elasticsearch.common.cache.Cache;\n@@ -98,41 +97,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r439065901", "createdAt": "2020-06-11T20:55:33Z", "author": {"login": "stu-elastic"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();\n-                    compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    // Since the cache key is the script content itself we don't need to\n+                    // invalidate/check the cache if an indexed script changes.\n+                    scriptMetrics.onCompilation();\n+                    return compiledScript;\n                 } catch (ScriptException good) {\n                     // TODO: remove this try-catch completely, when all script engines have good exceptions!\n                     throw good; // its already good\n                 } catch (Exception exception) {\n                     throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n                             exception);\n                 }\n-\n-                // Since the cache key is the script content itself we don't need to\n-                // invalidate/check the cache if an indexed script changes.\n-                scriptMetrics.onCompilation();\n-                cache.put(cacheKey, compiledScript);\n+            }));\n+        } catch (ExecutionException executionException) {\n+            Throwable cause = executionException.getCause();\n+            if(cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else {\n+                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n+                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNzM3NQ==", "bodyText": "Yeah I went for the smallest delta, this looks cleaner.", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r440017375", "createdAt": "2020-06-15T08:38:49Z", "author": {"login": "mjmbischoff"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();\n-                    compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    // Since the cache key is the script content itself we don't need to\n+                    // invalidate/check the cache if an indexed script changes.\n+                    scriptMetrics.onCompilation();\n+                    return compiledScript;\n                 } catch (ScriptException good) {\n                     // TODO: remove this try-catch completely, when all script engines have good exceptions!\n                     throw good; // its already good\n                 } catch (Exception exception) {\n                     throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n                             exception);\n                 }\n-\n-                // Since the cache key is the script content itself we don't need to\n-                // invalidate/check the cache if an indexed script changes.\n-                scriptMetrics.onCompilation();\n-                cache.put(cacheKey, compiledScript);\n+            }));\n+        } catch (ExecutionException executionException) {\n+            Throwable cause = executionException.getCause();\n+            if(cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else {\n+                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n+                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ=="}, "originalCommit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIzMDc2Mw==", "bodyText": "Yeah I went for the smallest delta, this looks cleaner.\n\nTotally reasonable, just made sense to go a bit further for this one.", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r440230763", "createdAt": "2020-06-15T14:47:47Z", "author": {"login": "stu-elastic"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();\n-                    compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    // Since the cache key is the script content itself we don't need to\n+                    // invalidate/check the cache if an indexed script changes.\n+                    scriptMetrics.onCompilation();\n+                    return compiledScript;\n                 } catch (ScriptException good) {\n                     // TODO: remove this try-catch completely, when all script engines have good exceptions!\n                     throw good; // its already good\n                 } catch (Exception exception) {\n                     throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n                             exception);\n                 }\n-\n-                // Since the cache key is the script content itself we don't need to\n-                // invalidate/check the cache if an indexed script changes.\n-                scriptMetrics.onCompilation();\n-                cache.put(cacheKey, compiledScript);\n+            }));\n+        } catch (ExecutionException executionException) {\n+            Throwable cause = executionException.getCause();\n+            if(cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else {\n+                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n+                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ=="}, "originalCommit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2838, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}