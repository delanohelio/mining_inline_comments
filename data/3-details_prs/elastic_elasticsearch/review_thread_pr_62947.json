{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MDY4Nzk2", "number": 62947, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDoyNjowNVrOEqHrvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNTo0ODoxMlrOEz2hXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAxNTM0OnYy", "diffSide": "RIGHT", "path": "docs/reference/search/async-search.asciidoc", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDoyNjowNVrOHcJ9rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODowODozN1rOHocPJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTQyMQ==", "bodyText": "Can I identify an error from a successful completion?\nI think we could follow the same pattern as the rest of the API and expose is_partial and is_running.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r499285421", "createdAt": "2020-10-04T20:26:05Z", "author": {"login": "lizozom"}, "path": "docs/reference/search/async-search.asciidoc", "diffHunk": "@@ -222,6 +222,53 @@ override such value and extend the validity of the request. When this period\n expires, the search, if still running, is cancelled. If the search is\n completed, its saved results are deleted.\n \n+\n+[[get-async-search-status]]\n+==== Get async search status\n+The get async search status API, without retrieving search results, shows\n+only the status of a previously submitted async search request given its `id`.\n+If the {es} {security-features} are enabled, the access to the get async\n+search status API is restricted to the\n+<<built-in-roles, monitoring_user role>>.\n+\n+[source,console,id=get-async-search-status-example]\n+--------------------------------------------------\n+GET /_async_search/status/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\n+--------------------------------------------------\n+// TEST[continued s/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=/\\${body.id}/]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : true,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 188, <1>\n+      \"skipped\" : 0,\n+      \"failed\" : 0\n+  }\n+}\n+--------------------------------------------------\n+// TEST[skip: a sample output of a status of a running async search]\n+\n+<1> Indicates how many shards have executed the query so far.\n+\n+For an async search that has been completed, the status response has a shorter form\n+that includes only `id`, `is_running` and `expiration_time_in_millis` fields.\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTU1NA==", "bodyText": "I think having start_time_in_millis can be useful on the complete request.\nIf you have end_time_in_millis it would be even greater, for telemetry purposes.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r499285554", "createdAt": "2020-10-04T20:27:40Z", "author": {"login": "lizozom"}, "path": "docs/reference/search/async-search.asciidoc", "diffHunk": "@@ -222,6 +222,53 @@ override such value and extend the validity of the request. When this period\n expires, the search, if still running, is cancelled. If the search is\n completed, its saved results are deleted.\n \n+\n+[[get-async-search-status]]\n+==== Get async search status\n+The get async search status API, without retrieving search results, shows\n+only the status of a previously submitted async search request given its `id`.\n+If the {es} {security-features} are enabled, the access to the get async\n+search status API is restricted to the\n+<<built-in-roles, monitoring_user role>>.\n+\n+[source,console,id=get-async-search-status-example]\n+--------------------------------------------------\n+GET /_async_search/status/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\n+--------------------------------------------------\n+// TEST[continued s/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=/\\${body.id}/]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : true,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 188, <1>\n+      \"skipped\" : 0,\n+      \"failed\" : 0\n+  }\n+}\n+--------------------------------------------------\n+// TEST[skip: a sample output of a status of a running async search]\n+\n+<1> Indicates how many shards have executed the query so far.\n+\n+For an async search that has been completed, the status response has a shorter form\n+that includes only `id`, `is_running` and `expiration_time_in_millis` fields.\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTQyMQ=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMzk2Ng==", "bodyText": "I agree that we should also add the http status code of the search. Something like \"status\":  200 or \"status: 503\" in case an error occurred.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508413966", "createdAt": "2020-10-20T11:12:06Z", "author": {"login": "jimczi"}, "path": "docs/reference/search/async-search.asciidoc", "diffHunk": "@@ -222,6 +222,53 @@ override such value and extend the validity of the request. When this period\n expires, the search, if still running, is cancelled. If the search is\n completed, its saved results are deleted.\n \n+\n+[[get-async-search-status]]\n+==== Get async search status\n+The get async search status API, without retrieving search results, shows\n+only the status of a previously submitted async search request given its `id`.\n+If the {es} {security-features} are enabled, the access to the get async\n+search status API is restricted to the\n+<<built-in-roles, monitoring_user role>>.\n+\n+[source,console,id=get-async-search-status-example]\n+--------------------------------------------------\n+GET /_async_search/status/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\n+--------------------------------------------------\n+// TEST[continued s/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=/\\${body.id}/]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : true,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 188, <1>\n+      \"skipped\" : 0,\n+      \"failed\" : 0\n+  }\n+}\n+--------------------------------------------------\n+// TEST[skip: a sample output of a status of a running async search]\n+\n+<1> Indicates how many shards have executed the query so far.\n+\n+For an async search that has been completed, the status response has a shorter form\n+that includes only `id`, `is_running` and `expiration_time_in_millis` fields.\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTQyMQ=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NzcxOA==", "bodyText": "@lizozom @jimczi Thanks, this is addressed in 0775cf1.\nThe revised format is presented in this documentation, and also in the comment", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512167718", "createdAt": "2020-10-26T18:08:37Z", "author": {"login": "mayya-sharipova"}, "path": "docs/reference/search/async-search.asciidoc", "diffHunk": "@@ -222,6 +222,53 @@ override such value and extend the validity of the request. When this period\n expires, the search, if still running, is cancelled. If the search is\n completed, its saved results are deleted.\n \n+\n+[[get-async-search-status]]\n+==== Get async search status\n+The get async search status API, without retrieving search results, shows\n+only the status of a previously submitted async search request given its `id`.\n+If the {es} {security-features} are enabled, the access to the get async\n+search status API is restricted to the\n+<<built-in-roles, monitoring_user role>>.\n+\n+[source,console,id=get-async-search-status-example]\n+--------------------------------------------------\n+GET /_async_search/status/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\n+--------------------------------------------------\n+// TEST[continued s/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=/\\${body.id}/]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : true,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 188, <1>\n+      \"skipped\" : 0,\n+      \"failed\" : 0\n+  }\n+}\n+--------------------------------------------------\n+// TEST[skip: a sample output of a status of a running async search]\n+\n+<1> Indicates how many shards have executed the query so far.\n+\n+For an async search that has been completed, the status response has a shorter form\n+that includes only `id`, `is_running` and `expiration_time_in_millis` fields.\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTQyMQ=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDczMjI4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTowMDo1OVrOHk2vOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoxMDoxN1rOHocTNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzYwOQ==", "bodyText": "This method should be synchronized.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508407609", "createdAt": "2020-10-20T11:00:59Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2ODc1OA==", "bodyText": "Thanks Jim, good comment. I have made some variables volatile and I believe it doesn't need synchronization any more.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512168758", "createdAt": "2020-10-26T18:10:17Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzYwOQ=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDczNDY1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTowMTo0M1rOHk2wrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoxMTowNVrOHocU_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzk4MQ==", "bodyText": "We still need the number of shards, start time, ... I don't understand why the status would be reseted to 0 when the search is done ?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508407981", "createdAt": "2020-10-20T11:01:43Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {\n+        if (frozen == false) {\n+            return new AsyncStatusResponse(\n+                asyncExecutionId,\n+                startTime,\n+                expirationTime,\n+                finalResponse != null ? finalResponse.getTotalShards() : totalShards,\n+                finalResponse != null ? finalResponse.getSuccessfulShards() : successfulShards,\n+                finalResponse != null ? finalResponse.getSkippedShards() : skippedShards,\n+                finalResponse != null ? (finalResponse.getShardFailures() == null ? finalResponse.getShardFailures().length : 0) :\n+                    (queryFailures != null ? queryFailures.length() : 0)\n+            );\n+        } else {\n+            return getCompletedSearchStatusResponse(asyncExecutionId, expirationTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwODQ0OA==", "bodyText": "So I think you don't need to check frozen and just build the status from the finalResponse if it's available and from the partial stats otherwise.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508408448", "createdAt": "2020-10-20T11:02:31Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {\n+        if (frozen == false) {\n+            return new AsyncStatusResponse(\n+                asyncExecutionId,\n+                startTime,\n+                expirationTime,\n+                finalResponse != null ? finalResponse.getTotalShards() : totalShards,\n+                finalResponse != null ? finalResponse.getSuccessfulShards() : successfulShards,\n+                finalResponse != null ? finalResponse.getSkippedShards() : skippedShards,\n+                finalResponse != null ? (finalResponse.getShardFailures() == null ? finalResponse.getShardFailures().length : 0) :\n+                    (queryFailures != null ? queryFailures.length() : 0)\n+            );\n+        } else {\n+            return getCompletedSearchStatusResponse(asyncExecutionId, expirationTime);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzk4MQ=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2OTIxNQ==", "bodyText": "addressed in 0775cf1 with the new format for a completed status.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512169215", "createdAt": "2020-10-26T18:11:05Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,32 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+    AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {\n+        if (frozen == false) {\n+            return new AsyncStatusResponse(\n+                asyncExecutionId,\n+                startTime,\n+                expirationTime,\n+                finalResponse != null ? finalResponse.getTotalShards() : totalShards,\n+                finalResponse != null ? finalResponse.getSuccessfulShards() : successfulShards,\n+                finalResponse != null ? finalResponse.getSkippedShards() : skippedShards,\n+                finalResponse != null ? (finalResponse.getShardFailures() == null ? finalResponse.getShardFailures().length : 0) :\n+                    (queryFailures != null ? queryFailures.length() : 0)\n+            );\n+        } else {\n+            return getCompletedSearchStatusResponse(asyncExecutionId, expirationTime);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwNzk4MQ=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDc0Mzk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTowNDoyMVrOHk22bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoxNDozOVrOHocdCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwOTQ1Mw==", "bodyText": "Can you add an option on getTask instead to enable/disable the authentication  check ?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508409453", "createdAt": "2020-10-20T11:04:21Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "diffHunk": "@@ -252,6 +253,23 @@ public void deleteResponse(AsyncExecutionId asyncExecutionId,\n         return asyncTask;\n     }\n \n+    /**\n+     * Returns the {@link AsyncTask} if the provided <code>asyncTaskId</code>\n+     * is registered in the task manager, <code>null</code> otherwise.\n+     *\n+     */\n+    <T extends AsyncTask> T getTaskStatus(TaskManager taskManager, AsyncExecutionId asyncExecutionId, Class<T> tClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MTI3Mg==", "bodyText": "Thanks for the comment, @jimczi .  I have talked to @albertzaharovits about this sometime ago, and he suggested me from a security point of view to use a separate method instead of adding a parameter to enable/disable authentication.\nI ended up  moving the logic of this method to TransportGetAsyncStatusAction in order to avoid parametrized function arguments.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512171272", "createdAt": "2020-10-26T18:14:39Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "diffHunk": "@@ -252,6 +253,23 @@ public void deleteResponse(AsyncExecutionId asyncExecutionId,\n         return asyncTask;\n     }\n \n+    /**\n+     * Returns the {@link AsyncTask} if the provided <code>asyncTaskId</code>\n+     * is registered in the task manager, <code>null</code> otherwise.\n+     *\n+     */\n+    <T extends AsyncTask> T getTaskStatus(TaskManager taskManager, AsyncExecutionId asyncExecutionId, Class<T> tClass) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwOTQ1Mw=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDc2MDA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTowODo0MVrOHk3APg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoxNjoxOVrOHochCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMTk2Ng==", "bodyText": "Can we reuse getEncodedResponse ? We'd need to disable the authentication check but that can be an option on the function directly ?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508411966", "createdAt": "2020-10-20T11:08:41Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "diffHunk": "@@ -307,6 +325,35 @@ public void getResponse(AsyncExecutionId asyncExecutionId,\n         ));\n     }\n \n+\n+    /**\n+     * Gets the status response of the async search from the index.\n+     * This should be called after unsuccessful attempt to retrieve a status from the Task Manager.\n+     * As the corresponding task doest' exist, we assume that the async search request\n+     * has been completed, and for a status response we are only interested in its expiration time.\n+     * @param asyncExecutionId \u2013 id of the async search\n+     * @param completedStatusProducer \u2013 a producer of the status response of the completed async task,\n+     *   where necessary fields are only id and expiration time.\n+     * @param listener \u2013 listener to report result to\n+     */\n+    public void getStatusResponse(\n+        AsyncExecutionId asyncExecutionId, BiFunction<String, Long, R> completedStatusProducer, ActionListener<R> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MjI5Ng==", "bodyText": "Similarly to a previous comment, I opted out to have a separate method for this .  Please let me know if we still want to have a single method.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512172296", "createdAt": "2020-10-26T18:16:19Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/async/AsyncTaskIndexService.java", "diffHunk": "@@ -307,6 +325,35 @@ public void getResponse(AsyncExecutionId asyncExecutionId,\n         ));\n     }\n \n+\n+    /**\n+     * Gets the status response of the async search from the index.\n+     * This should be called after unsuccessful attempt to retrieve a status from the Task Manager.\n+     * As the corresponding task doest' exist, we assume that the async search request\n+     * has been completed, and for a status response we are only interested in its expiration time.\n+     * @param asyncExecutionId \u2013 id of the async search\n+     * @param completedStatusProducer \u2013 a producer of the status response of the completed async task,\n+     *   where necessary fields are only id and expiration time.\n+     * @param listener \u2013 listener to report result to\n+     */\n+    public void getStatusResponse(\n+        AsyncExecutionId asyncExecutionId, BiFunction<String, Long, R> completedStatusProducer, ActionListener<R> listener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMTk2Ng=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDc2Mzc3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTowOTo0M1rOHk3Cfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODoxNzoxM1rOHocjDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMjU0Mw==", "bodyText": "Why would we set the stats to 0 on a completed search ? That seems wrong to me.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r508412543", "createdAt": "2020-10-20T11:09:43Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+import org.elasticsearch.xpack.core.async.AsyncResponse;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject, AsyncResponse<AsyncStatusResponse> {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+\n+    private AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+    }\n+\n+    /**\n+     * Creates a new {@link AsyncStatusResponse} for a running search.\n+     *\n+     * @param id The id of the async search.\n+     * @param startTimeMillis The start date of the search in milliseconds since epoch.\n+     * @param expirationTimeMillis The expiration date of the search in milliseconds since epoch.\n+     * @param totalShards The total number of shards the request search is executed on\n+     * @param successfulShards The number of shards the request is completed on\n+     * @param skippedShards The number of skipped shards\n+     * @param failedShards The number of shards that failed to executed the request\n+     */\n+    public AsyncStatusResponse(String id,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards) {\n+        this(id, true, startTimeMillis, expirationTimeMillis, totalShards, successfulShards, skippedShards, failedShards);\n+    }\n+\n+    /**\n+     * Creates a new {@link AsyncStatusResponse} for a completed search.\n+     *\n+     * @param id The id of the async search.\n+     * @param expirationTimeMillis \u2013 expiration time in milliseconds\n+     * @return status of the completed async search\n+     */\n+    public static AsyncStatusResponse getCompletedSearchStatusResponse(String id, long expirationTimeMillis) {\n+        return new AsyncStatusResponse(id, false, 0, expirationTimeMillis, 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MjgxNQ==", "bodyText": "addressed in 0775cf1", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r512172815", "createdAt": "2020-10-26T18:17:13Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+import org.elasticsearch.xpack.core.async.AsyncResponse;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject, AsyncResponse<AsyncStatusResponse> {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+\n+    private AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+    }\n+\n+    /**\n+     * Creates a new {@link AsyncStatusResponse} for a running search.\n+     *\n+     * @param id The id of the async search.\n+     * @param startTimeMillis The start date of the search in milliseconds since epoch.\n+     * @param expirationTimeMillis The expiration date of the search in milliseconds since epoch.\n+     * @param totalShards The total number of shards the request search is executed on\n+     * @param successfulShards The number of shards the request is completed on\n+     * @param skippedShards The number of skipped shards\n+     * @param failedShards The number of shards that failed to executed the request\n+     */\n+    public AsyncStatusResponse(String id,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards) {\n+        this(id, true, startTimeMillis, expirationTimeMillis, totalShards, successfulShards, skippedShards, failedShards);\n+    }\n+\n+    /**\n+     * Creates a new {@link AsyncStatusResponse} for a completed search.\n+     *\n+     * @param id The id of the async search.\n+     * @param expirationTimeMillis \u2013 expiration time in milliseconds\n+     * @return status of the completed async search\n+     */\n+    public static AsyncStatusResponse getCompletedSearchStatusResponse(String id, long expirationTimeMillis) {\n+        return new AsyncStatusResponse(id, false, 0, expirationTimeMillis, 0, 0, 0, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMjU0Mw=="}, "originalCommit": {"oid": "faafd18b22a60bdd3d56a9c57dee464969d01682"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTk4NTMzOnYy", "diffSide": "RIGHT", "path": "docs/reference/search/async-search.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODozMTowOVrOHpe4Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODozMTowOVrOHpe4Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1OTU0Ng==", "bodyText": "Can you make the example more realistic by setting successful+failed=total ?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513259546", "createdAt": "2020-10-28T08:31:09Z", "author": {"login": "jimczi"}, "path": "docs/reference/search/async-search.asciidoc", "diffHunk": "@@ -222,6 +222,87 @@ override such value and extend the validity of the request. When this period\n expires, the search, if still running, is cancelled. If the search is\n completed, its saved results are deleted.\n \n+\n+[[get-async-search-status]]\n+==== Get async search status\n+The get async search status API, without retrieving search results, shows\n+only the status of a previously submitted async search request given its `id`.\n+If the {es} {security-features} are enabled, the access to the get async\n+search status API is restricted to the\n+<<built-in-roles, monitoring_user role>>.\n+\n+[source,console,id=get-async-search-status-example]\n+--------------------------------------------------\n+GET /_async_search/status/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\n+--------------------------------------------------\n+// TEST[continued s/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=/\\${body.id}/]\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : true,\n+  \"is_partial\" : true,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 188, <1>\n+      \"skipped\" : 0,\n+      \"failed\" : 0\n+  }\n+}\n+--------------------------------------------------\n+// TEST[skip: a sample output of a status of a running async search]\n+\n+<1> Indicates how many shards have executed the query so far.\n+\n+For an async search that has been completed, the status response has\n+an additional `completion_status` field that shows the status\n+code of the completed async search.\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : false,\n+  \"is_partial\" : false,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 562,\n+      \"skipped\" : 0,\n+      \"failed\" : 0\n+  },\n+ \"completion_status\" : 200 <1>\n+}\n+--------------------------------------------------\n+// TEST[skip: a sample output of a status of a completed async search]\n+\n+<1> Indicates that the async search was successfully completed\n+\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+  \"id\" : \"FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=\",\n+  \"is_running\" : false,\n+  \"is_partial\" : true,\n+  \"start_time_in_millis\" : 1583945890986,\n+  \"expiration_time_in_millis\" : 1584377890986,\n+  \"_shards\" : {\n+      \"total\" : 562,\n+      \"successful\" : 188,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjAwMjE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODozNTozNVrOHpfB7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODozNTozNVrOHpfB7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MjA2Mg==", "bodyText": "I still think that this method should be synchronized. We need to ensure that the stats (failures, ...) are correct since they are attached to the response. Adding volatile is ok but these variables are connected so have to synchronize the access to them.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513262062", "createdAt": "2020-10-28T08:35:35Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -184,6 +187,58 @@ synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task,\n             failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n     }\n \n+\n+    /**\n+     * Creates an {@link AsyncStatusResponse} -- status of an async response.\n+     * Response is created based on the current state of the mutable response or based on {@code finalResponse} if it is available.\n+     * @param asyncExecutionId \u2013 id of async search request\n+     * @param startTime \u2013 start time of task\n+     * @param expirationTime \u2013 expiration time of async search request\n+     * @return response representing the status of async search\n+     */\n+     AsyncStatusResponse toStatusResponse(String asyncExecutionId, long startTime, long expirationTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjAzMjY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODo0Mzo0NVrOHpfUMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODo0Mzo0NVrOHpfUMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NjczNg==", "bodyText": "I think we can return the status for partial response too ?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513266736", "createdAt": "2020-10-28T08:43:45Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+    private final RestStatus completionStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjAzNDM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODo0NDoxMFrOHpfVPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNTo0MzozOVrOHrU-bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NzAwNQ==", "bodyText": "I'd prefer that we always return  a  status even for partial responses.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513267005", "createdAt": "2020-10-28T08:44:10Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+    private final RestStatus completionStatus;\n+\n+    public AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            boolean isPartial,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards,\n+            RestStatus completionStatus) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.isPartial = isPartial;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+        this.completionStatus = completionStatus;\n+    }\n+\n+    public static AsyncStatusResponse getStatusFromAsyncSearchResponseWithExpirationTime(AsyncSearchResponse asyncSearchResponse,\n+            long expirationTimeMillis) {\n+        int totalShards = 0;\n+        int successfulShards = 0;\n+        int skippedShards = 0;\n+        int failedShards = 0;\n+        RestStatus completionStatus = null;\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        if (searchResponse != null) {\n+            totalShards = searchResponse.getTotalShards();\n+            successfulShards = searchResponse.getSuccessfulShards();\n+            skippedShards = searchResponse.getSkippedShards();\n+            failedShards = searchResponse.getFailedShards();\n+        }\n+        if (asyncSearchResponse.isRunning() == false) {\n+            if (searchResponse != null) {\n+                completionStatus = searchResponse.status();\n+            } else {\n+                Exception failure = asyncSearchResponse.getFailure();\n+                if (failure != null) {\n+                    completionStatus = ExceptionsHelper.status(ExceptionsHelper.unwrapCause(failure));\n+                }\n+            }\n+        }\n+        return new AsyncStatusResponse(\n+            asyncSearchResponse.getId(),\n+            asyncSearchResponse.isRunning(),\n+            asyncSearchResponse.isPartial(),\n+            asyncSearchResponse.getStartTime(),\n+            expirationTimeMillis,\n+            totalShards,\n+            successfulShards,\n+            skippedShards,\n+            failedShards,\n+            completionStatus\n+        );\n+    }\n+\n+    public AsyncStatusResponse(StreamInput in) throws IOException {\n+        this.id = in.readString();\n+        this.isRunning = in.readBoolean();\n+        this.isPartial = in.readBoolean();\n+        this.startTimeMillis = in.readLong();\n+        this.expirationTimeMillis = in.readLong();\n+        this.totalShards = in.readVInt();\n+        this.successfulShards = in.readVInt();\n+        this.skippedShards = in.readVInt();\n+        this.failedShards = in.readVInt();\n+        this.completionStatus = (this.isRunning == false) ? RestStatus.readFrom(in) : null;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(id);\n+        out.writeBoolean(isRunning);\n+        out.writeBoolean(isPartial);\n+        out.writeLong(startTimeMillis);\n+        out.writeLong(expirationTimeMillis);\n+        out.writeVInt(totalShards);\n+        out.writeVInt(successfulShards);\n+        out.writeVInt(skippedShards);\n+        out.writeVInt(failedShards);\n+        if (isRunning == false) {\n+            RestStatus.writeTo(out, completionStatus);\n+        }\n+    }\n+\n+    @Override\n+    public RestStatus status() {\n+        return OK;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(\"id\", id);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.timeField(\"start_time_in_millis\", \"start_time\", startTimeMillis);\n+        builder.timeField(\"expiration_time_in_millis\", \"expiration_time\", expirationTimeMillis);\n+        RestActions.buildBroadcastShardsHeader(builder, params, totalShards, successfulShards, skippedShards, failedShards, null);\n+        if (isRunning == false) { // completion status information is only available for a completed search", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMzY2Nw==", "bodyText": "@jimczi Thanks for the comment. I am wondering how to define the status of a partial response?\nFor a completed response, we returned a failure status only if we end up with successfulShards = 0.\nFor a partial response we may  have successfulShards=0 simply because we haven't received yet a response from a successful shard.\nFor a partial response, we can have a different algorithm for deriving a status only looking at the presence or absence of failures, but this could be a different status response from a completed search.  For example, for a partial response we may have successfulShards=0, queryFailures.length>0 and return 400; but then when the search is completed we may have successfulShards=1, queryFailures.length>0  and based on completed response, return 200.\nThus, I would suggest not to return the status for a partial response. WDYT?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513703667", "createdAt": "2020-10-28T19:23:54Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+    private final RestStatus completionStatus;\n+\n+    public AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            boolean isPartial,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards,\n+            RestStatus completionStatus) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.isPartial = isPartial;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+        this.completionStatus = completionStatus;\n+    }\n+\n+    public static AsyncStatusResponse getStatusFromAsyncSearchResponseWithExpirationTime(AsyncSearchResponse asyncSearchResponse,\n+            long expirationTimeMillis) {\n+        int totalShards = 0;\n+        int successfulShards = 0;\n+        int skippedShards = 0;\n+        int failedShards = 0;\n+        RestStatus completionStatus = null;\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        if (searchResponse != null) {\n+            totalShards = searchResponse.getTotalShards();\n+            successfulShards = searchResponse.getSuccessfulShards();\n+            skippedShards = searchResponse.getSkippedShards();\n+            failedShards = searchResponse.getFailedShards();\n+        }\n+        if (asyncSearchResponse.isRunning() == false) {\n+            if (searchResponse != null) {\n+                completionStatus = searchResponse.status();\n+            } else {\n+                Exception failure = asyncSearchResponse.getFailure();\n+                if (failure != null) {\n+                    completionStatus = ExceptionsHelper.status(ExceptionsHelper.unwrapCause(failure));\n+                }\n+            }\n+        }\n+        return new AsyncStatusResponse(\n+            asyncSearchResponse.getId(),\n+            asyncSearchResponse.isRunning(),\n+            asyncSearchResponse.isPartial(),\n+            asyncSearchResponse.getStartTime(),\n+            expirationTimeMillis,\n+            totalShards,\n+            successfulShards,\n+            skippedShards,\n+            failedShards,\n+            completionStatus\n+        );\n+    }\n+\n+    public AsyncStatusResponse(StreamInput in) throws IOException {\n+        this.id = in.readString();\n+        this.isRunning = in.readBoolean();\n+        this.isPartial = in.readBoolean();\n+        this.startTimeMillis = in.readLong();\n+        this.expirationTimeMillis = in.readLong();\n+        this.totalShards = in.readVInt();\n+        this.successfulShards = in.readVInt();\n+        this.skippedShards = in.readVInt();\n+        this.failedShards = in.readVInt();\n+        this.completionStatus = (this.isRunning == false) ? RestStatus.readFrom(in) : null;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(id);\n+        out.writeBoolean(isRunning);\n+        out.writeBoolean(isPartial);\n+        out.writeLong(startTimeMillis);\n+        out.writeLong(expirationTimeMillis);\n+        out.writeVInt(totalShards);\n+        out.writeVInt(successfulShards);\n+        out.writeVInt(skippedShards);\n+        out.writeVInt(failedShards);\n+        if (isRunning == false) {\n+            RestStatus.writeTo(out, completionStatus);\n+        }\n+    }\n+\n+    @Override\n+    public RestStatus status() {\n+        return OK;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(\"id\", id);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.timeField(\"start_time_in_millis\", \"start_time\", startTimeMillis);\n+        builder.timeField(\"expiration_time_in_millis\", \"expiration_time\", expirationTimeMillis);\n+        RestActions.buildBroadcastShardsHeader(builder, params, totalShards, successfulShards, skippedShards, failedShards, null);\n+        if (isRunning == false) { // completion status information is only available for a completed search", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NzAwNQ=="}, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NDQ3OQ==", "bodyText": "Yes the discrepancy would be weird and since we return 200 if there's at least one successful shards I agree that we should expose the status only when the search has completed.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r515194479", "createdAt": "2020-10-30T15:43:39Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/search/action/AsyncStatusResponse.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.search.action;\n+\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.StatusToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestActions;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.rest.RestStatus.OK;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncStatusResponse extends ActionResponse implements StatusToXContentObject {\n+    private final String id;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+    private final int totalShards;\n+    private final int successfulShards;\n+    private final int skippedShards;\n+    private final int failedShards;\n+    private final RestStatus completionStatus;\n+\n+    public AsyncStatusResponse(String id,\n+            boolean isRunning,\n+            boolean isPartial,\n+            long startTimeMillis,\n+            long expirationTimeMillis,\n+            int totalShards,\n+            int successfulShards,\n+            int skippedShards,\n+            int failedShards,\n+            RestStatus completionStatus) {\n+        this.id = id;\n+        this.isRunning = isRunning;\n+        this.isPartial = isPartial;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+        this.totalShards = totalShards;\n+        this.successfulShards = successfulShards;\n+        this.skippedShards = skippedShards;\n+        this.failedShards = failedShards;\n+        this.completionStatus = completionStatus;\n+    }\n+\n+    public static AsyncStatusResponse getStatusFromAsyncSearchResponseWithExpirationTime(AsyncSearchResponse asyncSearchResponse,\n+            long expirationTimeMillis) {\n+        int totalShards = 0;\n+        int successfulShards = 0;\n+        int skippedShards = 0;\n+        int failedShards = 0;\n+        RestStatus completionStatus = null;\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        if (searchResponse != null) {\n+            totalShards = searchResponse.getTotalShards();\n+            successfulShards = searchResponse.getSuccessfulShards();\n+            skippedShards = searchResponse.getSkippedShards();\n+            failedShards = searchResponse.getFailedShards();\n+        }\n+        if (asyncSearchResponse.isRunning() == false) {\n+            if (searchResponse != null) {\n+                completionStatus = searchResponse.status();\n+            } else {\n+                Exception failure = asyncSearchResponse.getFailure();\n+                if (failure != null) {\n+                    completionStatus = ExceptionsHelper.status(ExceptionsHelper.unwrapCause(failure));\n+                }\n+            }\n+        }\n+        return new AsyncStatusResponse(\n+            asyncSearchResponse.getId(),\n+            asyncSearchResponse.isRunning(),\n+            asyncSearchResponse.isPartial(),\n+            asyncSearchResponse.getStartTime(),\n+            expirationTimeMillis,\n+            totalShards,\n+            successfulShards,\n+            skippedShards,\n+            failedShards,\n+            completionStatus\n+        );\n+    }\n+\n+    public AsyncStatusResponse(StreamInput in) throws IOException {\n+        this.id = in.readString();\n+        this.isRunning = in.readBoolean();\n+        this.isPartial = in.readBoolean();\n+        this.startTimeMillis = in.readLong();\n+        this.expirationTimeMillis = in.readLong();\n+        this.totalShards = in.readVInt();\n+        this.successfulShards = in.readVInt();\n+        this.skippedShards = in.readVInt();\n+        this.failedShards = in.readVInt();\n+        this.completionStatus = (this.isRunning == false) ? RestStatus.readFrom(in) : null;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(id);\n+        out.writeBoolean(isRunning);\n+        out.writeBoolean(isPartial);\n+        out.writeLong(startTimeMillis);\n+        out.writeLong(expirationTimeMillis);\n+        out.writeVInt(totalShards);\n+        out.writeVInt(successfulShards);\n+        out.writeVInt(skippedShards);\n+        out.writeVInt(failedShards);\n+        if (isRunning == false) {\n+            RestStatus.writeTo(out, completionStatus);\n+        }\n+    }\n+\n+    @Override\n+    public RestStatus status() {\n+        return OK;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(\"id\", id);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.timeField(\"start_time_in_millis\", \"start_time\", startTimeMillis);\n+        builder.timeField(\"expiration_time_in_millis\", \"expiration_time\", expirationTimeMillis);\n+        RestActions.buildBroadcastShardsHeader(builder, params, totalShards, successfulShards, skippedShards, failedShards, null);\n+        if (isRunning == false) { // completion status information is only available for a completed search", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2NzAwNQ=="}, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjA0MTI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncStatusAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODo0NTo1NlrOHpfZPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODo0NTo1NlrOHpfZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2ODAzMA==", "bodyText": "I don't think we should check the cancellation here, if the task is present, we should return the status.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r513268030", "createdAt": "2020-10-28T08:45:56Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncStatusAction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.search;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionListenerResponseHandler;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.async.AsyncExecutionId;\n+import org.elasticsearch.xpack.core.async.AsyncTask;\n+import org.elasticsearch.xpack.core.async.AsyncTaskIndexService;\n+import org.elasticsearch.xpack.core.async.GetAsyncStatusRequest;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.AsyncStatusResponse;\n+import org.elasticsearch.xpack.core.search.action.GetAsyncStatusAction;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ClientHelper.ASYNC_SEARCH_ORIGIN;\n+\n+public class TransportGetAsyncStatusAction extends HandledTransportAction<GetAsyncStatusRequest, AsyncStatusResponse> {\n+    private final TransportService transportService;\n+    private final ClusterService clusterService;\n+    private final AsyncTaskIndexService<AsyncSearchResponse> store;\n+\n+    @Inject\n+    public TransportGetAsyncStatusAction(TransportService transportService,\n+             ActionFilters actionFilters,\n+             ClusterService clusterService,\n+             NamedWriteableRegistry registry,\n+             Client client,\n+             ThreadPool threadPool) {\n+        super(GetAsyncStatusAction.NAME, transportService, actionFilters, GetAsyncStatusRequest::new);\n+        this.transportService = transportService;\n+        this.clusterService = clusterService;\n+        this.store = new AsyncTaskIndexService<>(XPackPlugin.ASYNC_RESULTS_INDEX, clusterService,\n+            threadPool.getThreadContext(), client, ASYNC_SEARCH_ORIGIN, AsyncSearchResponse::new, registry);\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GetAsyncStatusRequest request, ActionListener<AsyncStatusResponse> listener) {\n+        AsyncExecutionId searchId = AsyncExecutionId.decode(request.getId());\n+        DiscoveryNode node = clusterService.state().nodes().get(searchId.getTaskId().getNodeId());\n+        if (node == null || Objects.equals(node, clusterService.localNode())) {\n+            retrieveStatus(request, listener);\n+        } else {\n+            TransportRequestOptions.Builder builder = TransportRequestOptions.builder();\n+            transportService.sendRequest(node, GetAsyncStatusAction.NAME, request, builder.build(),\n+                new ActionListenerResponseHandler<>(listener, AsyncStatusResponse::new, ThreadPool.Names.SAME));\n+        }\n+    }\n+\n+    private void retrieveStatus(GetAsyncStatusRequest request, ActionListener<AsyncStatusResponse> listener) {\n+        long nowInMillis = System.currentTimeMillis();\n+        AsyncExecutionId searchId = AsyncExecutionId.decode(request.getId());\n+        try {\n+            AsyncTask task = (AsyncTask) taskManager.getTask(searchId.getTaskId().getId());\n+            if ((task instanceof AsyncSearchTask) && (task.getExecutionId().equals(searchId))) {\n+                if (task.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0775cf12e54c2e97c263e051467a611c3188ea19"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODA2MTA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNTo0ODoxMlrOHrVJkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0OTo0NVrOHsKNhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NzMyOQ==", "bodyText": "nit:  you can do return queryFailures.asList().size() ?", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r515197329", "createdAt": "2020-10-30T15:48:12Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -213,4 +268,17 @@ private void failIfFrozen() {\n         }\n         return failures.toArray(ShardSearchFailure[]::new);\n     }\n+\n+    private int getQueryFailuresCount() {\n+        if (queryFailures == null) {\n+            return 0;\n+        }\n+        int count = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e427d574946a87ee33391d6db830230df2a3b52"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NjY5NA==", "bodyText": "@jimczi Thanks for the suggestion. It seems that asList() method creates a additional list object. Instead, in 39dafa9, I've added AtomicArray::nonNullLength method.", "url": "https://github.com/elastic/elasticsearch/pull/62947#discussion_r516066694", "createdAt": "2020-11-02T15:49:45Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -213,4 +268,17 @@ private void failIfFrozen() {\n         }\n         return failures.toArray(ShardSearchFailure[]::new);\n     }\n+\n+    private int getQueryFailuresCount() {\n+        if (queryFailures == null) {\n+            return 0;\n+        }\n+        int count = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5NzMyOQ=="}, "originalCommit": {"oid": "1e427d574946a87ee33391d6db830230df2a3b52"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3375, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}