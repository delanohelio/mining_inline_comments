{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjUzNDAy", "number": 51100, "title": "Add NestedPathFieldMapper to store nested path information", "bodyText": "Currently nested documents repurpose the _type field to store their nested paths.\nThis commit adds a dedicated _nested_path field instead, which decouples this\ninformation from types and will allow the removal of the _type field entirely further\ndown the line.  To preserve backwards compatibility, references to this field are\nmediated via methods that take an index settings object, and indexes created before\n8x still use the _type field.\nRelates to #41059\nCloses #24362", "createdAt": "2020-01-16T13:45:37Z", "url": "https://github.com/elastic/elasticsearch/pull/51100", "merged": true, "mergeCommit": {"oid": "1dc9dd42235e876fde8c3b31934f1bc88d668896"}, "closed": true, "closedAt": "2020-01-22T16:31:35Z", "author": {"login": "romseygeek"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb653hNAH2gAyMzYzNjUzNDAyOjM1YThjNTBiMDIzZTI4ZGZjMDczY2YwMzllZWM1M2U3NGRiM2FjMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb83qSOgH2gAyMzYzNjUzNDAyOmJhZmI5NmI4MDEzZTMwM2EzOWQwODUzMDMwZGFlMjE0ZWYyMGJiN2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "35a8c50b023e28dfc073cf039eec53e74db3ac38", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/35a8c50b023e28dfc073cf039eec53e74db3ac38", "committedDate": "2020-01-16T13:07:46Z", "message": "Add new NestedPathFieldMapper, migrate nested docs to use it rather than type field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89c13b7bcbebf1470a345659fa2477546aa59c3c", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/89c13b7bcbebf1470a345659fa2477546aa59c3c", "committedDate": "2020-01-16T14:42:13Z", "message": "Don't add nested field mapper for pre-8 indexes, as this breaks mapping updates due to the _type field being overloaded"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "894bb528ae1c8ac54adad76a34f17ce26f831e75", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/894bb528ae1c8ac54adad76a34f17ce26f831e75", "committedDate": "2020-01-16T15:30:45Z", "message": "test different built-in mapper counts on different versions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39d2d1a85354ab7fda08ba0e5de032f535dffd8c", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/39d2d1a85354ab7fda08ba0e5de032f535dffd8c", "committedDate": "2020-01-16T16:34:44Z", "message": "doh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/0fff0cfd2dade3274c601991809ea9340599ad3d", "committedDate": "2020-01-17T09:04:09Z", "message": "Adjust isMetaDataField test to take version into account"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDQ3MzQz", "url": "https://github.com/elastic/elasticsearch/pull/51100#pullrequestreview-344447343", "createdAt": "2020-01-17T09:17:07Z", "commit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToxNzowN1rOFey4Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToxODo1NlrOFey7Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg==", "bodyText": "should we disallow fielddata on this field ? It's an implementation details and I am not sure that we want to expose it in aggs or sorting ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835206", "createdAt": "2020-01-17T09:17:07Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTQxOA==", "bodyText": "Maybe keep it only for indices created before 8 to handle bwc ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835418", "createdAt": "2020-01-17T09:17:41Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw==", "bodyText": "Can you switch to the NestedPathFieldMapper.TypeParser in this pr since you handle bwc in the new field type ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835907", "createdAt": "2020-01-17T09:18:56Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "diffHunk": "@@ -157,6 +158,7 @@ public IndicesModule(List<MapperPlugin> mapperPlugins) {\n         builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser());\n         builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser());\n         builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81c36c77d46370278cd8fb5d086b5ff89980a420", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/81c36c77d46370278cd8fb5d086b5ff89980a420", "committedDate": "2020-01-17T09:44:20Z", "message": "Merge remote-tracking branch 'origin/master' into types-removal/nested-field-mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bba4d6a284ac875f799e1f6d8a4389e76632f776", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/bba4d6a284ac875f799e1f6d8a4389e76632f776", "committedDate": "2020-01-17T10:15:36Z", "message": "Merge remote-tracking branch 'origin/master' into types-removal/nested-field-mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/7ea0da8acc167f8549d0ab77816c9717e5d2334b", "committedDate": "2020-01-17T10:58:20Z", "message": "No fielddata on nested path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjQ0ODg2", "url": "https://github.com/elastic/elasticsearch/pull/51100#pullrequestreview-344644886", "createdAt": "2020-01-17T15:14:48Z", "commit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToxNDo0OFrOFe8GUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToyMTo0M1rOFe8UnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjI1Ng==", "bodyText": "For indices created in v8 we don't need to add any prefix since we use a dedicated field ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367986256", "createdAt": "2020-01-17T15:14:48Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java", "diffHunk": "@@ -335,9 +331,8 @@ protected static void parseProperties(ObjectMapper.Builder objBuilder, Map<Strin\n         } else {\n             this.mappers = CopyOnWriteHashMap.copyOf(mappers);\n         }\n-        this.nestedTypePathAsString = \"__\" + fullPath;\n-        this.nestedTypePathAsBytes = new BytesRef(nestedTypePathAsString);\n-        this.nestedTypeFilter = new TermQuery(new Term(TypeFieldMapper.NAME, nestedTypePathAsBytes));\n+        this.nestedTypePath = \"__\" + fullPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjgzNw==", "bodyText": "Ok I was confused because there are some logic to handle bwc in NestedPathFieldMapper.", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367986837", "createdAt": "2020-01-17T15:15:58Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "diffHunk": "@@ -157,6 +158,7 @@ public IndicesModule(List<MapperPlugin> mapperPlugins) {\n         builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser());\n         builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser());\n         builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTkxNw==", "bodyText": "I don't think we need to index root document in this field. We use the nested path to find nested documents but we don't use this field to detect root documents so this indexing would be redundant ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367989917", "createdAt": "2020-01-17T15:21:43Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public boolean isSearchable() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new UnsupportedOperationException(\"Cannot run exists() query against the nested field path\");\n+        }\n+    }\n+\n+    private NestedPathFieldMapper(IndexSettings indexSettings, MappedFieldType existing) {\n+        this(existing == null ? defaultFieldType(indexSettings) : existing.clone(),\n+            indexSettings);\n+    }\n+\n+    private NestedPathFieldMapper(MappedFieldType fieldType, IndexSettings indexSettings) {\n+        super(name(indexSettings.getSettings()), fieldType, defaultFieldType(indexSettings), indexSettings.getSettings());\n+    }\n+\n+    private static MappedFieldType defaultFieldType(IndexSettings indexSettings) {\n+        MappedFieldType defaultFieldType = Defaults.FIELD_TYPE.clone();\n+        defaultFieldType.setIndexOptions(IndexOptions.NONE);\n+        defaultFieldType.setHasDocValues(false);\n+        defaultFieldType.setName(name(indexSettings.getSettings()));\n+        return defaultFieldType;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+        super.parse(context);\n+    }\n+\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        // we parse in pre parse\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        if (fieldType().indexOptions() == IndexOptions.NONE && !fieldType().stored()) {\n+            return;\n+        }\n+        fields.add(new Field(fieldType().name(), MapperService.SINGLE_MAPPING_NAME, fieldType()));\n+        if (fieldType().hasDocValues()) {\n+            fields.add(new SortedSetDocValuesField(fieldType().name(), new BytesRef(MapperService.SINGLE_MAPPING_NAME)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03029007738f878fe6b4363a6e6e50bc9f1eca80", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/03029007738f878fe6b4363a6e6e50bc9f1eca80", "committedDate": "2020-01-17T16:20:03Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/e59a3297806df9532e8130abd2475618b4d04971", "committedDate": "2020-01-20T10:58:48Z", "message": "Merge branch 'master' into types-removal/nested-field-mapper"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjE4ODg5", "url": "https://github.com/elastic/elasticsearch/pull/51100#pullrequestreview-346618889", "createdAt": "2020-01-22T14:17:10Z", "commit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoxNzoxMVrOFgdnMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoxNzo1NVrOFgdo5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MzkyMg==", "bodyText": "I think you need to preserve the sort order ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369583922", "createdAt": "2020-01-22T14:17:11Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -118,7 +118,7 @@\n     //TODO this needs to be cleaned up: _timestamp and _ttl are not supported anymore, _field_names, _seq_no, _version and _source are\n     //also missing, not sure if on purpose. See IndicesModule#getMetadataMappers\n     private static final String[] SORTED_META_FIELDS = new String[]{\n-        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\"\n+        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\", \"_nested_path\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw==", "bodyText": "Should it bee IndexOptions.NONE ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369584357", "createdAt": "2020-01-22T14:17:55Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "befa0ec9b5fed808c8e4922e29d663d9d529cb46", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/befa0ec9b5fed808c8e4922e29d663d9d529cb46", "committedDate": "2020-01-22T14:42:12Z", "message": "Merge remote-tracking branch 'origin/master' into types-removal/nested-field-mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b90105d14898dda83d27dd100f0b4806809f8bf3", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/b90105d14898dda83d27dd100f0b4806809f8bf3", "committedDate": "2020-01-22T14:43:03Z", "message": "Fix sort order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d21c65cf56ad92d0a36b18a66790345870264d4", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d21c65cf56ad92d0a36b18a66790345870264d4", "committedDate": "2020-01-22T14:43:37Z", "message": "Merge remote-tracking branch 'romseygeek/types-removal/nested-field-mapper' into types-removal/nested-field-mapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad8ac4d444761bf89790beb57b01cb7b95ab57d3", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/ad8ac4d444761bf89790beb57b01cb7b95ab57d3", "committedDate": "2020-01-22T15:09:49Z", "message": "compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bafb96b8013e303a39d0853030dae214ef20bb7f", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/bafb96b8013e303a39d0853030dae214ef20bb7f", "committedDate": "2020-01-22T15:41:21Z", "message": "fieldtype"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2906, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}