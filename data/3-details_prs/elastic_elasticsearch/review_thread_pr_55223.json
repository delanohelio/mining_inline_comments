{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNjY3ODg4", "number": 55223, "reviewThreads": {"totalCount": 74, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMTo1MVrOD2mcUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxODowN1rOD_v67g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTc5NTM3OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMTo1MVrOGMbbxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMTo1MVrOGMbbxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NTU3Mg==", "bodyText": "Unnecessary extra new line", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415685572", "createdAt": "2020-04-27T10:11:51Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -487,6 +487,49 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse1]\n include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse2]\n --------------------------------------------------\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: datetime\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]\n+If timezone is not specified in the time string expression and the parsing pattern, the resulting `time` will\n+be in `UTC` timezone.\n+\n+[NOTE]\n+If the parsing pattern contains date units (e.g. 'dd/MM/uuuu', 'dd-MM HH:mm:ss', etc.) an error is returned\n+as the function needs to return a value of `time` type which will contain only time.\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse1]\n+--------------------------------------------------\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse2]\n+--------------------------------------------------\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgwMjM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMzozNFrOGMbf3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxMzozNFrOGMbf3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NjYyMQ==", "bodyText": "Please revert all the formatting changes to untouched lines, it can cause confusion when looking at git history.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415686621", "createdAt": "2020-04-27T10:13:34Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -14,7 +14,7 @@ describeTable\n // tag::describeTable\n DESCRIBE emp;\n \n-       column       |     type      |    mapping    \n+       column       |     type      |    mapping", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgwODM4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxNDo1NVrOGMbjaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMzo0MToxNFrOGNutlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ==", "bodyText": "I don't think that's necessary, did it cause any problems?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415687531", "createdAt": "2020-04-27T10:14:55Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwODc0Ng==", "bodyText": "In csvjdbc, it parse time string with SimpleDateFormat. In the constructor of SimpleDateFormat, calendar will be initialized by  the initializeCalendar function.\nprivate void initializeCalendar(Locale loc) {\n        if (calendar == null) {\n            assert loc != null;\n            // The format object must be constructed using the symbols for this zone.\n            // However, the calendar should use the current default TimeZone.\n            // If this is not contained in the locale zone strings, then the zone\n            // will be formatted using generic GMT+/-H:MM nomenclature.\n            calendar = Calendar.getInstance(TimeZone.getDefault(), loc);\n        }\n    }\n\nAnd In parseTime function, it will get milliseconds from parsedDate. In different TimeZone, there will be different milliseconds.\npublic Time parseTime(String str){              \n\tjava.util.Date parsedDate = simpleTimeFormat.parse(str);\n\tlong millis = parsedDate.getTime();\n\tsqlResult = new Time(millis);\n\treturn sqlResult;\n}\nIs there a better way to solve this problem?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416408746", "createdAt": "2020-04-28T07:57:48Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTYwOQ==", "bodyText": "Cant' you use the timezone parsing pattern here: https://github.com/elastic/elasticsearch/pull/55223/files#diff-3dd1dabda293f7c99cda3ed7e09b2cacR66\ncsvProperties.setProperty(\"timeFormat\", \"HH:mm:ss.SSSX\");", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416481609", "createdAt": "2020-04-28T09:50:51Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU5ODYwMQ==", "bodyText": "It can't work.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416598601", "createdAt": "2020-04-28T13:09:22Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1NjU5MQ==", "bodyText": "I tried with your branch and it worked.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416656591", "createdAt": "2020-04-28T14:24:56Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA1MDAwNA==", "bodyText": "Sorry, it works, I made an another mistake.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417050004", "createdAt": "2020-04-29T03:41:14Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgxODAwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxNzoxOVrOGMbpJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxNzoxOVrOGMbpJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODk5OA==", "bodyText": "You should override hashCode() and equals() and include the new attribute.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415688998", "createdAt": "2020-04-27T10:17:19Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "diffHunk": "@@ -8,29 +8,33 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.DateTimeParseExtractor;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n+    \n+    private final DateTimeParseExtractor dateTimeParseExtractor;\n \n-    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right) {\n+    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, DateTimeParseExtractor dateTimeParseExtractor) {\n         super(source, expression, left, right, null);\n+        this.dateTimeParseExtractor = dateTimeParseExtractor;\n     }\n \n     @Override\n     protected NodeInfo<DateTimeParsePipe> info() {\n-        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right());\n+        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), dateTimeParseExtractor);\n     }\n \n     @Override\n     protected DateTimeParsePipe replaceChildren(Pipe left, Pipe right) {\n-        return new DateTimeParsePipe(source(), expression(), left, right);\n+        return new DateTimeParsePipe(source(), expression(), left, right, dateTimeParseExtractor);\n     }\n \n     @Override\n     protected Processor makeProcessor(Processor left, Processor right, ZoneId zoneId) {\n-        return new DateTimeParseProcessor(left, right);\n+        return new DateTimeParseProcessor(left, right, dateTimeParseExtractor);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgyMzYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxODo0NFrOGMbsjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoxODo0NFrOGMbsjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4OTg3MQ==", "bodyText": "wrong identation.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415689871", "createdAt": "2020-04-27T10:18:44Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n             }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n         }\n     }\n+    \n+    private final DateTimeParseExtractor extractor;\n+\n+    public static final String NAME = \"dtparse\";\n+\n+    public DateTimeParseProcessor(Processor source1, Processor source2, DateTimeParseExtractor extractor) {\n+        super(source1, source2, null);\n+        this.extractor = extractor;\n+    }\n \n+    public DateTimeParseProcessor(StreamInput in) throws IOException {\n+        super(in);\n+        this.extractor = in.readEnum(DateTimeParseExtractor.class);\n+    }\n+    \n+    @Override\n+    public void doWrite(StreamOutput out) throws IOException {\n+        out.writeEnum(extractor);\n+    }\n+    \n     @Override\n     public String getWriteableName() {\n         return NAME;\n     }\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern);\n+            return this.extractor.extract(timestamp, pattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgzMDYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMDoyOFrOGMbwuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMDoyOFrOGMbwuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MDkzNw==", "bodyText": "I would rename it to DateTimeParser or plain Parser since it's already under a class so it would be: DateTimeParseProcessor.Parser.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415690937", "createdAt": "2020-04-27T10:20:28Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgzNDg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMToyNFrOGMbzOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMToyNFrOGMbzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MTU3Ng==", "bodyText": "Please rename it apply -> parser.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415691576", "createdAt": "2020-04-27T10:21:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgzODA4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMjoxM1rOGMb1Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMjoxM1rOGMb1Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjA3MQ==", "bodyText": "Please rename extactor -> parser.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692071", "createdAt": "2020-04-27T10:22:13Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n             }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n         }\n     }\n+    \n+    private final DateTimeParseExtractor extractor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTgzOTI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMjozNVrOGMb18g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMjozNVrOGMb18g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjI3NA==", "bodyText": "Please rename to parse()", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692274", "createdAt": "2020-04-27T10:22:35Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTg0MzcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMzo0MlrOGMb4iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMzo0MlrOGMb4iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjkzOQ==", "bodyText": "date shouldn't be there, should be added with DATE_PARSE function.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692939", "createdAt": "2020-04-27T10:23:42Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTg0NDQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMzo1MFrOGMb47g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyMzo1MFrOGMb47g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MzAzOA==", "bodyText": "date shouldn't be there, should be added with DATE_PARSE function.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415693038", "createdAt": "2020-04-27T10:23:50Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTcxMjMxOnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNTo0N1rOGN2uyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNTo0N1rOGN2uyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MTM4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *Output*: datetime\n          \n          \n            \n            *Output*: time", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417181386", "createdAt": "2020-04-29T09:25:47Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -487,6 +487,47 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse1]\n include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse2]\n --------------------------------------------------\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: datetime", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTcxNTIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNjozOVrOGN2wsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNjozOVrOGN2wsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MTg3Mg==", "bodyText": "Please revert changes to this file.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417181872", "createdAt": "2020-04-29T09:26:39Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -18,6 +18,7 @@\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.util.List;\n+import java.util.TimeZone;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTcxOTU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNzo0N1rOGN2zSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOToyNzo0N1rOGN2zSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MjUzOA==", "bodyText": "Please keep the alphabetical ordering here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417182538", "createdAt": "2020-04-29T09:27:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java", "diffHunk": "@@ -77,17 +77,17 @@ private Processors() {}\n         entries.add(new Entry(Processor.class, NullIfProcessor.NAME, NullIfProcessor::new));\n \n         // datetime\n-        entries.add(new Entry(Processor.class, DateTimeProcessor.NAME, DateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, TimeProcessor.NAME, TimeProcessor::new));\n-        entries.add(new Entry(Processor.class, NamedDateTimeProcessor.NAME, NamedDateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, NonIsoDateTimeProcessor.NAME, NonIsoDateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, QuarterProcessor.NAME, QuarterProcessor::new));\n         entries.add(new Entry(Processor.class, DateAddProcessor.NAME, DateAddProcessor::new));\n         entries.add(new Entry(Processor.class, DateDiffProcessor.NAME, DateDiffProcessor::new));\n         entries.add(new Entry(Processor.class, DatePartProcessor.NAME, DatePartProcessor::new));\n-        entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));\n         entries.add(new Entry(Processor.class, DateTimeParseProcessor.NAME, DateTimeParseProcessor::new));\n+        entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTczNDA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMTo0N1rOGN28Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNTowNjoyM1rOGPCP6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NDgyMg==", "bodyText": "You should distinguish based on the enum value, this way you can have a specialized message for each and not a generic one that refers to both datetime and time.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417184822", "createdAt": "2020-04-29T09:31:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxODY2NQ==", "bodyText": "See my code changes, is it ok?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418418665", "createdAt": "2020-05-01T05:06:23Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NDgyMg=="}, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTczNTg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMjoxNlrOGN29Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMjoxNlrOGN29Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTA5OA==", "bodyText": "Minor: empty line", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185098", "createdAt": "2020-04-29T09:32:16Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+\n+    private final Parser parser;\n+\n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+        parser = Parser.TIME;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTczNjc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMjozM1rOGN291Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMjozM1rOGN291Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTIzNw==", "bodyText": "Minor: extra empty line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185237", "createdAt": "2020-04-29T09:32:33Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -294,9 +294,14 @@ public static String dateTimeFormat(Object dateTime, String pattern, String tzId\n     }\n \n     public static Object dateTimeParse(String dateField, String pattern, String tzId) {\n-        return DateTimeParseProcessor.process(dateField, pattern);\n+        return Parser.DATE_TIME.parse(dateField, pattern);\n     }\n \n+    public static Object timeParse(String dateField, String pattern, String tzId) {\n+        return Parser.TIME.parse(dateField, pattern);\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTczODUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMzowNVrOGN2-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTozMzowNVrOGN2-9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTUyNA==", "bodyText": "Minor: whitespaces.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185524", "createdAt": "2020-04-29T09:33:05Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -25,10 +26,11 @@\n     public static DateTimeParseProcessor randomDateTimeParseProcessor() {\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128))\n+            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n+                randomFrom(Parser.values())\n         );\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTc2NTMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTo0MDo1M1rOGN3Plg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNTowNjoyN1rOGPCP_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4OTc4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n          \n          \n            \n                    DATE_TIME(ZonedDateTime::from),\n          \n          \n            \n                    TIME(OffsetTime::from);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417189782", "createdAt": "2020-04-29T09:40:53Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxODY4Ng==", "bodyText": "See my code changes, is it ok?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418418686", "createdAt": "2020-05-01T05:06:27Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4OTc4Mg=="}, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTc3MDE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwOTo0MjoxOFrOGN3Sog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNTowNjozMlrOGPCQCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5MDU2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Parser(BiFunction<String, String, TemporalAccessor> parser) {\n          \n          \n            \n                    Parser(TemporalQuery<?> query) {\n          \n          \n            \n                        this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n          \n          \n            \n                            .parseBest(timestampStr, query, LocalTime::from));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417190562", "createdAt": "2020-04-29T09:42:18Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxODY5OQ==", "bodyText": "See my code changes, is it ok?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418418699", "createdAt": "2020-05-01T05:06:32Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5MDU2Mg=="}, "originalCommit": {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzU4Nzc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxNzo1MVrOGPDC1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxNzo1MVrOGPDC1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTcwMA==", "bodyText": "Could be static and initialized here instead of the constructor.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431700", "createdAt": "2020-05-01T06:17:51Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+\n+    private final Parser parser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzU4ODEwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxODowNVrOGPDDAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxODowNVrOGPDDAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTc0Nw==", "bodyText": "same here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431747", "createdAt": "2020-05-01T06:18:05Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "diffHunk": "@@ -8,29 +8,54 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n+import java.util.Objects;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n+    \n+    private final Parser parser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzU4OTYyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxODo1NFrOGPDDzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxODo1NFrOGPDDzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTk0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n          \n          \n            \n                    Parser(String parseType,  TemporalQuery<?> queries...) {", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431948", "createdAt": "2020-05-01T06:18:54Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,115 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzU5MTEyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxOTo0NFrOGPDEhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNjoxOTo0NFrOGPDEhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMjEzNA==", "bodyText": "whitespaces", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418432134", "createdAt": "2020-05-01T06:19:44Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,115 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, query, localQuery);\n+            this.parseType = parseType;\n+        }\n+        \n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {} \",\n+                    this.parseType,\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n+            }\n+        }\n+    }\n+    \n+    private final Parser parser;\n+\n     public static final String NAME = \"dtparse\";\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n+    public DateTimeParseProcessor(Processor source1, Processor source2, Parser parser) {\n         super(source1, source2, null);\n+        this.parser = parser;\n     }\n \n     public DateTimeParseProcessor(StreamInput in) throws IOException {\n         super(in);\n+        this.parser = in.readEnum(Parser.class);\n     }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n-        }\n-\n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n-\n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n-            }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n-            }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n-        }\n+    \n+    @Override\n+    public void doWrite(StreamOutput out) throws IOException {\n+        out.writeEnum(parser);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNzI0NTg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/src/main/resources/time.csv-spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNTo1NVrOGPiXHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNTo1NVrOGPiXHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDc5Nw==", "bodyText": "You can use a simple cast as String.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944797", "createdAt": "2020-05-02T11:05:55Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/time.csv-spec", "diffHunk": "@@ -104,3 +104,89 @@ SELECT MAX(salary) FROM test_emp GROUP BY CURRENT_TIME;\n ---------------\n 74999\n ;\n+\n+selectTimeParse\n+schema::dp_time1:time|dp_time2:time\n+SELECT TIME_PARSE('11:22:33', 'HH:mm:ss') AS dp_time1,\n+TIME_PARSE('11:22:33 -05:33', 'HH:mm:ss zz') AS dp_time2;\n+\n+       dp_time1             |    dp_time2\n+----------------------------+----------------------------\n+11:22:33.000Z               | 16:55:33.000Z\n+;\n+\n+selectTimeParseWithField\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH mm SSS ss'), 'HH mm SSS ss') AS dp_birth_time\n+FROM test_emp WHERE gender = 'M' AND emp_no BETWEEN 10037 AND 10052 ORDER BY emp_no;\n+\n+       birth_date        | dp_birth_time\n+-------------------------+-------------------------\n+1963-07-22 00:00:00.000Z | 00:00:00.000Z\n+1960-07-20 00:00:00.000Z | 00:00:00.000Z\n+1959-10-01 00:00:00.000Z | 00:00:00.000Z\n+null                     | null\n+null                     | null\n+null                     | null\n+null                     | null\n+null                     | null\n+1958-05-21 00:00:00.000Z | 00:00:00.000Z\n+1953-07-28 00:00:00.000Z | 00:00:00.000Z\n+1961-02-26 00:00:00.000Z | 00:00:00.000Z\n+;\n+\n+timeParseWhere\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH.mm.ss'), 'HH.mm.ss') AS dp_birth_time\n+FROM test_emp WHERE birth_date > '1963-10-20'::date and dp_birth_time = '00:00:00'::time ORDER BY emp_no;\n+\n+       birth_date        |     dp_birth_time\n+-------------------------+------------------------\n+1964-06-02 00:00:00.000Z | 00:00:00.000Z\n+1963-11-26 00:00:00.000Z | 00:00:00.000Z\n+1964-04-18 00:00:00.000Z | 00:00:00.000Z\n+1964-10-18 00:00:00.000Z | 00:00:00.000Z\n+1964-06-11 00:00:00.000Z | 00:00:00.000Z\n+1965-01-03 00:00:00.000Z | 00:00:00.000Z\n+;\n+\n+timeParseOrderBy\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH:mm:ss.SSS'), 'HH:mm:ss.SSS') AS dp_birth_time\n+FROM test_emp  ORDER BY 1 DESC NULLS LAST, 2 LIMIT 10;\n+\n+       birth_date        | dp_birth_time\n+-------------------------+-------------------------\n+1965-01-03 00:00:00.000Z | 00:00:00.000Z\n+1964-10-18 00:00:00.000Z | 00:00:00.000Z\n+1964-06-11 00:00:00.000Z | 00:00:00.000Z\n+1964-06-02 00:00:00.000Z | 00:00:00.000Z\n+1964-04-18 00:00:00.000Z | 00:00:00.000Z\n+1963-11-26 00:00:00.000Z | 00:00:00.000Z\n+1963-09-09 00:00:00.000Z | 00:00:00.000Z\n+1963-07-22 00:00:00.000Z | 00:00:00.000Z\n+1963-06-07 00:00:00.000Z | 00:00:00.000Z\n+1963-06-01 00:00:00.000Z | 00:00:00.000Z\n+;\n+\n+// Wait time format function implement\n+timeParseGroupBy-Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNzI0NjQ3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNjozM1rOGPiXaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNjozM1rOGPiXaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDg3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n          \n          \n            \n                                msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944875", "createdAt": "2020-05-02T11:06:33Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -70,10 +69,10 @@ public Object parse(Object timestamp, Object pattern) {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNzI0NjcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNjo0N1rOGPiXhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMTowNjo0N1rOGPiXhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDkwMQ==", "bodyText": "I think it's better to keep the square brackets.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944901", "createdAt": "2020-05-02T11:06:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -70,10 +69,10 @@ public Object parse(Object timestamp, Object pattern) {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n                 }\n                 throw new SqlIllegalArgumentException(\n-                    \"Invalid [{}] string [{}] or pattern [{}] is received; {} \",\n+                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTA3NDg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyMTozNFrOGQCoRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxOTowNDoxNVrOGQOD6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3MzQ3Nw==", "bodyText": "I don't understand this comment.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419473477", "createdAt": "2020-05-04T14:21:34Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java", "diffHunk": "@@ -62,6 +62,8 @@ public static Connection csvConnection(CsvTestCase csvTest) throws IOException,\n         csvProperties.setProperty(\"charset\", \"UTF-8\");\n         csvProperties.setProperty(\"separator\", \"|\");\n         csvProperties.setProperty(\"trimValues\", \"true\");\n+        // Converter when type is java.sql.Time use this property", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MDc3Nw==", "bodyText": "Should be rephrased to Format to read and compare java.sql.Time values", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419660777", "createdAt": "2020-05-04T19:04:15Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java", "diffHunk": "@@ -62,6 +62,8 @@ public static Connection csvConnection(CsvTestCase csvTest) throws IOException,\n         csvProperties.setProperty(\"charset\", \"UTF-8\");\n         csvProperties.setProperty(\"separator\", \"|\");\n         csvProperties.setProperty(\"trimValues\", \"true\");\n+        // Converter when type is java.sql.Time use this property", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3MzQ3Nw=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTExMzkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyOTo0M1rOGQDAxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDoyOTo0M1rOGQDAxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3OTc1MA==", "bodyText": "This package import I think it was ok where it was.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419479750", "createdAt": "2020-05-04T14:29:43Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -8,16 +8,17 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.type.DataTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTE1MTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/src/main/resources/time.csv-spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNzo1M1rOGQDYsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNDozNzo1M1rOGQDYsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NTg3Mw==", "bodyText": "I think we need to use a more useful set of test data. Have a look at the logs index - https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/qa/src/main/resources/logs.csv - and adjust the tests so that is uses that index instead. We need some real data for the time part, otherwise we just test a valid format, not that it's parsing that data properly.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419485873", "createdAt": "2020-05-04T14:37:53Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/src/main/resources/time.csv-spec", "diffHunk": "@@ -104,3 +104,88 @@ SELECT MAX(salary) FROM test_emp GROUP BY CURRENT_TIME;\n ---------------\n 74999\n ;\n+\n+selectTimeParse\n+schema::dp_time1:time|dp_time2:time\n+SELECT TIME_PARSE('11:22:33', 'HH:mm:ss') AS dp_time1,\n+TIME_PARSE('11:22:33 -05:33', 'HH:mm:ss zz') AS dp_time2;\n+\n+       dp_time1             |    dp_time2\n+----------------------------+----------------------------\n+11:22:33.000Z               | 16:55:33.000Z\n+;\n+\n+selectTimeParseWithField\n+schema::birth_date:ts|dp_birth_time:time\n+SELECT birth_date, TIME_PARSE(DATETIME_FORMAT(birth_date, 'HH mm SSS ss'), 'HH mm SSS ss') AS dp_birth_time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTMzNjQ2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxODoyOVrOGQFLcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxODoyOVrOGQFLcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTI0OQ==", "bodyText": "Indentation issue.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515249", "createdAt": "2020-05-04T15:18:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -88,23 +90,26 @@ protected DateTimeParsePipe mutate(DateTimeParsePipe instance) {\n                 f.source(),\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n-                f.right()\n+                f.right(),\n+                    DATE_TIME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTMzNzQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxODo0MVrOGQFL_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxODo0MVrOGQFL_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTM4OQ==", "bodyText": "Indentation issue.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515389", "createdAt": "2020-05-04T15:18:41Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -88,23 +90,26 @@ protected DateTimeParsePipe mutate(DateTimeParsePipe instance) {\n                 f.source(),\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n-                f.right()\n+                f.right(),\n+                    DATE_TIME\n             )\n         );\n         randoms.add(\n             f -> new DateTimeParsePipe(\n                 f.source(),\n                 f.expression(),\n                 f.left(),\n-                pipe(((Expression) randomValueOtherThan(f.right(), FunctionTestUtils::randomStringLiteral)))\n+                pipe(((Expression) randomValueOtherThan(f.right(), FunctionTestUtils::randomStringLiteral))),\n+                    DATE_TIME", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTMzODk0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxOTowMlrOGQFM8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToxOTowMlrOGQFM8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTYzNA==", "bodyText": "Indentation issue.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515634", "createdAt": "2020-05-04T15:19:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -12,20 +12,24 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.sql.AbstractSqlWireSerializingTestCase;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n \n import static org.elasticsearch.xpack.ql.expression.Literal.NULL;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.time;\n \n public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestCase<DateTimeParseProcessor> {\n \n     public static DateTimeParseProcessor randomDateTimeParseProcessor() {\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128))\n+            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n+                randomFrom(Parser.values())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTM1MTcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToyMTo1NVrOGQFVIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToyMTo1NVrOGQFVIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNzczMA==", "bodyText": "Extra white space after bracket.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419517730", "createdAt": "2020-05-04T15:21:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -126,5 +184,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time( 10, 20, 30, 123000000),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTQ5Njg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNTo1NDowN1rOGQGuUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMjoxNjo0NlrOGRB8Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ==", "bodyText": "I don't think I like the square brackets for the first argument.\nThe original message in this class was \"Invalid date/time string [{}] or pattern [{}] is received; {}\". Notice date/time that now was replaced by [{}] which means it will generate an error message like Invalid [datetime] string [07/05/2020] or pattern [dd/MM/uuuu] is received. I think it's better without square brackets.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419540561", "createdAt": "2020-05-04T15:54:07Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MTczMA==", "bodyText": "I commented to add the square brackets there, thought it made it more visible, but I'm fine without them as well.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419661730", "createdAt": "2020-05-04T19:05:49Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg3OTcyMw==", "bodyText": "We use the square brackets for values taken from the user context (like an expression the user used in the query) whereas here it's just a smart way of reusing code to build multiple error messages. This is in the same area as {}argument of [{}] must be [{}], found value [{}] type [{}] where the first argument can be first, second, third etc.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419879723", "createdAt": "2020-05-05T06:00:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3NTEzNw==", "bodyText": "Ok. I agree, thx!", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419975137", "createdAt": "2020-05-05T09:24:18Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDczOA==", "bodyText": "We use the square brackets for values taken from the user context\n\nOk, I know the rules now.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r420510738", "createdAt": "2020-05-06T02:16:46Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTUyNzE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjowMDo0NFrOGQHA6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjowMDo0NFrOGQHA6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NTMyMg==", "bodyText": "Do the assignments in the order received as parameters (ie this.parseType = parseType should come before this.parser=...).", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419545322", "createdAt": "2020-05-04T16:00:44Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTYwNTg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoxODo1N1rOGQHx2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoxODo1N1rOGQHx2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1Nzg1MQ==", "bodyText": "TimeParse and DateTimeParse have common methods (for example resolveType). Maybe have a common class handle those and extend TimeParse and DateTimeParse from that.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419557851", "createdAt": "2020-05-04T16:18:57Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTYxMjQ3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoyMDoyOVrOGQH17Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOToyNjowNlrOGQhTuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw==", "bodyText": "Shouldn't the pattern be isStringAndExact? What do you think, @matriv ? Same question for timestamp.\nOne concerning aspect, especially for pattern is that if the user provides a field as a pattern and that field is text (vs. keyword) any text in it will be analyzed. Think of capital letters being lowercased with a standard analyzer. Should we be concerned about this?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419558893", "createdAt": "2020-05-04T16:20:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MjI5OA==", "bodyText": "I understand the concern, but we don't check for exact (keyword only) in a various of other cases, like DATE_TRUNC, DATE_PART, etc.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419662298", "createdAt": "2020-05-04T19:06:46Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4ODA0OA==", "bodyText": "Maybe we should. Haven't given a lot of thought to something else other than the pattern but a text field can lowercase letters in a pattern and change the meaning of that pattern.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419888048", "createdAt": "2020-05-05T06:26:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3NjEyMw==", "bodyText": "I'd say to keep it with accepting also text for this PR.\nWe'll have to revisit all functions if we decide to exclude them and only accept exacts ('keyword'), and change the behavior consistently.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419976123", "createdAt": "2020-05-05T09:26:06Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw=="}, "originalCommit": {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUxOTA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozOTo0OVrOGRJQyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozOTo0OVrOGRJQyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMDcyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(time( 10, 20, 30, 123000000),\n          \n          \n            \n                    assertEquals(time(10, 20, 30, 123000000),", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r420630729", "createdAt": "2020-05-06T08:39:49Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -185,14 +185,12 @@ public void testParsing() {\n                 .process(null)\n         );\n         // TimeParse\n-        assertEquals(\n-                time( 10, 20, 30, 123000000),\n+        assertEquals(time( 10, 20, 30, 123000000),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "151042ac8c1ebd16368d0c632c23d88a576ecce1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIwMTY5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMDo0MFrOGR2UBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMDo0MFrOGR2UBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2ODgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Parser extractor() {\n          \n          \n            \n                public Parser parser() {", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421368837", "createdAt": "2020-05-07T09:30:40Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){\n+        return parser.toString();\n+    }\n+    \n+    public Parser extractor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIwMjc2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMTowMVrOGR2Uuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMTowMVrOGR2Uuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTAxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId , Parser parser) {\n          \n          \n            \n                public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId, Parser parser) {", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369019", "createdAt": "2020-05-07T09:31:01Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else if (ta instanceof ZonedDateTime){\n+                    return ((ZonedDateTime) ta).withZoneSameInstant(zoneId);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",\n+                    this.parseType,\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n+            }\n+        }\n+    }\n+    \n+    private final Parser parser;\n+\n     public static final String NAME = \"dtparse\";\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId) {\n+    public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId , Parser parser) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIwNDYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMToyN1rOGR2V1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzo0ODoyN1rOGScv_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.hash(parser, left(), right());\n          \n          \n            \n                    return Objects.hash(left(), right(), parser);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369302", "createdAt": "2020-05-07T09:31:27Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -79,12 +111,12 @@ public String getWriteableName() {\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern, zoneId());\n+        return this.parser.parse(timestamp, pattern, zoneId());\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right());\n+        return Objects.hash(parser, left(), right());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxMzU1MA==", "bodyText": "What's the difference?", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421913550", "createdAt": "2020-05-08T03:17:04Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -79,12 +111,12 @@ public String getWriteableName() {\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern, zoneId());\n+        return this.parser.parse(timestamp, pattern, zoneId());\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right());\n+        return Objects.hash(parser, left(), right());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg=="}, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5ODU4OA==", "bodyText": "Minor, just to have the same order as in the constructor.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421998588", "createdAt": "2020-05-08T07:48:27Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -79,12 +111,12 @@ public String getWriteableName() {\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern, zoneId());\n+        return this.parser.parse(timestamp, pattern, zoneId());\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right());\n+        return Objects.hash(parser, left(), right());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg=="}, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIwNzA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMjowMVrOGR2XTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMjowMVrOGR2XTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTY3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.equals(parser, other.parser)\n          \n          \n            \n                    return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n          \n          \n            \n                        && Objects.equals(parser, other.parser);", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369677", "createdAt": "2020-05-07T09:32:01Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIwOTg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozMjo0NlrOGR2ZLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNzo1MToxOVrOGSc1JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MDE1Ng==", "bodyText": "Is this used? If so it shouldn't contain only the parser.toString() but also left & and right.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421370156", "createdAt": "2020-05-07T09:32:46Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5OTkwOQ==", "bodyText": "It's useless, I remove it.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421999909", "createdAt": "2020-05-08T07:51:19Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MDE1Ng=="}, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIyMTYyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozNjowMlrOGR2gyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozNjowMlrOGR2gyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MjEwNA==", "bodyText": "The zoneId should be passed and used, please check out the changes in #56158", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421372104", "createdAt": "2020-05-07T09:36:02Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BaseDateTimeParseFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIzMDQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozODoyNlrOGR2mYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNDozMjo1MlrOGSYryw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzUzNw==", "bodyText": "The user session zoneId should be used.\nAn if for the OffsetTime should be added to apply the session zoneId also for times with a zone in the pattern.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421373537", "createdAt": "2020-05-07T09:38:26Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzMTk3OQ==", "bodyText": "public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n}\nIs this the right way\uff1f", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421931979", "createdAt": "2020-05-08T04:32:52Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzUzNw=="}, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzIzNDcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozOTozNlrOGR2pQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozOTozNlrOGR2pQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NDI3Mg==", "bodyText": "Parent class could hold a parser variable which is set accordingly in the constructors of the sub classes so this method and createPipe can be moved to the parent class.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421374272", "createdAt": "2020-05-07T09:39:36Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BaseDateTimeParseFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    @Override\n+    protected BinaryScalarFunction replaceChildren(Expression timestamp, Expression pattern) {\n+        return new TimeParse(source(), timestamp, pattern);\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, TimeParse::new, left(), right());\n+    }\n+\n+    @Override\n+    protected String scriptMethodName() {\n+        return \"timeParse\";\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return TIME.parse(left().fold(), right().fold(), zoneId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzI0NTYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0MjoyNFrOGR2v-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0MjoyNFrOGR2v-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NTk5NQ==", "bodyText": "DATE_TIME should be randomized with randomFrom(Parser.values())", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421375995", "createdAt": "2020-05-07T09:42:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,12 +53,12 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId());\n+        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId(), DATE_TIME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzI1NTUzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0NDo1MFrOGR22Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0NDo1MFrOGR22Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NzU3MQ==", "bodyText": "Please change test tests similarly to https://github.com/elastic/elasticsearch/pull/55223/files#diff-4469bf63c6bd559fd4d04c24e52f23e4R172 where the session timezone is used for the resulting time.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421377571", "createdAt": "2020-05-07T09:44:50Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzI3MDU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0ODo1MFrOGR2_og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0ODo1MFrOGR2_og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDAwMg==", "bodyText": "DateTimeParse shouldn't be then only function used in the creation of the pipe, since the pipe now doesn't \"belong\" to one function but it's more generic. Check this example https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/string/BinaryStringNumericPipeTests.java#L42 where you can randomize between the 2 functions DateTimeParse and TimeParse.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421380002", "createdAt": "2020-05-07T09:48:50Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -23,6 +23,8 @@\n import static org.elasticsearch.xpack.ql.expression.Expressions.pipe;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.ql.tree.SourceTests.randomSource;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+\n \n public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePipe, Pipe> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzMwMjM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoxNzo1NVrOGSdjvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoxNzo1NVrOGSdjvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMTgzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));\n          \n          \n            \n                    return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(lt.atDate(LocalDate.EPOCH)).get(0));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422011836", "createdAt": "2020-05-08T08:17:55Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -209,4 +211,32 @@ public static int getNanoPrecision(Expression precisionExpression, int nano) {\n     public static ZonedDateTime atTimeZone(LocalDateTime ldt, ZoneId zoneId) {\n         return ZonedDateTime.ofInstant(ldt, zoneId.getRules().getValidOffsets(ldt).get(0), zoneId);\n     }\n+    \n+    public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n+    }\n+    \n+    public static OffsetTime atTimeZone(LocalTime lt, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzMwOTI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMDoxMFrOGSdnnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMDoxMFrOGSdnnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMjgzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n          \n          \n            \n                    return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ot.atDate(LocalDate.EPOCH).toLocalDateTime()).get(0));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422012831", "createdAt": "2020-05-08T08:20:10Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -209,4 +211,32 @@ public static int getNanoPrecision(Expression precisionExpression, int nano) {\n     public static ZonedDateTime atTimeZone(LocalDateTime ldt, ZoneId zoneId) {\n         return ZonedDateTime.ofInstant(ldt, zoneId.getRules().getValidOffsets(ldt).get(0), zoneId);\n     }\n+    \n+    public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzMxMjAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMTowOFrOGSdpUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMTowOFrOGSdpUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzI2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013265", "createdAt": "2020-05-08T08:21:08Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DATETIME;\n+    protected Parser parser() {\n+        return DATE_TIME;\n     }\n-\n+    \n     @Override\n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        return TypeResolution.TYPE_RESOLVED;\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n+        return DateTimeParse::new;\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzMxMjI5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMToxNFrOGSdpeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMToxNFrOGSdpeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzMwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013306", "createdAt": "2020-05-08T08:21:14Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DATETIME;\n+    protected Parser parser() {\n+        return DATE_TIME;\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzMxMjcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMToyM1rOGSdptg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODoyMToyM1rOGSdptg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzM2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013366", "createdAt": "2020-05-08T08:21:23Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzY5OTQxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MDo1OVrOGShUCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToyMjowMlrOGSpZSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            08:20:30.000Z\n          \n          \n            \n            10:20:30.000+03:00", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422073353", "createdAt": "2020-05-08T10:40:59Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE2NTQyNg==", "bodyText": "LocalDateTime ldt = lt.atDate(LocalDate.of(1970, 1, 1)) I has one question. In 1970, the offset time of Athens is '+02:00',  but the offset time of Athens is '+03:00' now. I think using LocalDateTime.now().toLocalDateTime() is correctly.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422165426", "createdAt": "2020-05-08T14:10:48Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw=="}, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE2NzA5NQ==", "bodyText": "Let's leave the code with LocalDate.EPOCH and use +02:00 in the example.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422167095", "createdAt": "2020-05-08T14:13:52Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw=="}, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3NDE4Ng==", "bodyText": "Do I need to explain it in note\uff1f", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422174186", "createdAt": "2020-05-08T14:26:15Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw=="}, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NDM3Nw==", "bodyText": "Yes please! thank you.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422194377", "createdAt": "2020-05-08T15:01:08Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw=="}, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNTc3MQ==", "bodyText": "Let me try. I'm not good at English.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422205771", "createdAt": "2020-05-08T15:22:02Z", "author": {"login": "Patrick0308"}, "path": "x-pack/plugin/sql/qa/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2783,6 +2784,42 @@ schema::datetime:ts\n // end::dateTimeParse3\n ;\n \n+timeParse1\n+schema::time:time\n+// tag::timeParse1\n+SELECT TIME_PARSE('10:20:30.123', 'HH:mm:ss.SSS') AS \"time\";\n+\n+     time\n+---------------\n+10:20:30.123Z\n+// end::timeParse1\n+;\n+\n+timeParse2\n+schema::time:time\n+// tag::timeParse2\n+SELECT TIME_PARSE('10:20:30-01:00', 'HH:mm:ssXXX') AS \"time\";\n+\n+     time\n+---------------\n+11:20:30.000Z\n+// end::timeParse2\n+;\n+\n+timeParse3-Ignore\n+schema::time:time\n+// tag::timeParse3\n+{\n+    \"query\" : \"SELECT DATETIME_PARSE('10:20:30', 'HH:mm:ss') AS \\\"time\\\"\",\n+    \"time_zone\" : \"Europe/Athens\"\n+}\n+\n+      time\n+------------------------------------\n+08:20:30.000Z", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzM1Mw=="}, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzcwMTM4OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MTo1MlrOGShVNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMDo0MTo1MlrOGShVNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MzY1Mg==", "bodyText": "Please include it in a NOTE similarly to: https://github.com/elastic/elasticsearch/pull/56158/files#diff-b91ca24147aa7c0d4371fa129d3e51bdR487", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422073652", "createdAt": "2020-05-08T10:41:52Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -496,6 +496,53 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse3]\n --------------------------------------------------\n ====\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: time\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]\n+If timezone is not specified in the time string expression and the parsing pattern, the resulting `time` will\n+be in `UTC` timezone.\n+\n+[NOTE]\n+If the parsing pattern contains date units (e.g. 'dd/MM/uuuu', 'dd-MM HH:mm:ss', etc.) an error is returned\n+as the function needs to return a value of `time` type which will contain only time.\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse1]\n+--------------------------------------------------\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse2]\n+--------------------------------------------------\n+\n+[source, sql]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODQ5ODQxOnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNDoyNFrOGSozsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNDoyNFrOGSozsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NjE0Ng==", "bodyText": "Please remove the whole note.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422196146", "createdAt": "2020-05-08T15:04:24Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -496,6 +496,59 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse3]\n --------------------------------------------------\n ====\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: time\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74fb5ddf3c2cd233606cdf91c575b425b612f5bd"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODc3OTU1OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoyOTowNVrOGSrhww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoyOTowNVrOGSrhww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MDcwNw==", "bodyText": "If timezone is not specified in the time string expression and the parsing pattern, \nthe resulting `time` will have the offset of the time zone specified by the user through the\n <<sql-rest-fields-timezone,`time_zone`>>/<<jdbc-cfg-timezone,`timezone`>> REST/driver \nparameters at the Unix epoch date (`1970-01-01`) with no conversion applied.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422240707", "createdAt": "2020-05-08T16:29:05Z", "author": {"login": "matriv"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -496,6 +496,59 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[dateTimeParse3]\n --------------------------------------------------\n ====\n \n+[[sql-functions-datetime-timeparse]]\n+==== `TIME_PARSE`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TIME_PARSE(\n+    string_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> time expression as a string\n+<2> parsing pattern\n+\n+*Output*: time\n+\n+*Description*: Returns a time by parsing the 1st argument using the format specified in the 2nd argument. The parsing\n+format pattern used is the one from\n+https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html[`java.time.format.DateTimeFormatter`].\n+If any of the two arguments is `null` or an empty string `null` is returned.\n+\n+[NOTE]\n+If timezone is not specified in the time string expression and the parsing pattern, the resulting `time` will\n+be in `UTC` timezone.\n+\n+[NOTE]\n+If the parsing pattern contains date units (e.g. 'dd/MM/uuuu', 'dd-MM HH:mm:ss', etc.) an error is returned\n+as the function needs to return a value of `time` type which will contain only time.\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse1]\n+--------------------------------------------------\n+\n+[source, sql]\n+--------------------------------------------------\n+include-tagged::{sql-specs}/docs/docs.csv-spec[timeParse2]\n+--------------------------------------------------\n+\n+[NOTE]\n+====\n+The resulting `time` will have the offset time of time zone in The Unix epoch which specified by the user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ebd5f883f5fdc1808f6ab815c64c1d21c716eec"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDI3NjU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODo1ODo0MFrOGXWsOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODo1ODo0MFrOGXWsOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0MjIwMg==", "bodyText": "zoneId() should be part of equals and hashCode methods, through super method calls.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427142202", "createdAt": "2020-05-19T08:58:40Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -128,16 +121,11 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(parser, other.parser)\n-            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n-    }\n-\n-    @Override\n-    public String toString(){\n-        return parser.toString();\n+        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDMwNDc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowNToxOVrOGXW9Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowNToxOVrOGXW9Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjU5OQ==", "bodyText": "Please, remove these whitespaces.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427146599", "createdAt": "2020-05-19T09:05:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -6,65 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class TimeParse extends BinaryDateTimeFunction {\n+public class TimeParse extends BaseDateTimeParseFunction {\n     \n-    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDMwNTIyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowNToyNVrOGXW9sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTowNToyNVrOGXW9sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjY3NA==", "bodyText": "Please, remove these whitespaces.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427146674", "createdAt": "2020-05-19T09:05:25Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -6,65 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class TimeParse extends BinaryDateTimeFunction {\n+public class TimeParse extends BaseDateTimeParseFunction {\n     \n-    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return SqlDataTypes.TIME;\n+    protected Parser parser() {\n+        return TIME;\n     }\n-\n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        return TypeResolution.TYPE_RESOLVED;\n+    \n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n+        return TimeParse::new;\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQyOTE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNzoxOVrOGXYL9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNzoxOVrOGXYL9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjcxMQ==", "bodyText": "This should be new DateTimeParsePipe(b3.source().....). You change here the Parser not the Source. Source was changed and asserted before this.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427166711", "createdAt": "2020-05-19T09:37:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -53,21 +61,38 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), DATE_TIME);\n+        DateTimeParsePipe newB = new DateTimeParsePipe(\n+                b1.source(), \n+                newExpression, \n+                b1.left(), \n+                b1.right(), \n+                b1.zoneId(), \n+                b1.parser());\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), DATE_TIME);\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), b2.parser());\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n+    \n+        DateTimeParsePipe b3 = randomInstance();\n+        Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n+        newB = new DateTimeParsePipe(newLoc, b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDY3MjAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDo0NTowM1rOGXajvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDo0NTowM1rOGXajvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNTU2NQ==", "bodyText": "In testTransform I think you need to test a new zoneId, as well.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427205565", "createdAt": "2020-05-19T10:45:03Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,21 +61,38 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDkyMzk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTo1OTozM1rOGXdAZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTo1OTozM1rOGXdAZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTY3MA==", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245670", "createdAt": "2020-05-19T11:59:33Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -76,7 +82,8 @@ public void testInvalidInputs() {\n             () -> new DateTimeParse(Source.EMPTY, l(\"2020-04-07\"), l(\"MM/dd\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [2020-04-07] or pattern [MM/dd] is received; Text '2020-04-07' could not be parsed at index 2\",\n+            \"Invalid datetime string [2020-04-07] or pattern [MM/dd] is received; \" +\n+                    \"Text '2020-04-07' could not be parsed at index 2\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDkyNDM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTo1OTo0MVrOGXdAqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTo1OTo0MVrOGXdAqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTczNg==", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245736", "createdAt": "2020-05-19T11:59:41Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -85,7 +92,8 @@ public void testInvalidInputs() {\n             () -> new DateTimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [07/05/2020] or pattern [dd/MM/uuuu] is received; Unable to convert parsed text into [datetime]\",\n+            \"Invalid datetime string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n+                    \"Unable to convert parsed text into [datetime]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDkyNTI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTo1OTo1OFrOGXdBNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTo1OTo1OFrOGXdBNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTg3OA==", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245878", "createdAt": "2020-05-19T11:59:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -94,20 +102,70 @@ public void testInvalidInputs() {\n                 Source.EMPTY, l(\"10:20:30.123456789\"), l(\"HH:mm:ss.SSSSSSSSS\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [10:20:30.123456789] or pattern [HH:mm:ss.SSSSSSSSS] is received; \"\n+            \"Invalid datetime string [10:20:30.123456789] or pattern [HH:mm:ss.SSSSSSSSS] is received; \"\n                 + \"Unable to convert parsed text into [datetime]\",\n             siae.getMessage()\n         );\n     }\n+    \n+    public void testTimeInvalidInputs() {\n+        SqlIllegalArgumentException siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(10), randomStringLiteral(), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\"A string is required; received [10]\", siae.getMessage());\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, randomStringLiteral(), l(20), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\"A string is required; received [20]\", siae.getMessage());\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"11:04:07\"), l(\"invalid\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [11:04:07] or pattern [invalid] is received; Unknown pattern letter: i\",\n+                siae.getMessage()\n+        );\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"11:04:07\"), l(\"HH:mm\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [11:04:07] or pattern [HH:mm] is received; \" +\n+                        \"Text '11:04:07' could not be parsed, unparsed text found at index 5\",\n+                siae.getMessage()\n+        );\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n+                        \"Unable to convert parsed text into [time]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDkzMDc2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMTo0NVrOGXdE9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMTo0NVrOGXdE9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NjgzNw==", "bodyText": "These lines do not align with the previous tests in the same method. Please, use the same indentation rules.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427246837", "createdAt": "2020-05-19T12:01:45Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDkzMjA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMjoxMVrOGXdFyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMjowMjoxMVrOGXdFyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NzA0OA==", "bodyText": "These lines do not align with the previous tests in the same method. Please, use the same indentation rules.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427247048", "createdAt": "2020-05-19T12:02:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)\n+        );\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDU5NzI5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODozOToyNFrOGYBLig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODozOToyNFrOGYBLig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzODM0Ng==", "bodyText": "All these four lines do not align with the rest of the calls in the same method. Compare these with the ones above and, please, change them to have a consistent look and feel.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427838346", "createdAt": "2020-05-20T08:39:24Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -192,14 +189,14 @@ public void testParsing() {\n         assertEquals(\n                 time(10, 20, 30, 123000000, zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODczMTY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODowMDoyNFrOGYp1_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODowMDoyNFrOGYp1_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNDU3NA==", "bodyText": "Please use super.hashCode() and add only the parser here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r428504574", "createdAt": "2020-05-21T08:00:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -107,7 +107,7 @@ protected Object doProcess(Object timestamp, Object pattern) {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right(), parser);\n+        return Objects.hash(left(), right(), zoneId(), parser);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODczMzY1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODowMToxNlrOGYp3Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODowMToxNlrOGYp3Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNDg5MA==", "bodyText": "Please use super.equals() and only check the equality on parser here.", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r428504890", "createdAt": "2020-05-21T08:01:16Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -122,7 +122,7 @@ public boolean equals(Object obj) {\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n         return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n-                && Objects.equals(parser, other.parser);\n+                && Objects.equals(zoneId(), other.zoneId()) && Objects.equals(parser, other.parser);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTY5ODUzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxMzoxMVrOGal08A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxMzoxMVrOGal08A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNTkyMA==", "bodyText": "This is wrong again. It should be\n        DateTimeParsePipe b4 = randomInstance();\n        ZoneId newZI = randomValueOtherThan(b4.zoneId(), ESTestCase::randomZone);\n        newB = new DateTimeParsePipe(b4.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n        assertEquals(newB, b4.transformPropertiesOnly(v -> Objects.equals(v, b4.zoneId()) ? newZI : v, ZoneId.class));", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r430535920", "createdAt": "2020-05-26T16:13:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,21 +62,43 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId());\n+        DateTimeParsePipe newB = new DateTimeParsePipe(\n+                b1.source(), \n+                newExpression, \n+                b1.left(), \n+                b1.right(), \n+                b1.zoneId(), \n+                b1.parser());\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId());\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), b2.parser());\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n+    \n+        DateTimeParsePipe b3 = randomInstance();\n+        Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n+        newB = new DateTimeParsePipe(b3.source(), b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.parser()) ? newPr : v, Parser.class));\n+    \n+        DateTimeParsePipe b4 = randomInstance();\n+        ZoneId newZI = ESTestCase.randomZone();\n+        newB = new DateTimeParsePipe(b3.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.zoneId()) ? newZI : v, ZoneId.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTcyMDE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxODowN1rOGamCCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxODowN1rOGamCCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzOTI3Mw==", "bodyText": "Again, indentation should be consistent. This method should look like below. As it is now, it is not like I commented in my review.\n    public void testParsing() {\n        // DateTimeParse\n        ZoneId zoneId = ZoneId.of(\"America/Sao_Paulo\");\n        assertEquals(\n            dateTime(2020, 4, 7, 10, 20, 30, 123000000, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123\"), l(\"dd/MM/uuuu HH:mm:ss.SSS\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            dateTime(2020, 4, 7, 5, 20, 30, 123456789, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 Europe/Berlin\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS VV\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            dateTime(2020, 4, 7, 1, 50, 30, 123456789, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 +05:30\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS zz\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        // TimeParse\n        assertEquals(\n            time(10, 20, 30, 123000000, zoneId),\n            new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n            new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n                .asProcessor()\n                .process(null)\n        );\n    }", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r430539273", "createdAt": "2020-05-26T16:18:07Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +185,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                    .asProcessor()\n+                    .process(null)\n+        );\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                    .asProcessor()\n+                    .process(null)\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9"}, "originalPosition": 160}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1043, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}