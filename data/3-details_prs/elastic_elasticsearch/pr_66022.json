{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NDM3MDU2", "number": 66022, "title": "QL: Simplify arithmetic operations in binary comps", "bodyText": "This PR adds an optimizer rule to simplify the arithmetic operations\nin binary comparison expressions, which in turn will allow for further\nexpression compounding by the optimiser.\nOnly the negation and plus, minus, multiplication and division are\ncurrently considered and only when two of the operands are a literal.\nFor instance ((a + 1) / 2 - 3) * 4 >= 14 becomes a >= 12.\nCloses #65394.", "createdAt": "2020-12-08T13:04:34Z", "url": "https://github.com/elastic/elasticsearch/pull/66022", "merged": true, "mergeCommit": {"oid": "f5c2982202d5f5eedf2794aa1602f2290fb0b887"}, "closed": true, "closedAt": "2021-02-01T19:09:23Z", "author": {"login": "bpintea"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkJkSAgH2gAyNTM0NDM3MDU2OmM5MzFlZjhkZDRjNTRmMzRhNmFmMjYwYjlhZjQ0MGNiYzA3NTM4MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd16p02AH2gAyNTM0NDM3MDU2OjE4YzExYmU1MDFjODdjOGE5ZTZjMGU3NGI1ODljY2MzM2ZlOTE1NjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c931ef8dd4c54f34a6af260b9af440cbc0753826", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/c931ef8dd4c54f34a6af260b9af440cbc0753826", "committedDate": "2020-12-08T12:47:17Z", "message": "Simplify arithmetic operations in binary comps\n\nThis commit adds an optimizer rule to simplify the arithmetic operations\nin binary comparison expressions, which in turn will allow for further\nexpression compounding by the optimiser.\n\nOnly the negation and plus, minus, multiplication and division are\ncurrently considered and only when two of the operands are a literal.\n\nFor instance `((a + 1) / 2 - 3) * 4 >= 14` becomes `a >= 12`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/0db90e4457b32e85954126ec5a565850661b0535", "committedDate": "2020-12-08T13:00:30Z", "message": "Undo unintentional change\n\nRevert unintentional change of a source file."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Mjc1NjUx", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-547275651", "createdAt": "2020-12-08T14:17:53Z", "commit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoxNzo1M1rOIBereA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoxNzo1M1rOIBereA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyMjEzNg==", "bodyText": "Why do you identify multiplication with wildcard symbol and not with an instanceof?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538422136", "createdAt": "2020-12-08T14:17:53Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MjgzNjg0", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-547283684", "createdAt": "2020-12-08T14:26:22Z", "commit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyNjoyMlrOIBfNow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDo1MTozMlrOIBg26Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMDg4Mw==", "bodyText": "Add javadoc regarding the purpose of the method.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538430883", "createdAt": "2020-12-08T14:26:22Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/comparison/BinaryComparison.java", "diffHunk": "@@ -49,4 +49,6 @@ protected Pipe makePipe() {\n     public static Integer compare(Object left, Object right) {\n         return Comparisons.compare(left, right);\n     }\n+\n+    public abstract BinaryComparison reverse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTI2Ng==", "bodyText": "return Div instead of ArithmeticOperation.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538431266", "createdAt": "2020-12-08T14:26:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mul.java", "diffHunk": "@@ -52,4 +52,9 @@ protected Mul replaceChildren(Expression newLeft, Expression newRight) {\n     public Mul swapLeftAndRight() {\n         return new Mul(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTM4Ng==", "bodyText": "return Add instead of ArithmeticOperation", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538431386", "createdAt": "2020-12-08T14:26:53Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Sub.java", "diffHunk": "@@ -27,4 +27,9 @@ public Sub(Source source, Expression left, Expression right) {\n     protected Sub replaceChildren(Expression newLeft, Expression newRight) {\n         return new Sub(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjc3MA==", "bodyText": "The exception type is wrong. And we rarely thrown an exception on methods that are forced to be implemented - that indicates either the code is incomplete (as here) or that the contract is too broad.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538432770", "createdAt": "2020-12-08T14:28:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -30,4 +30,10 @@ public Mod(Source source, Expression left, Expression right) {\n     protected Mod replaceChildren(Expression newLeft, Expression newRight) {\n         return new Mod(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        // TODO: Modular Multiplicative Inverse, if ever needed?\n+        throw new UnsupportedOperationException(\"inverting modulo operation is not supported\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjk2OQ==", "bodyText": "return Mul instead of ArithmeticOperation", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538432969", "createdAt": "2020-12-08T14:28:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Div.java", "diffHunk": "@@ -34,4 +34,9 @@ protected Div replaceChildren(Expression newLeft, Expression newRight) {\n     public DataType dataType() {\n         return DataTypeConverter.commonType(left().dataType(), right().dataType());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzE5OA==", "bodyText": "Javadoc on what this does.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538433198", "createdAt": "2020-12-08T14:28:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,6 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    public abstract ArithmeticOperation inverse(Source source, Expression left, Expression right);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzQwMg==", "bodyText": "return Sub instead of ArithmeticOperation", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538433402", "createdAt": "2020-12-08T14:28:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNzEzNw==", "bodyText": "The test only cares about the expression so you can just use parser.createExpression (see tests inside ExpressionTests).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538437137", "createdAt": "2020-12-08T14:32:41Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {\n+        // i >= 12\n+        doTestBinaryComparisonReduction(\"((int + 1) / 2 - 3) * 4 >= 14\", GreaterThanOrEqual.class, 12d);\n+    }\n+\n+    public void testReducedBinaryComYparisonLessThen() {\n+        // i < -5/6\n+        doTestBinaryComparisonReduction(\"12 * (-int / 5) > (8 + 12) / 10\", LessThan.class, -5d / 6);\n+    }\n+\n+    public void testReducedBinaryComYparisonNotEquals() {\n+        // i != 7000\n+        doTestBinaryComparisonReduction(\"-3600 != (int - 200) / 2\", NotEquals.class, -7000);\n+    }\n+\n+    public void testReducedBinaryComparisonEquals() {\n+        // i = -12\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithConjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 AND int >= -12\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithDisjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 OR int > -12\", GreaterThanOrEqual.class, -12d);\n+    }\n+\n+    private void doTestBinaryComparisonReduction(String expression, Class<? extends BinaryComparison> binaryComparisonClass,\n+                                                 Number bound) {\n+        LogicalPlan plan = plan(\"SELECT some.string FROM test WHERE \" + expression);\n+\n+        assertTrue(plan instanceof UnaryPlan);\n+        UnaryPlan unaryPlan = (UnaryPlan) plan;\n+        assertTrue(unaryPlan.child() instanceof Filter);\n+        Filter filter = (Filter) unaryPlan.child();\n+        assertEquals(binaryComparisonClass, filter.condition().getClass());\n+        BinaryComparison bc = (BinaryComparison) filter.condition();\n+\n+        assertTrue(bc.left() instanceof FieldAttribute);\n+        FieldAttribute attribute = (FieldAttribute) bc.left();\n+        assertEquals(\"int\", attribute.name());\n+\n+        assertTrue(bc.right() instanceof Literal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0MjE1Ng==", "bodyText": "I'd like to see more tests that the behavior regarding commutative vs non-commutative expressions:\na + 2 > 3\n2 + a > 3\na - 2 > 3\n2 - a > 3\na * 2 > 3\n2 * a > 3\na / 2 > 3\n2 / a > 3\n1 / (a - 2) > 3\n1 / (2 - a) > 3\n1 / (2 + (2 - a) > 3", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538442156", "createdAt": "2020-12-08T14:37:14Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NDc5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (e instanceof BinaryComparison) {\n          \n          \n            \n                            return reduce((BinaryComparison) e);\n          \n          \n            \n                        }\n          \n          \n            \n                        return e;\n          \n          \n            \n                        if (e instanceof BinaryComparison) {\n          \n          \n            \n                            e = reduce((BinaryComparison) e);\n          \n          \n            \n                        }\n          \n          \n            \n                        return e;", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538444797", "createdAt": "2020-12-08T14:39:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NjAwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n          \n          \n            \n                        // optimize only once the expression looks like `Expression [ArithmeticOp] Expression [BinaryComp] Literal`", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538446002", "createdAt": "2020-12-08T14:40:43Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzgzMw==", "bodyText": "Try to avoid using strings for type matching. Assuming there's no other either way move use a string reference to indicate its source, such as DefaultBinaryArithmeticOperation.MUL.symbol() instead of *.\nAlso please add some comments to explain what's going on - if the symbol is Mul, force double division by promoting the right literal to a double?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538457833", "createdAt": "2020-12-08T14:51:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDM4MTIx", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-547438121", "createdAt": "2020-12-08T17:01:31Z", "commit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzowMTozMVrOIBp3DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzowNDoxN1rOIBqDBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwNTMyNQ==", "bodyText": "Precision loss might cause some issues here. a + b == c is mathematically the same as a == c - b, except when you take into account the potential precision loss.\nFor example:\na = 1.0E-15\nb = 1.0E15\nc = 1.0E15\n\na + b == c\n1.0E-15 + 1.0E15 == 1.0E15\n1.0E15 == 1.0E15\ntrue\n\na == c - b\n1.0E-15 == 1.0E15 - 1.0E15\n1.0E-15 == 0.0\nfalse\n\nSo even though the query before and after the optimization might be mathematically equivalent, it still won't return the same result after the optimization is applied. This might have unintended consequences after a version upgrade. I think we should discuss this before moving ahead with the PR.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538605325", "createdAt": "2020-12-08T17:01:31Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul\n+                        bcRight = new Literal(bcRight.source(), ((Number) bcRight.value()).doubleValue(), DOUBLE);\n+                    }\n+                    return bc.replaceChildren(List.of(opLeft.left(), opLeft.inverse(bcRight.source(), bcRight, opLeft.right())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwODM4OA==", "bodyText": "I would add some tests for testing with numbers where overflow or precision loss can occur.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538608388", "createdAt": "2020-12-08T17:04:17Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abc632d2f043832f3d0d63b1ea50906fc1b8fb31", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/abc632d2f043832f3d0d63b1ea50906fc1b8fb31", "committedDate": "2020-12-14T09:14:20Z", "message": "Refactor the optimisation. Adress review comments\n\nThe optimisation is now refactor splitting the logic by add-sub and\nmul-div operations.\nFurther restictions are put in place, to prevent the\noptimiser from chaning the outcome of the filtering.\nMore tests have been added."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b031dfbcd348117b01ff89712af9b55bd1882398", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/b031dfbcd348117b01ff89712af9b55bd1882398", "committedDate": "2020-12-14T09:17:16Z", "message": "Merge branch 'master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d641e45fe7faea9d2aaa635fec272521788bb1e", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d641e45fe7faea9d2aaa635fec272521788bb1e", "committedDate": "2020-12-14T09:36:09Z", "message": "Style fix\n\nRemoved now unused import."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/1a28179fd76bae83d23c56ef566ae006ff7a7a2a", "committedDate": "2020-12-14T10:32:44Z", "message": "Test fix\n\n- update test condition to remove (non-optimisable) integer division."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1Njk2NzQ1", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-555696745", "createdAt": "2020-12-18T17:57:01Z", "commit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzo1NzowMlrOIIs7VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo0MToxNVrOIIwffQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5NTYwNA==", "bodyText": "Why not mark it as abstract? In case we add a new operation, silently using this inverse might have unintended consequences, while with abstract the compiler will force you to think about it.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r545995604", "createdAt": "2020-12-18T17:57:02Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**\n+     * Returns the opposite of this operation.\n+     */\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzI4NQ==", "bodyText": "Extract symbol check into a separate function.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (child instanceof ArithmeticOperation) {\n          \n          \n            \n                                ArithmeticOperation operation = (ArithmeticOperation) child;\n          \n          \n            \n                                String opSymbol = operation.symbol();\n          \n          \n            \n                                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n          \n          \n            \n                            if (isMulOrDiv(child)) {\n          \n          \n            \n                                ArithmeticOperation operation = (ArithmeticOperation) child;", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546007285", "createdAt": "2020-12-18T18:18:25Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODMwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n          \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) e;\n          \n          \n            \n                            String opSymbol = operation.symbol();\n          \n          \n            \n                            if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n          \n          \n            \n                        } else if (isMulOrDiv(e)) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n          \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) e;", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546008307", "createdAt": "2020-12-18T18:20:04Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMDczNw==", "bodyText": "I would use the field() method that already abstracts out the children access.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n          \n          \n            \n                                        return operation.replaceChildren(List.of(((Neg)operation.left()).field(), operation.right()));", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546010737", "createdAt": "2020-12-18T18:24:45Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTI0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (operation.right() instanceof Neg) {\n          \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n          \n          \n            \n                                    }\n          \n          \n            \n                                    if (operation.right() instanceof Neg) {\n          \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left(), ((Neg)operation.right()).field()));\n          \n          \n            \n                                    }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546011248", "createdAt": "2020-12-18T18:25:44Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjk2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    Neg neg = (Neg) operation.left();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n          \n          \n            \n                                    Expression newLeft = ((Neg) operation.left()).field();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(newLeft, operation.right())));", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546012969", "createdAt": "2020-12-18T18:28:53Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDM0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    Neg neg = (Neg) operation.right();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n          \n          \n            \n                                    Expression newRight = ((Neg) operation.right()).field();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), newRight)));", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546014349", "createdAt": "2020-12-18T18:31:38Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTE4Mw==", "bodyText": "What about double Neg? Do we already have a rule that changes NEG - NEG - x to x?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546019183", "createdAt": "2020-12-18T18:41:14Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNTAxNg==", "bodyText": "Some renaming and inlining would make this easier to read and reason about. The safeMaybeFold is just a really simple try-catch that you kind of mimic with the null check anyways.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private static Expression reduceNegation(BinaryComparison bc) {\n          \n          \n            \n                        Literal bcLiteral = (Literal) bc.right();\n          \n          \n            \n                        Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n          \n          \n            \n                        return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n          \n          \n            \n                    }\n          \n          \n            \n                    private static Expression reduceNegation(BinaryComparison bc) {\n          \n          \n            \n                        Literal oldRight = (Literal) bc.right();\n          \n          \n            \n                        Neg newRight = new Neg(oldRight.source(), oldRight);\n          \n          \n            \n                        Expression newLeft = ((Neg) bc.left()).field();\n          \n          \n            \n                        try {\n          \n          \n            \n                            newRight = new Literal(newRight.source(), newRight.fold(), newRight.dataType());\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // cannot optimize the negation, either ArithmeticException or DateTimeException\n          \n          \n            \n                            // but safe to just turn off the optmisation should any exception arise\n          \n          \n            \n                            return bc;\n          \n          \n            \n                        }\n          \n          \n            \n                        return bc.reverse().replaceChildren(List.of(newLeft, newRight));\n          \n          \n            \n                    }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546035016", "createdAt": "2020-12-18T19:09:11Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1MjI1OA==", "bodyText": "Remove the explicit check on the not handled cases (MUL), just to stay on the safe side in case we add any sort of magic Arithmetic operators (so any possible new operation won't be treated as Add/Sub by default).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n          \n          \n            \n                            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n          \n          \n            \n                            String opSymbol = operation.symbol();\n          \n          \n            \n                            // Modulo can't be simplified.\n          \n          \n            \n                            if (MOD.symbol().equals(opSymbol)) {\n          \n          \n            \n                                return comparison;\n          \n          \n            \n                            }\n          \n          \n            \n                            SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n          \n          \n            \n                                ? new SimplifyMulDiv(comparison)\n          \n          \n            \n                                : new SimplifyAddSub(comparison);\n          \n          \n            \n                            SimplifyOperation simplification = null;\n          \n          \n            \n                            if (isMulOrDiv(comparison.left()) {\n          \n          \n            \n                                simplification = new SimplifyMulDiv(comparison);\n          \n          \n            \n                            } else if (isAddOrSub(comparison.left()) {\n          \n          \n            \n                                simplification = new SimpliAddSub(comparison);\n          \n          \n            \n                            }\n          \n          \n            \n                            if (simplification == null) {\n          \n          \n            \n                                return comparison;\n          \n          \n            \n                            }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546052258", "createdAt": "2020-12-18T19:37:29Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation\n+                    // should any exception arise.\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n+                    ? new SimplifyMulDiv(comparison)\n+                    : new SimplifyAddSub(comparison);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NDAxMw==", "bodyText": "I think the inverse should throw an exception in this class.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546054013", "createdAt": "2020-12-18T19:41:15Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * <a href=\"https://en.wikipedia.org/wiki/Modulo_operation\">Modulo</a>\n  * function ({@code a % b}).\n- * \n+ *\n  * Note this operator is also registered as a function (needed for ODBC/SQL) purposes.\n  */\n public class Mod extends ArithmeticOperation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxODk1NzUz", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-561895753", "createdAt": "2021-01-05T15:39:53Z", "commit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTozOTo1M1rOIOcGlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo1ODozN1rOIOc3xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMTQxMw==", "bodyText": "Why were these values changed? I assume it's about checking the limit however why not add new tests instead of modifying the existing ones?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552011413", "createdAt": "2021-01-05T15:39:53Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/test/resources/queryfolder_tests.txt", "diffHunk": "@@ -454,35 +454,35 @@ process where wildcard(process_path, \"*\\\\red_ttp\\\\wininit.*\", \"*\\\\abc\\\\*\", \"*def\n \n \n addOperator\n-process where serial_event_id + 2 == 41\n+process where serial_event_id + 2 == -2147483647", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMjk1NA==", "bodyText": "What does opposite mean? And why is the opposite called inverse?\nFurther more is a bit of a stretch to define this method on the current instance - from what I can tell this method is about finding the method opposite operation for the given operation WITHOUT reusing its arguments. That is this is about Add not Add(3,1).\nThis can be better conveyed by returning a BiFunction and thus returning a Factory instead of the final product or moving somewhere else considering you pass a Source object as well.\nThe result also might not be an ArithmeticOperation, see Mod which is an integral operation and thus something we should strive to support.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552012954", "createdAt": "2021-01-05T15:42:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMzc2OQ==", "bodyText": "I'm not sure this is correct. Add is a commutative operation but Sub is not. 3 + 1 is the same as 1 +3 but 1 -3 ! 3 - 1.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552013769", "createdAt": "2021-01-05T15:43:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxOTg4Mg==", "bodyText": "Let's catch just those expections then - otherwise we might catch accidently and swallow other exceptions that we should not.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552019882", "createdAt": "2021-01-05T15:52:39Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyMjQ3Ng==", "bodyText": "Nice - please add test with double negations and checking the min/max value for both integer and longs and division by zero.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552022476", "createdAt": "2021-01-05T15:56:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.sql-spec", "diffHunk": "@@ -87,3 +87,149 @@ orderByModulo\n SELECT emp_no FROM test_emp ORDER BY emp_no % 10000 LIMIT 10;\n orderByMul\n SELECT emp_no FROM test_emp ORDER BY emp_no * 2 LIMIT 10;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg==", "bodyText": "Why is the script still used? there's no point in moving the interval to the right if it is not added to the given literal.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552024006", "createdAt": "2021-01-05T15:58:37Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e74b697a5aefb1050961cd28b016577c14af471d", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/e74b697a5aefb1050961cd28b016577c14af471d", "committedDate": "2021-01-07T15:42:47Z", "message": "Address review comments\n\n- add isMulOrDiv and isAddOrSub methods;\n- add a new factory if'ace for the arithmetic operations invertible in\n  relation to a binary comparison;\n- simplify NEG - NEG tree structures;\n- more tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25becef5051ed502f1f600abcdbd16c057c01409", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/25becef5051ed502f1f600abcdbd16c057c01409", "committedDate": "2021-01-07T15:44:52Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92c74c98b6aeb4ae5ca79ba5dc8bd0bb46d45605", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/92c74c98b6aeb4ae5ca79ba5dc8bd0bb46d45605", "committedDate": "2021-01-11T16:30:08Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06fea9ca1e0d45fbad6bf731fe4fd0d36a7dfa8b", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/06fea9ca1e0d45fbad6bf731fe4fd0d36a7dfa8b", "committedDate": "2021-01-12T12:03:05Z", "message": "Remove negation optmisations\n\nThese are unsafe, see\nhttps://github.com/elastic/elasticsearch/pull/67278"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa5059917d544e4e4faa1c3ff21a6963861766c5", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa5059917d544e4e4faa1c3ff21a6963861766c5", "committedDate": "2021-01-12T12:04:07Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e9d04b63c4012dcd44dece07482e8dc5ff1440c", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e9d04b63c4012dcd44dece07482e8dc5ff1440c", "committedDate": "2021-01-12T15:56:15Z", "message": "Reintroduce negation reduction\n\n* `NEG - x < Literal` becomes `x > -Literal` if folding can be done.\n* add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c9c088e024e0a7fff43678dfd2b773683c373a4", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/0c9c088e024e0a7fff43678dfd2b773683c373a4", "committedDate": "2021-01-12T15:59:50Z", "message": "Revert WS-only changes\n\nRevert changes in files where only WS was updated."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e28e9a69b933ef31b32f553cf0b5da0fe30aa3cd", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/e28e9a69b933ef31b32f553cf0b5da0fe30aa3cd", "committedDate": "2021-01-12T16:00:54Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32cefb8a296a57a9e9aeccee05fef27cce5432a7", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/32cefb8a296a57a9e9aeccee05fef27cce5432a7", "committedDate": "2021-01-12T18:27:27Z", "message": "CSV spec test\n\n- add test on negation handling with integer limit value."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/9eba1c3ccc1ec277bd584997163ff1e6e60b20a9", "committedDate": "2021-01-13T14:39:25Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NTk1MzIx", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-568595321", "createdAt": "2021-01-14T20:20:18Z", "commit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDoyMDoxOFrOIT1wwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTowNDoxOFrOIT3Kaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3NDY5MA==", "bodyText": "Invertible is typically used in the context of matrices. How about inversion or inverse or inversible? Essentially use inverse instead of invert.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557674690", "createdAt": "2021-01-14T20:20:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * Addition function ({@code a + b}).\n  */\n-public class Add extends DateTimeArithmeticOperation {\n+public class Add extends DateTimeArithmeticOperation implements BinaryComparisonInvertible {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3Njc5NA==", "bodyText": "Why is this check required? Are there any doubts on what type of code is being received and if so, why not do the filtering before hand?\nI'm not a fan of this defensive programming since it promotes uncertainty to a degree. This is our own code, our own system, working in synch - no need to double check the code flow.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557676794", "createdAt": "2021-01-14T20:24:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1284,7 +1246,12 @@ Expression doSimplify() {\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3ODA4Mw==", "bodyText": "The code is a bit messy and could use some comments on what are the cases the rules tries to optimize - some basic examples of input vs output are enough.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557678083", "createdAt": "2021-01-14T20:26:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1148,46 +1152,6 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n-    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n-\n-        public BubbleUpNegations() {\n-            super(TransformDirection.DOWN);\n-        }\n-\n-        @Override\n-        protected Expression rule(Expression e) {\n-            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n-                Expression child = e.children().get(0);\n-                if (child instanceof ArithmeticOperation) {\n-                    ArithmeticOperation operation = (ArithmeticOperation) child;\n-                    String opSymbol = operation.symbol();\n-                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                        if (operation.left() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n-                        }\n-                        if (operation.right() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n-                        }\n-                    }\n-                }\n-            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n-                ArithmeticOperation operation = (ArithmeticOperation) e;\n-                String opSymbol = operation.symbol();\n-                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                    if (operation.left() instanceof Neg) {\n-                        Neg neg = (Neg) operation.left();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n-                    }\n-                    if (operation.right() instanceof Neg) {\n-                        Neg neg = (Neg) operation.right();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n-                    }\n-                }\n-            }\n-            return e;\n-        }\n-    }\n-\n     // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n     public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4MzQ0OQ==", "bodyText": "tryFolding vs safeMaybeFold.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557683449", "createdAt": "2021-01-14T20:37:05Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDczNQ==", "bodyText": "use asList for backporting. Also literalNeg should preserve the right origin so maybe rightNegated?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557684735", "createdAt": "2021-01-14T20:39:25Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDk0NA==", "bodyText": "foldNegation vs reduce (different terminology).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557684944", "createdAt": "2021-01-14T20:39:50Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTc5OQ==", "bodyText": "What's the use of this class? The name is fairly generic. Also can it be used by itself ? if not making abstract.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557685799", "createdAt": "2021-01-14T20:41:33Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE4OA==", "bodyText": "The constructor makes a lot of assumptions here, are these safe?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557686188", "createdAt": "2021-01-14T20:42:20Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODI2Ng==", "bodyText": "Why is this static method defined in this class? It's confusing to see the class Simplify being called both as an instance and its static method.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557688266", "createdAt": "2021-01-14T20:46:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODkwMQ==", "bodyText": "It's better to do a switch on the operation enum as that will cover all cases.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557688901", "createdAt": "2021-01-14T20:47:33Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MTk0OA==", "bodyText": "Why not Math.signum (see MathOperation.SIGN)?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557691948", "createdAt": "2021-01-14T20:52:56Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // Integer divisions are not safe to optimise: x / 5 > 1 <=/=> x > 5 for x in [6, 9]; same for the `==` comp\n+                return operation.dataType().isInteger() && isDiv || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                // If current operation is a multiplication, it's inverse will be a division: safe only if outcome is still integral.\n+                if (isDiv == false && opLeft.dataType().isInteger()) {\n+                    long opLiteralValue = ((Number) opLiteral.value()).longValue();\n+                    if (opLiteralValue == 0 || ((Number) bcLiteral.value()).longValue() % opLiteralValue != 0) {\n+                        return comparison;\n+                    }\n+                }\n+                // negative multiplication/division changes the direction of the comparison\n+                int sign = sign(opRight);\n+                if (sign == 0) {\n+                    return comparison;\n+                }\n+                BinaryComparison bc = (BinaryComparison) super.doSimplify();\n+                return sign < 0 ? bc.reverse() : bc;\n+            }\n+\n+            private int sign(Object obj) {\n+                int sign = 1;\n+                if (obj instanceof Number) {\n+                    double d = ((Number) obj).doubleValue();\n+                    sign = d == 0 ? 0 : (d < 0 ? -1 : 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTEwNg==", "bodyText": "Since submethods keep calling the super method, instead of overriding it declare a separate method that is empty in the base class which subclasses can call:\ncheckSimplification() {\n  ...code...\n  extraChecks()\n}\n\nprotected extraChecks() {}\n\nNaming could be improved though.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557695106", "createdAt": "2021-01-14T20:59:02Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw==", "bodyText": "Check the enums directly, don't use their names.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557695737", "createdAt": "2021-01-14T21:00:14Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NjA2OA==", "bodyText": "Also is this condition correct? the else (parent doSimplify) is picked if it is a sub but the opRight is a literal", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557696068", "createdAt": "2021-01-14T21:00:59Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5Njc0Nw==", "bodyText": "Looks like this method is never called in this form, subclasses always override it and enhance it. If that's the case, simply declare the method as is and declare a separate one as abstract which subclasses are forced to override and in where they can call this method.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557696747", "createdAt": "2021-01-14T21:02:27Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NzY0Mw==", "bodyText": "Could you then add a test where the optimization is applied? I'm confused since in this instance, I expect the PR to add tests not modify existing ones.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557697643", "createdAt": "2021-01-14T21:04:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NjMyMTEx", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-568632111", "createdAt": "2021-01-14T21:15:36Z", "commit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMToxNTozN1rOIT3hUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMToxNTozN1rOIT3hUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMzUwNg==", "bodyText": "typesCompatible -> typeCheck", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557703506", "createdAt": "2021-01-14T21:15:37Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwOTgyNDY2", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-570982466", "createdAt": "2021-01-19T08:00:45Z", "commit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODowMDo0NlrOIWCSXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1NDowM1rOIWEMzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA==", "bodyText": "I don't particularly like this method and, imo, it doesn't help much understanding the code. I think the return null inside the catch block bothers me.\nI would have kept the original (no separate method used) block of code, as I find it easier to read.\n        private static Expression reduceNegation(BinaryComparison bc) {\n            Literal bcLiteral = (Literal) bc.right();\n            Expression expression = new Neg(bcLiteral.source(), bcLiteral);\n            if (expression.foldable()) {\n                try {\n                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n                    return bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), expression));\n                } catch (ArithmeticException | DateTimeException e) {\n                    // implicitly return the original BinaryComparison in case the folding results in scenarios where,\n                    // for example, we have Long.MAX_VALUE+1 to fold. In this case, we skip the optimization.\n                }\n            }\n            return bc;\n        }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559977054", "createdAt": "2021-01-19T08:00:46Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3OTU4NA==", "bodyText": "I think only if (bc.left().... is enough. else if doesn't necessarily help here.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559979584", "createdAt": "2021-01-19T08:05:52Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk5NzEzNQ==", "bodyText": "I think here equals is not needed for this String comparison. == should be enough. There are other similar uses in this class as well.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559997135", "createdAt": "2021-01-19T08:36:26Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwNTg3Mw==", "bodyText": "Can you return here hire_date as well, please? As the results are at the moment, I cannot tell if the filter in the WHERE clause is correctly applied or not.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560005873", "createdAt": "2021-01-19T08:50:24Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "diffHunk": "@@ -23,7 +23,51 @@ nullArithmetics\n schema::a:i|b:d|c:s|d:s|e:l|f:i|g:i|h:i|i:i|j:i|k:d\n SELECT null + 2 AS a, null * 1.5 AS b, null + null AS c, null - null AS d, null - 1234567890123 AS e, 123 - null AS f, null / 5 AS g, 5 / null AS h, null % 5 AS i, 5 % null AS j, null + 5.5 - (null * (null * 3)) AS k;\n \n-       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k       \n+       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k\n ---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------\n-null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null           \n+null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null\n+;\n+\n+optimizedIntervalFilterPlus\n+SELECT emp_no x FROM test_emp WHERE hire_date + INTERVAL 20 YEAR > CAST('2010-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwNjA4Mg==", "bodyText": "Same comment as above, here as well.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560006082", "createdAt": "2021-01-19T08:50:44Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "diffHunk": "@@ -23,7 +23,51 @@ nullArithmetics\n schema::a:i|b:d|c:s|d:s|e:l|f:i|g:i|h:i|i:i|j:i|k:d\n SELECT null + 2 AS a, null * 1.5 AS b, null + null AS c, null - null AS d, null - 1234567890123 AS e, 123 - null AS f, null / 5 AS g, 5 / null AS h, null % 5 AS i, 5 % null AS j, null + 5.5 - (null * (null * 3)) AS k;\n \n-       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k       \n+       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k\n ---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------\n-null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null           \n+null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null\n+;\n+\n+optimizedIntervalFilterPlus\n+SELECT emp_no x FROM test_emp WHERE hire_date + INTERVAL 20 YEAR > CAST('2010-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;\n+\n+       x:i\n+---------------\n+10008\n+10011\n+10012\n+10016\n+10017\n+10019\n+10020\n+10022\n+10024\n+10026\n+;\n+\n+optimizedIntervalFilterMinus\n+SELECT emp_no x FROM test_emp WHERE hire_date - INTERVAL 10 YEAR > CAST('1980-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwODM5Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560008396", "createdAt": "2021-01-19T08:54:03Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/operator/arithmetic/SqlBinaryArithmeticOperation.java", "diffHunk": "@@ -52,7 +52,7 @@\n             return IntervalArithmetics.add((Temporal) r, ((IntervalDayTime) l).interval());\n         }\n \n-        throw new QlIllegalArgumentException(\"Cannot compute [+] between [{}] [{}]\", l.getClass().getSimpleName(),\n+        throw new QlIllegalArgumentException(\"Cannot compute [+] between [{}] and [{}]\", l.getClass().getSimpleName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dadbeb84481202b65d536e9a42b0730d89ecc4c", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/6dadbeb84481202b65d536e9a42b0730d89ecc4c", "committedDate": "2021-01-26T16:10:13Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70df9813a1eff54774acc46a66d0e4bfd4de6862", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/70df9813a1eff54774acc46a66d0e4bfd4de6862", "committedDate": "2021-01-27T10:46:02Z", "message": "Address feedback\n\n- rename methods for more clarify;\n- regroup simplification checks;\n- eliminate calling super class' methods;\n- use == for static string comps;\n- use Math.signum instead of inlining the calculation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f74d627df0f7afb8a8294f0774db71635c52ff66", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/f74d627df0f7afb8a8294f0774db71635c52ff66", "committedDate": "2021-01-27T10:50:27Z", "message": "Merge branch 'master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99f08c1f30aafe63f8e03237c3197510d4c58eb6", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/99f08c1f30aafe63f8e03237c3197510d4c58eb6", "committedDate": "2021-01-27T11:19:34Z", "message": "Address review comments\n\nUpdate QA test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/a3b66c85e72e691520e1ef01a02425165a4c04ed", "committedDate": "2021-01-27T11:20:27Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4MDk2MzMy", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-578096332", "createdAt": "2021-01-28T08:42:20Z", "commit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQwODo0MjoyMFrOIbsbuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQwODo0MjoyMFrOIbsbuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTkxMDQ1Nw==", "bodyText": "Can be left as is I guess. My initial suggestion seems to be just a personal preference. If there will be other changes to this PR, I'd add a comment similar to the one I made in the catch (ArithmeticException | DateTimeException e) { to explain the catch block \"ignoring\" the math failure.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565910457", "createdAt": "2021-01-28T08:42:20Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4MzIwOTQx", "url": "https://github.com/elastic/elasticsearch/pull/66022#pullrequestreview-578320941", "createdAt": "2021-01-28T13:17:05Z", "commit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoxNzowNlrOIb3Gsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoyMjowOVrOIb3S-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NTI5OQ==", "bodyText": "If this method necessary? I only see it used in one place and the check can check can be directly just life for ADD and SUB.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566085299", "createdAt": "2021-01-28T13:17:06Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1170,21 +1171,44 @@ private Expression simplify(BinaryComparison bc) {\n             // optimize only once the expression has a literal on the right side of the binary comparison\n             if (bc.right() instanceof Literal) {\n                 if (bc.left() instanceof ArithmeticOperation) {\n-                    return SimplifyOperation.simplify(bc, typesCompatible);\n-                } else if (bc.left() instanceof Neg) {\n-                    return reduceNegation(bc);\n+                    return simplifyBinaryComparison(bc);\n+                }\n+                if (bc.left() instanceof Neg) {\n+                    return foldNegation(bc);\n                 }\n             }\n             return bc;\n         }\n \n-        private static Expression reduceNegation(BinaryComparison bc) {\n+        private Expression simplifyBinaryComparison(BinaryComparison comparison) {\n+            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+            String opSymbol = operation.symbol();\n+            // Modulo can't be simplified.\n+            if (opSymbol == MOD.symbol()) {\n+                return comparison;\n+            }\n+            OperationSimplifier simplification = null;\n+            if (isMulOrDiv(opSymbol)) {\n+                simplification = new MulDivSimplifier(comparison);\n+            } else if (opSymbol == ADD.symbol() || opSymbol == SUB.symbol()) {\n+                simplification = new AddSubSimplifier(comparison);\n+            }\n+\n+            return (simplification == null || simplification.isUnsafe(typesCompatible)) ? comparison : simplification.apply();\n+        }\n+\n+        private static boolean isMulOrDiv(String opSymbol) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4Njk3OQ==", "bodyText": "postApply or postProcess. opSpecific is somewhat meaningless.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566086979", "createdAt": "2021-01-28T13:19:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();\n             }\n \n-            Expression doSimplify() {\n+            Expression apply() {\n                 // force float point folding for FlP field\n                 Literal bcl = operation.dataType().isRational()\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n-                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n-                }\n-                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                Expression bcRightExpression = ((BinaryComparisonInversible) operation).binaryComparisonInverse()\n                     .create(bcl.source(), bcl, opRight);\n-                bcRightExpression = safeMaybeFold(bcRightExpression);\n-                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+                bcRightExpression = tryFolding(bcRightExpression);\n+                return bcRightExpression != null\n+                    ? opSpecificPostApply((BinaryComparison) comparison.replaceChildren(List.of(opLeft, bcRightExpression)))\n+                    : comparison;\n             }\n \n-            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n-                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n-                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n-                String opSymbol = operation.symbol();\n-                // Modulo can't be simplified.\n-                if (MOD.symbol().equals(opSymbol)) {\n-                    return comparison;\n-                }\n-                SimplifyOperation simplify = null;\n-                if (isMulOrDiv(opSymbol)) {\n-                    simplify = new SimplifyMulDiv(comparison);\n-                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n-                    simplify = new SimplifyAddSub(comparison);\n-                }\n-\n-                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n-            }\n+            // operation-specific operations:\n+            //  - fast-tracking of simplification unsafety\n+            abstract boolean opSpecificIsUnsafe();\n \n-            static boolean isMulOrDiv(String opSymbol) {\n-                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            //  - post adjustments\n+            Expression opSpecificPostApply(BinaryComparison binaryComparison) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NzU4Ng==", "bodyText": "If you don't this to be subclass because of the dedicated method, consider making it final.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566087586", "createdAt": "2021-01-28T13:20:43Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1221,7 +1245,7 @@ static Expression safeMaybeFold(Expression expression) {\n             }\n \n             // can it be quickly fast-tracked that the operation can't be reduced?\n-            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            boolean isUnsafe(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4ODQ0MA==", "bodyText": "how about check, doCheck without opSpecific?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566088440", "createdAt": "2021-01-28T13:22:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eee4eab81b3a49a39ba31319e2b75169e5892e9", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/8eee4eab81b3a49a39ba31319e2b75169e5892e9", "committedDate": "2021-01-28T19:21:23Z", "message": "Address review comments\n\n- rename methods;\n- add comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "053fcde61acadf9e05883696608268495813eaaa", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/053fcde61acadf9e05883696608268495813eaaa", "committedDate": "2021-01-28T19:23:32Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c7781f78703f6bbe35e7d9ef7f4358f6cf488b7", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/1c7781f78703f6bbe35e7d9ef7f4358f6cf488b7", "committedDate": "2021-02-01T17:03:22Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/optimize_arithm_in_bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28ba3e53c69ac9f3ab2e5d68f7e682d580c91f35", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/28ba3e53c69ac9f3ab2e5d68f7e682d580c91f35", "committedDate": "2021-02-01T17:33:10Z", "message": "Adjust merging outcome for one test\n\nBoth upstream and current branch updated line in the same way\n(incrementing a count), so merging left it unchanged. However the net\nresult needs to reflect both modifications (i.e. inc by two)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18c11be501c87c8a9e6c0e74b589ccc33fe91563", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/18c11be501c87c8a9e6c0e74b589ccc33fe91563", "committedDate": "2021-02-01T17:35:24Z", "message": "Merge branch 'master' into enh/optimize_arithm_in_bc"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4747, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}