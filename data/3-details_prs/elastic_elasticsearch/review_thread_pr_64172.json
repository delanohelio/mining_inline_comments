{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMTEzMTcy", "number": 64172, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozNzo1NVrOEx9eLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozNzo1NVrOEx9eLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODIyODMxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/mapper-aggregate-metric/src/main/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateDoubleMetricFieldMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozNzo1NVrOHoViVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozNzo1NVrOHoViVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1Nzk0Mw==", "bodyText": "nit: can we have {} around the throw clause?", "url": "https://github.com/elastic/elasticsearch/pull/64172#discussion_r512057943", "createdAt": "2020-10-26T15:37:55Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/mapper-aggregate-metric/src/main/java/org/elasticsearch/xpack/aggregatemetric/mapper/AggregateDoubleMetricFieldMapper.java", "diffHunk": "@@ -102,95 +101,89 @@ public static String subfieldName(String fieldName, Metric metric) {\n     }\n \n     public static class Defaults {\n-        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n-        public static final Explicit<Set<Metric>> METRICS = new Explicit<>(Collections.emptySet(), false);\n-        public static final Explicit<Metric> DEFAULT_METRIC = new Explicit<>(Metric.max, false);\n-        public static final FieldType FIELD_TYPE = new FieldType();\n+        public static final Set<Metric> METRICS = Collections.emptySet();\n+        public static final Metric DEFAULT_METRIC = Metric.max;\n     }\n \n-    static class Builder extends FieldMapper.Builder {\n-\n-        private Boolean ignoreMalformed;\n-\n-        /**\n-         * The aggregated metrics supported by the field type\n-         */\n-        private Set<Metric> metrics;\n-\n-        /**\n-         * Set the default metric so that query operations are delegated to it.\n-         */\n-        private Metric defaultMetric;\n-\n-        Builder(String name) {\n-            super(name, Defaults.FIELD_TYPE);\n-        }\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        public AggregateDoubleMetricFieldMapper.Builder ignoreMalformed(boolean ignoreMalformed) {\n-            this.ignoreMalformed = ignoreMalformed;\n-            return this;\n-        }\n-\n-        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n-            if (ignoreMalformed != null) {\n-                return new Explicit<>(ignoreMalformed, true);\n-            }\n-            if (context.indexSettings() != null) {\n-                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n-            }\n-            return AggregateDoubleMetricFieldMapper.Defaults.IGNORE_MALFORMED;\n-        }\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n \n-        public AggregateDoubleMetricFieldMapper.Builder defaultMetric(Metric defaultMetric) {\n-            this.defaultMetric = defaultMetric;\n-            return this;\n-        }\n+        private final Parameter<Boolean> ignoreMalformed;\n \n-        protected Explicit<Metric> defaultMetric(BuilderContext context) {\n-            if (defaultMetric != null) {\n-                if (metrics != null && metrics.contains(defaultMetric) == false) {\n-                    // The default_metric is not defined in the \"metrics\" field\n-                    throw new IllegalArgumentException(\"Metric [\" + defaultMetric + \"] is not defined in the metrics field.\");\n+        private final Parameter<Set<Metric>> metrics = new Parameter<>(Names.METRICS, false, () -> Defaults.METRICS, (n, c, o) -> {\n+            @SuppressWarnings(\"unchecked\")\n+            List<String> metricsList = (List<String>) o;\n+            EnumSet<Metric> parsedMetrics = EnumSet.noneOf(Metric.class);\n+            for (String s : metricsList) {\n+                try {\n+                    Metric m = Metric.valueOf(s);\n+                    parsedMetrics.add(m);\n+                } catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(\"Metric [\" + s + \"] is not supported.\", e);\n                 }\n-                return new Explicit<>(defaultMetric, true);\n             }\n-\n-            // If a single metric is contained, this should be the default\n-            if (metrics != null && metrics.size() == 1) {\n-                return new Explicit<>(metrics.iterator().next(), false);\n+            return parsedMetrics;\n+        }, m -> toType(m).metrics).setValidator(v -> {\n+            if (v == null || v.isEmpty()) {\n+                throw new IllegalArgumentException(\"Property [\" + Names.METRICS + \"] is required for field [\" + name() + \"].\");\n             }\n+        });\n \n-            if (metrics.contains(Defaults.DEFAULT_METRIC.value())) {\n-                return Defaults.DEFAULT_METRIC;\n-            }\n-            throw new IllegalArgumentException(\n-                \"Property [\" + Names.DEFAULT_METRIC.getPreferredName() + \"] must be set for field [\" + name() + \"].\"\n+        /**\n+         * Set the default metric so that query operations are delegated to it.\n+         */\n+        private final Parameter<Metric> defaultMetric = new Parameter<>(\n+            Names.DEFAULT_METRIC,\n+            true,\n+            () -> Defaults.DEFAULT_METRIC,\n+            (n, c, o) -> {\n+                try {\n+                    return Metric.valueOf(o.toString());\n+                } catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(\"Metric [\" + o.toString() + \"] is not supported.\", e);\n+                }\n+            },\n+            m -> toType(m).defaultMetric\n+        );\n+\n+        public Builder(String name, Boolean ignoreMalformedByDefault) {\n+            super(name);\n+            this.ignoreMalformed = Parameter.boolParam(\n+                Names.IGNORE_MALFORMED,\n+                true,\n+                m -> toType(m).ignoreMalformed,\n+                ignoreMalformedByDefault\n             );\n         }\n \n-        public AggregateDoubleMetricFieldMapper.Builder metrics(EnumSet<Metric> metrics) {\n-            this.metrics = metrics;\n-            return this;\n-        }\n-\n-        protected Explicit<Set<Metric>> metrics(BuilderContext context) {\n-            if (metrics != null) {\n-                return new Explicit<>(metrics, true);\n-            }\n-            return Defaults.METRICS;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(ignoreMalformed, metrics, defaultMetric, meta);\n         }\n \n         @Override\n         public AggregateDoubleMetricFieldMapper build(BuilderContext context) {\n-            if (metrics == null || metrics.isEmpty()) {\n-                throw new IllegalArgumentException(\n-                    \"Property [\" + Names.METRICS.getPreferredName() + \"] must be set for field [\" + name() + \"].\"\n+            if (defaultMetric.isConfigured() == false) {\n+                // If a single metric is contained, this should be the default\n+                if (metrics.getValue().size() == 1) {\n+                    Metric m = metrics.getValue().iterator().next();\n+                    defaultMetric.setValue(m);\n+                }\n+\n+                if (metrics.getValue().contains(defaultMetric.getValue()) == false) throw new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05a0a45bb2daffeb159340070b1ef644c7b07269"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4183, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}