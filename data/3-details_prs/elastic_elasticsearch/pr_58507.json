{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MzM5NTQ4", "number": 58507, "title": "Aggregation tests for Wildcard Field", "bodyText": "Add a couple of unit tests for running the Wildcard Field through terms agg and composite terms agg.  I had expected to need to do some additional work to get composite to work, but turns out it just works already, so this is now a test-only PR.", "createdAt": "2020-06-24T17:14:13Z", "url": "https://github.com/elastic/elasticsearch/pull/58507", "merged": true, "mergeCommit": {"oid": "4e33a40e85b65a56581bc03482495c3f578822f5"}, "closed": true, "closedAt": "2020-07-29T17:59:21Z", "author": {"login": "not-napoleon"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcshpF3AH2gAyNDM5MzM5NTQ4OjA5ZWRkMDJlMjhhZmEzMGU2OTg2N2JmZTNkNGViZmMxODM4ODJhNjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5rg2jAH2gAyNDM5MzM5NTQ4OjlmZjExYjUwMWM5MTdhYzJkODZkYTAyMDAxNjIwZGRiODgwMmQ2NTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "09edd02e28afa30e69867bfe3d4ebfc183882a65", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/09edd02e28afa30e69867bfe3d4ebfc183882a65", "committedDate": "2020-06-18T17:10:30Z", "message": "wildcard field tests for terms agg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e69d37349fdf9fbbeb9ae37d6c1c0c690f5291fc", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/e69d37349fdf9fbbeb9ae37d6c1c0c690f5291fc", "committedDate": "2020-06-23T14:07:50Z", "message": "Add tests for wildcard agg support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/3223032d5192f0702f41a52ea8e8ab18eaaa4009", "committedDate": "2020-06-23T14:50:40Z", "message": "words"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzkxOTcw", "url": "https://github.com/elastic/elasticsearch/pull/58507#pullrequestreview-437791970", "createdAt": "2020-06-25T19:23:22Z", "commit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOToyMzoyMlrOGpIrUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOTozNzoxOFrOGpJFdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Njk2MQ==", "bodyText": "I think Optional prefers things to look like:\nRandomIndexWriter indexWriter = indexWriterConfg.map(c -> new RandomIndexWriter(random(), directory, c).orElseGet(() -> new RandomIndexWriter(random(), directory);", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445786961", "createdAt": "2020-06-25T19:23:22Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -535,13 +537,27 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n+        testCase(aggregationBuilder, Optional.empty(), query, buildIndex, verify, fieldTypes);\n+    }\n+\n+    protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n+        T aggregationBuilder,\n+        Optional<IndexWriterConfig> indexWriterConfig, Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4ODAzNg==", "bodyText": "This says \"when I don't tell you what analyzer to use then use the wildcard analyzer\". I believe Elasticsearch always sets the analyzer. The wildcard field mapper looks like it does. I don't think either test needs this.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445788036", "createdAt": "2020-06-25T19:25:34Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzA4MA==", "bodyText": "(StringTerms results) -> should do the same thing with a little less ceremony.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445793080", "createdAt": "2020-06-25T19:36:09Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);\n+\n+        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME);\n+        builder.ignoreAbove(MAX_FIELD_LENGTH);\n+        wildcardFieldMapper = builder.build(new Mapper.BuilderContext(createIndexSettings().getSettings(), new ContentPath(0)));\n+\n+        wildcardFieldType = wildcardFieldMapper.fieldType();\n+    }\n+\n+    private void addFields(ParseContext.Document parseDoc, Document doc, String docContent) throws IOException {\n+        ArrayList<IndexableField> fields = new ArrayList<>();\n+        wildcardFieldMapper.createFields(docContent, parseDoc, fields);\n+\n+        for (IndexableField indexableField : fields) {\n+            doc.add(indexableField);\n+        }\n+    }\n+\n+    private void indexDoc(ParseContext.Document parseDoc, Document doc, RandomIndexWriter iw) throws IOException {\n+        IndexableField field = parseDoc.getByKey(wildcardFieldMapper.name());\n+        if (field != null) {\n+            doc.add(field);\n+        }\n+        iw.addDocument(doc);\n+    }\n+\n+    private void indexStrings(RandomIndexWriter iw, String... values) throws IOException {\n+        Document doc = new Document();\n+        ParseContext.Document parseDoc = new ParseContext.Document();\n+        for (String value : values) {\n+            addFields(parseDoc, doc, value);\n+        }\n+        indexDoc(parseDoc, doc, iw);\n+    }\n+\n+    public void testTermsAggregation() throws IOException {\n+        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n+            .field(WILDCARD_FIELD_NAME)\n+            .order(BucketOrder.key(true));\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"c\");\n+            },\n+            (Consumer<StringTerms>) result -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzY1Mg==", "bodyText": "Could you try running with aggregateAfter set? I think that'd be useful to make sure works as well.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445793652", "createdAt": "2020-06-25T19:37:18Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);\n+\n+        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME);\n+        builder.ignoreAbove(MAX_FIELD_LENGTH);\n+        wildcardFieldMapper = builder.build(new Mapper.BuilderContext(createIndexSettings().getSettings(), new ContentPath(0)));\n+\n+        wildcardFieldType = wildcardFieldMapper.fieldType();\n+    }\n+\n+    private void addFields(ParseContext.Document parseDoc, Document doc, String docContent) throws IOException {\n+        ArrayList<IndexableField> fields = new ArrayList<>();\n+        wildcardFieldMapper.createFields(docContent, parseDoc, fields);\n+\n+        for (IndexableField indexableField : fields) {\n+            doc.add(indexableField);\n+        }\n+    }\n+\n+    private void indexDoc(ParseContext.Document parseDoc, Document doc, RandomIndexWriter iw) throws IOException {\n+        IndexableField field = parseDoc.getByKey(wildcardFieldMapper.name());\n+        if (field != null) {\n+            doc.add(field);\n+        }\n+        iw.addDocument(doc);\n+    }\n+\n+    private void indexStrings(RandomIndexWriter iw, String... values) throws IOException {\n+        Document doc = new Document();\n+        ParseContext.Document parseDoc = new ParseContext.Document();\n+        for (String value : values) {\n+            addFields(parseDoc, doc, value);\n+        }\n+        indexDoc(parseDoc, doc, iw);\n+    }\n+\n+    public void testTermsAggregation() throws IOException {\n+        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n+            .field(WILDCARD_FIELD_NAME)\n+            .order(BucketOrder.key(true));\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"c\");\n+            },\n+            (Consumer<StringTerms>) result -> {\n+                assertTrue(AggregationInspectionHelper.hasValue(result));\n+\n+                assertEquals(3, result.getBuckets().size());\n+                assertEquals(\"a\", result.getBuckets().get(0).getKeyAsString());\n+                assertEquals(2L, result.getBuckets().get(0).getDocCount());\n+                assertEquals(\"b\", result.getBuckets().get(1).getKeyAsString());\n+                assertEquals(3L, result.getBuckets().get(1).getDocCount());\n+                assertEquals(\"c\", result.getBuckets().get(2).getKeyAsString());\n+                assertEquals(1L, result.getBuckets().get(2).getDocCount());\n+            },\n+            wildcardFieldType);\n+    }\n+\n+    public void testCompositeTermsAggregation() throws IOException {\n+        CompositeAggregationBuilder aggregationBuilder = new CompositeAggregationBuilder(\n+            \"name\",\n+            List.of(\n+                new TermsValuesSourceBuilder(\"terms_key\").field(WILDCARD_FIELD_NAME)\n+            )\n+        );\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"c\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"d\");\n+                indexStrings(iw, \"c\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cef1c9a60bcb5a11212691d5b70da9071806324", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/1cef1c9a60bcb5a11212691d5b70da9071806324", "committedDate": "2020-07-02T16:37:37Z", "message": "Merge branch 'master' into extend-composite-over-wildcard"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11e171fc5c4bfc8e2a9bcac5429ba0eaaf70b4de", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/11e171fc5c4bfc8e2a9bcac5429ba0eaaf70b4de", "committedDate": "2020-07-06T17:37:07Z", "message": "add search after test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d67fd8c271f4feb80578885052b3cf889b72115", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d67fd8c271f4feb80578885052b3cf889b72115", "committedDate": "2020-07-09T19:08:08Z", "message": "remove unneeded IndexWriterConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6640aa143b93ba13f98e7fa702c42f22e9a6ef", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/4f6640aa143b93ba13f98e7fa702c42f22e9a6ef", "committedDate": "2020-07-23T14:54:26Z", "message": "Merge branch 'master' into extend-composite-over-wildcard"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzM5NjUy", "url": "https://github.com/elastic/elasticsearch/pull/58507#pullrequestreview-454339652", "createdAt": "2020-07-23T17:16:37Z", "commit": {"oid": "4f6640aa143b93ba13f98e7fa702c42f22e9a6ef"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxNjozN1rOG2UEBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxNjozN1rOG2UEBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNDk5OA==", "bodyText": "Maybe revert this bit too?", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r459604998", "createdAt": "2020-07-23T17:16:37Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -547,13 +547,14 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;\n+            indexWriter = new RandomIndexWriter(random(), directory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f6640aa143b93ba13f98e7fa702c42f22e9a6ef"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff670b6cc7925d2bf07214a735ff0efbb34abb9e", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/ff670b6cc7925d2bf07214a735ff0efbb34abb9e", "committedDate": "2020-07-28T13:52:32Z", "message": "response to PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ff11b501c917ac2d86da02001620ddb8802d657", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/9ff11b501c917ac2d86da02001620ddb8802d657", "committedDate": "2020-07-29T14:01:34Z", "message": "Merge branch 'master' into extend-composite-over-wildcard"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 405, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}