{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNzYxMDE5", "number": 66644, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo0ODowMVrOFQjj-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo0ODoyNVrOFQjkkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyOTA0MTg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/NetworkDirectionProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo0ODowMVrOIWelPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo0ODowMVrOIWelPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ0MDYzNg==", "bodyText": "Elasticsearch has a convention that we don't use ! to negate boolean values. Instead, we use the form booleanValue == false.", "url": "https://github.com/elastic/elasticsearch/pull/66644#discussion_r560440636", "createdAt": "2021-01-19T19:48:01Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/NetworkDirectionProcessor.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+import org.elasticsearch.common.network.InetAddresses;\n+import org.elasticsearch.xpack.core.common.network.CIDRUtils;\n+\n+import java.net.InetAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Arrays;\n+\n+import static org.elasticsearch.ingest.ConfigurationUtils.readBooleanProperty;\n+\n+public class NetworkDirectionProcessor extends AbstractProcessor {\n+    static final byte[] UNDEFINED_IP4 = new byte[] { 0, 0, 0, 0 };\n+    static final byte[] UNDEFINED_IP6 = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+    static final byte[] BROADCAST_IP4 = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff };\n+\n+    public static final String TYPE = \"network_direction\";\n+\n+    public static final String DIRECTION_INTERNAL = \"internal\";\n+    public static final String DIRECTION_EXTERNAL = \"external\";\n+    public static final String DIRECTION_INBOUND = \"inbound\";\n+    public static final String DIRECTION_OUTBOUND = \"outbound\";\n+\n+    private static final String LOOPBACK_NAMED_NETWORK = \"loopback\";\n+    private static final String GLOBAL_UNICAST_NAMED_NETWORK = \"global_unicast\";\n+    private static final String UNICAST_NAMED_NETWORK = \"unicast\";\n+    private static final String LINK_LOCAL_UNICAST_NAMED_NETWORK = \"link_local_unicast\";\n+    private static final String INTERFACE_LOCAL_NAMED_NETWORK = \"interface_local_multicast\";\n+    private static final String LINK_LOCAL_MULTICAST_NAMED_NETWORK = \"link_local_multicast\";\n+    private static final String MULTICAST_NAMED_NETWORK = \"multicast\";\n+    private static final String UNSPECIFIED_NAMED_NETWORK = \"unspecified\";\n+    private static final String PRIVATE_NAMED_NETWORK = \"private\";\n+    private static final String PUBLIC_NAMED_NETWORK = \"public\";\n+\n+    private final String sourceIpField;\n+    private final String destinationIpField;\n+    private final String targetField;\n+    private final List<String> internalNetworks;\n+    private final boolean ignoreMissing;\n+\n+    NetworkDirectionProcessor(\n+        String tag,\n+        String description,\n+        String sourceIpField,\n+        String destinationIpField,\n+        String targetField,\n+        List<String> internalNetworks,\n+        boolean ignoreMissing\n+    ) {\n+        super(tag, description);\n+        this.sourceIpField = sourceIpField;\n+        this.destinationIpField = destinationIpField;\n+        this.targetField = targetField;\n+        this.internalNetworks = internalNetworks;\n+        this.ignoreMissing = ignoreMissing;\n+    }\n+\n+    public String getSourceIpField() {\n+        return sourceIpField;\n+    }\n+\n+    public String getDestinationIpField() {\n+        return destinationIpField;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public List<String> getInternalNetworks() {\n+        return internalNetworks;\n+    }\n+\n+    public boolean getIgnoreMissing() {\n+        return ignoreMissing;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String direction = getDirection(ingestDocument);\n+        if (direction == null) {\n+            if (ignoreMissing) {\n+                return ingestDocument;\n+            } else {\n+                throw new IllegalArgumentException(\"unable to calculate network direction from document\");\n+            }\n+        }\n+\n+        ingestDocument.setFieldValue(targetField, direction);\n+        return ingestDocument;\n+    }\n+\n+    private String getDirection(IngestDocument d) {\n+        if (internalNetworks == null) {\n+            return null;\n+        }\n+\n+        String sourceIpAddrString = d.getFieldValue(sourceIpField, String.class, ignoreMissing);\n+        if (sourceIpAddrString == null) {\n+            return null;\n+        }\n+\n+        String destIpAddrString = d.getFieldValue(destinationIpField, String.class, ignoreMissing);\n+        if (destIpAddrString == null) {\n+            return null;\n+        }\n+\n+        boolean sourceInternal = isInternal(sourceIpAddrString);\n+        boolean destinationInternal = isInternal(destIpAddrString);\n+\n+        if (sourceInternal && destinationInternal) {\n+            return DIRECTION_INTERNAL;\n+        }\n+        if (sourceInternal) {\n+            return DIRECTION_OUTBOUND;\n+        }\n+        if (destinationInternal) {\n+            return DIRECTION_INBOUND;\n+        }\n+        return DIRECTION_EXTERNAL;\n+    }\n+\n+    private boolean isInternal(String ip) {\n+        for (String network : internalNetworks) {\n+            if (inNetwork(ip, network)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean inNetwork(String ip, String network) {\n+        InetAddress address = InetAddresses.forString(ip);\n+        switch (network) {\n+            case LOOPBACK_NAMED_NETWORK:\n+                return isLoopback(address);\n+            case GLOBAL_UNICAST_NAMED_NETWORK:\n+            case UNICAST_NAMED_NETWORK:\n+                return isUnicast(address);\n+            case LINK_LOCAL_UNICAST_NAMED_NETWORK:\n+                return isLinkLocalUnicast(address);\n+            case INTERFACE_LOCAL_NAMED_NETWORK:\n+                return isInterfaceLocalMulticast(address);\n+            case LINK_LOCAL_MULTICAST_NAMED_NETWORK:\n+                return isLinkLocalMulticast(address);\n+            case MULTICAST_NAMED_NETWORK:\n+                return isMulticast(address);\n+            case UNSPECIFIED_NAMED_NETWORK:\n+                return isUnspecified(address);\n+            case PRIVATE_NAMED_NETWORK:\n+                return isPrivate(ip);\n+            case PUBLIC_NAMED_NETWORK:\n+                return isPublic(ip);\n+            default:\n+                return CIDRUtils.isInRange(ip, network);\n+        }\n+    }\n+\n+    private boolean isLoopback(InetAddress ip) {\n+        return ip.isLoopbackAddress();\n+    }\n+\n+    private boolean isUnicast(InetAddress ip) {\n+        return !Arrays.equals(ip.getAddress(), BROADCAST_IP4)\n+            && !isUnspecified(ip)\n+            && !isLoopback(ip)\n+            && !isMulticast(ip)\n+            && !isLinkLocalUnicast(ip);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e8863979ad223aaf682e1bd55a6364c1b7b8"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyOTA0MzM3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/NetworkDirectionProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo0ODoyNVrOIWemMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTo0ODoyNVrOIWemMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ0MDg4Mw==", "bodyText": "Same as above.", "url": "https://github.com/elastic/elasticsearch/pull/66644#discussion_r560440883", "createdAt": "2021-01-19T19:48:25Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/ingest/src/main/java/org/elasticsearch/xpack/ingest/NetworkDirectionProcessor.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ingest;\n+\n+import org.elasticsearch.ingest.AbstractProcessor;\n+import org.elasticsearch.ingest.ConfigurationUtils;\n+import org.elasticsearch.ingest.IngestDocument;\n+import org.elasticsearch.ingest.Processor;\n+import org.elasticsearch.common.network.InetAddresses;\n+import org.elasticsearch.xpack.core.common.network.CIDRUtils;\n+\n+import java.net.InetAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Arrays;\n+\n+import static org.elasticsearch.ingest.ConfigurationUtils.readBooleanProperty;\n+\n+public class NetworkDirectionProcessor extends AbstractProcessor {\n+    static final byte[] UNDEFINED_IP4 = new byte[] { 0, 0, 0, 0 };\n+    static final byte[] UNDEFINED_IP6 = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+    static final byte[] BROADCAST_IP4 = new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff };\n+\n+    public static final String TYPE = \"network_direction\";\n+\n+    public static final String DIRECTION_INTERNAL = \"internal\";\n+    public static final String DIRECTION_EXTERNAL = \"external\";\n+    public static final String DIRECTION_INBOUND = \"inbound\";\n+    public static final String DIRECTION_OUTBOUND = \"outbound\";\n+\n+    private static final String LOOPBACK_NAMED_NETWORK = \"loopback\";\n+    private static final String GLOBAL_UNICAST_NAMED_NETWORK = \"global_unicast\";\n+    private static final String UNICAST_NAMED_NETWORK = \"unicast\";\n+    private static final String LINK_LOCAL_UNICAST_NAMED_NETWORK = \"link_local_unicast\";\n+    private static final String INTERFACE_LOCAL_NAMED_NETWORK = \"interface_local_multicast\";\n+    private static final String LINK_LOCAL_MULTICAST_NAMED_NETWORK = \"link_local_multicast\";\n+    private static final String MULTICAST_NAMED_NETWORK = \"multicast\";\n+    private static final String UNSPECIFIED_NAMED_NETWORK = \"unspecified\";\n+    private static final String PRIVATE_NAMED_NETWORK = \"private\";\n+    private static final String PUBLIC_NAMED_NETWORK = \"public\";\n+\n+    private final String sourceIpField;\n+    private final String destinationIpField;\n+    private final String targetField;\n+    private final List<String> internalNetworks;\n+    private final boolean ignoreMissing;\n+\n+    NetworkDirectionProcessor(\n+        String tag,\n+        String description,\n+        String sourceIpField,\n+        String destinationIpField,\n+        String targetField,\n+        List<String> internalNetworks,\n+        boolean ignoreMissing\n+    ) {\n+        super(tag, description);\n+        this.sourceIpField = sourceIpField;\n+        this.destinationIpField = destinationIpField;\n+        this.targetField = targetField;\n+        this.internalNetworks = internalNetworks;\n+        this.ignoreMissing = ignoreMissing;\n+    }\n+\n+    public String getSourceIpField() {\n+        return sourceIpField;\n+    }\n+\n+    public String getDestinationIpField() {\n+        return destinationIpField;\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public List<String> getInternalNetworks() {\n+        return internalNetworks;\n+    }\n+\n+    public boolean getIgnoreMissing() {\n+        return ignoreMissing;\n+    }\n+\n+    @Override\n+    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {\n+        String direction = getDirection(ingestDocument);\n+        if (direction == null) {\n+            if (ignoreMissing) {\n+                return ingestDocument;\n+            } else {\n+                throw new IllegalArgumentException(\"unable to calculate network direction from document\");\n+            }\n+        }\n+\n+        ingestDocument.setFieldValue(targetField, direction);\n+        return ingestDocument;\n+    }\n+\n+    private String getDirection(IngestDocument d) {\n+        if (internalNetworks == null) {\n+            return null;\n+        }\n+\n+        String sourceIpAddrString = d.getFieldValue(sourceIpField, String.class, ignoreMissing);\n+        if (sourceIpAddrString == null) {\n+            return null;\n+        }\n+\n+        String destIpAddrString = d.getFieldValue(destinationIpField, String.class, ignoreMissing);\n+        if (destIpAddrString == null) {\n+            return null;\n+        }\n+\n+        boolean sourceInternal = isInternal(sourceIpAddrString);\n+        boolean destinationInternal = isInternal(destIpAddrString);\n+\n+        if (sourceInternal && destinationInternal) {\n+            return DIRECTION_INTERNAL;\n+        }\n+        if (sourceInternal) {\n+            return DIRECTION_OUTBOUND;\n+        }\n+        if (destinationInternal) {\n+            return DIRECTION_INBOUND;\n+        }\n+        return DIRECTION_EXTERNAL;\n+    }\n+\n+    private boolean isInternal(String ip) {\n+        for (String network : internalNetworks) {\n+            if (inNetwork(ip, network)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean inNetwork(String ip, String network) {\n+        InetAddress address = InetAddresses.forString(ip);\n+        switch (network) {\n+            case LOOPBACK_NAMED_NETWORK:\n+                return isLoopback(address);\n+            case GLOBAL_UNICAST_NAMED_NETWORK:\n+            case UNICAST_NAMED_NETWORK:\n+                return isUnicast(address);\n+            case LINK_LOCAL_UNICAST_NAMED_NETWORK:\n+                return isLinkLocalUnicast(address);\n+            case INTERFACE_LOCAL_NAMED_NETWORK:\n+                return isInterfaceLocalMulticast(address);\n+            case LINK_LOCAL_MULTICAST_NAMED_NETWORK:\n+                return isLinkLocalMulticast(address);\n+            case MULTICAST_NAMED_NETWORK:\n+                return isMulticast(address);\n+            case UNSPECIFIED_NAMED_NETWORK:\n+                return isUnspecified(address);\n+            case PRIVATE_NAMED_NETWORK:\n+                return isPrivate(ip);\n+            case PUBLIC_NAMED_NETWORK:\n+                return isPublic(ip);\n+            default:\n+                return CIDRUtils.isInRange(ip, network);\n+        }\n+    }\n+\n+    private boolean isLoopback(InetAddress ip) {\n+        return ip.isLoopbackAddress();\n+    }\n+\n+    private boolean isUnicast(InetAddress ip) {\n+        return !Arrays.equals(ip.getAddress(), BROADCAST_IP4)\n+            && !isUnspecified(ip)\n+            && !isLoopback(ip)\n+            && !isMulticast(ip)\n+            && !isLinkLocalUnicast(ip);\n+    }\n+\n+    private boolean isLinkLocalUnicast(InetAddress ip) {\n+        return ip.isLinkLocalAddress();\n+    }\n+\n+    private boolean isInterfaceLocalMulticast(InetAddress ip) {\n+        return ip.isMCNodeLocal();\n+    }\n+\n+    private boolean isLinkLocalMulticast(InetAddress ip) {\n+        return ip.isMCLinkLocal();\n+    }\n+\n+    private boolean isMulticast(InetAddress ip) {\n+        return ip.isMulticastAddress();\n+    }\n+\n+    private boolean isUnspecified(InetAddress ip) {\n+        var address = ip.getAddress();\n+        return Arrays.equals(UNDEFINED_IP4, address) || Arrays.equals(UNDEFINED_IP6, address);\n+    }\n+\n+    private boolean isPrivate(String ip) {\n+        return CIDRUtils.isInRange(ip, \"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\", \"fd00::/8\");\n+    }\n+\n+    private boolean isPublic(String ip) {\n+        return !isLocalOrPrivate(ip);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4c0e8863979ad223aaf682e1bd55a6364c1b7b8"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4493, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}