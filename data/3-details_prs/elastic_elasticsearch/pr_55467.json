{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MTE3NDk4", "number": 55467, "title": "Rely on the computeIfAbsent logic to prevent duplicated compilation of scripts", "bodyText": "Not ready to merge see below\nOpening PR also to exchange thoughts / opinions\n\nInstead of serializing compilation using a plain lock / mutex combined with a double check, rely on the computeIfAbsent logic to prevent duplicated compilation of scripts.\nContext\nInitially looked into the code based on customer having a cluster with nodes that would sporadically leave and join the cluster, with the intent to change the lock to a fair lock and to implement back-off using Lock#tryLock(long time, TimeUnit unit). The current code is prone to thread starvation preventing threads from making any progress in light of contention and other thread(s) winning over others. Since threads hitting this code are request handling threads they might get tied up for long enough for the node to look death.\nThe compilation limit circuit breaker helps here but only to keep the operation short enough to avoid contention. In the unlikely event of 'long running' script compilation the contention might still occur, or in the alternative case, when a 'high enough' limit is set.\nApproach\nRelying instead of on a node wide / script cache wide mutex, limit it to the cache segment / per CacheKey instead. This is more efficient as it reduces contention but in this case also ensures progress is made as all blocked threads are waiting for the same result which is being computed. This therefor also means no more starved threads. Additionally we gain some parallelization as multiple scripts can be compiled. The token based implementation should still protect against resource starvation, although one might wonder if an approach that tracks a percentage of time spend should be preferred over simply the number of compilations.\n(I realize writing this that checkCompilationLimit is not thread safe, don't merge, will add additional commit) -> fixed.\nI would have not written a pull request if the logic to implement this wasn't already part of the codebase but I noticed org.elasticsearch.common.cache.Cache already supported #computeIfAbsent(..)\nImplementation\ncomputeIfAbsent(...) is now used removing the need for a monitor in the ScriptCache class, the double lookup / check and the put in the cache simplifying the code somewhat.\nI currently unwrap the ExecutionException to ensure the methods contact doesn't change. As we can't signal that no checked exception is thrown we do end up with a catch block that's kinda clunky. I re-throw here as an ElasticsearchException as I can't pick a more specific type, because that code should never get called.\nUpdated checkCompilationLimit to be thread-safe, as the new logic permits multiple threads calling it concurrently. Implemented lock-free, using CAS. Calculating the current number of tokens in the bucket + attempt to obtain token is done atomically and happens before other calculate+token-obtaining-attempts or new state is not committed and a new happens. Snapshot of state after - but before other tokens are taken, is returned. This snapshot of the state is used to trigger the exception, upon failing to obtain a token. This ensures exactly one thread is able to obtain the last token.", "createdAt": "2020-04-20T14:59:36Z", "url": "https://github.com/elastic/elasticsearch/pull/55467", "merged": true, "mergeCommit": {"oid": "865acadab6255dd698349d3b62141327a3f22ee1"}, "closed": true, "closedAt": "2020-06-15T15:37:41Z", "author": {"login": "mjmbischoff"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceYRdSAFqTQwNjA0MzE3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrhzlNAFqTQzMDcxNzA4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDQzMTcx", "url": "https://github.com/elastic/elasticsearch/pull/55467#pullrequestreview-406043171", "createdAt": "2020-05-05T18:20:36Z", "commit": {"oid": "ae24c668a68496080b9990b978503590b79d9aca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoyMDozNlrOGQ197w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoyMDozNlrOGQ197w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw==", "bodyText": "The call to checkCompilationLimit() is no longer locked on the ScriptCache, we'll have to make this call safe.", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r420314607", "createdAt": "2020-05-05T18:20:36Z", "author": {"login": "stu-elastic"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae24c668a68496080b9990b978503590b79d9aca"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dd254137c228138d9b3af4ffdd2f5acc7217d92", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/0dd254137c228138d9b3af4ffdd2f5acc7217d92", "committedDate": "2020-05-08T16:02:14Z", "message": "Instead of serializing compilation using a plain lock / mutex combined with a double check, rely on the computeIfAbsent logic to prevent duplicated compilation of scripts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65a09c3d8a954dddeb109cc7ca588e5833deb01f", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/65a09c3d8a954dddeb109cc7ca588e5833deb01f", "committedDate": "2020-05-08T16:02:14Z", "message": "Updating checkCompilationLimit to be thread-safe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/e999353b7adf00745d2218b90c5e2031cc7b2a43", "committedDate": "2020-05-08T16:02:14Z", "message": "Fixing checkstyle violations."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae24c668a68496080b9990b978503590b79d9aca", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae24c668a68496080b9990b978503590b79d9aca", "committedDate": "2020-04-21T11:30:03Z", "message": "Fixing checkstyle violations."}, "afterCommit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/e999353b7adf00745d2218b90c5e2031cc7b2a43", "committedDate": "2020-05-08T16:02:14Z", "message": "Fixing checkstyle violations."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MjgyMzQ1", "url": "https://github.com/elastic/elasticsearch/pull/55467#pullrequestreview-429282345", "createdAt": "2020-06-11T20:55:33Z", "commit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDo1NTozM1rOGiudLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDo1NTozM1rOGiudLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ==", "bodyText": "Let's clean this up a bit by moving the try/catch from inside the lambda out to this level and avoid checking for RuntimeException.\ngit diff\ndiff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5..5d59a91b207 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.breaker.CircuitBreaker;\n import org.elasticsearch.common.breaker.CircuitBreakingException;\n import org.elasticsearch.common.cache.Cache;\n@@ -98,41 +97,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r439065901", "createdAt": "2020-06-11T20:55:33Z", "author": {"login": "stu-elastic"}, "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();\n-                    compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    // Since the cache key is the script content itself we don't need to\n+                    // invalidate/check the cache if an indexed script changes.\n+                    scriptMetrics.onCompilation();\n+                    return compiledScript;\n                 } catch (ScriptException good) {\n                     // TODO: remove this try-catch completely, when all script engines have good exceptions!\n                     throw good; // its already good\n                 } catch (Exception exception) {\n                     throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n                             exception);\n                 }\n-\n-                // Since the cache key is the script content itself we don't need to\n-                // invalidate/check the cache if an indexed script changes.\n-                scriptMetrics.onCompilation();\n-                cache.put(cacheKey, compiledScript);\n+            }));\n+        } catch (ExecutionException executionException) {\n+            Throwable cause = executionException.getCause();\n+            if(cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else {\n+                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n+                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MjgyNzgx", "url": "https://github.com/elastic/elasticsearch/pull/55467#pullrequestreview-429282781", "createdAt": "2020-06-11T20:56:17Z", "commit": {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b253d00005ddc5ef14e5b5b76174431b4c7db11", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b253d00005ddc5ef14e5b5b76174431b4c7db11", "committedDate": "2020-06-15T08:38:00Z", "message": "Processing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc3f1d83369749be20780b8e0b07343151c7769f", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/bc3f1d83369749be20780b8e0b07343151c7769f", "committedDate": "2020-06-15T09:16:19Z", "message": "Merge remote-tracking branch 'origin/master' into script-compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52925938e6fd9624011c26ac4e57f32240ac1403", "author": {"user": {"login": "mjmbischoff", "name": "Michael Bischoff"}}, "url": "https://github.com/elastic/elasticsearch/commit/52925938e6fd9624011c26ac4e57f32240ac1403", "committedDate": "2020-06-15T10:00:34Z", "message": "Fixing unused import triggering checkstyle."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNzE3MDg0", "url": "https://github.com/elastic/elasticsearch/pull/55467#pullrequestreview-430717084", "createdAt": "2020-06-15T14:48:03Z", "commit": {"oid": "52925938e6fd9624011c26ac4e57f32240ac1403"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 725, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}