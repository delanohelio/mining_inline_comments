{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzkyODc4", "number": 54227, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMjozNDo0NFrODunS0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoyMjoyNlrODvJt1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjA0ODgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMjozNDo0NFrOGArogA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMjozNDo0NFrOGArogA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2ODA2NA==", "bodyText": "I added #54760 to track an issue for removing unknown time units and only supporting ones that are recognized by range queries.", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r403368064", "createdAt": "2020-04-03T22:34:44Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {\n+                throw new ParsingException(source(numberCtx), \"A positive maxspan value is required; found [{}]\", value);\n+            }\n+            \n+            String timeString = text(ctx.timeUnit().IDENTIFIER());\n+            TimeUnit timeUnit = TimeUnit.SECONDS;\n+            if (timeString != null) {\n+                switch (timeString) {\n+                    case \"\":\n+                    case \"s\":\n+                    case \"sec\":\n+                    case \"secs\":\n+                    case \"second\":\n+                    case \"seconds\":\n+                        timeUnit = TimeUnit.SECONDS;\n+                        break;\n+                    case \"m\":\n+                    case \"min\":\n+                    case \"mins\":\n+                    case \"minute\":\n+                    case \"minutes\":\n+                        timeUnit = TimeUnit.MINUTES;\n+                        break;\n+                    case \"h\":\n+                    case \"hs\":\n+                    case \"hour\":\n+                    case \"hours\":\n+                        timeUnit = TimeUnit.HOURS;\n+                        break;\n+                    case \"d\":\n+                    case \"ds\":\n+                    case \"day\":\n+                    case \"days\":\n+                        timeUnit = TimeUnit.DAYS;\n+                        break;\n+                    default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d344373133fbd0f261bb5e2292bea65193d1b75"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzY4ODUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDoyMjoyNlrOGBaMHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNTozOTo0NFrOGBd2DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzMDg0Ng==", "bodyText": "does the sequence of 0 timespan make sense at all?", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r404130846", "createdAt": "2020-04-06T14:22:26Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08bd9240399c22446d61512d8c70431d97e09318"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE5MDczMg==", "bodyText": "I think not - if no maxspan is needed I opted for not declaring it.\nIf we agree to have 0 indicate no limit across EQL, the parser can be improved.", "url": "https://github.com/elastic/elasticsearch/pull/54227#discussion_r404190732", "createdAt": "2020-04-06T15:39:44Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LogicalPlanBuilder.java", "diffHunk": "@@ -44,11 +61,157 @@ public LogicalPlan visitEventQuery(EqlBaseParser.EventQueryContext ctx) {\n             condition = new And(source, eventMatch, condition);\n         }\n \n-        Filter filter = new Filter(source, new UnresolvedRelation(Source.EMPTY, null, \"\", false, \"\"), condition);\n-        // add implicit sorting - when pipes are added, this would better seat there (as a default pipe)\n+        Filter filter = new Filter(source, RELATION, condition);\n+        // add implicit sorting - when pipes are added, this would better sit there (as a default pipe)\n         Order order = new Order(source, new UnresolvedAttribute(source, params.fieldTimestamp()), Order.OrderDirection.ASC,\n                 Order.NullsPosition.FIRST);\n         OrderBy orderBy = new OrderBy(source, filter, singletonList(order));\n         return orderBy;\n     }\n-}\n+\n+    @Override\n+    public Join visitJoin(JoinContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        LogicalPlan until;\n+        \n+        if (ctx.until != null) {\n+            until = visitJoinTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+        \n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.joinTerm().size());\n+\n+        for (JoinTermContext joinTermCtx : ctx.joinTerm()) {\n+            KeyedFilter joinTerm = visitJoinTerm(joinTermCtx, parentJoinKeys);\n+            int keySize = joinTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(joinTermCtx.by != null ? joinTermCtx.by : joinTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(joinTerm);\n+            }\n+        }\n+\n+        return new Join(source(ctx), queries, until);\n+    }\n+\n+    public KeyedFilter visitJoinTerm(JoinTermContext ctx, List<Expression> joinKeys) {\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public Sequence visitSequence(SequenceContext ctx) {\n+        List<Expression> parentJoinKeys = visitJoinKeys(ctx.by);\n+\n+        TimeValue maxSpan = visitSequenceParams(ctx.sequenceParams());\n+\n+        LogicalPlan until;\n+\n+        if (ctx.until != null) {\n+            until = visitSequenceTerm(ctx.until, parentJoinKeys);\n+        } else {\n+            // no until declared means the condition never gets executed and thus folds to false\n+            until = new Filter(source(ctx), RELATION, new Literal(source(ctx), Boolean.FALSE, DataTypes.BOOLEAN));\n+        }\n+\n+        int numberOfKeys = -1;\n+        List<LogicalPlan> queries = new ArrayList<>(ctx.sequenceTerm().size());\n+\n+        for (SequenceTermContext sequenceTermCtx : ctx.sequenceTerm()) {\n+            KeyedFilter sequenceTerm = visitSequenceTerm(sequenceTermCtx, parentJoinKeys);\n+            int keySize = sequenceTerm.keys().size();\n+            if (numberOfKeys < 0) {\n+                numberOfKeys = keySize;\n+            } else {\n+                if (numberOfKeys != keySize) {\n+                    Source src = source(sequenceTermCtx.by != null ? sequenceTermCtx.by : sequenceTermCtx);\n+                    int expected = numberOfKeys - parentJoinKeys.size();\n+                    int found = keySize - parentJoinKeys.size();\n+                    throw new ParsingException(src, \"Inconsistent number of join keys specified; expected [{}] but found [{}]\", expected,\n+                            found);\n+                }\n+                queries.add(sequenceTerm);\n+            }\n+        }\n+\n+        return new Sequence(source(ctx), queries, until, maxSpan);\n+    }\n+\n+    public KeyedFilter visitSequenceTerm(SequenceTermContext ctx, List<Expression> joinKeys) {\n+        if (ctx.FORK() != null) {\n+            throw new ParsingException(source(ctx.FORK()), \"sequence fork is unsupported\");\n+        }\n+\n+        List<Expression> keys = CollectionUtils.combine(joinKeys, visitJoinKeys(ctx.by));\n+        return new KeyedFilter(source(ctx), visitEventQuery(ctx.subquery().eventQuery()), keys);\n+    }\n+\n+    @Override\n+    public TimeValue visitSequenceParams(SequenceParamsContext ctx) {\n+        if (ctx == null) {\n+            return TimeValue.MINUS_ONE;\n+        }\n+\n+        NumberContext numberCtx = ctx.timeUnit().number();\n+        if (numberCtx instanceof IntegerLiteralContext) {\n+            Number number = (Number) visitIntegerLiteral((IntegerLiteralContext) numberCtx).fold();\n+            long value = number.longValue();\n+            \n+            if (value <= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEzMDg0Ng=="}, "originalCommit": {"oid": "08bd9240399c22446d61512d8c70431d97e09318"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4108, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}