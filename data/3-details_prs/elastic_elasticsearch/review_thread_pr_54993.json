{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMTAyMzU1", "number": 54993, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowNzoxOFrODwTJOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowNzoxOFrODwTJOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTcxODk5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/watcher/ResourceWatcherService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowNzoxOFrOGDN_9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODoyMjo0OFrOGD0bxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyODI3Ng==", "bodyText": "This schedule will still begin its first poll after the initial delay, which is the \"big\" gap for #54867. Or theoretically, anything added between 2 polls may have a chance to miss an update. You are probably solving it in #54999 (I haven't looked through). Even so, I wonder whether it would be better if this watch service can guarantee no gaps.", "url": "https://github.com/elastic/elasticsearch/pull/54993#discussion_r406028276", "createdAt": "2020-04-09T08:07:18Z", "author": {"login": "ywangd"}, "path": "server/src/main/java/org/elasticsearch/watcher/ResourceWatcherService.java", "diffHunk": "@@ -78,51 +77,42 @@\n         Setting.timeSetting(\"resource.reload.interval.low\", Frequency.LOW.interval, Property.NodeScope);\n \n     private final boolean enabled;\n-    private final ThreadPool threadPool;\n \n     final ResourceMonitor lowMonitor;\n     final ResourceMonitor mediumMonitor;\n     final ResourceMonitor highMonitor;\n \n-    private volatile Cancellable lowFuture;\n-    private volatile Cancellable mediumFuture;\n-    private volatile Cancellable highFuture;\n+    private final Cancellable lowFuture;\n+    private final Cancellable mediumFuture;\n+    private final Cancellable highFuture;\n \n-    @Inject\n     public ResourceWatcherService(Settings settings, ThreadPool threadPool) {\n         this.enabled = ENABLED.get(settings);\n-        this.threadPool = threadPool;\n \n         TimeValue interval = RELOAD_INTERVAL_LOW.get(settings);\n         lowMonitor = new ResourceMonitor(interval, Frequency.LOW);\n         interval = RELOAD_INTERVAL_MEDIUM.get(settings);\n         mediumMonitor = new ResourceMonitor(interval, Frequency.MEDIUM);\n         interval = RELOAD_INTERVAL_HIGH.get(settings);\n         highMonitor = new ResourceMonitor(interval, Frequency.HIGH);\n-    }\n-\n-    @Override\n-    protected void doStart() {\n-        if (!enabled) {\n-            return;\n+        if (enabled) {\n+            lowFuture = threadPool.scheduleWithFixedDelay(lowMonitor, lowMonitor.interval, Names.SAME);\n+            mediumFuture = threadPool.scheduleWithFixedDelay(mediumMonitor, mediumMonitor.interval, Names.SAME);\n+            highFuture = threadPool.scheduleWithFixedDelay(highMonitor, highMonitor.interval, Names.SAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0804591b3af6fd28ad9165e921d7a665ce50a36"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NjA1Nw==", "bodyText": "Correct, there will still be the initial delay but we won't miss an update AFAICS. The add method initializes the watcher that is being registered: \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/ResourceWatcherService.java\n    \n    \n        Lines 138 to 139\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           public <W extends ResourceWatcher> WatcherHandle<W> add(W watcher, Frequency frequency) throws IOException { \n        \n\n        \n          \n               watcher.init(); \n        \n    \n  \n\n\nGiven that we are monitoring files, this will be a FileWatcher which extends AbstractResourceWatcher. AbstractResourceWatcher has an init method that will call the doInit method in the FileWatcher class \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/AbstractResourceWatcher.java\n    \n    \n        Lines 33 to 39\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           @Override \n        \n\n        \n          \n           public void init() throws IOException { \n        \n\n        \n          \n               if (!initialized) { \n        \n\n        \n          \n                   doInit(); \n        \n\n        \n          \n                   initialized = true; \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nThe FileWatcher#doInit method will initialize the FileObserver \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/FileWatcher.java\n    \n    \n        Lines 63 to 66\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           @Override \n        \n\n        \n          \n           protected void doInit() throws IOException { \n        \n\n        \n          \n               rootFileObserver.init(true); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nThe FileObserver initialization captures whether the directory we are monitoring exists  \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/FileWatcher.java\n    \n    \n        Lines 156 to 169\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           private void init(boolean initial) throws IOException { \n        \n\n        \n          \n               exists = Files.exists(file); \n        \n\n        \n          \n               if (exists) { \n        \n\n        \n          \n                   BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class); \n        \n\n        \n          \n                   isDirectory = attributes.isDirectory(); \n        \n\n        \n          \n                   if (isDirectory) { \n        \n\n        \n          \n                       onDirectoryCreated(initial); \n        \n\n        \n          \n                   } else { \n        \n\n        \n          \n                       length = attributes.size(); \n        \n\n        \n          \n                       lastModified = attributes.lastModifiedTime().toMillis(); \n        \n\n        \n          \n                       onFileCreated(initial); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nThis will then trigger the listing of the child files within that directory and sub directories \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/FileWatcher.java\n    \n    \n        Lines 287 to 300\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           private void onDirectoryCreated(boolean initial) throws IOException { \n        \n\n        \n          \n               for (FileChangesListener listener : listeners()) { \n        \n\n        \n          \n                   try { \n        \n\n        \n          \n                       if (initial) { \n        \n\n        \n          \n                           listener.onDirectoryInit(file); \n        \n\n        \n          \n                       } else { \n        \n\n        \n          \n                           listener.onDirectoryCreated(file); \n        \n\n        \n          \n                       } \n        \n\n        \n          \n                   } catch (Exception e) { \n        \n\n        \n          \n                       logger.warn(\"cannot notify file changes listener\", e); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n               children = listChildren(initial); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nA FileObserver is created for each child \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/FileWatcher.java\n    \n    \n        Lines 183 to 194\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           private FileObserver[] listChildren(boolean initial) throws IOException { \n        \n\n        \n          \n               Path[] files = listFiles(); \n        \n\n        \n          \n               if (files != null && files.length > 0) { \n        \n\n        \n          \n                   FileObserver[] children = new FileObserver[files.length]; \n        \n\n        \n          \n                   for (int i = 0; i < files.length; i++) { \n        \n\n        \n          \n                       children[i] = createChild(files[i], initial); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   return children; \n        \n\n        \n          \n               } else { \n        \n\n        \n          \n                   return EMPTY_DIRECTORY; \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nEach child is also initialized \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/watcher/FileWatcher.java\n    \n    \n        Lines 171 to 175\n      in\n      af7ea67\n    \n    \n    \n    \n\n        \n          \n           private FileObserver createChild(Path file, boolean initial) throws IOException { \n        \n\n        \n          \n               FileObserver child = new FileObserver(file); \n        \n\n        \n          \n               child.init(initial); \n        \n\n        \n          \n               return child; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nThis means that we will not miss any updates to these files if we register the monitoring of the files prior to actually loading the files, which is where #54999 comes into play. This change will allow for changes to possibly be found sooner.", "url": "https://github.com/elastic/elasticsearch/pull/54993#discussion_r406466057", "createdAt": "2020-04-09T20:44:04Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/watcher/ResourceWatcherService.java", "diffHunk": "@@ -78,51 +77,42 @@\n         Setting.timeSetting(\"resource.reload.interval.low\", Frequency.LOW.interval, Property.NodeScope);\n \n     private final boolean enabled;\n-    private final ThreadPool threadPool;\n \n     final ResourceMonitor lowMonitor;\n     final ResourceMonitor mediumMonitor;\n     final ResourceMonitor highMonitor;\n \n-    private volatile Cancellable lowFuture;\n-    private volatile Cancellable mediumFuture;\n-    private volatile Cancellable highFuture;\n+    private final Cancellable lowFuture;\n+    private final Cancellable mediumFuture;\n+    private final Cancellable highFuture;\n \n-    @Inject\n     public ResourceWatcherService(Settings settings, ThreadPool threadPool) {\n         this.enabled = ENABLED.get(settings);\n-        this.threadPool = threadPool;\n \n         TimeValue interval = RELOAD_INTERVAL_LOW.get(settings);\n         lowMonitor = new ResourceMonitor(interval, Frequency.LOW);\n         interval = RELOAD_INTERVAL_MEDIUM.get(settings);\n         mediumMonitor = new ResourceMonitor(interval, Frequency.MEDIUM);\n         interval = RELOAD_INTERVAL_HIGH.get(settings);\n         highMonitor = new ResourceMonitor(interval, Frequency.HIGH);\n-    }\n-\n-    @Override\n-    protected void doStart() {\n-        if (!enabled) {\n-            return;\n+        if (enabled) {\n+            lowFuture = threadPool.scheduleWithFixedDelay(lowMonitor, lowMonitor.interval, Names.SAME);\n+            mediumFuture = threadPool.scheduleWithFixedDelay(mediumMonitor, mediumMonitor.interval, Names.SAME);\n+            highFuture = threadPool.scheduleWithFixedDelay(highMonitor, highMonitor.interval, Names.SAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyODI3Ng=="}, "originalCommit": {"oid": "e0804591b3af6fd28ad9165e921d7a665ce50a36"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1Nzk5MQ==", "bodyText": "You are absolutely right. I completely missed that watcher.init(); call. \ud83e\udd26", "url": "https://github.com/elastic/elasticsearch/pull/54993#discussion_r406657991", "createdAt": "2020-04-10T08:22:48Z", "author": {"login": "ywangd"}, "path": "server/src/main/java/org/elasticsearch/watcher/ResourceWatcherService.java", "diffHunk": "@@ -78,51 +77,42 @@\n         Setting.timeSetting(\"resource.reload.interval.low\", Frequency.LOW.interval, Property.NodeScope);\n \n     private final boolean enabled;\n-    private final ThreadPool threadPool;\n \n     final ResourceMonitor lowMonitor;\n     final ResourceMonitor mediumMonitor;\n     final ResourceMonitor highMonitor;\n \n-    private volatile Cancellable lowFuture;\n-    private volatile Cancellable mediumFuture;\n-    private volatile Cancellable highFuture;\n+    private final Cancellable lowFuture;\n+    private final Cancellable mediumFuture;\n+    private final Cancellable highFuture;\n \n-    @Inject\n     public ResourceWatcherService(Settings settings, ThreadPool threadPool) {\n         this.enabled = ENABLED.get(settings);\n-        this.threadPool = threadPool;\n \n         TimeValue interval = RELOAD_INTERVAL_LOW.get(settings);\n         lowMonitor = new ResourceMonitor(interval, Frequency.LOW);\n         interval = RELOAD_INTERVAL_MEDIUM.get(settings);\n         mediumMonitor = new ResourceMonitor(interval, Frequency.MEDIUM);\n         interval = RELOAD_INTERVAL_HIGH.get(settings);\n         highMonitor = new ResourceMonitor(interval, Frequency.HIGH);\n-    }\n-\n-    @Override\n-    protected void doStart() {\n-        if (!enabled) {\n-            return;\n+        if (enabled) {\n+            lowFuture = threadPool.scheduleWithFixedDelay(lowMonitor, lowMonitor.interval, Names.SAME);\n+            mediumFuture = threadPool.scheduleWithFixedDelay(mediumMonitor, mediumMonitor.interval, Names.SAME);\n+            highFuture = threadPool.scheduleWithFixedDelay(highMonitor, highMonitor.interval, Names.SAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyODI3Ng=="}, "originalCommit": {"oid": "e0804591b3af6fd28ad9165e921d7a665ce50a36"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1198, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}