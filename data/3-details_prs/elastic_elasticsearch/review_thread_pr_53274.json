{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NTA4NjYy", "number": 53274, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzoxMDoyMFrODobS5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo0NjowNlrODooONQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzE2ODM4OnYy", "diffSide": "RIGHT", "path": "docs/reference/transform/painless-examples.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzoxMDoyMFrOF29-Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzoxMDoyMFrOF29-Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4Mjc0Ng==", "bodyText": "You can use the shared attribute from https://github.com/elastic/docs/blob/master/shared/attributes.asciidoc:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-guide.html[Painless guide].\n          \n          \n            \n            {painless}/painless-guide.html[Painless guide].", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r393182746", "createdAt": "2020-03-16T17:10:20Z", "author": {"login": "lcawl"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-guide.html[Painless guide].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fb38c11642bbe7d026b29e574c222fb31e6fcd"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzY4OTQwOnYy", "diffSide": "RIGHT", "path": "docs/reference/transform/painless-examples.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOTozODoxOFrOF3DJRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOTozODoxOFrOF3DJRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI2NzUyNw==", "bodyText": "I added this anchor in #53618\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {ref}/search-aggregations-metrics-scripted-metric-aggregation.html#_scope_of_scripts[scope of scripts]\n          \n          \n            \n            <<scripted-metric-aggregation-scope,scope of scripts>>", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r393267527", "createdAt": "2020-03-16T19:38:18Z", "author": {"login": "lcawl"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.\n+<3> The `combine_script` returns `state` from each shard.\n+<4> The `reduce_script` iterates through the value of `s.timestamp_latest` \n+returned by each shard and returns the document with the latest timestamp \n+(`last_doc`). In the response, the top hit (in other words, the `latest_doc`) is \n+nested below the `latest_doc` field.\n+\n+Check the\n+{ref}/search-aggregations-metrics-scripted-metric-aggregation.html#_scope_of_scripts[scope of scripts]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fb38c11642bbe7d026b29e574c222fb31e6fcd"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTI2MDQxOnYy", "diffSide": "RIGHT", "path": "docs/reference/transform/painless-examples.asciidoc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODozODowM1rOF3SWDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOToxNjoxM1rOF58jyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNjU1OQ==", "bodyText": "For correctness I think we should explain new HashMap(...):\n\"By using new HashMap(...) we copy the source document, this is important whenever you want to pass the full source object from one phase to the next.\"\nBut: let me clarify this with the painless developers, this might be a bug in painless.", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r393516559", "createdAt": "2020-03-17T08:38:03Z", "author": {"login": "hendrikmuhs"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+{painless}/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f02c2d3e928df58c2dfa5ed0c78eac0eaeded74"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNzQ0OA==", "bodyText": "follow up issue: #53679\n(will be picked up on thursday, so I expect some answer at the end of this week)", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r393827448", "createdAt": "2020-03-17T16:55:07Z", "author": {"login": "hendrikmuhs"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+{painless}/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNjU1OQ=="}, "originalCommit": {"oid": "2f02c2d3e928df58c2dfa5ed0c78eac0eaeded74"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5ODI5OQ==", "bodyText": "@hendrikmuhs Thank you for this!", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r394198299", "createdAt": "2020-03-18T09:11:34Z", "author": {"login": "szabosteve"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+{painless}/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNjU1OQ=="}, "originalCommit": {"oid": "2f02c2d3e928df58c2dfa5ed0c78eac0eaeded74"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNTM1NA==", "bodyText": "For the record: we decided to go forward with the workaround and change the documentation once #53679 got fixed.", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r396305354", "createdAt": "2020-03-23T09:16:13Z", "author": {"login": "hendrikmuhs"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+{painless}/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNjU1OQ=="}, "originalCommit": {"oid": "2f02c2d3e928df58c2dfa5ed0c78eac0eaeded74"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTI4NjI5OnYy", "diffSide": "RIGHT", "path": "docs/reference/transform/painless-examples.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo0NjowN1rOF3Smmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOTowNToxNVrOF3TP6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMDc5NQ==", "bodyText": "This PR has the 7.6.2 label, too. However scripting in group_by is a 7.7 feature.", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r393520795", "createdAt": "2020-03-17T08:46:07Z", "author": {"login": "hendrikmuhs"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+{painless}/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.\n+<3> The `combine_script` returns `state` from each shard.\n+<4> The `reduce_script` iterates through the value of `s.timestamp_latest` \n+returned by each shard and returns the document with the latest timestamp \n+(`last_doc`). In the response, the top hit (in other words, the `latest_doc`) is \n+nested below the `latest_doc` field.\n+\n+Check the\n+<<scripted-metric-aggregation-scope,scope of scripts>>\n+for detailed explanation on the respective scripts.\n+\n+You can retrieve the last value in a similar way: \n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_value\": {\n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_value = ''\",\n+    \"map_script\": \"\"\"\n+      def current_date = doc['date'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_value = params['_source']['value'];}\n+    \"\"\",\n+    \"combine_script\": \"return state\",\n+    \"reduce_script\": \"\"\"\n+      def last_value = '';\n+      def timestamp_latest = 0L; \n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest)) \n+      {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}} \n+      return last_value\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+\n+[discrete]\n+[[painless-time-features]]\n+==== Getting time features as scripted fields\n+\n+This snippet shows how to extract time based features by using Painless. The \n+snippet uses an index where `@timestamp` is defined as a `date` type field.\n+\n+[source,js]\n+--------------------------------------------------\n+\"script_fields\": {\n+    \"hour_of_day\": { <1>\n+      \"script\": {\n+        \"lang\": \"painless\",\n+        \"source\": \"\"\"\n+          ZonedDateTime date =  doc['@timestamp'].value; <2>\n+          return date.getHour(); <3>\n+        \"\"\"\n+      }\n+    },\n+    \"month_of_year\": { <4>\n+      \"script\": {\n+        \"lang\": \"painless\",\n+        \"source\": \"\"\"\n+          ZonedDateTime date =  doc['@timestamp'].value; <5>\n+          return date.getMonthValue(); <6>\n+        \"\"\"\n+      }\n+    }\n+  }\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> Contains the Painless script that returns the hour of the day.\n+<2> Sets `date` based on the timestamp of the document.\n+<3> Returns the hour value from `date`.\n+<4> Contains the Painless script that returns the month of the year.\n+<5> Sets `date` based on the timestamp of the document.\n+<6> Returns the month value from `date`.\n+\n+\n+[discrete]\n+[[painless-group-by]]\n+==== Using Painless in `group_by`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f02c2d3e928df58c2dfa5ed0c78eac0eaeded74"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzMTM2OA==", "bodyText": "@hendrikmuhs Thanks, Hendrik! I removed the label.", "url": "https://github.com/elastic/elasticsearch/pull/53274#discussion_r393531368", "createdAt": "2020-03-17T09:05:15Z", "author": {"login": "szabosteve"}, "path": "docs/reference/transform/painless-examples.asciidoc", "diffHunk": "@@ -0,0 +1,327 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[transform-painless-examples]]\n+=== Painless examples for {transforms}\n+++++\n+<titleabbrev>Painless examples for {transforms}</titleabbrev>\n+++++\n+\n+These examples demonstrate how to use Painless in {transforms}. You can learn \n+more about the Painless scripting language in the \n+{painless}/painless-guide.html[Painless guide].\n+\n+* <<painless-top-hits>>\n+* <<painless-time-features>>\n+* <<painless-group-by>>\n+* <<painless-bucket-script>>\n+\n+\n+[discrete]\n+[[painless-top-hits]]\n+==== Getting top hits by using scripted metric\n+\n+This snippet shows how to find the latest document, in other words the document \n+with the earliest timestamp. From a technical perspective, it helps to achieve \n+the function of a <<search-aggregations-metrics-top-hits-aggregation>> by using \n+scripted metric aggregation which provides a metric output.\n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_doc\": { \n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_doc = ''\", <1>\n+    \"map_script\": \"\"\" <2>\n+      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_doc = new HashMap(params['_source']);}\n+    \"\"\",\n+    \"combine_script\": \"return state\", <3>\n+    \"reduce_script\": \"\"\" <4>\n+      def last_doc = '';\n+      def timestamp_latest = 0L;\n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest))\n+      {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}} \n+      return last_doc\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The `init_script` creates a long type `timestamp_latest` and a string type \n+`last_doc` in the `state` object.\n+<2> The `map_script` defines `current_date` based on the timestamp of the \n+document, then compares `current_date` with `state.timestamp_latest`, finally \n+returns `state.last_doc` from the shard.\n+<3> The `combine_script` returns `state` from each shard.\n+<4> The `reduce_script` iterates through the value of `s.timestamp_latest` \n+returned by each shard and returns the document with the latest timestamp \n+(`last_doc`). In the response, the top hit (in other words, the `latest_doc`) is \n+nested below the `latest_doc` field.\n+\n+Check the\n+<<scripted-metric-aggregation-scope,scope of scripts>>\n+for detailed explanation on the respective scripts.\n+\n+You can retrieve the last value in a similar way: \n+\n+[source,js]\n+--------------------------------------------------\n+\"latest_value\": {\n+  \"scripted_metric\": {\n+    \"init_script\": \"state.timestamp_latest = 0L; state.last_value = ''\",\n+    \"map_script\": \"\"\"\n+      def current_date = doc['date'].getValue().toInstant().toEpochMilli(); \n+      if (current_date > state.timestamp_latest) \n+      {state.timestamp_latest = current_date;\n+      state.last_value = params['_source']['value'];}\n+    \"\"\",\n+    \"combine_script\": \"return state\",\n+    \"reduce_script\": \"\"\"\n+      def last_value = '';\n+      def timestamp_latest = 0L; \n+      for (s in states) {if (s.timestamp_latest > (timestamp_latest)) \n+      {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}} \n+      return last_value\n+    \"\"\"\n+  }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+\n+[discrete]\n+[[painless-time-features]]\n+==== Getting time features as scripted fields\n+\n+This snippet shows how to extract time based features by using Painless. The \n+snippet uses an index where `@timestamp` is defined as a `date` type field.\n+\n+[source,js]\n+--------------------------------------------------\n+\"script_fields\": {\n+    \"hour_of_day\": { <1>\n+      \"script\": {\n+        \"lang\": \"painless\",\n+        \"source\": \"\"\"\n+          ZonedDateTime date =  doc['@timestamp'].value; <2>\n+          return date.getHour(); <3>\n+        \"\"\"\n+      }\n+    },\n+    \"month_of_year\": { <4>\n+      \"script\": {\n+        \"lang\": \"painless\",\n+        \"source\": \"\"\"\n+          ZonedDateTime date =  doc['@timestamp'].value; <5>\n+          return date.getMonthValue(); <6>\n+        \"\"\"\n+      }\n+    }\n+  }\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> Contains the Painless script that returns the hour of the day.\n+<2> Sets `date` based on the timestamp of the document.\n+<3> Returns the hour value from `date`.\n+<4> Contains the Painless script that returns the month of the year.\n+<5> Sets `date` based on the timestamp of the document.\n+<6> Returns the month value from `date`.\n+\n+\n+[discrete]\n+[[painless-group-by]]\n+==== Using Painless in `group_by`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMDc5NQ=="}, "originalCommit": {"oid": "2f02c2d3e928df58c2dfa5ed0c78eac0eaeded74"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3361, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}