{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NDU5MDE5", "number": 50642, "title": "Add async dangling indices support", "bodyText": "Adds support for writing out dangling indices in an asynchronous way. Also provides an option to avoid writing out dangling indices at all.\nRelates #48701\nA follow-up will look at how the cluster state on data-only nodes can be written out asynchronously.  The main reason it is still written out in this PR is that the cluster state contains the cluster UUID, which allows data nodes to snap into a cluster.", "createdAt": "2020-01-06T09:20:34Z", "url": "https://github.com/elastic/elasticsearch/pull/50642", "merged": true, "mergeCommit": {"oid": "1a9f88f9bcbe22cbdeb2825aab3ee795ab02c1c5"}, "closed": true, "closedAt": "2020-01-08T13:06:49Z", "author": {"login": "ywelsch"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb3oRD0AH2gAyMzU5NDU5MDE5OjdkOWUxZDQyODMyZmMwN2I4N2Q3MzZiMTA3YTcwMjlkNWFjNmQ1Mjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb4VA0FgFqTMzOTg0ODM0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d9e1d42832fc07b87d736b107a7029d5ac6d528", "committedDate": "2020-01-06T08:55:36Z", "message": "Add async dangling indices support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e36f297362275eb8125dc19cffb30a044094a6e3", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/e36f297362275eb8125dc19cffb30a044094a6e3", "committedDate": "2020-01-07T14:56:15Z", "message": "Merge branch 'reduce-metadata-writes-master' into dangling-indices-v2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5Nzk1MjYy", "url": "https://github.com/elastic/elasticsearch/pull/50642#pullrequestreview-339795262", "createdAt": "2020-01-08T11:10:53Z", "commit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMToxMDo1M1rOFbTvLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxMTo0ODoyOFrOFbUlEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3OTI0NA==", "bodyText": "Doing this before calling indexService.writeDanglingIndicesInfo() means that allPendingDanglingIndicesWritten() may return true while there's still a write in progress.", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364179244", "createdAt": "2020-01-08T11:10:53Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -1487,4 +1529,48 @@ private void setIdFieldDataEnabled(boolean value) {\n         }\n         return Optional.empty();\n     }\n+\n+    private void updateDanglingIndicesInfo(Index index) {\n+        assert DiscoveryNode.isDataNode(settings) : \"dangling indices information should only be persisted on data nodes\";\n+        if (danglingIndicesToWrite.add(index)) {\n+            logger.trace(\"triggered dangling indices update for {}\", index);\n+            final long triggeredTimeMillis = threadPool.relativeTimeInMillis();\n+            try {\n+                danglingIndicesThreadPoolExecutor.execute(new AbstractRunnable() {\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index), e);\n+                    }\n+\n+                    @Override\n+                    protected void doRun() {\n+                        final boolean exists = danglingIndicesToWrite.remove(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MDY0NA==", "bodyText": "If gateway.write_dangling_indices_info is false I think we should avoid creating a thread here.", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364180644", "createdAt": "2020-01-08T11:15:01Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -289,12 +306,25 @@ protected void closeInternal() {\n                 }\n             }\n         };\n+\n+        final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+        danglingIndicesThreadPoolExecutor = EsExecutors.newScaling(\n+            nodeName + \"/\" + DANGLING_INDICES_UPDATE_THREAD_NAME,\n+            1, 1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MTIyMA==", "bodyText": "Nice catch. Maybe call unreferenceAll() here instead?", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364191220", "createdAt": "2020-01-08T11:43:23Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/MetaStateService.java", "diffHunk": "@@ -264,15 +264,28 @@ public void cleanupIndex(Index index, long currentGeneration) {\n         INDEX_META_DATA_FORMAT.cleanupOldFiles(currentGeneration, nodeEnv.indexPaths(index));\n     }\n \n+    /**\n+     * Creates empty cluster state file on disk, deleting global metadata and unreferencing all index metadata\n+     * (only used for dangling indices at that point).\n+     */\n+    public void unreferenceAll() throws IOException {\n+        MANIFEST_FORMAT.writeAndCleanup(Manifest.empty(), nodeEnv.nodeDataPaths()); // write empty file so that indices become unreferenced\n+        META_DATA_FORMAT.cleanupOldFiles(Long.MAX_VALUE, nodeEnv.nodeDataPaths());\n+    }\n+\n     /**\n      * Removes manifest file, global metadata and all index metadata\n      */\n     public void deleteAll() throws IOException {\n-        MANIFEST_FORMAT.cleanupOldFiles(Long.MAX_VALUE, nodeEnv.nodeDataPaths());\n+        // To ensure that the metadata is never reimported by loadFullStateBWC in case where the deletions here fail mid-way through,\n+        // we first write an empty manifest file so that the indices become unreferenced, then clean up the indices, and only then delete\n+        // the manifest file.\n+        MANIFEST_FORMAT.writeAndCleanup(Manifest.empty(), nodeEnv.nodeDataPaths());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MjEwMw==", "bodyText": "I think a failure here indicates a bad enough problem to warrant a WARN-level log.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);\n          \n          \n            \n                        logger.warn(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364192103", "createdAt": "2020-01-08T11:45:44Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/IndexService.java", "diffHunk": "@@ -324,6 +327,29 @@ public synchronized void close(final String reason, boolean delete) throws IOExc\n         }\n     }\n \n+    // method is synchronized so that IndexService can't be closed while we're writing out dangling indices information\n+    public synchronized void writeDanglingIndicesInfo() {\n+        if (closed.get()) {\n+            return;\n+        }\n+        try {\n+            IndexMetaData.FORMAT.writeAndCleanup(getMetaData(), nodeEnv.indexPaths(index()));\n+        } catch (WriteStateException e) {\n+            logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MjE2Nw==", "bodyText": "I think a failure here indicates a bad enough problem to warrant a WARN-level log.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(() -> new ParameterizedMessage(\"failed to delete dangling indices state for index {}\", index()), e);\n          \n          \n            \n                        logger.warn(() -> new ParameterizedMessage(\"failed to delete dangling indices state for index {}\", index()), e);", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364192167", "createdAt": "2020-01-08T11:45:54Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/IndexService.java", "diffHunk": "@@ -324,6 +327,29 @@ public synchronized void close(final String reason, boolean delete) throws IOExc\n         }\n     }\n \n+    // method is synchronized so that IndexService can't be closed while we're writing out dangling indices information\n+    public synchronized void writeDanglingIndicesInfo() {\n+        if (closed.get()) {\n+            return;\n+        }\n+        try {\n+            IndexMetaData.FORMAT.writeAndCleanup(getMetaData(), nodeEnv.indexPaths(index()));\n+        } catch (WriteStateException e) {\n+            logger.info(() -> new ParameterizedMessage(\"failed to write dangling indices state for index {}\", index()), e);\n+        }\n+    }\n+\n+    // method is synchronized so that IndexService can't be closed while we're deleting dangling indices information\n+    public synchronized void deleteDanglingIndicesInfo() {\n+        if (closed.get()) {\n+            return;\n+        }\n+        try {\n+            MetaDataStateFormat.deleteMetaState(nodeEnv.indexPaths(index()));\n+        } catch (IOException e) {\n+            logger.info(() -> new ParameterizedMessage(\"failed to delete dangling indices state for index {}\", index()), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE5MzA0Mg==", "bodyText": "\ud83d\udc4d noting that if dangling indices functionality is disabled then we delete the metadata as the indices are allocated, so if any indices are genuinely dangling at this point then we keep their metadata around.", "url": "https://github.com/elastic/elasticsearch/pull/50642#discussion_r364193042", "createdAt": "2020-01-08T11:48:28Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -109,7 +109,11 @@ public void start(Settings settings, TransportService transportService, ClusterS\n                             .build());\n                     lucenePersistedState = new LucenePersistedState(\n                         persistenceWriter, currentTerm, clusterState);\n-                    metaStateService.deleteAll(); // delete legacy files\n+                    if (DiscoveryNode.isDataNode(settings)) {\n+                        metaStateService.unreferenceAll(); // unreference legacy files (only keep them for dangling indices functionality)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d9e1d42832fc07b87d736b107a7029d5ac6d528"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a7b656f5ce344c3ee413a5a933d4f8fed34cf9a", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/3a7b656f5ce344c3ee413a5a933d4f8fed34cf9a", "committedDate": "2020-01-08T12:54:03Z", "message": "review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5ODQ1MTQw", "url": "https://github.com/elastic/elasticsearch/pull/50642#pullrequestreview-339845140", "createdAt": "2020-01-08T12:57:10Z", "commit": {"oid": "3a7b656f5ce344c3ee413a5a933d4f8fed34cf9a"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5ODQ4MzQ2", "url": "https://github.com/elastic/elasticsearch/pull/50642#pullrequestreview-339848346", "createdAt": "2020-01-08T13:03:35Z", "commit": {"oid": "3a7b656f5ce344c3ee413a5a933d4f8fed34cf9a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3831, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}