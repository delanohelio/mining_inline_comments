{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMjAzNTQx", "number": 61525, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTo0MTowNFrOEyuhyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDoyNzo1MlrOEyvuEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjI2NTY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateDataStreamService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTo0MTowNFrOHphh1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTo0MTowNFrOHphh1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMjk5Nw==", "bodyText": "maybe add what the write index is and backing indices (if any) to this log message?", "url": "https://github.com/elastic/elasticsearch/pull/61525#discussion_r513302997", "createdAt": "2020-10-28T09:41:04Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateDataStreamService.java", "diffHunk": "@@ -120,49 +123,75 @@ public CreateDataStreamClusterStateUpdateRequest(String name,\n \n     static ClusterState createDataStream(MetadataCreateIndexService metadataCreateIndexService,\n                                          ClusterState currentState,\n-                                         CreateDataStreamClusterStateUpdateRequest request)\n-        throws Exception {\n-        if (currentState.metadata().dataStreams().containsKey(request.name)) {\n-            throw new ResourceAlreadyExistsException(\"data_stream [\" + request.name + \"] already exists\");\n+                                         CreateDataStreamClusterStateUpdateRequest request) throws Exception {\n+        return createDataStream(metadataCreateIndexService, currentState, request.name, List.of(), null);\n+    }\n+\n+    /**\n+     * Creates a data stream with the specified properties.\n+     *\n+     * @param metadataCreateIndexService Used if a new write index must be created\n+     * @param currentState               Cluster state\n+     * @param dataStreamName             Name of the data stream\n+     * @param backingIndices             List of backing indices. May be empty\n+     * @param writeIndex                 Write index for the data stream. If null, a new write index will be created.\n+     * @return                           Cluster state containing the new data stream\n+     */\n+    static ClusterState createDataStream(MetadataCreateIndexService metadataCreateIndexService,\n+                                         ClusterState currentState,\n+                                         String dataStreamName,\n+                                         List<IndexMetadata> backingIndices,\n+                                         IndexMetadata writeIndex) throws Exception\n+    {\n+        if (writeIndex == null) {\n+            Objects.requireNonNull(metadataCreateIndexService);\n+        }\n+        Objects.requireNonNull(currentState);\n+        Objects.requireNonNull(backingIndices);\n+        if (currentState.metadata().dataStreams().containsKey(dataStreamName)) {\n+            throw new ResourceAlreadyExistsException(\"data_stream [\" + dataStreamName + \"] already exists\");\n         }\n \n-        MetadataCreateIndexService.validateIndexOrAliasName(request.name,\n+        MetadataCreateIndexService.validateIndexOrAliasName(dataStreamName,\n             (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n-        if (request.name.toLowerCase(Locale.ROOT).equals(request.name) == false) {\n-            throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] must be lowercase\");\n+        if (dataStreamName.toLowerCase(Locale.ROOT).equals(dataStreamName) == false) {\n+            throw new IllegalArgumentException(\"data_stream [\" + dataStreamName + \"] must be lowercase\");\n         }\n-        if (request.name.startsWith(\".\")) {\n-            throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] must not start with '.'\");\n+        if (dataStreamName.startsWith(\".\")) {\n+            throw new IllegalArgumentException(\"data_stream [\" + dataStreamName + \"] must not start with '.'\");\n         }\n \n-        ComposableIndexTemplate template = lookupTemplateForDataStream(request.name, currentState.metadata());\n-\n-        String firstBackingIndexName = DataStream.getDefaultBackingIndexName(request.name, 1);\n-        CreateIndexClusterStateUpdateRequest createIndexRequest =\n-            new CreateIndexClusterStateUpdateRequest(\"initialize_data_stream\", firstBackingIndexName, firstBackingIndexName)\n-                .dataStreamName(request.name)\n-                .settings(Settings.builder().put(\"index.hidden\", true).build());\n-        try {\n-            currentState = metadataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n-        } catch (ResourceAlreadyExistsException e) {\n-            // Rethrow as ElasticsearchStatusException, so that bulk transport action doesn't ignore it during\n-            // auto index/data stream creation.\n-            // (otherwise bulk execution fails later, because data stream will also not have been created)\n-            throw new ElasticsearchStatusException(\"data stream could not be created because backing index [{}] already exists\",\n-                RestStatus.BAD_REQUEST, e, firstBackingIndexName);\n+        ComposableIndexTemplate template = lookupTemplateForDataStream(dataStreamName, currentState.metadata());\n+\n+        if (writeIndex == null) {\n+            String firstBackingIndexName = DataStream.getDefaultBackingIndexName(dataStreamName, 1);\n+            CreateIndexClusterStateUpdateRequest createIndexRequest =\n+                new CreateIndexClusterStateUpdateRequest(\"initialize_data_stream\", firstBackingIndexName, firstBackingIndexName)\n+                    .dataStreamName(dataStreamName)\n+                    .settings(Settings.builder().put(\"index.hidden\", true).build());\n+            try {\n+                currentState = metadataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n+            } catch (ResourceAlreadyExistsException e) {\n+                // Rethrow as ElasticsearchStatusException, so that bulk transport action doesn't ignore it during\n+                // auto index/data stream creation.\n+                // (otherwise bulk execution fails later, because data stream will also not have been created)\n+                throw new ElasticsearchStatusException(\"data stream could not be created because backing index [{}] already exists\",\n+                    RestStatus.BAD_REQUEST, e, firstBackingIndexName);\n+            }\n+            writeIndex = currentState.metadata().index(firstBackingIndexName);\n         }\n-        IndexMetadata firstBackingIndex = currentState.metadata().index(firstBackingIndexName);\n-        assert firstBackingIndex != null;\n-        assert firstBackingIndex.mapping() != null : \"no mapping found for backing index [\" + firstBackingIndexName + \"]\";\n+        assert writeIndex != null;\n+        assert writeIndex.mapping() != null : \"no mapping found for backing index [\" + writeIndex.getIndex().getName() + \"]\";\n \n         String fieldName = template.getDataStreamTemplate().getTimestampField();\n         DataStream.TimestampField timestampField = new DataStream.TimestampField(fieldName);\n-        DataStream newDataStream =\n-            new DataStream(request.name, timestampField, List.of(firstBackingIndex.getIndex()), 1L,\n-                template.metadata() != null ? Map.copyOf(template.metadata()) : null);\n+        List<Index> dsBackingIndices = backingIndices.stream().map(IndexMetadata::getIndex).collect(Collectors.toList());\n+        dsBackingIndices.add(writeIndex.getIndex());\n+        DataStream newDataStream = new DataStream(dataStreamName, timestampField, dsBackingIndices, 1L,\n+                                                  template.metadata() != null ? Map.copyOf(template.metadata()) : null);\n         Metadata.Builder builder = Metadata.builder(currentState.metadata()).put(newDataStream);\n-        logger.info(\"adding data stream [{}]\", request.name);\n+        logger.info(\"adding data stream [{}]\", dataStreamName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "768b163afa438ec8796fe7f3b8c5650f3f1db2a9"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjQ2MDk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/data-streams/src/test/java/org/elasticsearch/xpack/datastreams/mapper/DataStreamTimestampFieldMapperTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDoyNzo1MlrOHpja1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDo0NTo0N1rOHpkF5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzMzk3NQ==", "bodyText": "I think we need to adjust test and the data stream timestamp field mapper.\nUpdating from false to true is allowed, but updating from true to false is disallowed.\n`", "url": "https://github.com/elastic/elasticsearch/pull/61525#discussion_r513333975", "createdAt": "2020-10-28T10:27:52Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/data-streams/src/test/java/org/elasticsearch/xpack/datastreams/mapper/DataStreamTimestampFieldMapperTests.java", "diffHunk": "@@ -277,17 +277,17 @@ public void testValidateNotDisallowedAttribute() throws IOException {\n         assertThat(e.getMessage(), equalTo(\"data stream timestamp field [@timestamp] has disallowed attributes: [store]\"));\n     }\n \n-    public void testCannotUpdateTimestampField() throws IOException {\n+    public void testCanUpdateTimestampField() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "768b163afa438ec8796fe7f3b8c5650f3f1db2a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM0NDk5Nw==", "bodyText": "This validation can be added by invoking setMergeValidator(...)method when building enabled parameter in DataStreamTimestampFieldMapper line 78.", "url": "https://github.com/elastic/elasticsearch/pull/61525#discussion_r513344997", "createdAt": "2020-10-28T10:45:47Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/data-streams/src/test/java/org/elasticsearch/xpack/datastreams/mapper/DataStreamTimestampFieldMapperTests.java", "diffHunk": "@@ -277,17 +277,17 @@ public void testValidateNotDisallowedAttribute() throws IOException {\n         assertThat(e.getMessage(), equalTo(\"data stream timestamp field [@timestamp] has disallowed attributes: [store]\"));\n     }\n \n-    public void testCannotUpdateTimestampField() throws IOException {\n+    public void testCanUpdateTimestampField() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzMzk3NQ=="}, "originalCommit": {"oid": "768b163afa438ec8796fe7f3b8c5650f3f1db2a9"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 828, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}