{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1OTY2MjQ1", "number": 65386, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjowMzowMVrOE9cysQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo1MzowNVrOE-6qYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODcwMzIxOnYy", "diffSide": "RIGHT", "path": "docs/reference/search/search-your-data/retrieve-selected-fields.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjowMzowMVrOH6JTKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjowMzowMVrOH6JTKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczMTgxNg==", "bodyText": "Small typo, fieldS -> fields", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530731816", "createdAt": "2020-11-26T02:03:01Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/search/search-your-data/retrieve-selected-fields.asciidoc", "diffHunk": "@@ -167,7 +167,92 @@ no dedicated array type, and any field could contain multiple values. The\n a specific order. See the mapping documentation on <<array, arrays>> for more\n background.\n \n+[discrete]\n+[[retrieve-unmapped-fields]]\n+==== Retrieving unmapped fields\n+\n+By default, the `fields` parameter returns only values of mapped fields. However,\n+Elasticsearch allows storing fields in `_source` that are unmapped, for example by\n+setting <<dynamic-field-mapping,Dynamic field mapping>> to `false` or by using an\n+object field with `enabled: false`, thereby disabling parsing and indexing of its content.\n+\n+Fields in such an object can be retrieved from `_source` using the `include_unmapped` option\n+in the `fieldS` section:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODcwNTkyOnYy", "diffSide": "RIGHT", "path": "docs/reference/search/search-your-data/retrieve-selected-fields.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjowNDozMFrOH6JUwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjowNDozMFrOH6JUwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczMjIyNg==", "bodyText": "'true' has a missing backtick", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530732226", "createdAt": "2020-11-26T02:04:30Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/search/search-your-data/retrieve-selected-fields.asciidoc", "diffHunk": "@@ -167,7 +167,92 @@ no dedicated array type, and any field could contain multiple values. The\n a specific order. See the mapping documentation on <<array, arrays>> for more\n background.\n \n+[discrete]\n+[[retrieve-unmapped-fields]]\n+==== Retrieving unmapped fields\n+\n+By default, the `fields` parameter returns only values of mapped fields. However,\n+Elasticsearch allows storing fields in `_source` that are unmapped, for example by\n+setting <<dynamic-field-mapping,Dynamic field mapping>> to `false` or by using an\n+object field with `enabled: false`, thereby disabling parsing and indexing of its content.\n+\n+Fields in such an object can be retrieved from `_source` using the `include_unmapped` option\n+in the `fieldS` section:\n+\n+[source,console]\n+----\n+PUT my-index-000001\n+{\n+  \"mappings\": {\n+    \"enabled\": false <1>\n+  }\n+}\n+\n+PUT my-index-000001/_doc/1?refresh=true\n+{\n+  \"user_id\": \"kimchy\",\n+  \"session_data\": {\n+     \"object\": {\n+       \"some_field\": \"some_value\"\n+     }\n+   }\n+}\n+\n+POST my-index-000001/_search\n+{\n+  \"fields\": [\n+    \"user_id\",\n+    {\n+      \"field\": \"session_data.object.*\",\n+      \"include_unmapped\" : true <2>\n+    }\n+  ],\n+  \"_source\": false\n+}\n+----\n+\n+<1> Disable all mappings.\n+<2> Include unmapped fields matching this field pattern.\n \n+The response will contain fields results under the  `session_data.object.*` path even if the\n+fields are unmapped, but will not contain `user_id` since it is unmapped but the `include_unmapped`\n+flag hasn't been set to `true for that field pattern.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODczMTM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldAndFormat.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjoxODozM1rOH6JjLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyODo0NVrOH8Uh9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNTkxOQ==", "bodyText": "Maybe we could stick to a nullable Boolean, for consistency with the format parameter and what we do elsewhere in the search builder code?\nIn mapping code I've also seen us use the Explicit class for this purpose (distinguishing between a value that was set explicitly vs. default).", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530735919", "createdAt": "2020-11-26T02:18:33Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldAndFormat.java", "diffHunk": "@@ -79,28 +86,44 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n     /** The format of the field, or {@code null} if defaults should be used. */\n     public final String format;\n \n-    /** Sole constructor. */\n+    /** Whether to include unmapped fields or not. */\n+    public final Optional<Boolean> includeUnmapped;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4ODM0MA==", "bodyText": "Sure, I'll look into Explicit, I personally really dislike using null as carrying semantic meaning like unset, which is my main motivation for Optional here.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531088340", "createdAt": "2020-11-26T15:05:28Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldAndFormat.java", "diffHunk": "@@ -79,28 +86,44 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n     /** The format of the field, or {@code null} if defaults should be used. */\n     public final String format;\n \n-    /** Sole constructor. */\n+    /** Whether to include unmapped fields or not. */\n+    public final Optional<Boolean> includeUnmapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNTkxOQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5MDAyNA==", "bodyText": "After trying Explicit I went with the null option here although I don't like it, but it seems the least complex here.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531190024", "createdAt": "2020-11-26T18:55:01Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldAndFormat.java", "diffHunk": "@@ -79,28 +86,44 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n     /** The format of the field, or {@code null} if defaults should be used. */\n     public final String format;\n \n-    /** Sole constructor. */\n+    /** Whether to include unmapped fields or not. */\n+    public final Optional<Boolean> includeUnmapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNTkxOQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMjk4MQ==", "bodyText": "I do agree it's not ideal, but great that it's consistent and keeps the constructors simple!", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533012981", "createdAt": "2020-12-01T01:28:45Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldAndFormat.java", "diffHunk": "@@ -79,28 +86,44 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n     /** The format of the field, or {@code null} if defaults should be used. */\n     public final String format;\n \n-    /** Sole constructor. */\n+    /** Whether to include unmapped fields or not. */\n+    public final Optional<Boolean> includeUnmapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNTkxOQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODczOTgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjoyMzozM1rOH6JoGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NTo1NFrOH6g2cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNzE3OQ==", "bodyText": "Looks like includeUnmapped is unused here. Also, the number of addFetchField methods is adding up, some builders like TopHitsAggregationBuilder have three. Maybe we should switch to passing FieldAndFormat directly as an argument? We could still retain a single convenience method like addFetchField(String name).", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530737179", "createdAt": "2020-11-26T02:23:33Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java", "diffHunk": "@@ -319,9 +319,10 @@ public SearchRequestBuilder addFetchField(String name) {\n      *\n      * @param name The field to load\n      * @param format an optional format string used when formatting values, for example a date format.\n+     * @param includeUnmapped whether this field pattern should also include unmapped fields\n      */\n-    public SearchRequestBuilder addFetchField(String name, String format) {\n-        sourceBuilder().fetchField(name, format);\n+    public SearchRequestBuilder addFetchField(String name, String format, boolean includeUnmapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNzY4MA==", "bodyText": "sure. Will try to reduce it to a convenience method and one using FieldsAndFormat", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531117680", "createdAt": "2020-11-26T15:55:54Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java", "diffHunk": "@@ -319,9 +319,10 @@ public SearchRequestBuilder addFetchField(String name) {\n      *\n      * @param name The field to load\n      * @param format an optional format string used when formatting values, for example a date format.\n+     * @param includeUnmapped whether this field pattern should also include unmapped fields\n      */\n-    public SearchRequestBuilder addFetchField(String name, String format) {\n-        sourceBuilder().fetchField(name, format);\n+    public SearchRequestBuilder addFetchField(String name, String format, boolean includeUnmapped) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNzE3OQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODc3NDI4OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/flattened/10_basic.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjo0MzoxN1rOH6J8Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjo0MzoxN1rOH6J8Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0MjI5OA==", "bodyText": "Could we make this a separate check, to keep the original too? Flattened field behavior is tricky and more test coverage is helpful!", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530742298", "createdAt": "2020-11-26T02:43:17Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/flattened/10_basic.yml", "diffHunk": "@@ -150,9 +150,10 @@\n       search:\n         index: test\n         body:\n-          fields: [\"flat*\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODgwMzEyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzowMDoyM1rOH6KM6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTowNjo0NlrOH6fGjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0NjYwMw==", "bodyText": "Happy to discuss, my current thinking is that we should omit null values to be consistent with the case where include_unmapped: false.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530746603", "createdAt": "2020-11-26T03:00:23Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4OTAzOQ==", "bodyText": "Sorry, this was a left over, we already discussed this on the WIP. Will remove the TODO.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531089039", "createdAt": "2020-11-26T15:06:46Z", "author": {"login": "cbuescher"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0NjYwMw=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODgxMzE4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzowNjoyMlrOH6KSnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzowNTo0N1rOH6i-Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0ODA2MQ==", "bodyText": "Small comment, could this be combined with one of the previous test cases? I'm not sure it tests a new situation.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530748061", "createdAt": "2020-11-26T03:06:22Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here\n+        fields = fetchFields(mapperService, source, \"null*\", true);\n+        assertThat(fields.size(), equalTo(0));\n+        // assertThat(fields.get(\"null_value\").getValue(), equalTo(null));\n+    }\n+\n+    public void testSimpleUnmappedArray() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .array(\"unmapped_field\", \"foo\", \"bar\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_field\"));\n+\n+        for (DocumentField field : fields.values()) {\n+            assertThat(field.getValues().size(), equalTo(2));\n+            assertThat(field.getValues().get(0), equalTo(\"foo\"));\n+            assertThat(field.getValues().get(1), equalTo(\"bar\"));\n+        }\n+    }\n+\n+    public void testSimpleUnmappedArrayWithObjects() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f2\", \"b\")\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.get(\"unmapped_field.f1\").getValue(), equalTo(\"a\"));\n+        assertThat(fields.get(\"unmapped_field.f2\").getValue(), equalTo(\"b\"));\n+\n+        source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        DocumentField field = fields.get(\"unmapped_field.f1\");\n+        assertThat(field.getValues().size(), equalTo(2));\n+        assertThat(field.getValues().get(0), equalTo(\"a\"));\n+        assertThat(field.getValues().get(1), equalTo(\"b\"));\n+\n+    }\n+\n+    public void testUnmappedFieldsInsideObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"dynamic\", \"false\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"f1\").field(\"type\", \"keyword\").endObject()\n+                    .endObject()\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"obj.f1\", \"value1\")\n+            .field(\"obj.f2\", \"unmapped_value_f2\")\n+            .field(\"obj.innerObj.f3\", \"unmapped_value_f3\")\n+            .field(\"obj.innerObj.f4\", \"unmapped_value_f4\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+\n+        // without unmapped fields this should only return \"obj.f1\"\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(4));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\", \"obj.f2\", \"obj.innerObj.f3\", \"obj.innerObj.f4\"));\n+    }\n+\n+    public void testUnmappedFieldsInsideDisabledObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"enabled\", \"false\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"obj\")\n+            .value(\"string_value\")\n+            .startObject()\n+                .field(\"a\", \"b\")\n+            .endObject()\n+            .startArray()\n+                .value(1).value(2).value(3)\n+            .endArray()\n+            .endArray()\n+        .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+        // without unmapped fields this should return nothing\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj\", \"obj.a\"));\n+\n+        List<Object> obj = fields.get(\"obj\").getValues();\n+        assertEquals(2, obj.size());\n+        assertThat(obj.get(0), instanceOf(String.class));\n+        assertEquals(\"string_value\", obj.get(0).toString());\n+        assertThat(obj.get(1), instanceOf(List.class));\n+        assertEquals(3, ((List<?>) obj.get(1)).size());\n+        assertEquals(\"[1, 2, 3]\", obj.get(1).toString());\n+\n+        List<Object> innerObj = fields.get(\"obj.a\").getValues();\n+        assertEquals(1, innerObj.size());\n+        assertEquals(\"b\", fields.get(\"obj.a\").getValue());\n+    }\n+\n+    /**\n+     * If a mapped field for some reason contains a \"_source\" value that is not returned by the\n+     * mapped retrieval mechanism (e.g. because its malformed), we don't want to fetch it from _source.\n+     */\n+    public void testMappedFieldNotOverwritten() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"f1\")\n+                    .field(\"type\", \"integer\")\n+                    .field(\"ignore_malformed\", \"true\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n \n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"f1\", \"malformed\")\n+            .endObject();\n+\n+        // this should not return a field bc. f1 is in the ignored fields\n+        Map<String, DocumentField> fields = fetchFields(\n+            mapperService,\n+            source,\n+            List.of(new FieldAndFormat(\"*\", null, Optional.of(true))),\n+            Set.of(\"f1\")\n+        );\n+        assertThat(fields.size(), equalTo(0));\n+\n+        // and this should neither\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"*\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"f1\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+    }\n+\n+    public void testUnmappedFieldsWildcard() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1MjM5NQ==", "bodyText": "The previous test case 'testMappedFieldNotOverwritten' tests the special case where we don't want to return a mapped field that is not present in the document but in _source (e.g. because of ignore_malformed). Here I wanted to test various field pattern behaviours for object structures in an isolated test. So I think its not ideal to merge them.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531152395", "createdAt": "2020-11-26T17:05:47Z", "author": {"login": "cbuescher"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here\n+        fields = fetchFields(mapperService, source, \"null*\", true);\n+        assertThat(fields.size(), equalTo(0));\n+        // assertThat(fields.get(\"null_value\").getValue(), equalTo(null));\n+    }\n+\n+    public void testSimpleUnmappedArray() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .array(\"unmapped_field\", \"foo\", \"bar\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_field\"));\n+\n+        for (DocumentField field : fields.values()) {\n+            assertThat(field.getValues().size(), equalTo(2));\n+            assertThat(field.getValues().get(0), equalTo(\"foo\"));\n+            assertThat(field.getValues().get(1), equalTo(\"bar\"));\n+        }\n+    }\n+\n+    public void testSimpleUnmappedArrayWithObjects() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f2\", \"b\")\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.get(\"unmapped_field.f1\").getValue(), equalTo(\"a\"));\n+        assertThat(fields.get(\"unmapped_field.f2\").getValue(), equalTo(\"b\"));\n+\n+        source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        DocumentField field = fields.get(\"unmapped_field.f1\");\n+        assertThat(field.getValues().size(), equalTo(2));\n+        assertThat(field.getValues().get(0), equalTo(\"a\"));\n+        assertThat(field.getValues().get(1), equalTo(\"b\"));\n+\n+    }\n+\n+    public void testUnmappedFieldsInsideObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"dynamic\", \"false\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"f1\").field(\"type\", \"keyword\").endObject()\n+                    .endObject()\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"obj.f1\", \"value1\")\n+            .field(\"obj.f2\", \"unmapped_value_f2\")\n+            .field(\"obj.innerObj.f3\", \"unmapped_value_f3\")\n+            .field(\"obj.innerObj.f4\", \"unmapped_value_f4\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+\n+        // without unmapped fields this should only return \"obj.f1\"\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(4));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\", \"obj.f2\", \"obj.innerObj.f3\", \"obj.innerObj.f4\"));\n+    }\n+\n+    public void testUnmappedFieldsInsideDisabledObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"enabled\", \"false\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"obj\")\n+            .value(\"string_value\")\n+            .startObject()\n+                .field(\"a\", \"b\")\n+            .endObject()\n+            .startArray()\n+                .value(1).value(2).value(3)\n+            .endArray()\n+            .endArray()\n+        .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+        // without unmapped fields this should return nothing\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj\", \"obj.a\"));\n+\n+        List<Object> obj = fields.get(\"obj\").getValues();\n+        assertEquals(2, obj.size());\n+        assertThat(obj.get(0), instanceOf(String.class));\n+        assertEquals(\"string_value\", obj.get(0).toString());\n+        assertThat(obj.get(1), instanceOf(List.class));\n+        assertEquals(3, ((List<?>) obj.get(1)).size());\n+        assertEquals(\"[1, 2, 3]\", obj.get(1).toString());\n+\n+        List<Object> innerObj = fields.get(\"obj.a\").getValues();\n+        assertEquals(1, innerObj.size());\n+        assertEquals(\"b\", fields.get(\"obj.a\").getValue());\n+    }\n+\n+    /**\n+     * If a mapped field for some reason contains a \"_source\" value that is not returned by the\n+     * mapped retrieval mechanism (e.g. because its malformed), we don't want to fetch it from _source.\n+     */\n+    public void testMappedFieldNotOverwritten() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"f1\")\n+                    .field(\"type\", \"integer\")\n+                    .field(\"ignore_malformed\", \"true\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n \n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"f1\", \"malformed\")\n+            .endObject();\n+\n+        // this should not return a field bc. f1 is in the ignored fields\n+        Map<String, DocumentField> fields = fetchFields(\n+            mapperService,\n+            source,\n+            List.of(new FieldAndFormat(\"*\", null, Optional.of(true))),\n+            Set.of(\"f1\")\n+        );\n+        assertThat(fields.size(), equalTo(0));\n+\n+        // and this should neither\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"*\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"f1\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+    }\n+\n+    public void testUnmappedFieldsWildcard() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0ODA2MQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODg0Mzk1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzoyNToxM1rOH6KkUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzoyNToxM1rOH6KkUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MjU5Mg==", "bodyText": "Maybe we should define the default of 'false' in a constant to make it easier to find?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530752592", "createdAt": "2020-11-26T03:25:13Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -45,9 +49,16 @@ public static FieldFetcher create(QueryShardContext context,\n                                       Collection<FieldAndFormat> fieldAndFormats) {\n \n         List<FieldContext> fieldContexts = new ArrayList<>();\n+        List<String> unmappedFetchPattern = new ArrayList<>();\n+        Set<String> mappedToExclude = new HashSet<>();\n+        int i = 0;\n \n         for (FieldAndFormat fieldAndFormat : fieldAndFormats) {\n             String fieldPattern = fieldAndFormat.field;\n+            if (fieldAndFormat.includeUnmapped.orElse(false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODg0NTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzoyNTo0OVrOH6Kk-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzoyNTo0OVrOH6Kk-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1Mjc2Mw==", "bodyText": "I think i is unused.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530752763", "createdAt": "2020-11-26T03:25:49Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -45,9 +49,16 @@ public static FieldFetcher create(QueryShardContext context,\n                                       Collection<FieldAndFormat> fieldAndFormats) {\n \n         List<FieldContext> fieldContexts = new ArrayList<>();\n+        List<String> unmappedFetchPattern = new ArrayList<>();\n+        Set<String> mappedToExclude = new HashSet<>();\n+        int i = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODg1MjI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzozMDozMFrOH6KpGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzozMDozMFrOH6KpGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MzgxNg==", "bodyText": "To me it'd be clearer to completely skip collectUnmapped if we don't need to handle unmapped fields. We expect this to be the common case, and it would make it clear we won't do extra work.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530753816", "createdAt": "2020-11-26T03:30:30Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODg1NTM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzozMjoyMlrOH6Kq1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToyMzozMFrOH88QOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA==", "bodyText": "For consistency with the other cases, should this add to documentFields instead of returning a new list?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530754260", "createdAt": "2020-11-26T03:32:22Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2MzY3Ng==", "bodyText": "It took me a while to see how this could be an issue but I think you mean cases like:\n{\n\t\"user\": [{\n\t\t\"name\": \"eve\",\n\t\t\"scores\": [1, 2, 3]\n\t}, {\n\t\t\"name\": \"adam\",\n\t\t\"scores\": [4, 5, 6]\n\t}]\n}\n\nI see the fields API currently returns \"user.scores\": [ 1, 2, 3, 4, 5, 6] here at the moment, so I will add a test to make the unmapped behaviour doing the same. Or did you think about a different case?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531163676", "createdAt": "2020-11-26T17:32:56Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3MDk0MA==", "bodyText": "Interesting variation that cannot happen with mapped fields, but is accepted e.g. with \"dynamic\": false, since we have no mapping and type checks then:\n{\n\t\"user\": [{\n\t\t\"name\": \"eve\",\n\t\t\"scores\": [1, 2, 3]\n\t}, {\n\t\t\"name\": \"adam\",\n\t\t\"scores\": \"foo\"\n\t}]\n}\n\nI think this should return the flattened \"user.scores\": [ 1, 2, \"foo\"] then, but maybe you disagree on that?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531170940", "createdAt": "2020-11-26T17:52:59Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxNzY0Ng==", "bodyText": "Sorry for the confusion -- I didn't spot a behavioral bug, I just found the API choice surprising. The collectUnmappedList method returns a list, but collectUnmapped adds directly to the document fields map. I was wondering if there needs to be a difference?\nAnd your understanding looks right, thanks for adding more tests to confirm those cases.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533017646", "createdAt": "2020-12-01T01:43:15Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5MDM1Ng==", "bodyText": "It looks like this comment is still open. Concretely, could we avoid returning a list from collectUnmappedList and just have it add to documentFields? This would match the signature for collectUnmapped.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533590356", "createdAt": "2020-12-01T17:25:53Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0MjczNg==", "bodyText": "Thanks, I understand now. I investigated this and unfortunately it is not as straight-forward as it seems, at least I didn't find an easy way after a bit of searching. I now remember the reason I added the return type was another case I have in the tests. Consider this:\nMapping:\n{\n\t\"_doc\": {\n\t\t\"properties\": {\n\t\t\t\"obj\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"enabled\": \"false\"\n\t\t\t}\n\t\t}\n\t}\n}\n\nDoc:\n{\n\t\"obj\": [\"string_value\", {\n\t\t\t\"a\": \"b\"\n\t\t},\n\t\t[1, 2, 3]\n\t]\n}\n\nI would expect the fields output for obj to be [ \"string_value, [1, 2, 3]] (note the list inside the list. Do do this I need to be able to add to the list collected when on the \"obj\" level (see  https://github.com/elastic/elasticsearch/pull/65386/files#diff-3c196c8a285307ef760ada7bc5a1df27dce1f4e7160bf75d028833793d171a9aR185).\nAt the same time the case above (adding to the same key from two different nested objects should return a single concatenated list) should work. I wasn't able to reconcile both cases without the return type so far.\nIf you agree with the above expectations on list-inside-list maybe we can leave this investigation for a follow up as well since its an internal anyway?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533642736", "createdAt": "2020-12-01T18:48:22Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1MTk2Ng==", "bodyText": "Got it, that is indeed a tricky example. I would actually expect that lists of lists get flattened, as we do for mapped fields. For example, we accept and index documents like this (although maybe we shouldn't):\n{ \"field\": [[1, 2, 3]] }\n\nThe fields option will descend into the arrays and return { \"field\": [1, 2, 3] }. So maybe we can just do the same in your example and return { \"field\": [\"string_value\", 1, 2, 3] }.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533651966", "createdAt": "2020-12-01T19:03:05Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MDk5Ng==", "bodyText": "Got it, with those expectations I think I can alter the code and test to get around without the return type. I'm not particularly interested in the expected behaviour I mentioned earlier as long as you think flattening is okay here, and since that seems to be the behaviour for mapped types as well I think its okay.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533660996", "createdAt": "2020-12-01T19:18:59Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MzgwMQ==", "bodyText": "See latest commit and let me know if you are okay with this, otherwise I'd merge and backport to 7.x once CI is green", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533663801", "createdAt": "2020-12-01T19:23:30Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODg3MDg3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMzo0MjoxOFrOH6Kzuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODowMDoyMlrOH6kQNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NjUzOQ==", "bodyText": "I think we also need to check that the current path isn't part of mappedToExclude, otherwise we could overwrite mapped fields with these values.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530756539", "createdAt": "2020-11-26T03:42:18Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);\n+                if (list.isEmpty() == false) {\n+                    documentFields.put(currentPath, new DocumentField(currentPath, list));\n+                }\n+            } else {\n+                // we have a leaf value\n+                if (this.unmappedFetchAutomaton.isAccept(currentState) && this.mappedToExclude.contains(currentPath) == false) {\n+                    if (value != null) {\n+                        DocumentField currentEntry = documentFields.get(currentPath);\n+                        if (currentEntry == null) {\n+                            List<Object> list = new ArrayList<>();\n+                            list.add(value);\n+                            documentFields.put(currentPath, new DocumentField(currentPath, list));\n+                        } else {\n+                            currentEntry.getValues().add(value);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private List<Object> collectUnmappedList(\n+        Map<String, DocumentField> documentFields,\n+        Iterable<?> iterable,\n+        String parentPath,\n+        int lastState\n+    ) {\n+        List<Object> list = new ArrayList<>();\n+        for (Object value : iterable) {\n+            if (value instanceof Map) {\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    parentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", lastState)\n+                );\n+            } else if (value instanceof List) {\n+                // weird case, but can happen for objects with \"enabled\" : \"false\"\n+                list.add(collectUnmappedList(documentFields, (List<?>) value, parentPath, lastState));\n+            } else if (this.unmappedFetchAutomaton.isAccept(lastState)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3MzQzMA==", "bodyText": "Nice catch, yet another weird edge case. Adding to tests.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531173430", "createdAt": "2020-11-26T18:00:22Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);\n+                if (list.isEmpty() == false) {\n+                    documentFields.put(currentPath, new DocumentField(currentPath, list));\n+                }\n+            } else {\n+                // we have a leaf value\n+                if (this.unmappedFetchAutomaton.isAccept(currentState) && this.mappedToExclude.contains(currentPath) == false) {\n+                    if (value != null) {\n+                        DocumentField currentEntry = documentFields.get(currentPath);\n+                        if (currentEntry == null) {\n+                            List<Object> list = new ArrayList<>();\n+                            list.add(value);\n+                            documentFields.put(currentPath, new DocumentField(currentPath, list));\n+                        } else {\n+                            currentEntry.getValues().add(value);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private List<Object> collectUnmappedList(\n+        Map<String, DocumentField> documentFields,\n+        Iterable<?> iterable,\n+        String parentPath,\n+        int lastState\n+    ) {\n+        List<Object> list = new ArrayList<>();\n+        for (Object value : iterable) {\n+            if (value instanceof Map) {\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    parentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", lastState)\n+                );\n+            } else if (value instanceof List) {\n+                // weird case, but can happen for objects with \"enabled\" : \"false\"\n+                list.add(collectUnmappedList(documentFields, (List<?>) value, parentPath, lastState));\n+            } else if (this.unmappedFetchAutomaton.isAccept(lastState)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NjUzOQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODkwMTcxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNDowMjo0MlrOH6LFrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODo0MDo1NVrOH6lA0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MTEzNQ==", "bodyText": "Small comment: there's getting to be a lot of convenience methods, maybe we could prefer just constructing and passing in FieldAndFormat?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530761135", "createdAt": "2020-11-26T04:02:42Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here\n+        fields = fetchFields(mapperService, source, \"null*\", true);\n+        assertThat(fields.size(), equalTo(0));\n+        // assertThat(fields.get(\"null_value\").getValue(), equalTo(null));\n+    }\n+\n+    public void testSimpleUnmappedArray() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .array(\"unmapped_field\", \"foo\", \"bar\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_field\"));\n+\n+        for (DocumentField field : fields.values()) {\n+            assertThat(field.getValues().size(), equalTo(2));\n+            assertThat(field.getValues().get(0), equalTo(\"foo\"));\n+            assertThat(field.getValues().get(1), equalTo(\"bar\"));\n+        }\n+    }\n+\n+    public void testSimpleUnmappedArrayWithObjects() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f2\", \"b\")\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.get(\"unmapped_field.f1\").getValue(), equalTo(\"a\"));\n+        assertThat(fields.get(\"unmapped_field.f2\").getValue(), equalTo(\"b\"));\n+\n+        source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        DocumentField field = fields.get(\"unmapped_field.f1\");\n+        assertThat(field.getValues().size(), equalTo(2));\n+        assertThat(field.getValues().get(0), equalTo(\"a\"));\n+        assertThat(field.getValues().get(1), equalTo(\"b\"));\n+\n+    }\n+\n+    public void testUnmappedFieldsInsideObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"dynamic\", \"false\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"f1\").field(\"type\", \"keyword\").endObject()\n+                    .endObject()\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"obj.f1\", \"value1\")\n+            .field(\"obj.f2\", \"unmapped_value_f2\")\n+            .field(\"obj.innerObj.f3\", \"unmapped_value_f3\")\n+            .field(\"obj.innerObj.f4\", \"unmapped_value_f4\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+\n+        // without unmapped fields this should only return \"obj.f1\"\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(4));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\", \"obj.f2\", \"obj.innerObj.f3\", \"obj.innerObj.f4\"));\n+    }\n+\n+    public void testUnmappedFieldsInsideDisabledObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"enabled\", \"false\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"obj\")\n+            .value(\"string_value\")\n+            .startObject()\n+                .field(\"a\", \"b\")\n+            .endObject()\n+            .startArray()\n+                .value(1).value(2).value(3)\n+            .endArray()\n+            .endArray()\n+        .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+        // without unmapped fields this should return nothing\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj\", \"obj.a\"));\n+\n+        List<Object> obj = fields.get(\"obj\").getValues();\n+        assertEquals(2, obj.size());\n+        assertThat(obj.get(0), instanceOf(String.class));\n+        assertEquals(\"string_value\", obj.get(0).toString());\n+        assertThat(obj.get(1), instanceOf(List.class));\n+        assertEquals(3, ((List<?>) obj.get(1)).size());\n+        assertEquals(\"[1, 2, 3]\", obj.get(1).toString());\n+\n+        List<Object> innerObj = fields.get(\"obj.a\").getValues();\n+        assertEquals(1, innerObj.size());\n+        assertEquals(\"b\", fields.get(\"obj.a\").getValue());\n+    }\n+\n+    /**\n+     * If a mapped field for some reason contains a \"_source\" value that is not returned by the\n+     * mapped retrieval mechanism (e.g. because its malformed), we don't want to fetch it from _source.\n+     */\n+    public void testMappedFieldNotOverwritten() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"f1\")\n+                    .field(\"type\", \"integer\")\n+                    .field(\"ignore_malformed\", \"true\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n \n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"f1\", \"malformed\")\n+            .endObject();\n+\n+        // this should not return a field bc. f1 is in the ignored fields\n+        Map<String, DocumentField> fields = fetchFields(\n+            mapperService,\n+            source,\n+            List.of(new FieldAndFormat(\"*\", null, Optional.of(true))),\n+            Set.of(\"f1\")\n+        );\n+        assertThat(fields.size(), equalTo(0));\n+\n+        // and this should neither\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"*\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"f1\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+    }\n+\n+    public void testUnmappedFieldsWildcard() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"unmapped_object\")\n+                .field(\"a\", \"foo\")\n+                .field(\"b\", \"bar\")\n+            .endObject()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_object\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmap*object\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_object.a\", \"unmapped_object.b\"));\n+\n+        assertThat(fields.get(\"unmapped_object.a\").getValue(), equalTo(\"foo\"));\n+        assertThat(fields.get(\"unmapped_object.b\").getValue(), equalTo(\"bar\"));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.a\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.get(\"unmapped_object.a\").getValue(), equalTo(\"foo\"));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.b\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.get(\"unmapped_object.b\").getValue(), equalTo(\"bar\"));\n+    }\n+\n+    private Map<String, DocumentField> fetchFields(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE4NTg3NA==", "bodyText": "Removed some", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531185874", "createdAt": "2020-11-26T18:40:55Z", "author": {"login": "cbuescher"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here\n+        fields = fetchFields(mapperService, source, \"null*\", true);\n+        assertThat(fields.size(), equalTo(0));\n+        // assertThat(fields.get(\"null_value\").getValue(), equalTo(null));\n+    }\n+\n+    public void testSimpleUnmappedArray() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .array(\"unmapped_field\", \"foo\", \"bar\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_field\"));\n+\n+        for (DocumentField field : fields.values()) {\n+            assertThat(field.getValues().size(), equalTo(2));\n+            assertThat(field.getValues().get(0), equalTo(\"foo\"));\n+            assertThat(field.getValues().get(1), equalTo(\"bar\"));\n+        }\n+    }\n+\n+    public void testSimpleUnmappedArrayWithObjects() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f2\", \"b\")\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.get(\"unmapped_field.f1\").getValue(), equalTo(\"a\"));\n+        assertThat(fields.get(\"unmapped_field.f2\").getValue(), equalTo(\"b\"));\n+\n+        source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        DocumentField field = fields.get(\"unmapped_field.f1\");\n+        assertThat(field.getValues().size(), equalTo(2));\n+        assertThat(field.getValues().get(0), equalTo(\"a\"));\n+        assertThat(field.getValues().get(1), equalTo(\"b\"));\n+\n+    }\n+\n+    public void testUnmappedFieldsInsideObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"dynamic\", \"false\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"f1\").field(\"type\", \"keyword\").endObject()\n+                    .endObject()\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"obj.f1\", \"value1\")\n+            .field(\"obj.f2\", \"unmapped_value_f2\")\n+            .field(\"obj.innerObj.f3\", \"unmapped_value_f3\")\n+            .field(\"obj.innerObj.f4\", \"unmapped_value_f4\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+\n+        // without unmapped fields this should only return \"obj.f1\"\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(4));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\", \"obj.f2\", \"obj.innerObj.f3\", \"obj.innerObj.f4\"));\n+    }\n+\n+    public void testUnmappedFieldsInsideDisabledObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"enabled\", \"false\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"obj\")\n+            .value(\"string_value\")\n+            .startObject()\n+                .field(\"a\", \"b\")\n+            .endObject()\n+            .startArray()\n+                .value(1).value(2).value(3)\n+            .endArray()\n+            .endArray()\n+        .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+        // without unmapped fields this should return nothing\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj\", \"obj.a\"));\n+\n+        List<Object> obj = fields.get(\"obj\").getValues();\n+        assertEquals(2, obj.size());\n+        assertThat(obj.get(0), instanceOf(String.class));\n+        assertEquals(\"string_value\", obj.get(0).toString());\n+        assertThat(obj.get(1), instanceOf(List.class));\n+        assertEquals(3, ((List<?>) obj.get(1)).size());\n+        assertEquals(\"[1, 2, 3]\", obj.get(1).toString());\n+\n+        List<Object> innerObj = fields.get(\"obj.a\").getValues();\n+        assertEquals(1, innerObj.size());\n+        assertEquals(\"b\", fields.get(\"obj.a\").getValue());\n+    }\n+\n+    /**\n+     * If a mapped field for some reason contains a \"_source\" value that is not returned by the\n+     * mapped retrieval mechanism (e.g. because its malformed), we don't want to fetch it from _source.\n+     */\n+    public void testMappedFieldNotOverwritten() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"f1\")\n+                    .field(\"type\", \"integer\")\n+                    .field(\"ignore_malformed\", \"true\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n \n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"f1\", \"malformed\")\n+            .endObject();\n+\n+        // this should not return a field bc. f1 is in the ignored fields\n+        Map<String, DocumentField> fields = fetchFields(\n+            mapperService,\n+            source,\n+            List.of(new FieldAndFormat(\"*\", null, Optional.of(true))),\n+            Set.of(\"f1\")\n+        );\n+        assertThat(fields.size(), equalTo(0));\n+\n+        // and this should neither\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"*\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"f1\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+    }\n+\n+    public void testUnmappedFieldsWildcard() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"unmapped_object\")\n+                .field(\"a\", \"foo\")\n+                .field(\"b\", \"bar\")\n+            .endObject()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_object\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmap*object\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_object.a\", \"unmapped_object.b\"));\n+\n+        assertThat(fields.get(\"unmapped_object.a\").getValue(), equalTo(\"foo\"));\n+        assertThat(fields.get(\"unmapped_object.b\").getValue(), equalTo(\"bar\"));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.a\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.get(\"unmapped_object.a\").getValue(), equalTo(\"foo\"));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.b\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.get(\"unmapped_object.b\").getValue(), equalTo(\"bar\"));\n+    }\n+\n+    private Map<String, DocumentField> fetchFields(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MTEzNQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODkwMTgwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNDowMjo0OVrOH6LFww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODo0MDo0M1rOH6lAqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MTE1NQ==", "bodyText": "Nice test coverage! Some other cases that'd be good to check:\n\nSource documents that have dots in field names (like unmapped_field.a: value).\nMixed dot and object notation. We recently found a bug in the 'fields' option related to this: #65499.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530761155", "createdAt": "2020-11-26T04:02:49Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE4NTgzMg==", "bodyText": "Adding tests here...", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r531185832", "createdAt": "2020-11-26T18:40:43Z", "author": {"login": "cbuescher"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MTE1NQ=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDA1NTc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo0MDoyOVrOH8Uw_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMTo1MFrOH8lzWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxNjgzMA==", "bodyText": "I just noticed -- maybe we could switch fieldContexts to a LinkedHashMap? Then we could consult its key set and avoid creating this new set mappedToExclude. I could tackle this in a follow-up though, to keep this PR small.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533016830", "createdAt": "2020-12-01T01:40:29Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -78,21 +78,24 @@ public static FieldFetcher create(QueryShardContext context,\n                 Regex.simpleMatchToAutomaton(unmappedFetchPattern.toArray(new String[unmappedFetchPattern.size()]))\n             );\n         }\n-        return new FieldFetcher(fieldContexts, unmappedFetchAutomaton, mappedToExclude);\n+        return new FieldFetcher(fieldContexts, unmappedFetchAutomaton, mappedToExclude, includeUnmapped);\n     }\n \n     private final List<FieldContext> fieldContexts;\n     private final CharacterRunAutomaton unmappedFetchAutomaton;\n     private final Set<String> mappedToExclude;\n+    private final boolean includeUnmapped;\n \n     private FieldFetcher(\n         List<FieldContext> fieldContexts,\n         CharacterRunAutomaton unmappedFetchAutomaton,\n-        Set<String> mappedToExclude\n+        Set<String> mappedToExclude,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NTk2Mw==", "bodyText": "Interesting idea, I took a quick look and wasn't sure if we have to consider edge cases where the current list might contain different elements with the same field key though. I agree we should probably do this as a follow up in the interest of getting the basics in this PR in first.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533295963", "createdAt": "2020-12-01T10:31:50Z", "author": {"login": "cbuescher"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -78,21 +78,24 @@ public static FieldFetcher create(QueryShardContext context,\n                 Regex.simpleMatchToAutomaton(unmappedFetchPattern.toArray(new String[unmappedFetchPattern.size()]))\n             );\n         }\n-        return new FieldFetcher(fieldContexts, unmappedFetchAutomaton, mappedToExclude);\n+        return new FieldFetcher(fieldContexts, unmappedFetchAutomaton, mappedToExclude, includeUnmapped);\n     }\n \n     private final List<FieldContext> fieldContexts;\n     private final CharacterRunAutomaton unmappedFetchAutomaton;\n     private final Set<String> mappedToExclude;\n+    private final boolean includeUnmapped;\n \n     private FieldFetcher(\n         List<FieldContext> fieldContexts,\n         CharacterRunAutomaton unmappedFetchAutomaton,\n-        Set<String> mappedToExclude\n+        Set<String> mappedToExclude,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxNjgzMA=="}, "originalCommit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDA4MjkwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo1MzowNVrOH8VAwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDo1ODo1OVrOH8nUag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDg2NA==", "bodyText": "Small comment, we don't actually guarantee the values come back in the original order. So maybe we should check through something like assertThat(field.getValues(), hasItems(...)).", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533020864", "createdAt": "2020-12-01T01:53:05Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -474,20 +482,40 @@ public void testSimpleUnmappedArrayWithObjects() throws IOException {\n             .startArray(\"unmapped_field\")\n                 .startObject()\n                     .field(\"f1\", \"a\")\n+                    .array(\"f2\", 1, 2)\n+                    .array(\"f3\", 1, 2)\n                 .endObject()\n                 .startObject()\n                     .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                    .array(\"f2\", 3, 4)\n+                    .array(\"f3\", \"foo\")\n                 .endObject()\n             .endArray()\n             .endObject();\n \n-        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        fields = fetchFields(mapperService, source, fieldAndFormatList(\"unmapped_field.f1\", null, true), null);\n         assertThat(fields.size(), equalTo(1));\n         DocumentField field = fields.get(\"unmapped_field.f1\");\n         assertThat(field.getValues().size(), equalTo(2));\n         assertThat(field.getValues().get(0), equalTo(\"a\"));\n         assertThat(field.getValues().get(1), equalTo(\"b\"));\n \n+        fields = fetchFields(mapperService, source, fieldAndFormatList(\"unmapped_field.f2\", null, true), null);\n+        assertThat(fields.size(), equalTo(1));\n+        field = fields.get(\"unmapped_field.f2\");\n+        assertThat(field.getValues().size(), equalTo(4));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyMDgxMA==", "bodyText": "changed that", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533320810", "createdAt": "2020-12-01T10:58:59Z", "author": {"login": "cbuescher"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -474,20 +482,40 @@ public void testSimpleUnmappedArrayWithObjects() throws IOException {\n             .startArray(\"unmapped_field\")\n                 .startObject()\n                     .field(\"f1\", \"a\")\n+                    .array(\"f2\", 1, 2)\n+                    .array(\"f3\", 1, 2)\n                 .endObject()\n                 .startObject()\n                     .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                    .array(\"f2\", 3, 4)\n+                    .array(\"f3\", \"foo\")\n                 .endObject()\n             .endArray()\n             .endObject();\n \n-        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        fields = fetchFields(mapperService, source, fieldAndFormatList(\"unmapped_field.f1\", null, true), null);\n         assertThat(fields.size(), equalTo(1));\n         DocumentField field = fields.get(\"unmapped_field.f1\");\n         assertThat(field.getValues().size(), equalTo(2));\n         assertThat(field.getValues().get(0), equalTo(\"a\"));\n         assertThat(field.getValues().get(1), equalTo(\"b\"));\n \n+        fields = fetchFields(mapperService, source, fieldAndFormatList(\"unmapped_field.f2\", null, true), null);\n+        assertThat(fields.size(), equalTo(1));\n+        field = fields.get(\"unmapped_field.f2\");\n+        assertThat(field.getValues().size(), equalTo(4));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDg2NA=="}, "originalCommit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "originalPosition": 140}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2015, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}