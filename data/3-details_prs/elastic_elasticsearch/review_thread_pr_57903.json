{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDM4MTU0", "number": 57903, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODowMTowNlrOEEZ58g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODowMTowNlrOEEZ58g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDU0MTk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificanceLookup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODowMTowNlrOGiAbXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo0NDoyNFrOGiIt6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMTc3NA==", "bodyText": "Is this javadoc correct?  Looks like it's operating on a long term below.", "url": "https://github.com/elastic/elasticsearch/pull/57903#discussion_r438311774", "createdAt": "2020-06-10T18:01:06Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificanceLookup.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.bucket.terms;\n+\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.PostingsEnum;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.index.TermsEnum;\n+import org.apache.lucene.search.BooleanClause.Occur;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.lucene.index.FilterableTermsEnum;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BytesRefHash;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.LongHash;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.aggregations.bucket.terms.heuristic.SignificanceHeuristic;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Looks up values used for {@link SignificanceHeuristic}s.\n+ */\n+class SignificanceLookup {\n+    /**\n+     * Lookup frequencies for {@link BytesRef} terms.\n+     */\n+    interface BackgroundFrequencyForBytes extends Releasable {\n+        long freq(BytesRef term) throws IOException;\n+    }\n+\n+    /**\n+     * Lookup frequencies for {@code long} terms.\n+     */\n+    interface BackgroundFrequencyForLong extends Releasable {\n+        long freq(long term) throws IOException;\n+    }\n+\n+    private final QueryShardContext context;\n+    private final ValuesSourceConfig config;\n+    private final Query backgroundFilter;\n+    private final int supersetNumDocs;\n+    private TermsEnum termsEnum;\n+\n+    SignificanceLookup(QueryShardContext context, ValuesSourceConfig config, QueryBuilder backgroundFilter) throws IOException {\n+        this.context = context;\n+        this.config = config;\n+        this.backgroundFilter = backgroundFilter == null ? null : backgroundFilter.toQuery(context);\n+        /*\n+         * We need to use a superset size that includes deleted docs or we\n+         * could end up blowing up with bad statistics that cause us to blow\n+         * up later on.\n+         */\n+        IndexSearcher searcher = context.searcher();\n+        supersetNumDocs = backgroundFilter == null ? searcher.getIndexReader().maxDoc() : searcher.count(this.backgroundFilter);\n+    }\n+\n+    /**\n+     * Get the number of docs in the superset.\n+     */\n+    long supersetSize() {\n+        return supersetNumDocs;\n+    }\n+\n+    /**\n+     * Get the background frequency of a {@link BytesRef} term.\n+     */\n+    BackgroundFrequencyForBytes bytesLookup(BigArrays bigArrays, boolean collectsFromSingleBucket) {\n+        if (collectsFromSingleBucket) {\n+            return new BackgroundFrequencyForBytes() {\n+                @Override\n+                public long freq(BytesRef term) throws IOException {\n+                    return getBackgroundFrequency(term);\n+                }\n+\n+                @Override\n+                public void close() {}\n+            };\n+        }\n+        return new BackgroundFrequencyForBytes() {\n+            private final BytesRefHash termToPosition = new BytesRefHash(1, bigArrays);\n+            private LongArray positionToFreq = bigArrays.newLongArray(1, false);\n+\n+            @Override\n+            public long freq(BytesRef term) throws IOException {\n+                long position = termToPosition.add(term);\n+                if (position < 0) {\n+                    return positionToFreq.get(-1 - position);\n+                }\n+                long freq = getBackgroundFrequency(term);\n+                positionToFreq = bigArrays.grow(positionToFreq, position + 1);\n+                positionToFreq.set(position, freq);\n+                return freq;\n+            }\n+\n+            @Override\n+            public void close() {\n+                Releasables.close(termToPosition, positionToFreq);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get the background frequency of a {@link BytesRef} term.\n+     */\n+    private long getBackgroundFrequency(BytesRef term) throws IOException {\n+        return getBackgroundFrequency(config.fieldContext().fieldType().termQuery(config.format().format(term).toString(), context));\n+    }\n+\n+    /**\n+     * Get the background frequency of a {@link BytesRef} term.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "785243901e27880ed238390f508299eafb7b4367"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0NzU5Mw==", "bodyText": "It wasn't! I fixed it.", "url": "https://github.com/elastic/elasticsearch/pull/57903#discussion_r438447593", "createdAt": "2020-06-10T22:44:24Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificanceLookup.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations.bucket.terms;\n+\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.PostingsEnum;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.index.TermsEnum;\n+import org.apache.lucene.search.BooleanClause.Occur;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.lease.Releasables;\n+import org.elasticsearch.common.lucene.index.FilterableTermsEnum;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.BytesRefHash;\n+import org.elasticsearch.common.util.LongArray;\n+import org.elasticsearch.common.util.LongHash;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.aggregations.bucket.terms.heuristic.SignificanceHeuristic;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Looks up values used for {@link SignificanceHeuristic}s.\n+ */\n+class SignificanceLookup {\n+    /**\n+     * Lookup frequencies for {@link BytesRef} terms.\n+     */\n+    interface BackgroundFrequencyForBytes extends Releasable {\n+        long freq(BytesRef term) throws IOException;\n+    }\n+\n+    /**\n+     * Lookup frequencies for {@code long} terms.\n+     */\n+    interface BackgroundFrequencyForLong extends Releasable {\n+        long freq(long term) throws IOException;\n+    }\n+\n+    private final QueryShardContext context;\n+    private final ValuesSourceConfig config;\n+    private final Query backgroundFilter;\n+    private final int supersetNumDocs;\n+    private TermsEnum termsEnum;\n+\n+    SignificanceLookup(QueryShardContext context, ValuesSourceConfig config, QueryBuilder backgroundFilter) throws IOException {\n+        this.context = context;\n+        this.config = config;\n+        this.backgroundFilter = backgroundFilter == null ? null : backgroundFilter.toQuery(context);\n+        /*\n+         * We need to use a superset size that includes deleted docs or we\n+         * could end up blowing up with bad statistics that cause us to blow\n+         * up later on.\n+         */\n+        IndexSearcher searcher = context.searcher();\n+        supersetNumDocs = backgroundFilter == null ? searcher.getIndexReader().maxDoc() : searcher.count(this.backgroundFilter);\n+    }\n+\n+    /**\n+     * Get the number of docs in the superset.\n+     */\n+    long supersetSize() {\n+        return supersetNumDocs;\n+    }\n+\n+    /**\n+     * Get the background frequency of a {@link BytesRef} term.\n+     */\n+    BackgroundFrequencyForBytes bytesLookup(BigArrays bigArrays, boolean collectsFromSingleBucket) {\n+        if (collectsFromSingleBucket) {\n+            return new BackgroundFrequencyForBytes() {\n+                @Override\n+                public long freq(BytesRef term) throws IOException {\n+                    return getBackgroundFrequency(term);\n+                }\n+\n+                @Override\n+                public void close() {}\n+            };\n+        }\n+        return new BackgroundFrequencyForBytes() {\n+            private final BytesRefHash termToPosition = new BytesRefHash(1, bigArrays);\n+            private LongArray positionToFreq = bigArrays.newLongArray(1, false);\n+\n+            @Override\n+            public long freq(BytesRef term) throws IOException {\n+                long position = termToPosition.add(term);\n+                if (position < 0) {\n+                    return positionToFreq.get(-1 - position);\n+                }\n+                long freq = getBackgroundFrequency(term);\n+                positionToFreq = bigArrays.grow(positionToFreq, position + 1);\n+                positionToFreq.set(position, freq);\n+                return freq;\n+            }\n+\n+            @Override\n+            public void close() {\n+                Releasables.close(termToPosition, positionToFreq);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get the background frequency of a {@link BytesRef} term.\n+     */\n+    private long getBackgroundFrequency(BytesRef term) throws IOException {\n+        return getBackgroundFrequency(config.fieldContext().fieldType().termQuery(config.format().format(term).toString(), context));\n+    }\n+\n+    /**\n+     * Get the background frequency of a {@link BytesRef} term.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMTc3NA=="}, "originalCommit": {"oid": "785243901e27880ed238390f508299eafb7b4367"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1651, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}