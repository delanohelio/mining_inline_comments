{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MTU3ODQw", "number": 51558, "title": "EQL: Add AstBuilder to convert to QL tree", "bodyText": "This adds visit* methods for the AstBuilder to convert an ANTLR tree into a QL tree. I've only scoped this to stateless expressions (no sequence, join, pipes, ancestry).\nThere are a few cases of EQL are just shorthand for now, unless we add more optimal/direct support within QL:\n\nx in (a, b, c, ...) -> x == a or x == b or x == c or ...\nx == \"some*wildcard*expr*\" -> wildcard(x, \"some*wildcard*expr*\")\n\nFunctions get turned into UnresolvedFunction. I think at some point, we'll need to add QL support for these or have these functions be EQL only with a custom registry. I haven't dived much into that yet to see how this works. I'm assuming that this will be done in a separate follow up PR (created issue #51556 for new functions)\nRelated Issues\n\n#49589\n#49997", "createdAt": "2020-01-28T18:16:04Z", "url": "https://github.com/elastic/elasticsearch/pull/51558", "merged": true, "mergeCommit": {"oid": "a462700f9c8e1fb977d62d42eb0077403b8fa98b"}, "closed": true, "closedAt": "2020-02-03T19:00:21Z", "author": {"login": "rw-access"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-oBDNgH2gAyMzY4MTU3ODQwOmVlNzVkZGYxODE1ZmYwYTc0ZTA0NTcwN2E0MTYxYjFiMGYxYzRjMmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_xBMygH2gAyMzY4MTU3ODQwOjJlZGQ5NDg2NTUwOGM5Mzk3ZjM2ODkyZWJmZTMwNTdlNjFhNTNkMTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ee75ddf1815ff0a74e045707a4161b1b0f1c4c2e", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/ee75ddf1815ff0a74e045707a4161b1b0f1c4c2e", "committedDate": "2020-01-28T02:35:35Z", "message": "EQL: Add AstBuilder visitors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b237eeabc5dd7431c93d806f6f470daeacf674dc", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/b237eeabc5dd7431c93d806f6f470daeacf674dc", "committedDate": "2020-01-28T17:37:39Z", "message": "EQL: Add tests for wildcards and sets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b594566cfc6b301e749baca51ccce74748e71937", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/b594566cfc6b301e749baca51ccce74748e71937", "committedDate": "2020-01-28T17:59:26Z", "message": "EQL: Fix licensing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89c912636e792f5372cd4acedad8d2a674ae9cb0", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/89c912636e792f5372cd4acedad8d2a674ae9cb0", "committedDate": "2020-01-28T22:52:03Z", "message": "EQL: Fix ExpressionTests.java license"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c", "committedDate": "2020-01-28T23:05:38Z", "message": "EQL: Cleanup imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTM4NDQ2", "url": "https://github.com/elastic/elasticsearch/pull/51558#pullrequestreview-350138446", "createdAt": "2020-01-29T14:18:35Z", "commit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDoxODozNlrOFjJ8HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowNTo1OFrOFjLvLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNzMyNA==", "bodyText": "As far as I'm aware the issues in ANTLR still exist so to no get bitten again by this obscure behavior, I would keep the construct in place.", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372407324", "createdAt": "2020-01-29T14:18:36Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/antlr/EqlBase.g4", "diffHunk": "@@ -73,26 +73,15 @@ expression\n booleanExpression\n     : NOT booleanExpression                                               #logicalNot\n     | relationship=IDENTIFIER OF subquery                                 #processCheck\n-    | predicated                                                          #booleanDefault\n+    | valueExpression                                                     #booleanDefault\n     | left=booleanExpression operator=AND right=booleanExpression         #logicalBinary\n     | left=booleanExpression operator=OR right=booleanExpression          #logicalBinary\n     ;\n \n-// workaround for:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQxOTM4Mw==", "bodyText": "Can you give an example of the grammar this should parse?\nResolution of pattern literals should be handled inside the analyzer and grammar not the parser.\nFor example in SQL * as in SELECT * FROM  is handled as UnresolvedStar (which means it's not a literal but a dedicated char) which is then resolved to a proper function.\nThis seems to be a similar case.\nSee \n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java\n    \n    \n         Line 167\n      in\n      893d4a2\n    \n    \n    \n    \n\n        \n          \n           public Expression visitStar(StarContext ctx) { \n        \n    \n  \n\n\nand\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/antlr/SqlBase.g4\n    \n    \n         Line 237\n      in\n      893d4a2\n    \n    \n    \n    \n\n        \n          \n           | (qualifiedName DOT)? ASTERISK                                                            #star", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372419383", "createdAt": "2020-01-29T14:38:45Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/ExpressionBuilder.java", "diffHunk": "@@ -6,6 +6,188 @@\n \n package org.elasticsearch.xpack.eql.parser;\n \n-public class ExpressionBuilder extends IdentifierBuilder {\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ArithmeticUnaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ComparisonContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ContainsExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.DereferenceContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.FunctionExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalBinaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalNotContext;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.Function;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Not;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Add;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Div;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mod;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mul;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Sub;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.tree.Source;\n \n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+public class ExpressionBuilder extends LiteralBuilder {\n+\n+    protected Expression expression(ParseTree ctx) {\n+        return typedParsing(ctx, Expression.class);\n+    }\n+\n+    protected List<Expression> expressions(List<? extends ParserRuleContext> contexts) {\n+        return visitList(contexts, Expression.class);\n+    }\n+\n+    @Override\n+    public Expression visitSingleExpression(EqlBaseParser.SingleExpressionContext ctx) {\n+        return expression(ctx.expression());\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticUnary(ArithmeticUnaryContext ctx) {\n+        Expression expr = expression(ctx.valueExpression());\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        return type == EqlBaseParser.MINUS ? new Neg(source, expr) : expr;\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticBinary(EqlBaseParser.ArithmeticBinaryContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        switch (type) {\n+            case EqlBaseParser.ASTERISK:\n+                return new Mul(source, left, right);\n+            case EqlBaseParser.SLASH:\n+                return new Div(source, left, right);\n+            case EqlBaseParser.PERCENT:\n+                return new Mod(source, left, right);\n+            case EqlBaseParser.PLUS:\n+                return new Add(source, left, right);\n+            case EqlBaseParser.MINUS:\n+                return new Sub(source, left, right);\n+            default:\n+                throw new ParsingException(source, \"Unknown arithmetic {}\", source.text());\n+        }\n+    }\n+\n+    @Override\n+    public Expression visitComparison(ComparisonContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        TerminalNode op = (TerminalNode) ctx.comparisonOperator().getChild(0);\n+\n+        Source source = source(ctx);\n+\n+        // check if the RHS is a wildcard string and convert to a function check instead\n+        if (right instanceof Literal) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMTA1OQ==", "bodyText": "IsNotNull and IsNull haven't been moved since in SQL null means missing as oppose to null value. This leads to subtle semantics such as 3-value bool logic (TRUE AND null -> null, FALSE AND null -> FALSE, TRUE AND TRUE -> TRUE).\nAre the semantics the same ?", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372421059", "createdAt": "2020-01-29T14:41:35Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/ExpressionBuilder.java", "diffHunk": "@@ -6,6 +6,188 @@\n \n package org.elasticsearch.xpack.eql.parser;\n \n-public class ExpressionBuilder extends IdentifierBuilder {\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ArithmeticUnaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ComparisonContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.ContainsExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.DereferenceContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.FunctionExpressionContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalBinaryContext;\n+import org.elasticsearch.xpack.eql.parser.EqlBaseParser.LogicalNotContext;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.Function;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Not;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Add;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Div;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mod;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Mul;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Sub;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.tree.Source;\n \n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+public class ExpressionBuilder extends LiteralBuilder {\n+\n+    protected Expression expression(ParseTree ctx) {\n+        return typedParsing(ctx, Expression.class);\n+    }\n+\n+    protected List<Expression> expressions(List<? extends ParserRuleContext> contexts) {\n+        return visitList(contexts, Expression.class);\n+    }\n+\n+    @Override\n+    public Expression visitSingleExpression(EqlBaseParser.SingleExpressionContext ctx) {\n+        return expression(ctx.expression());\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticUnary(ArithmeticUnaryContext ctx) {\n+        Expression expr = expression(ctx.valueExpression());\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        return type == EqlBaseParser.MINUS ? new Neg(source, expr) : expr;\n+    }\n+\n+    @Override\n+    public Expression visitArithmeticBinary(EqlBaseParser.ArithmeticBinaryContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        Source source = source(ctx);\n+        int type = ctx.operator.getType();\n+\n+        switch (type) {\n+            case EqlBaseParser.ASTERISK:\n+                return new Mul(source, left, right);\n+            case EqlBaseParser.SLASH:\n+                return new Div(source, left, right);\n+            case EqlBaseParser.PERCENT:\n+                return new Mod(source, left, right);\n+            case EqlBaseParser.PLUS:\n+                return new Add(source, left, right);\n+            case EqlBaseParser.MINUS:\n+                return new Sub(source, left, right);\n+            default:\n+                throw new ParsingException(source, \"Unknown arithmetic {}\", source.text());\n+        }\n+    }\n+\n+    @Override\n+    public Expression visitComparison(ComparisonContext ctx) {\n+        Expression left = expression(ctx.left);\n+        Expression right = expression(ctx.right);\n+        TerminalNode op = (TerminalNode) ctx.comparisonOperator().getChild(0);\n+\n+        Source source = source(ctx);\n+\n+        // check if the RHS is a wildcard string and convert to a function check instead\n+        if (right instanceof Literal) {\n+            Object rightValue = ((Literal) right).value();\n+            if ((rightValue instanceof String) && ((String) rightValue).contains(\"*\")) {\n+\n+                List<Expression> arguments = Arrays.asList(left, right);\n+                UnresolvedFunction.ResolutionType resolutionType = UnresolvedFunction.ResolutionType.STANDARD;\n+                Expression wildcardExpression = new UnresolvedFunction(source, \"wildcard\", resolutionType, arguments);\n+\n+                switch (op.getSymbol().getType()) {\n+                    case EqlBaseParser.EQ:\n+                        return wildcardExpression;\n+                    case EqlBaseParser.NEQ:\n+                        return new Not(source, wildcardExpression);\n+                }\n+            }\n+        }\n+\n+        switch (op.getSymbol().getType()) {\n+            case EqlBaseParser.EQ:\n+                // TODO: check for left == null after moving IsNotNull from SQL -> QL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMzc1Mg==", "bodyText": "Since it's a char not a string we're replacing, use\nidentifier.replace('`', '')", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372423752", "createdAt": "2020-01-29T14:45:45Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/IdentifierBuilder.java", "diffHunk": "@@ -14,7 +16,17 @@ public String visitIdentifier(IdentifierContext ctx) {\n         return ctx == null ? null : unquoteIdentifier(ctx.getText());\n     }\n \n+    @Override\n+    public String visitQualifiedName(QualifiedNameContext ctx) {\n+        if (ctx == null) {\n+            return null;\n+        }\n+\n+        // this is fine, because we've already checked for array indexes [...]\n+        return Strings.collectionToDelimitedString(visitList(ctx.identifier(), String.class), \".\");\n+    }\n+\n     private static String unquoteIdentifier(String identifier) {\n-        return identifier.replace(\"\\\"\\\"\", \"\\\"\");\n+        return identifier.replace(\"`\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNDg4MA==", "bodyText": "Should it be ?\" or is ?' allowed as well ? In both cases I would do the check a bit stricter to not trip if somehow a different char follows ?", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372424880", "createdAt": "2020-01-29T14:47:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LiteralBuilder.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class LiteralBuilder extends IdentifierBuilder {\n+\n+    static String unquoteString(String text) {\n+        // remove leading and trailing ' for strings and also eliminate escaped single quotes\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        // unescaped strings can be interpreted directly\n+        if (text.startsWith(\"?\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNjE5NQ==", "bodyText": "Extract the pattern out to avoid compiling one per each string. Further more if there's not regex used, simply splitting the string and parsing it manually might be a bit more investment but easier to maintain long term.\nCurrently the identifier bits are mixed with the literal ones.", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372426195", "createdAt": "2020-01-29T14:49:35Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LiteralBuilder.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class LiteralBuilder extends IdentifierBuilder {\n+\n+    static String unquoteString(String text) {\n+        // remove leading and trailing ' for strings and also eliminate escaped single quotes\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        // unescaped strings can be interpreted directly\n+        if (text.startsWith(\"?\")) {\n+            return text.substring(2, text.length() - 1);\n+        }\n+\n+        text = text.substring(1, text.length() - 1);\n+        Pattern regex = Pattern.compile(\"\\\\\\\\.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyNzQ3NA==", "bodyText": "If you want to extract literals, move them after ExpressionBuilder (since Literals are expressions) - i.e. LiteralBuilder extends ExpressionBuilder", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372427474", "createdAt": "2020-01-29T14:51:42Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/LiteralBuilder.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.StringUtils;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class LiteralBuilder extends IdentifierBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMzExNQ==", "bodyText": "The query should map to a Filter, that is a LogicalPlan (action) not an Expression (properties):\ncostin@5237f2b#diff-74e29c0f2741ee97378ecd3b111c6e8cR20\nor\nhttps://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/LogicalPlanBuilder.java#L125", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372433115", "createdAt": "2020-01-29T15:00:06Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/QueryBuilder.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+public class QueryBuilder extends ExpressionBuilder {\n+\n+    @Override\n+    public Expression visitEventQuery(EqlBaseParser.EventQueryContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNTMwMg==", "bodyText": "formatting is off", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372435302", "createdAt": "2020-01-29T15:03:35Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\nworld\", AstBuilder.unquoteString(\"'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\nworld\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n+\n+        // test for unescaped strings: ?\"....\" or ?'....'\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"?'hello\\\"world'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"?\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n+    }\n+\n+    public void testLiterals() {\n+        assertEquals(Literal.TRUE, parser.createExpression(\"true\"));\n+        assertEquals(Literal.FALSE, parser.createExpression(\"false\"));\n+        assertEquals(Literal.NULL, parser.createExpression(\"null\"));\n+    }\n+\n+    public void testSingleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello ' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testSingleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"?'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello \\\\' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = parser.createExpression(\"?\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\\\\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testNumbers() {\n+        assertEquals(new Literal(null, 8589934592L, DataTypes.LONG), parser.createExpression(\"8589934592\"));\n+        assertEquals(new Literal(null, 5, DataTypes.INTEGER), parser.createExpression(\"5\"));\n+        assertEquals(new Literal(null, 5e14, DataTypes.DOUBLE), parser.createExpression(\"5e14\"));\n+        assertEquals(new Literal(null, 5.2, DataTypes.DOUBLE), parser.createExpression(\"5.2\"));\n+\n+        Expression parsed = parser.createExpression(\"-5.2\");\n+        Expression expected = new Neg(null, new Literal(null, 5.2, DataTypes.DOUBLE));\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testBackQuotedAttribute() {\n+        String quote = \"`\";\n+        String qualifier = \"table\";\n+        String name = \"@timestamp\";\n+        Expression exp = parser.createExpression(quote + qualifier + quote + \".\" + quote + name + quote);\n+        assertThat(exp, instanceOf(UnresolvedAttribute.class));\n+        UnresolvedAttribute ua = (UnresolvedAttribute) exp;\n+        assertThat(ua.name(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifiedName(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifier(), is(nullValue()));\n+    }\n+\n+    public void testFunctions() {\n+        List<Expression> arguments = Arrays.asList(\n+            new UnresolvedAttribute(null, \"some.field\"),\n+            new Literal(null, \"test string\", DataTypes.KEYWORD)\n+        );\n+        UnresolvedFunction.ResolutionType resolutionType = UnresolvedFunction.ResolutionType.STANDARD;\n+        Expression expected = new UnresolvedFunction(null, \"concat\", resolutionType, arguments);\n+\n+        assertEquals(expected, parser.createExpression(\"concat(some.field, 'test string')\"));\n+    }\n+\n+    public void testComparison() {\n+        String fieldText = \"field\";\n+        String valueText = \"2.0\";\n+\n+        Expression field = expr(fieldText);\n+        Expression value = expr(valueText);\n+\n+        assertEquals( new Equals(null, field, value), expr(fieldText + \"==\" + valueText));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjI4OQ==", "bodyText": "you could import static unquoteString and further mroe extract it a public static method into StringUtils and then invoke it inside AstBuilder.\n\n\nthe import should be on IdentifierBuilder.unquoteStringnotAstBuidler` - not sure what IDE you are using but normally you should get a warning about this (static methods are not inherited and thus there's no dispatch).\n\n\nunquote tests should sit in their own test class IdentifierTests or StringUtilsTests.", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372436289", "createdAt": "2020-01-29T15:05:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNjc4Mg==", "bodyText": "why not use expr everywhere instead of parser.createExpression", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r372436782", "createdAt": "2020-01-29T15:05:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\nworld\", AstBuilder.unquoteString(\"'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\nworld\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n+\n+        // test for unescaped strings: ?\"....\" or ?'....'\n+        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"?'hello\\\"world'\"));\n+        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\"world'\"));\n+        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"?\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n+    }\n+\n+    public void testLiterals() {\n+        assertEquals(Literal.TRUE, parser.createExpression(\"true\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eba19f752782f8780025eaecafbe3946722f337f", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/eba19f752782f8780025eaecafbe3946722f337f", "committedDate": "2020-01-29T21:26:50Z", "message": "EQL: PR feedback and remove LiteralBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d976f1e9ec1c6cb4eaa712bde3352142500bb53f", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/d976f1e9ec1c6cb4eaa712bde3352142500bb53f", "committedDate": "2020-01-29T22:55:43Z", "message": "EQL: Split off logical plan from expressions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "324f54c4cf93083610a3c2f834c3236712518901", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/324f54c4cf93083610a3c2f834c3236712518901", "committedDate": "2020-01-29T23:00:15Z", "message": "EQL: Remove stray import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7acdf28948dbc6f881266f60e782a656046446a8", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/7acdf28948dbc6f881266f60e782a656046446a8", "committedDate": "2020-01-29T23:33:21Z", "message": "EQL: Add predicate handling for set checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwOTQwOTMz", "url": "https://github.com/elastic/elasticsearch/pull/51558#pullrequestreview-350940933", "createdAt": "2020-01-30T16:02:32Z", "commit": {"oid": "324f54c4cf93083610a3c2f834c3236712518901"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNjowMjozMlrOFjwehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNjoyNTo0N1rOFjxWIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzODcyNQ==", "bodyText": "I agree with @costin and this is still not reverted.", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373038725", "createdAt": "2020-01-30T16:02:32Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/antlr/EqlBase.g4", "diffHunk": "@@ -73,26 +73,15 @@ expression\n booleanExpression\n     : NOT booleanExpression                                               #logicalNot\n     | relationship=IDENTIFIER OF subquery                                 #processCheck\n-    | predicated                                                          #booleanDefault\n+    | valueExpression                                                     #booleanDefault\n     | left=booleanExpression operator=AND right=booleanExpression         #logicalBinary\n     | left=booleanExpression operator=OR right=booleanExpression          #logicalBinary\n     ;\n \n-// workaround for:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNzMyNA=="}, "originalCommit": {"oid": "0658e2b4fdaf6fa4d5a9e53a9fc2267d80cc242c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzOTM5MQ==", "bodyText": "Maybe you can keep the comment.", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373039391", "createdAt": "2020-01-30T16:03:37Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/parser/AbstractBuilder.java", "diffHunk": "@@ -113,14 +115,7 @@ static String text(ParseTree node) {\n         return node == null ? null : node.getText();\n     }\n \n-    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324f54c4cf93083610a3c2f834c3236712518901"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1MjUyNQ==", "bodyText": "leftover?", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373052525", "createdAt": "2020-01-30T16:25:04Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/GrammarTests.java", "diffHunk": "@@ -28,29 +28,14 @@\n  */\n public class GrammarTests extends ESTestCase {\n \n-    public void testStrings() throws Exception {\n-        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"'hello\\\"world'\"));\n-        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"\\\"hello'world\\\"\"));\n-        assertEquals(\"hello\\nworld\", AstBuilder.unquoteString(\"'hello\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\nworld\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n-\n-        // test for unescaped strings: ?\"....\" or ?'....'\n-        assertEquals(\"hello\\\"world\", AstBuilder.unquoteString(\"?'hello\\\"world'\"));\n-        assertEquals(\"hello\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\"world'\"));\n-        assertEquals(\"hello'world\", AstBuilder.unquoteString(\"?\\\"hello'world\\\"\"));\n-        assertEquals(\"hello\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\\\\\\nworld\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n-        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", AstBuilder.unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n-    }\n-\n     public void testSupportedQueries() throws Exception {\n         EqlParser parser = new EqlParser();\n         List<Tuple<String, Integer>> lines = readQueries(\"/queries-supported.eql\");\n         for (Tuple<String, Integer> line : lines) {\n             String q = line.v1();\n+            parser.createStatement(q);\n \n+            /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324f54c4cf93083610a3c2f834c3236712518901"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1Mjk2Mw==", "bodyText": "Maybe add a TODO?", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373052963", "createdAt": "2020-01-30T16:25:47Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/parser/ExpressionTests.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+\n+package org.elasticsearch.xpack.eql.parser;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.expression.UnresolvedAttribute;\n+import org.elasticsearch.xpack.ql.expression.function.UnresolvedFunction;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.And;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.arithmetic.Neg;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.GreaterThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThan;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.LessThanOrEqual;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.NotEquals;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.eql.parser.AbstractBuilder.unquoteString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ExpressionTests extends ESTestCase {\n+\n+    private final EqlParser parser = new EqlParser();\n+\n+    public Expression expr(String source) {\n+        return parser.createExpression(source);\n+    }\n+\n+\n+    public void testStrings() throws Exception {\n+        assertEquals(\"hello\\\"world\", unquoteString(\"'hello\\\"world'\"));\n+        assertEquals(\"hello'world\", unquoteString(\"\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\nworld\", unquoteString(\"'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\nworld\", unquoteString(\"'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\"world\", unquoteString(\"'hello\\\\\\\\\\\\\\\"world'\"));\n+\n+        // test for unescaped strings: ?\"....\" or ?'....'\n+        assertEquals(\"hello\\\"world\", unquoteString(\"?'hello\\\"world'\"));\n+        assertEquals(\"hello\\\\\\\"world\", unquoteString(\"?'hello\\\\\\\"world'\"));\n+        assertEquals(\"hello'world\", unquoteString(\"?\\\"hello'world\\\"\"));\n+        assertEquals(\"hello\\\\nworld\", unquoteString(\"?'hello\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\nworld\", unquoteString(\"?'hello\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\nworld\", unquoteString(\"?'hello\\\\\\\\\\\\nworld'\"));\n+        assertEquals(\"hello\\\\\\\\\\\\\\\"world\", unquoteString(\"?'hello\\\\\\\\\\\\\\\"world'\"));\n+    }\n+\n+    public void testLiterals() {\n+        assertEquals(Literal.TRUE, expr(\"true\"));\n+        assertEquals(Literal.FALSE, expr(\"false\"));\n+        assertEquals(Literal.NULL, expr(\"null\"));\n+    }\n+\n+    public void testSingleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello ' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testSingleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"?'hello \\\\' world!'\");\n+        Expression expected = new Literal(null, \"hello \\\\' world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testDoubleQuotedUnescapedString() {\n+        // \"hello \\\" world\"\n+        Expression parsed = expr(\"?\\\"hello \\\\\\\" world!\\\"\");\n+        Expression expected = new Literal(null, \"hello \\\\\\\" world!\", DataTypes.KEYWORD);\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testNumbers() {\n+        assertEquals(new Literal(null, 8589934592L, DataTypes.LONG), expr(\"8589934592\"));\n+        assertEquals(new Literal(null, 5, DataTypes.INTEGER), expr(\"5\"));\n+        assertEquals(new Literal(null, 5e14, DataTypes.DOUBLE), expr(\"5e14\"));\n+        assertEquals(new Literal(null, 5.2, DataTypes.DOUBLE), expr(\"5.2\"));\n+\n+        Expression parsed = expr(\"-5.2\");\n+        Expression expected = new Neg(null, new Literal(null, 5.2, DataTypes.DOUBLE));\n+        assertEquals(expected, parsed);\n+    }\n+\n+    public void testBackQuotedAttribute() {\n+        String quote = \"`\";\n+        String qualifier = \"table\";\n+        String name = \"@timestamp\";\n+        Expression exp = expr(quote + qualifier + quote + \".\" + quote + name + quote);\n+        assertThat(exp, instanceOf(UnresolvedAttribute.class));\n+        UnresolvedAttribute ua = (UnresolvedAttribute) exp;\n+        assertThat(ua.name(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifiedName(), equalTo(qualifier + \".\" + name));\n+        assertThat(ua.qualifier(), is(nullValue()));\n+    }\n+\n+    public void testFunctions() {\n+        List<Expression> arguments = Arrays.asList(\n+            new UnresolvedAttribute(null, \"some.field\"),\n+            new Literal(null, \"test string\", DataTypes.KEYWORD)\n+        );\n+        UnresolvedFunction.ResolutionType resolutionType = UnresolvedFunction.ResolutionType.STANDARD;\n+        Expression expected = new UnresolvedFunction(null, \"concat\", resolutionType, arguments);\n+\n+        assertEquals(expected, expr(\"concat(some.field, 'test string')\"));\n+    }\n+\n+    public void testComparison() {\n+        String fieldText = \"field\";\n+        String valueText = \"2.0\";\n+\n+        Expression field = expr(fieldText);\n+        Expression value = expr(valueText);\n+\n+        assertEquals(new Equals(null, field, value), expr(fieldText + \"==\" + valueText));\n+        assertEquals(new NotEquals(null, field, value), expr(fieldText + \"!=\" + valueText));\n+        assertEquals(new LessThanOrEqual(null, field, value), expr(fieldText + \"<=\" + valueText));\n+        assertEquals(new GreaterThanOrEqual(null, field, value), expr(fieldText + \">=\" + valueText));\n+        assertEquals(new GreaterThan(null, field, value), expr(fieldText + \">\" + valueText));\n+        assertEquals(new LessThan(null, field, value), expr(fieldText + \"<\" + valueText));\n+    }\n+\n+    public void testBoolean() {\n+        String leftText = \"process_name == 'net.exe'\";\n+        String rightText = \"command_line == '* localgroup*'\";\n+\n+        Expression lhs = expr(leftText);\n+        Expression rhs = expr(rightText);\n+\n+        Expression booleanAnd = expr(leftText + \" and \" + rightText);\n+        assertEquals(new And(null, lhs, rhs), booleanAnd);\n+\n+        Expression booleanOr = expr(leftText + \" or \" + rightText);\n+        assertEquals(new Or(null, lhs, rhs), booleanOr);\n+    }\n+\n+    /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324f54c4cf93083610a3c2f834c3236712518901"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "160ba32f59c11143ef9ff036e575900d5366f931", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/160ba32f59c11143ef9ff036e575900d5366f931", "committedDate": "2020-01-30T16:54:44Z", "message": "EQL: Remove commented out dead code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDk0Mzc1", "url": "https://github.com/elastic/elasticsearch/pull/51558#pullrequestreview-351094375", "createdAt": "2020-01-30T19:45:27Z", "commit": {"oid": "160ba32f59c11143ef9ff036e575900d5366f931"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTo0NToyN1rOFj3rRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTo0NToyN1rOFj3rRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1NjY3Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/51558#discussion_r373156676", "createdAt": "2020-01-30T19:45:27Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/EsIndex.java", "diffHunk": "@@ -33,4 +34,23 @@ public String name() {\n     public String toString() {\n         return name;\n     }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "160ba32f59c11143ef9ff036e575900d5366f931"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDk0NDg5", "url": "https://github.com/elastic/elasticsearch/pull/51558#pullrequestreview-351094489", "createdAt": "2020-01-30T19:45:39Z", "commit": {"oid": "160ba32f59c11143ef9ff036e575900d5366f931"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTEyNDk1", "url": "https://github.com/elastic/elasticsearch/pull/51558#pullrequestreview-351112495", "createdAt": "2020-01-30T20:15:35Z", "commit": {"oid": "160ba32f59c11143ef9ff036e575900d5366f931"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2edd94865508c9397f36892ebfe3057e61a53d13", "author": {"user": {"login": "rw-access", "name": "Ross Wolf"}}, "url": "https://github.com/elastic/elasticsearch/commit/2edd94865508c9397f36892ebfe3057e61a53d13", "committedDate": "2020-01-31T15:38:49Z", "message": "EQL: Remove wildcard test, wait until analyzer"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3180, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}