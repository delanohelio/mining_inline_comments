{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwODM5NjA1", "number": 50782, "title": "Write CS asynchronously on data-only nodes", "bodyText": "Writes cluster states out asynchronously on data-only nodes. The main reason for writing out the cluster state at all is so that the data-only nodes can snap into a cluster, that they can do a bit of bootstrap validation and so that the shard recovery tools work.\nCluster states that are written asynchronously have their voting configuration adapted to a non-existing configuration so that these nodes cannot mistakenly become master even if their node role is changed back and forth.\nRelates #48701", "createdAt": "2020-01-09T08:47:09Z", "url": "https://github.com/elastic/elasticsearch/pull/50782", "merged": true, "mergeCommit": {"oid": "65366e0d1faab4e9d88cfb94e477848950552ab6"}, "closed": true, "closedAt": "2020-01-09T13:49:57Z", "author": {"login": "ywelsch"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4l4QEgH2gAyMzYwODM5NjA1OmUxNDcxZmE5ODQzZTk4OGYxNTcwZWI3M2MwZjQ0M2I3NmEwZjQwMGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb4qIRQAFqTM0MDUyNDY4MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/e1471fa9843e988f1570eb73c0f443b76a0f400a", "committedDate": "2020-01-09T08:42:37Z", "message": "Write CS asynchronously on data-only nodes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwNDM4MDc1", "url": "https://github.com/elastic/elasticsearch/pull/50782#pullrequestreview-340438075", "createdAt": "2020-01-09T10:55:04Z", "commit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMDo1NTowNVrOFbyD-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTozNDoxNlrOFbzBOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NjA5MA==", "bodyText": "I think it'd be neater for the caller to construct this PersistedState (no need for it to be a LucenePersistedState either, and it already carries the current term and last-accepted state).", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364676090", "createdAt": "2020-01-09T10:55:05Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjM0MA==", "bodyText": "Could this executor have a bounded queue? AFAICT there'll only be \u22641 task.", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364682340", "createdAt": "2020-01-09T11:10:25Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjcxOQ==", "bodyText": "I think this is unexpected unless we're shutting down, so maybe better to assert threadPoolExecutor.isShutdown().", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364682719", "createdAt": "2020-01-09T11:11:18Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);\n+        }\n+\n+        @Override\n+        public void setCurrentTerm(long currentTerm) {\n+            synchronized (mutex) {\n+                super.setCurrentTerm(currentTerm);\n+                if (newCurrentTermQueued) {\n+                    logger.trace(\"term update already queued (setting term to {})\", currentTerm);\n+                } else {\n+                    logger.trace(\"queuing term update (setting term to {})\", currentTerm);\n+                    newCurrentTermQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void setLastAcceptedState(ClusterState clusterState) {\n+            synchronized (mutex) {\n+                super.setLastAcceptedState(clusterState);\n+                if (newStateQueued) {\n+                    logger.trace(\"cluster state update already queued (setting cluster state to {})\", clusterState.version());\n+                } else {\n+                    logger.trace(\"queuing cluster state update (setting cluster state to {})\", clusterState.version());\n+                    newStateQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        private void scheduleUpdate() {\n+            assert Thread.holdsLock(mutex);\n+            try {\n+                threadPoolExecutor.execute(new AbstractRunnable() {\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.error(\"Exception occurred when storing new meta data\", e);\n+                    }\n+\n+                    @Override\n+                    protected void doRun() {\n+                        final Long term;\n+                        final ClusterState clusterState;\n+                        synchronized (mutex) {\n+                            if (newCurrentTermQueued) {\n+                                term = getCurrentTerm();\n+                                newCurrentTermQueued = false;\n+                            } else {\n+                                term = null;\n+                            }\n+                            if (newStateQueued) {\n+                                clusterState = getLastAcceptedState();\n+                                newStateQueued = false;\n+                            } else {\n+                                clusterState = null;\n+                            }\n+                        }\n+                        // write current term before last accepted state so that it is never below term in last accepted state\n+                        if (term != null) {\n+                            lucenePersistedState.setCurrentTerm(term);\n+                        }\n+                        if (clusterState != null) {\n+                            lucenePersistedState.setLastAcceptedState(resetVotingConfiguration(clusterState));\n+                        }\n+                    }\n+                });\n+            } catch (EsRejectedExecutionException e) {\n+                // ignore cases where we are shutting down..., there is really nothing interesting to be done here...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4NDc0OA==", "bodyText": "\ud83d\udc4d Slightly subtle given that we're already under the Coordinator's mutex here, but we aren't in the scheduled updater thread so it's important to be under our own mutex too.", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364684748", "createdAt": "2020-01-09T11:16:50Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);\n+        }\n+\n+        @Override\n+        public void setCurrentTerm(long currentTerm) {\n+            synchronized (mutex) {\n+                super.setCurrentTerm(currentTerm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTc2OA==", "bodyText": "I see some slightly questionable synchronisation here. We construct the PersistedClusterStateService.Writer using a simple ArrayList of MetaDataIndexWriters, and then iterate through that when closing it on (potentially) a different thread. Unrelated to this PR, I just noticed it.", "url": "https://github.com/elastic/elasticsearch/pull/50782#discussion_r364691768", "createdAt": "2020-01-09T11:34:16Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java", "diffHunk": "@@ -227,6 +245,147 @@ public void close() throws IOException {\n         IOUtils.close(persistedState.get());\n     }\n \n+    // visible for testing\n+    public boolean allPendingAsyncStatesWritten() {\n+        final PersistedState ps = persistedState.get();\n+        if (ps instanceof AsyncLucenePersistedState) {\n+            return ((AsyncLucenePersistedState) ps).allPendingAsyncStatesWritten();\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    static class AsyncLucenePersistedState extends InMemoryPersistedState {\n+\n+        private static final Logger logger = LogManager.getLogger(AsyncLucenePersistedState.class);\n+\n+        static final String THREAD_NAME = \"AsyncLucenePersistedState#updateTask\";\n+\n+        private final EsThreadPoolExecutor threadPoolExecutor;\n+        private final LucenePersistedState lucenePersistedState;\n+\n+        boolean newCurrentTermQueued = false;\n+        boolean newStateQueued = false;\n+\n+        private final Object mutex = new Object();\n+\n+        AsyncLucenePersistedState(Settings settings, ThreadPool threadPool, PersistedClusterStateService.Writer persistenceWriter,\n+                                  long currentTerm, ClusterState lastAcceptedState) throws IOException {\n+            super(currentTerm, lastAcceptedState);\n+            final String nodeName = Objects.requireNonNull(Node.NODE_NAME_SETTING.get(settings));\n+            threadPoolExecutor = EsExecutors.newScaling(\n+                nodeName + \"/\" + THREAD_NAME,\n+                1, 1,\n+                0, TimeUnit.MILLISECONDS,\n+                daemonThreadFactory(nodeName, THREAD_NAME),\n+                threadPool.getThreadContext());\n+            lucenePersistedState = new LucenePersistedState(persistenceWriter, currentTerm, lastAcceptedState);\n+        }\n+\n+        @Override\n+        public void setCurrentTerm(long currentTerm) {\n+            synchronized (mutex) {\n+                super.setCurrentTerm(currentTerm);\n+                if (newCurrentTermQueued) {\n+                    logger.trace(\"term update already queued (setting term to {})\", currentTerm);\n+                } else {\n+                    logger.trace(\"queuing term update (setting term to {})\", currentTerm);\n+                    newCurrentTermQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void setLastAcceptedState(ClusterState clusterState) {\n+            synchronized (mutex) {\n+                super.setLastAcceptedState(clusterState);\n+                if (newStateQueued) {\n+                    logger.trace(\"cluster state update already queued (setting cluster state to {})\", clusterState.version());\n+                } else {\n+                    logger.trace(\"queuing cluster state update (setting cluster state to {})\", clusterState.version());\n+                    newStateQueued = true;\n+                    scheduleUpdate();\n+                }\n+            }\n+        }\n+\n+        private void scheduleUpdate() {\n+            assert Thread.holdsLock(mutex);\n+            try {\n+                threadPoolExecutor.execute(new AbstractRunnable() {\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.error(\"Exception occurred when storing new meta data\", e);\n+                    }\n+\n+                    @Override\n+                    protected void doRun() {\n+                        final Long term;\n+                        final ClusterState clusterState;\n+                        synchronized (mutex) {\n+                            if (newCurrentTermQueued) {\n+                                term = getCurrentTerm();\n+                                newCurrentTermQueued = false;\n+                            } else {\n+                                term = null;\n+                            }\n+                            if (newStateQueued) {\n+                                clusterState = getLastAcceptedState();\n+                                newStateQueued = false;\n+                            } else {\n+                                clusterState = null;\n+                            }\n+                        }\n+                        // write current term before last accepted state so that it is never below term in last accepted state\n+                        if (term != null) {\n+                            lucenePersistedState.setCurrentTerm(term);\n+                        }\n+                        if (clusterState != null) {\n+                            lucenePersistedState.setLastAcceptedState(resetVotingConfiguration(clusterState));\n+                        }\n+                    }\n+                });\n+            } catch (EsRejectedExecutionException e) {\n+                // ignore cases where we are shutting down..., there is really nothing interesting to be done here...\n+                if (threadPoolExecutor.isShutdown() == false) {\n+                    throw e;\n+                }\n+            }\n+        }\n+\n+        static final CoordinationMetaData.VotingConfiguration staleStateConfiguration =\n+            new CoordinationMetaData.VotingConfiguration(Collections.singleton(\"STALE_STATE_CONFIG\"));\n+\n+        static ClusterState resetVotingConfiguration(ClusterState clusterState) {\n+            CoordinationMetaData newCoordinationMetaData = CoordinationMetaData.builder(clusterState.coordinationMetaData())\n+                .lastAcceptedConfiguration(staleStateConfiguration)\n+                .lastCommittedConfiguration(staleStateConfiguration)\n+                .build();\n+            return ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData())\n+                .coordinationMetaData(newCoordinationMetaData).build()).build();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            try {\n+                ThreadPool.terminate(threadPoolExecutor, 10, TimeUnit.SECONDS);\n+            } finally {\n+                lucenePersistedState.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1471fa9843e988f1570eb73c0f443b76a0f400a"}, "originalPosition": 212}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6ada35fe9286cf623814d5502d4625747f7d282", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/f6ada35fe9286cf623814d5502d4625747f7d282", "committedDate": "2020-01-09T13:03:15Z", "message": "review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwNTI0Njgw", "url": "https://github.com/elastic/elasticsearch/pull/50782#pullrequestreview-340524680", "createdAt": "2020-01-09T13:39:44Z", "commit": {"oid": "f6ada35fe9286cf623814d5502d4625747f7d282"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3689, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}