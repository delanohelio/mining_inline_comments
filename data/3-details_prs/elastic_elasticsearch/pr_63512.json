{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMjA0NDcz", "number": 63512, "title": "Move write out of ir nodes and into an external phase", "bodyText": "This change moves the write phase out of the ir nodes and into an external phase to match the design of the rest of the phases for the both the user tree and ir the tree. This is the final phase internal to the either the user tree nodes and ir tree nodes.\nI know this is a large change, but it almost completely mechanical. All of the write methods in the ir nodes get directly translated to the DefaultIRTreeToASMBytesPhase other than changes to using accessors instead of member variables directly.", "createdAt": "2020-10-08T21:38:53Z", "url": "https://github.com/elastic/elasticsearch/pull/63512", "merged": true, "mergeCommit": {"oid": "bbcf8c47368ecfca6b5b685644fc01d74b276acb"}, "closed": true, "closedAt": "2020-10-16T20:46:41Z", "author": {"login": "jdconrad"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMtIoegH2gAyNTAwMjA0NDczOjBhMWI1ZWQwOTI3MDRhMWMyNWQxNTA5MjEzYjE2OTY2ZDI2M2M5YzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTL4DxgH2gAyNTAwMjA0NDczOjkwMmIyYmEzMjhlNGY5ZTNmYzBhM2Q1ZjM4MDllMjU3ZTM5NmQyYTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0a1b5ed092704a1c25d1509213b16966d263c9c1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/0a1b5ed092704a1c25d1509213b16966d263c9c1", "committedDate": "2020-09-26T16:39:29Z", "message": "make location final in IRNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d62d0752fb2a99ae998fcab291c0f709bded0f5", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d62d0752fb2a99ae998fcab291c0f709bded0f5", "committedDate": "2020-09-26T17:18:49Z", "message": "add scoping for script, class, and method to WriteScope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "712b0a8965bba0939acd0f8e73932796eddc7238", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/712b0a8965bba0939acd0f8e73932796eddc7238", "committedDate": "2020-09-26T17:36:01Z", "message": "update scope to include classwriter and methodwriter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e38647855a1c5cca0c30a3f7e43f71c5d164edf", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/8e38647855a1c5cca0c30a3f7e43f71c5d164edf", "committedDate": "2020-09-26T17:56:22Z", "message": "move loop labels to writescope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65502b186dbd52a0c784a52a83b1fb659e3a6abc", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/65502b186dbd52a0c784a52a83b1fb659e3a6abc", "committedDate": "2020-09-26T18:22:52Z", "message": "move try/catch labels to WriteScope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7231b5ebd24838d08a18b46615849ab7842667eb", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7231b5ebd24838d08a18b46615849ab7842667eb", "committedDate": "2020-09-26T20:26:14Z", "message": "move write to an external phase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae8d2a1f12069641171f0013205b5887c7dfcd6a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae8d2a1f12069641171f0013205b5887c7dfcd6a", "committedDate": "2020-09-30T14:38:56Z", "message": "Merge branch 'master' into proto"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "760b9b940997249b18947d6da787d338f2a9dc38", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/760b9b940997249b18947d6da787d338f2a9dc38", "committedDate": "2020-10-05T16:36:09Z", "message": "Merge branch 'master' into proto"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0320fe53e81db05b2d0b571bb34fb92af6e57c5", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b0320fe53e81db05b2d0b571bb34fb92af6e57c5", "committedDate": "2020-10-05T17:04:18Z", "message": "Merge branch 'proto' into proto2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "527afc40f1b3a96f97b63aaf64c0f2c908b9b97f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/527afc40f1b3a96f97b63aaf64c0f2c908b9b97f", "committedDate": "2020-10-08T19:53:15Z", "message": "Merge branch 'master' into proto"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "879afcac4496aa42f0d57c3485a94d11575bfe4c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/879afcac4496aa42f0d57c3485a94d11575bfe4c", "committedDate": "2020-10-08T19:53:23Z", "message": "Merge branch 'proto' into proto2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49397f77f269c06949af28d6a0b33e8f5d653018", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/49397f77f269c06949af28d6a0b33e8f5d653018", "committedDate": "2020-10-08T20:17:35Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c8082f74654dccabbb2ee339e9089623f445fb3", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c8082f74654dccabbb2ee339e9089623f445fb3", "committedDate": "2020-10-08T21:21:07Z", "message": "Merge branch 'master' into proto2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/883486155e6f1c304fe53b5c8ef09ee255964141", "committedDate": "2020-10-08T21:32:23Z", "message": "Merge branch 'proto2' into proto3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjEwMTE2", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510610116", "createdAt": "2020-10-16T16:09:02Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjowOTowMlrOHjG9UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjowOTowMlrOHjG9UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3NjIwOQ==", "bodyText": "Consider calling this visitCondition.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506576209", "createdAt": "2020-10-16T16:09:02Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 799}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjEzMTkz", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510613193", "createdAt": "2020-10-16T16:12:57Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxMjo1N1rOHjHGFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxMjo1N1rOHjHGFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3ODQ1Mw==", "bodyText": "Do ya need this?", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506578453", "createdAt": "2020-10-16T16:12:57Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjE1Mjkx", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510615291", "createdAt": "2020-10-16T16:15:26Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxNToyN1rOHjHL0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxNToyN1rOHjHL0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3OTkyMA==", "bodyText": "Pull out some of these inline operations when calling this method, it's hard to read.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506579920", "createdAt": "2020-10-16T16:15:27Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjE2OTAz", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510616903", "createdAt": "2020-10-16T16:17:26Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxNzoyNlrOHjHQiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxNzoyNlrOHjHQiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4MTEzMQ==", "bodyText": "Since MethodWriter.getType(irFlipDefIndexNode.getChildNode().getExpressionType())) is repeated, and it's fine to reuse, let's pull it out.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506581131", "createdAt": "2020-10-16T16:17:26Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        } else {\n+            methodWriter.putField(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreBraceDef(StoreBraceDefNode irStoreBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreBraceDefNode.getIndexType()),\n+                MethodWriter.getType(irStoreBraceDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(\"arrayStore\", methodType, DefBootstrap.ARRAY_STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreBrace(StoreBraceNode irStoreBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceNode.getLocation());\n+        methodWriter.arrayStore(MethodWriter.getType(irStoreBraceNode.getStoreType()));\n+    }\n+\n+    @Override\n+    public void visitInvokeCallDef(InvokeCallDefNode irInvokeCallDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallDefNode.getLocation());\n+\n+        // its possible to have unknown functional interfaces\n+        // as arguments that require captures; the set of\n+        // captures with call arguments is ambiguous so\n+        // additional information is encoded to indicate\n+        // which are values are arguments and which are captures\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n+\n+        // add an Object class as a placeholder type for the receiver\n+        typeParameters.add(Object.class);\n+\n+        for (int i = 0; i < irInvokeCallDefNode.getArgumentNodes().size(); ++i) {\n+            ExpressionNode irArgumentNode = irInvokeCallDefNode.getArgumentNodes().get(i);\n+            visit(irArgumentNode, writeScope);\n+\n+            typeParameters.add(irArgumentNode.getExpressionType());\n+\n+            // handle the case for unknown functional interface\n+            // to hint at which values are the call's arguments\n+            // versus which values are captures\n+            if (irArgumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)irArgumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n+\n+                // the encoding uses a char to indicate the number of captures\n+                // where the value is the number of current arguments plus the\n+                // total number of captures for easier capture count tracking\n+                // when resolved at runtime\n+                char encoding = (char)(i + capturedCount);\n+                defCallRecipe.append(encoding);\n+                capturedCount += defInterfaceReferenceNode.getCaptures().size();\n+\n+                for (String capturedName : defInterfaceReferenceNode.getCaptures()) {\n+                    Variable capturedVariable = writeScope.getVariable(capturedName);\n+                    typeParameters.add(capturedVariable.getType());\n+                }\n+            }\n+        }\n+\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irInvokeCallDefNode.getExpressionType()), asmParameterTypes);\n+\n+        boostrapArguments.add(0, defCallRecipe.toString());\n+        methodWriter.invokeDefCall(irInvokeCallDefNode.getName(), methodType, DefBootstrap.METHOD_CALL, boostrapArguments.toArray());\n+    }\n+\n+    @Override\n+    public void visitInvokeCall(InvokeCallNode irInvokeCallNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallNode.getLocation());\n+\n+        if (irInvokeCallNode.getBox().isPrimitive()) {\n+            methodWriter.box(MethodWriter.getType(irInvokeCallNode.getBox()));\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irInvokeCallNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        methodWriter.invokeMethodCall(irInvokeCallNode.getMethod());\n+    }\n+\n+    @Override\n+    public void visitInvokeCallMember(InvokeCallMemberNode irInvokeCallMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallMemberNode.getLocation());\n+\n+        LocalFunction localFunction = irInvokeCallMemberNode.getLocalFunction();\n+        PainlessMethod importedMethod = irInvokeCallMemberNode.getImportedMethod();\n+        PainlessClassBinding classBinding = irInvokeCallMemberNode.getClassBinding();\n+        PainlessInstanceBinding instanceBinding = irInvokeCallMemberNode.getInstanceBinding();\n+        List<ExpressionNode> irArgumentNodes = irInvokeCallMemberNode.getArgumentNodes();\n+\n+        if (localFunction != null) {\n+            if (localFunction.isStatic() == false) {\n+                methodWriter.loadThis();\n+            }\n+\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (localFunction.isStatic()) {\n+                methodWriter.invokeStatic(CLASS_TYPE, localFunction.getAsmMethod());\n+            } else {\n+                methodWriter.invokeVirtual(CLASS_TYPE, localFunction.getAsmMethod());\n+            }\n+        } else if (importedMethod != null) {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            methodWriter.invokeStatic(Type.getType(importedMethod.targetClass),\n+                    new Method(importedMethod.javaMethod.getName(), importedMethod.methodType.toMethodDescriptorString()));\n+        } else if (classBinding != null) {\n+            Type type = Type.getType(classBinding.javaConstructor.getDeclaringClass());\n+            int classBindingOffset = irInvokeCallMemberNode.getClassBindingOffset();\n+            int javaConstructorParameterCount = classBinding.javaConstructor.getParameterCount() - classBindingOffset;\n+            String bindingName = irInvokeCallMemberNode.getBindingName();\n+\n+            Label nonNull = new Label();\n+\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE, bindingName, type);\n+            methodWriter.ifNonNull(nonNull);\n+            methodWriter.loadThis();\n+            methodWriter.newInstance(type);\n+            methodWriter.dup();\n+\n+            if (classBindingOffset == 1) {\n+                methodWriter.loadThis();\n+            }\n+\n+            for (int argument = 0; argument < javaConstructorParameterCount; ++argument) {\n+                visit(irArgumentNodes.get(argument), writeScope);\n+            }\n+\n+            methodWriter.invokeConstructor(type, Method.getMethod(classBinding.javaConstructor));\n+            methodWriter.putField(CLASS_TYPE, bindingName, type);\n+\n+            methodWriter.mark(nonNull);\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE, bindingName, type);\n+\n+            for (int argument = 0; argument < classBinding.javaMethod.getParameterCount(); ++argument) {\n+                visit(irArgumentNodes.get(argument + javaConstructorParameterCount), writeScope);\n+            }\n+\n+            methodWriter.invokeVirtual(type, Method.getMethod(classBinding.javaMethod));\n+        } else if (instanceBinding != null) {\n+            Type type = Type.getType(instanceBinding.targetInstance.getClass());\n+            String bindingName = irInvokeCallMemberNode.getBindingName();\n+\n+            methodWriter.loadThis();\n+            methodWriter.getStatic(CLASS_TYPE, bindingName, type);\n+\n+            for (int argument = 0; argument < instanceBinding.javaMethod.getParameterCount(); ++argument) {\n+                visit(irArgumentNodes.get(argument), writeScope);\n+            }\n+\n+            methodWriter.invokeVirtual(type, Method.getMethod(instanceBinding.javaMethod));\n+        } else {\n+            throw new IllegalStateException(\"invalid unbound call\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitFlipArrayIndex(FlipArrayIndexNode irFlipArrayIndexNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irFlipArrayIndexNode.getChildNode(), writeScope);\n+\n+        Label noFlip = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifZCmp(Opcodes.IFGE, noFlip);\n+        methodWriter.swap();\n+        methodWriter.dupX1();\n+        methodWriter.arrayLength();\n+        methodWriter.visitInsn(Opcodes.IADD);\n+        methodWriter.mark(noFlip);\n+    }\n+\n+    @Override\n+    public void visitFlipCollectionIndex(FlipCollectionIndexNode irFlipCollectionIndexNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irFlipCollectionIndexNode.getChildNode(), writeScope);\n+\n+        Label noFlip = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifZCmp(Opcodes.IFGE, noFlip);\n+        methodWriter.swap();\n+        methodWriter.dupX1();\n+        methodWriter.invokeInterface(WriterConstants.COLLECTION_TYPE, WriterConstants.COLLECTION_SIZE);\n+        methodWriter.visitInsn(Opcodes.IADD);\n+        methodWriter.mark(noFlip);\n+    }\n+\n+    @Override\n+    public void visitFlipDefIndex(FlipDefIndexNode irFlipDefIndexNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        methodWriter.dup();\n+        visit(irFlipDefIndexNode.getChildNode(), writeScope);\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irFlipDefIndexNode.getChildNode().getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irFlipDefIndexNode.getChildNode().getExpressionType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1645}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjIwMDU0", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510620054", "createdAt": "2020-10-16T16:21:23Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoyMToyM1rOHjHZjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoyMToyM1rOHjHZjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4MzQzNg==", "bodyText": "Break this out, there's a lot of text in this statement.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506583436", "createdAt": "2020-10-16T16:21:23Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 502}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI0NDgy", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510624482", "createdAt": "2020-10-16T16:27:17Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoyNzoxN1rOHjHmrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoyNzoxN1rOHjHmrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4Njc5OA==", "bodyText": "A bit too much going on here.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506586798", "createdAt": "2020-10-16T16:27:17Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 995}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI1ODk5", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510625899", "createdAt": "2020-10-16T16:29:11Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoyOToxMVrOHjHrBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoyOToxMVrOHjHrBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4NzkxMQ==", "bodyText": "Break this line up.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506587911", "createdAt": "2020-10-16T16:29:11Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        } else {\n+            methodWriter.putField(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreBraceDef(StoreBraceDefNode irStoreBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreBraceDefNode.getIndexType()),\n+                MethodWriter.getType(irStoreBraceDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(\"arrayStore\", methodType, DefBootstrap.ARRAY_STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreBrace(StoreBraceNode irStoreBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreBraceNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreBraceNode.getLocation());\n+        methodWriter.arrayStore(MethodWriter.getType(irStoreBraceNode.getStoreType()));\n+    }\n+\n+    @Override\n+    public void visitInvokeCallDef(InvokeCallDefNode irInvokeCallDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallDefNode.getLocation());\n+\n+        // its possible to have unknown functional interfaces\n+        // as arguments that require captures; the set of\n+        // captures with call arguments is ambiguous so\n+        // additional information is encoded to indicate\n+        // which are values are arguments and which are captures\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n+\n+        // add an Object class as a placeholder type for the receiver\n+        typeParameters.add(Object.class);\n+\n+        for (int i = 0; i < irInvokeCallDefNode.getArgumentNodes().size(); ++i) {\n+            ExpressionNode irArgumentNode = irInvokeCallDefNode.getArgumentNodes().get(i);\n+            visit(irArgumentNode, writeScope);\n+\n+            typeParameters.add(irArgumentNode.getExpressionType());\n+\n+            // handle the case for unknown functional interface\n+            // to hint at which values are the call's arguments\n+            // versus which values are captures\n+            if (irArgumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)irArgumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n+\n+                // the encoding uses a char to indicate the number of captures\n+                // where the value is the number of current arguments plus the\n+                // total number of captures for easier capture count tracking\n+                // when resolved at runtime\n+                char encoding = (char)(i + capturedCount);\n+                defCallRecipe.append(encoding);\n+                capturedCount += defInterfaceReferenceNode.getCaptures().size();\n+\n+                for (String capturedName : defInterfaceReferenceNode.getCaptures()) {\n+                    Variable capturedVariable = writeScope.getVariable(capturedName);\n+                    typeParameters.add(capturedVariable.getType());\n+                }\n+            }\n+        }\n+\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irInvokeCallDefNode.getExpressionType()), asmParameterTypes);\n+\n+        boostrapArguments.add(0, defCallRecipe.toString());\n+        methodWriter.invokeDefCall(irInvokeCallDefNode.getName(), methodType, DefBootstrap.METHOD_CALL, boostrapArguments.toArray());\n+    }\n+\n+    @Override\n+    public void visitInvokeCall(InvokeCallNode irInvokeCallNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallNode.getLocation());\n+\n+        if (irInvokeCallNode.getBox().isPrimitive()) {\n+            methodWriter.box(MethodWriter.getType(irInvokeCallNode.getBox()));\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irInvokeCallNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        methodWriter.invokeMethodCall(irInvokeCallNode.getMethod());\n+    }\n+\n+    @Override\n+    public void visitInvokeCallMember(InvokeCallMemberNode irInvokeCallMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irInvokeCallMemberNode.getLocation());\n+\n+        LocalFunction localFunction = irInvokeCallMemberNode.getLocalFunction();\n+        PainlessMethod importedMethod = irInvokeCallMemberNode.getImportedMethod();\n+        PainlessClassBinding classBinding = irInvokeCallMemberNode.getClassBinding();\n+        PainlessInstanceBinding instanceBinding = irInvokeCallMemberNode.getInstanceBinding();\n+        List<ExpressionNode> irArgumentNodes = irInvokeCallMemberNode.getArgumentNodes();\n+\n+        if (localFunction != null) {\n+            if (localFunction.isStatic() == false) {\n+                methodWriter.loadThis();\n+            }\n+\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (localFunction.isStatic()) {\n+                methodWriter.invokeStatic(CLASS_TYPE, localFunction.getAsmMethod());\n+            } else {\n+                methodWriter.invokeVirtual(CLASS_TYPE, localFunction.getAsmMethod());\n+            }\n+        } else if (importedMethod != null) {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            methodWriter.invokeStatic(Type.getType(importedMethod.targetClass),\n+                    new Method(importedMethod.javaMethod.getName(), importedMethod.methodType.toMethodDescriptorString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1551}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI2NDg1", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510626485", "createdAt": "2020-10-16T16:30:02Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMDowMlrOHjHswQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMDowMlrOHjHswQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4ODM1Mw==", "bodyText": "Pull these out into variables.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506588353", "createdAt": "2020-10-16T16:30:02Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1043}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI3ODU3", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510627857", "createdAt": "2020-10-16T16:31:57Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMTo1N1rOHjHw4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMTo1N1rOHjHw4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTQwOA==", "bodyText": "pull out these arguments.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589408", "createdAt": "2020-10-16T16:31:57Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1244}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI3OTcz", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510627973", "createdAt": "2020-10-16T16:32:07Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMjowN1rOHjHxRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMjowN1rOHjHxRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTUwOQ==", "bodyText": "pull out these arguments", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589509", "createdAt": "2020-10-16T16:32:07Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1247}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI4MzE1", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510628315", "createdAt": "2020-10-16T16:32:38Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMjozOFrOHjHyYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMjozOFrOHjHyYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTc5NA==", "bodyText": "Pull this out.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589794", "createdAt": "2020-10-16T16:32:38Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1298}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI4Mzgy", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510628382", "createdAt": "2020-10-16T16:32:43Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMjo0M1rOHjHykg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozMjo0M1rOHjHykg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTg0Mg==", "bodyText": "Pull this out.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506589842", "createdAt": "2020-10-16T16:32:43Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1301}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjI5NDU2", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510629456", "createdAt": "2020-10-16T16:34:17Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozNDoxN1rOHjH10g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozNDoxN1rOHjH10g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MDY3NA==", "bodyText": "See how difficult it is to make these visits alphabetical.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506590674", "createdAt": "2020-10-16T16:34:17Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1335}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjMwMDIz", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510630023", "createdAt": "2020-10-16T16:35:04Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozNTowNFrOHjH3pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozNTowNFrOHjH3pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MTE0MA==", "bodyText": "pull these out.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506591140", "createdAt": "2020-10-16T16:35:04Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjMxODU4", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510631858", "createdAt": "2020-10-16T16:37:45Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozNzo0NVrOHjH9VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjozNzo0NVrOHjH9VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MjU5Ng==", "bodyText": "pull this out.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506592596", "createdAt": "2020-10-16T16:37:45Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 589}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjMzMzg4", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510633388", "createdAt": "2020-10-16T16:40:02Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDowMlrOHjIBtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDowMlrOHjIBtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MzcxNw==", "bodyText": "lot going on here.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506593717", "createdAt": "2020-10-16T16:40:02Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1360}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjMzNDY0", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510633464", "createdAt": "2020-10-16T16:40:09Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDoxMFrOHjICDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDoxMFrOHjICDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5MzgwNA==", "bodyText": "lot going on here.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506593804", "createdAt": "2020-10-16T16:40:10Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1363}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjMzNzQ2", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510633746", "createdAt": "2020-10-16T16:40:38Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDozOFrOHjIC_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDozOFrOHjIC_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDA0Nw==", "bodyText": "break this up.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506594047", "createdAt": "2020-10-16T16:40:38Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1414}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjMzODU4", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510633858", "createdAt": "2020-10-16T16:40:48Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDo0OFrOHjIDYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MDo0OFrOHjIDYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDE0NA==", "bodyText": "break this up.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506594144", "createdAt": "2020-10-16T16:40:48Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());\n+    }\n+\n+    @Override\n+    public void visitStatic(StaticNode irStaticNode, WriteScope writeScope) {\n+        // do nothing\n+    }\n+\n+    @Override\n+    public void visitLoadVariable(LoadVariableNode irLoadVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Variable variable = writeScope.getVariable(irLoadVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitNullSafeSub(NullSafeSubNode irNullSafeSubNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNullSafeSubNode.getLocation());\n+\n+        Label end = new Label();\n+        methodWriter.dup();\n+        methodWriter.ifNull(end);\n+        visit(irNullSafeSubNode.getChildNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitLoadDotArrayLengthNode(LoadDotArrayLengthNode irLoadDotArrayLengthNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotArrayLengthNode.getLocation());\n+        methodWriter.arrayLength();\n+    }\n+\n+    @Override\n+    public void visitLoadDotDef(LoadDotDefNode irLoadDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadDotDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class));\n+        methodWriter.invokeDefCall(irLoadDotDefNode.getValue(), methodType, DefBootstrap.LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadDot(LoadDotNode irLoadDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadDotNode.getLocation());\n+\n+        PainlessField painlessField = irLoadDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.getStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.getField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadDotShortcut(LoadDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irDotSubShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (!getterPainlessMethod.returnType.equals(getterPainlessMethod.javaMethod.getReturnType())) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadListShortcut(LoadListShortcutNode irLoadListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadListShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadListShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType == getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadMapShortcut(LoadMapShortcutNode irLoadMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadMapShortcutNode.getLocation());\n+\n+        PainlessMethod getterPainlessMethod = irLoadMapShortcutNode.getGetter();\n+        methodWriter.invokeMethodCall(getterPainlessMethod);\n+\n+        if (getterPainlessMethod.returnType != getterPainlessMethod.javaMethod.getReturnType()) {\n+            methodWriter.checkCast(MethodWriter.getType(getterPainlessMethod.returnType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadFieldMember(LoadFieldMemberNode irLoadFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadFieldMemberNode.getLocation());\n+\n+        if (irLoadFieldMemberNode.isStatic()) {\n+            methodWriter.getStatic(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        } else {\n+            methodWriter.loadThis();\n+            methodWriter.getField(CLASS_TYPE,\n+                    irLoadFieldMemberNode.getName(), MethodWriter.getType(irLoadFieldMemberNode.getExpressionType()));\n+        }\n+    }\n+\n+    @Override\n+    public void visitLoadBraceDef(LoadBraceDefNode irLoadBraceDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(irLoadBraceDefNode.getExpressionType()),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irLoadBraceDefNode.getIndexType()));\n+        methodWriter.invokeDefCall(\"arrayLoad\", methodType, DefBootstrap.ARRAY_LOAD);\n+    }\n+\n+    @Override\n+    public void visitLoadBrace(LoadBraceNode irLoadBraceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irLoadBraceNode.getLocation());\n+        methodWriter.arrayLoad(MethodWriter.getType(irLoadBraceNode.getExpressionType()));\n+    }\n+\n+    @Override\n+    public void visitStoreVariable(StoreVariableNode irStoreVariableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreVariableNode.getChildNode(), writeScope);\n+\n+        Variable variable = writeScope.getVariable(irStoreVariableNode.getName());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitStoreDotDef(StoreDotDefNode irStoreDotDefNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotDefNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotDefNode.getLocation());\n+        Type methodType = Type.getMethodType(\n+                MethodWriter.getType(void.class),\n+                MethodWriter.getType(def.class),\n+                MethodWriter.getType(irStoreDotDefNode.getStoreType()));\n+        methodWriter.invokeDefCall(irStoreDotDefNode.getValue(), methodType, DefBootstrap.STORE);\n+    }\n+\n+    @Override\n+    public void visitStoreDot(StoreDotNode irStoreDotNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreDotNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreDotNode.getLocation());\n+\n+        PainlessField painlessField = irStoreDotNode.getField();\n+\n+        if (java.lang.reflect.Modifier.isStatic(painlessField.javaField.getModifiers())) {\n+            methodWriter.putStatic(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        } else {\n+            methodWriter.putField(Type.getType(painlessField.javaField.getDeclaringClass()),\n+                    painlessField.javaField.getName(), MethodWriter.getType(painlessField.typeParameter));\n+        }\n+    }\n+\n+    @Override\n+    public void visitStoreDotShortcut(StoreDotShortcutNode irDotSubShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irDotSubShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irDotSubShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irDotSubShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irDotSubShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreListShortcut(StoreListShortcutNode irStoreListShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreListShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreListShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreListShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreListShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreMapShortcut(StoreMapShortcutNode irStoreMapShortcutNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irStoreMapShortcutNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreMapShortcutNode.getLocation());\n+        methodWriter.invokeMethodCall(irStoreMapShortcutNode.getSetter());\n+        methodWriter.writePop(MethodWriter.getType(irStoreMapShortcutNode.getSetter().returnType).getSize());\n+    }\n+\n+    @Override\n+    public void visitStoreFieldMember(StoreFieldMemberNode irStoreFieldMemberNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        if (irStoreFieldMemberNode.isStatic() == false) {\n+            methodWriter.loadThis();\n+        }\n+\n+        visit(irStoreFieldMemberNode.getChildNode(), writeScope);\n+\n+        methodWriter.writeDebugInfo(irStoreFieldMemberNode.getLocation());\n+\n+        if (irStoreFieldMemberNode.isStatic()) {\n+            methodWriter.putStatic(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));\n+        } else {\n+            methodWriter.putField(CLASS_TYPE,\n+                    irStoreFieldMemberNode.getName(), MethodWriter.getType(irStoreFieldMemberNode.getStoreType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1417}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjM0OTU4", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510634958", "createdAt": "2020-10-16T16:42:24Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MjoyNFrOHjIGhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0MjoyNFrOHjIGhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NDk1MA==", "bodyText": "put some parens around this condition.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506594950", "createdAt": "2020-10-16T16:42:24Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 615}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjM1Mzg3", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510635387", "createdAt": "2020-10-16T16:42:58Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0Mjo1OVrOHjIHuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjo0Mjo1OVrOHjIHuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU5NTI1Nw==", "bodyText": "These got pretty long, pull some variables out.", "url": "https://github.com/elastic/elasticsearch/pull/63512#discussion_r506595257", "createdAt": "2020-10-16T16:42:59Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultIRTreeToASMBytesPhase.java", "diffHunk": "@@ -0,0 +1,1655 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.ScriptClassInfo;\n+import org.elasticsearch.painless.WriterConstants;\n+import org.elasticsearch.painless.api.Augmentation;\n+import org.elasticsearch.painless.ir.BinaryImplNode;\n+import org.elasticsearch.painless.ir.BinaryMathNode;\n+import org.elasticsearch.painless.ir.BlockNode;\n+import org.elasticsearch.painless.ir.BooleanNode;\n+import org.elasticsearch.painless.ir.BreakNode;\n+import org.elasticsearch.painless.ir.CastNode;\n+import org.elasticsearch.painless.ir.CatchNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ComparisonNode;\n+import org.elasticsearch.painless.ir.ConditionalNode;\n+import org.elasticsearch.painless.ir.ConstantNode;\n+import org.elasticsearch.painless.ir.ContinueNode;\n+import org.elasticsearch.painless.ir.DeclarationBlockNode;\n+import org.elasticsearch.painless.ir.DeclarationNode;\n+import org.elasticsearch.painless.ir.DefInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.DoWhileLoopNode;\n+import org.elasticsearch.painless.ir.DupNode;\n+import org.elasticsearch.painless.ir.ElvisNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.FieldNode;\n+import org.elasticsearch.painless.ir.FlipArrayIndexNode;\n+import org.elasticsearch.painless.ir.FlipCollectionIndexNode;\n+import org.elasticsearch.painless.ir.FlipDefIndexNode;\n+import org.elasticsearch.painless.ir.ForEachLoopNode;\n+import org.elasticsearch.painless.ir.ForEachSubArrayNode;\n+import org.elasticsearch.painless.ir.ForEachSubIterableNode;\n+import org.elasticsearch.painless.ir.ForLoopNode;\n+import org.elasticsearch.painless.ir.FunctionNode;\n+import org.elasticsearch.painless.ir.IRNode;\n+import org.elasticsearch.painless.ir.IfElseNode;\n+import org.elasticsearch.painless.ir.IfNode;\n+import org.elasticsearch.painless.ir.InstanceofNode;\n+import org.elasticsearch.painless.ir.InvokeCallDefNode;\n+import org.elasticsearch.painless.ir.InvokeCallMemberNode;\n+import org.elasticsearch.painless.ir.InvokeCallNode;\n+import org.elasticsearch.painless.ir.ListInitializationNode;\n+import org.elasticsearch.painless.ir.LoadBraceDefNode;\n+import org.elasticsearch.painless.ir.LoadBraceNode;\n+import org.elasticsearch.painless.ir.LoadDotArrayLengthNode;\n+import org.elasticsearch.painless.ir.LoadDotDefNode;\n+import org.elasticsearch.painless.ir.LoadDotNode;\n+import org.elasticsearch.painless.ir.LoadDotShortcutNode;\n+import org.elasticsearch.painless.ir.LoadFieldMemberNode;\n+import org.elasticsearch.painless.ir.LoadListShortcutNode;\n+import org.elasticsearch.painless.ir.LoadMapShortcutNode;\n+import org.elasticsearch.painless.ir.LoadVariableNode;\n+import org.elasticsearch.painless.ir.MapInitializationNode;\n+import org.elasticsearch.painless.ir.NewArrayNode;\n+import org.elasticsearch.painless.ir.NewObjectNode;\n+import org.elasticsearch.painless.ir.NullNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.ir.ReturnNode;\n+import org.elasticsearch.painless.ir.StatementExpressionNode;\n+import org.elasticsearch.painless.ir.StatementNode;\n+import org.elasticsearch.painless.ir.StaticNode;\n+import org.elasticsearch.painless.ir.StoreBraceDefNode;\n+import org.elasticsearch.painless.ir.StoreBraceNode;\n+import org.elasticsearch.painless.ir.StoreDotDefNode;\n+import org.elasticsearch.painless.ir.StoreDotNode;\n+import org.elasticsearch.painless.ir.StoreDotShortcutNode;\n+import org.elasticsearch.painless.ir.StoreFieldMemberNode;\n+import org.elasticsearch.painless.ir.StoreListShortcutNode;\n+import org.elasticsearch.painless.ir.StoreMapShortcutNode;\n+import org.elasticsearch.painless.ir.StoreVariableNode;\n+import org.elasticsearch.painless.ir.StringConcatenationNode;\n+import org.elasticsearch.painless.ir.ThrowNode;\n+import org.elasticsearch.painless.ir.TryNode;\n+import org.elasticsearch.painless.ir.TypedCaptureReferenceNode;\n+import org.elasticsearch.painless.ir.TypedInterfaceReferenceNode;\n+import org.elasticsearch.painless.ir.UnaryMathNode;\n+import org.elasticsearch.painless.ir.WhileLoopNode;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.WriteScope;\n+import org.elasticsearch.painless.symbol.WriteScope.Variable;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.commons.Method;\n+import org.objectweb.asm.util.Printer;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+import static org.elasticsearch.painless.WriterConstants.BASE_INTERFACE_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.CLASS_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.EQUALS;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;\n+import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;\n+import static org.elasticsearch.painless.WriterConstants.OBJECTS_TYPE;\n+\n+public class DefaultIRTreeToASMBytesPhase implements IRTreeVisitor<WriteScope> {\n+\n+    protected void visit(IRNode irNode, WriteScope writeScope) {\n+        irNode.visit(this, writeScope);\n+    }\n+\n+    public void visitScript(ClassNode irClassNode) {\n+        WriteScope writeScope = WriteScope.newScriptScope();\n+        visitClass(irClassNode, writeScope);\n+    }\n+\n+    @Override\n+    public void visitClass(ClassNode irClassNode, WriteScope writeScope) {\n+        ScriptScope scriptScope = irClassNode.getScriptScope();\n+        ScriptClassInfo scriptClassInfo = scriptScope.getScriptClassInfo();\n+        BitSet statements = new BitSet(scriptScope.getScriptSource().length());\n+        scriptScope.addStaticConstant(\"$STATEMENTS\", statements);\n+        Printer debugStream = irClassNode.getDebugStream();\n+\n+        // Create the ClassWriter.\n+\n+        int classFrames = org.objectweb.asm.ClassWriter.COMPUTE_FRAMES | org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+        int classAccess = Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL;\n+        String interfaceBase = BASE_INTERFACE_TYPE.getInternalName();\n+        String className = CLASS_TYPE.getInternalName();\n+        String[] classInterfaces = new String[] { interfaceBase };\n+\n+        ClassWriter classWriter = new ClassWriter(scriptScope.getCompilerSettings(), statements, debugStream,\n+                scriptClassInfo.getBaseClass(), classFrames, classAccess, className, classInterfaces);\n+        ClassVisitor classVisitor = classWriter.getClassVisitor();\n+        classVisitor.visitSource(Location.computeSourceName(scriptScope.getScriptName()), null);\n+        writeScope = writeScope.newClassScope(classWriter);\n+\n+        org.objectweb.asm.commons.Method init;\n+\n+        if (scriptClassInfo.getBaseClass().getConstructors().length == 0) {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class).toMethodDescriptorString());\n+        } else {\n+            init = new org.objectweb.asm.commons.Method(\"<init>\", MethodType.methodType(void.class,\n+                    scriptClassInfo.getBaseClass().getConstructors()[0].getParameterTypes()).toMethodDescriptorString());\n+        }\n+\n+        // Write the constructor:\n+        MethodWriter constructor = classWriter.newMethodWriter(Opcodes.ACC_PUBLIC, init);\n+        constructor.visitCode();\n+        constructor.loadThis();\n+        constructor.loadArgs();\n+        constructor.invokeConstructor(Type.getType(scriptClassInfo.getBaseClass()), init);\n+        constructor.returnValue();\n+        constructor.endMethod();\n+\n+        BlockNode irClinitBlockNode = irClassNode.getClinitBlockNode();\n+\n+        if (irClinitBlockNode.getStatementsNodes().isEmpty() == false) {\n+            MethodWriter methodWriter = classWriter.newMethodWriter(\n+                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,\n+                    new Method(\"<clinit>\", Type.getType(void.class), new Type[0]));\n+            visit(irClinitBlockNode, writeScope.newMethodScope(methodWriter).newBlockScope());\n+            methodWriter.returnValue();\n+            methodWriter.endMethod();\n+        }\n+\n+        // Write all fields:\n+        for (FieldNode irFieldNode : irClassNode.getFieldsNodes()) {\n+            visit(irFieldNode, writeScope);\n+        }\n+\n+        // Write all functions:\n+        for (FunctionNode irFunctionNode : irClassNode.getFunctionsNodes()) {\n+            visit(irFunctionNode, writeScope);\n+        }\n+\n+        // End writing the class and store the generated bytes.\n+        classVisitor.visitEnd();\n+        irClassNode.setBytes(classWriter.getClassBytes());\n+    }\n+\n+    @Override\n+    public void visitFunction(FunctionNode irFunctionNode, WriteScope writeScope) {\n+        int access = Opcodes.ACC_PUBLIC;\n+\n+        if (irFunctionNode.isStatic()) {\n+            access |= Opcodes.ACC_STATIC;\n+        }\n+\n+        if (irFunctionNode.hasVarArgs()) {\n+            access |= Opcodes.ACC_VARARGS;\n+        }\n+\n+        if (irFunctionNode.isSynthetic()) {\n+            access |= Opcodes.ACC_SYNTHETIC;\n+        }\n+\n+        Type asmReturnType = MethodWriter.getType(irFunctionNode.getReturnType());\n+        List<Class<?>> typeParameters = irFunctionNode.getTypeParameters();\n+        Type[] asmParameterTypes = new Type[typeParameters.size()];\n+\n+        for (int index = 0; index < asmParameterTypes.length; ++index) {\n+            asmParameterTypes[index] = MethodWriter.getType(typeParameters.get(index));\n+        }\n+\n+        Method method = new Method(irFunctionNode.getName(), asmReturnType, asmParameterTypes);\n+\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        MethodWriter methodWriter = classWriter.newMethodWriter(access, method);\n+        writeScope = writeScope.newMethodScope(methodWriter);\n+\n+        if (irFunctionNode.isStatic() == false) {\n+            writeScope.defineInternalVariable(Object.class, \"this\");\n+        }\n+\n+        List<String> parameterNames = irFunctionNode.getParameterNames();\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            writeScope.defineVariable(typeParameters.get(index), parameterNames.get(index));\n+        }\n+\n+        methodWriter.visitCode();\n+\n+        if (irFunctionNode.getMaxLoopCounter() > 0) {\n+            // if there is infinite loop protection, we do this once:\n+            // int #loop = settings.getMaxLoopCounter()\n+\n+            Variable loop = writeScope.defineInternalVariable(int.class, \"loop\");\n+\n+            methodWriter.push(irFunctionNode.getMaxLoopCounter());\n+            methodWriter.visitVarInsn(Opcodes.ISTORE, loop.getSlot());\n+        }\n+\n+        visit(irFunctionNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        methodWriter.endMethod();\n+    }\n+\n+    @Override\n+    public void visitField(FieldNode irFieldNode, WriteScope writeScope) {\n+        ClassWriter classWriter = writeScope.getClassWriter();\n+        classWriter.getClassVisitor().visitField(\n+                ClassWriter.buildAccess(irFieldNode.getModifiers(), true), irFieldNode.getName(),\n+                Type.getType(irFieldNode.getFieldType()).getDescriptor(), null, null).visitEnd();\n+    }\n+\n+    @Override\n+    public void visitBlock(BlockNode irBlockNode, WriteScope writeScope) {\n+        for (StatementNode statementNode : irBlockNode.getStatementsNodes()) {\n+            visit(statementNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(IfNode irIfNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfNode.getLocation());\n+\n+        Label fals = new Label();\n+\n+        visit(irIfNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfNode.getBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(fals);\n+    }\n+\n+    @Override\n+    public void visitIfElse(IfElseNode irIfElseNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irIfElseNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irIfElseNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+        visit(irIfElseNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irIfElseNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(end);\n+        }\n+\n+        methodWriter.mark(fals);\n+        visit(irIfElseNode.getElseBlockNode(), writeScope.newBlockScope());\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(WhileLoopNode irWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        if (irWhileLoopNode.isContinuous() == false) {\n+            visit(irWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irWhileLoopNode.getLocation());\n+        }\n+\n+        BlockNode irBlockNode = irWhileLoopNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irBlockNode == null || irBlockNode.doAllEscape() == false) {\n+            methodWriter.goTo(begin);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDoWhileLoop(DoWhileLoopNode irDoWhileLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDoWhileLoopNode.getLocation());\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(start);\n+        visit(irDoWhileLoopNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.mark(begin);\n+\n+        if (irDoWhileLoopNode.isContinuous() == false) {\n+            visit(irDoWhileLoopNode.getConditionNode(), writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irDoWhileLoopNode.getLocation());\n+        }\n+\n+        methodWriter.goTo(start);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForLoop(ForLoopNode irForLoopNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForLoopNode.getLocation());\n+\n+        IRNode irInitializerNode = irForLoopNode.getInitializerNode();\n+        ExpressionNode irConditionNode = irForLoopNode.getConditionNode();\n+        ExpressionNode irAfterthoughtNode = irForLoopNode.getAfterthoughtNode();\n+        BlockNode irBlockNode = irForLoopNode.getBlockNode();\n+\n+        writeScope = writeScope.newBlockScope();\n+\n+        Label start = new Label();\n+        Label begin = irAfterthoughtNode == null ? start : new Label();\n+        Label end = new Label();\n+\n+        if (irInitializerNode instanceof DeclarationBlockNode) {\n+            visit(irInitializerNode, writeScope);\n+        } else if (irInitializerNode instanceof ExpressionNode) {\n+            ExpressionNode irExpressionNode = (ExpressionNode)irInitializerNode;\n+\n+            visit(irExpressionNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irExpressionNode.getExpressionType()).getSize());\n+        }\n+\n+        methodWriter.mark(start);\n+\n+        if (irConditionNode != null && irForLoopNode.isContinuous() == false) {\n+            visit(irConditionNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, end);\n+        }\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForLoopNode.getLocation());\n+        }\n+\n+        boolean allEscape = false;\n+\n+        if (irBlockNode != null) {\n+            allEscape = irBlockNode.doAllEscape();\n+            visit(irBlockNode, writeScope.newLoopScope(begin, end));\n+        }\n+\n+        if (irAfterthoughtNode != null) {\n+            methodWriter.mark(begin);\n+            visit(irAfterthoughtNode, writeScope);\n+            methodWriter.writePop(MethodWriter.getType(irAfterthoughtNode.getExpressionType()).getSize());\n+        }\n+\n+        if (irAfterthoughtNode != null || allEscape == false) {\n+            methodWriter.goTo(start);\n+        }\n+\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachLoop(ForEachLoopNode irForEachLoopNode, WriteScope writeScope) {\n+        visit(irForEachLoopNode.getConditionNode(), writeScope.newBlockScope());\n+    }\n+\n+    @Override\n+    public void visitForEachSubArrayLoop(ForEachSubArrayNode irForEachSubArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubArrayNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irForEachSubArrayNode.getVariableType(), irForEachSubArrayNode.getVariableName());\n+        Variable array = writeScope.defineInternalVariable(irForEachSubArrayNode.getArrayType(), irForEachSubArrayNode.getArrayName());\n+        Variable index = writeScope.defineInternalVariable(irForEachSubArrayNode.getIndexType(), irForEachSubArrayNode.getIndexName());\n+\n+        visit(irForEachSubArrayNode.getConditionNode(), writeScope);\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ISTORE), array.getSlot());\n+        methodWriter.push(-1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ISTORE), index.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitIincInsn(index.getSlot(), 1);\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.arrayLength();\n+        methodWriter.ifICmp(MethodWriter.GE, end);\n+\n+        methodWriter.visitVarInsn(array.getAsmType().getOpcode(Opcodes.ILOAD), array.getSlot());\n+        methodWriter.visitVarInsn(index.getAsmType().getOpcode(Opcodes.ILOAD), index.getSlot());\n+        methodWriter.arrayLoad(MethodWriter.getType(irForEachSubArrayNode.getIndexedType()));\n+        methodWriter.writeCast(irForEachSubArrayNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubArrayNode.getLocation());\n+        }\n+\n+        visit(irForEachSubArrayNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitForEachSubIterableLoop(ForEachSubIterableNode irForEachSubIterableNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irForEachSubIterableNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(\n+                irForEachSubIterableNode.getVariableType(), irForEachSubIterableNode.getVariableName());\n+        Variable iterator = writeScope.defineInternalVariable(\n+                irForEachSubIterableNode.getIteratorType(), irForEachSubIterableNode.getIteratorName());\n+\n+        visit(irForEachSubIterableNode.getConditionNode(), writeScope);\n+\n+        if (irForEachSubIterableNode.getMethod() == null) {\n+            org.objectweb.asm.Type methodType = org.objectweb.asm.Type\n+                    .getMethodType(org.objectweb.asm.Type.getType(Iterator.class), org.objectweb.asm.Type.getType(Object.class));\n+            methodWriter.invokeDefCall(\"iterator\", methodType, DefBootstrap.ITERATOR);\n+        } else {\n+            methodWriter.invokeMethodCall(irForEachSubIterableNode.getMethod());\n+        }\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ISTORE), iterator.getSlot());\n+\n+        Label begin = new Label();\n+        Label end = new Label();\n+\n+        methodWriter.mark(begin);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);\n+        methodWriter.ifZCmp(MethodWriter.EQ, end);\n+\n+        methodWriter.visitVarInsn(iterator.getAsmType().getOpcode(Opcodes.ILOAD), iterator.getSlot());\n+        methodWriter.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);\n+        methodWriter.writeCast(irForEachSubIterableNode.getCast());\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        Variable loop = writeScope.getInternalVariable(\"loop\");\n+\n+        if (loop != null) {\n+            methodWriter.writeLoopCounter(loop.getSlot(), irForEachSubIterableNode.getLocation());\n+        }\n+\n+        visit(irForEachSubIterableNode.getBlockNode(), writeScope.newLoopScope(begin, end));\n+        methodWriter.goTo(begin);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitDeclarationBlock(DeclarationBlockNode irDeclarationBlockNode, WriteScope writeScope) {\n+        for (DeclarationNode declarationNode : irDeclarationBlockNode.getDeclarationsNodes()) {\n+            visit(declarationNode, writeScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(DeclarationNode irDeclarationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irDeclarationNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irDeclarationNode.getDeclarationType(), irDeclarationNode.getName());\n+\n+        if (irDeclarationNode.getExpressionNode() ==  null) {\n+            Class<?> sort = variable.getType();\n+\n+            if (sort == void.class || sort == boolean.class || sort == byte.class ||\n+                    sort == short.class || sort == char.class || sort == int.class) {\n+                methodWriter.push(0);\n+            } else if (sort == long.class) {\n+                methodWriter.push(0L);\n+            } else if (sort == float.class) {\n+                methodWriter.push(0F);\n+            } else if (sort == double.class) {\n+                methodWriter.push(0D);\n+            } else {\n+                methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+            }\n+        } else {\n+            visit(irDeclarationNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+    }\n+\n+    @Override\n+    public void visitReturn(ReturnNode irReturnNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irReturnNode.getLocation());\n+\n+        if (irReturnNode.getExpressionNode() != null) {\n+            visit(irReturnNode.getExpressionNode(), writeScope);\n+        }\n+\n+        methodWriter.returnValue();\n+    }\n+\n+    @Override\n+    public void visitStatementExpression(StatementExpressionNode irStatementExpressionNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irStatementExpressionNode.getLocation());\n+        visit(irStatementExpressionNode.getExpressionNode(), writeScope);\n+        methodWriter.writePop(MethodWriter.getType(irStatementExpressionNode.getExpressionNode().getExpressionType()).getSize());\n+    }\n+\n+    @Override\n+    public void visitTry(TryNode irTryNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irTryNode.getLocation());\n+\n+        Label tryBeginLabel = new Label();\n+        Label tryEndLabel = new Label();\n+        Label catchesEndLabel = new Label();\n+\n+        methodWriter.mark(tryBeginLabel);\n+\n+        visit(irTryNode.getBlockNode(), writeScope.newBlockScope());\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false) {\n+            methodWriter.goTo(catchesEndLabel);\n+        }\n+\n+        methodWriter.mark(tryEndLabel);\n+\n+        List<CatchNode> catchNodes = irTryNode.getCatchNodes();\n+\n+        for (int i = 0; i < catchNodes.size(); ++i) {\n+            CatchNode irCatchNode = catchNodes.get(i);\n+            Label catchJumpLabel = catchNodes.size() > 1 && i < catchNodes.size() - 1 ? catchesEndLabel : null;\n+            visit(irCatchNode, writeScope.newTryScope(tryBeginLabel, tryEndLabel, catchJumpLabel));\n+        }\n+\n+        if (irTryNode.getBlockNode().doAllEscape() == false || catchNodes.size() > 1) {\n+            methodWriter.mark(catchesEndLabel);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(CatchNode irCatchNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irCatchNode.getLocation());\n+\n+        Variable variable = writeScope.defineVariable(irCatchNode.getExceptionType(), irCatchNode.getSymbol());\n+\n+        Label jump = new Label();\n+\n+        methodWriter.mark(jump);\n+        methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ISTORE), variable.getSlot());\n+\n+        BlockNode irBlockNode = irCatchNode.getBlockNode();\n+\n+        if (irBlockNode != null) {\n+            visit(irBlockNode, writeScope.newBlockScope(true));\n+        }\n+\n+        methodWriter.visitTryCatchBlock(\n+                writeScope.getTryBeginLabel(), writeScope.getTryEndLabel(), jump, variable.getAsmType().getInternalName());\n+\n+        if (writeScope.getCatchesEndLabel() != null && (irBlockNode == null || irBlockNode.doAllEscape() == false)) {\n+            methodWriter.goTo(writeScope.getCatchesEndLabel());\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(ThrowNode irThrowNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeStatementOffset(irThrowNode.getLocation());\n+        visit(irThrowNode.getExpressionNode(), writeScope);\n+        methodWriter.throwException();\n+    }\n+\n+    @Override\n+    public void visitContinue(ContinueNode irContinueNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getContinueLabel());\n+    }\n+\n+    @Override\n+    public void visitBreak(BreakNode irBreakNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.goTo(writeScope.getBreakLabel());\n+    }\n+\n+    @Override\n+    public void visitBinaryImpl(BinaryImplNode irBinaryImplNode, WriteScope writeScope) {\n+        visit(irBinaryImplNode.getLeftNode(), writeScope);\n+        visit(irBinaryImplNode.getRightNode(), writeScope);\n+    }\n+\n+    @Override\n+    public void visitUnaryMath(UnaryMathNode irUnaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irUnaryMathNode.getLocation());\n+\n+        Operation operation = irUnaryMathNode.getOperation();\n+\n+        if (operation == Operation.NOT) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        } else {\n+            visit(irUnaryMathNode.getChildNode(), writeScope);\n+\n+            // Def calls adopt the wanted return value. If there was a narrowing cast,\n+            // we need to flag that so that it's done at runtime.\n+            int defFlags = 0;\n+\n+            if (irUnaryMathNode.getOriginallyExplicit()) {\n+                defFlags |= DefBootstrap.OPERATOR_EXPLICIT_CAST;\n+            }\n+\n+            Type actualType = MethodWriter.getType(irUnaryMathNode.getExpressionType());\n+            Type childType = MethodWriter.getType(irUnaryMathNode.getChildNode().getExpressionType());\n+\n+            Class<?> unaryType = irUnaryMathNode.getUnaryType();\n+\n+            if (operation == Operation.BWNOT) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"not\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    if (unaryType == int.class) {\n+                        methodWriter.push(-1);\n+                    } else if (unaryType == long.class) {\n+                        methodWriter.push(-1L);\n+                    } else {\n+                        throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                                \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+                    }\n+\n+                    methodWriter.math(MethodWriter.XOR, actualType);\n+                }\n+            } else if (operation == Operation.SUB) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"neg\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                } else {\n+                    methodWriter.math(MethodWriter.NEG, actualType);\n+                }\n+            } else if (operation == Operation.ADD) {\n+                if (unaryType == def.class) {\n+                    org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(actualType, childType);\n+                    methodWriter.invokeDefCall(\"plus\", descriptor, DefBootstrap.UNARY_OPERATOR, defFlags);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected unary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irUnaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinaryMath(BinaryMathNode irBinaryMathNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBinaryMathNode.getLocation());\n+\n+        Operation operation = irBinaryMathNode.getOperation();\n+        ExpressionNode irLeftNode = irBinaryMathNode.getLeftNode();\n+        ExpressionNode irRightNode = irBinaryMathNode.getRightNode();\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            visit(irRightNode, writeScope);\n+            methodWriter.push(irBinaryMathNode.getRegexLimit());\n+            visit(irLeftNode, writeScope);\n+            methodWriter.invokeStatic(org.objectweb.asm.Type.getType(Augmentation.class), WriterConstants.PATTERN_MATCHER);\n+\n+            if (operation == Operation.FIND) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_FIND);\n+            } else if (operation == Operation.MATCH) {\n+                methodWriter.invokeVirtual(org.objectweb.asm.Type.getType(Matcher.class), WriterConstants.MATCHER_MATCHES);\n+            } else {\n+                throw new IllegalStateException(\"unexpected binary math operation [\" + operation + \"] \" +\n+                        \"for type [\" + irBinaryMathNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            visit(irLeftNode, writeScope);\n+            visit(irRightNode, writeScope);\n+\n+            if (irBinaryMathNode.getBinaryType() == def.class ||\n+                    (irBinaryMathNode.getShiftType() != null && irBinaryMathNode.getShiftType() == def.class)) {\n+                methodWriter.writeDynamicBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(),\n+                        irLeftNode.getExpressionType(), irRightNode.getExpressionType(), operation, irBinaryMathNode.getFlags());\n+            } else {\n+                methodWriter.writeBinaryInstruction(irBinaryMathNode.getLocation(), irBinaryMathNode.getExpressionType(), operation);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitStringConcatenation(StringConcatenationNode irStringConcatenationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irStringConcatenationNode.getLocation());\n+        methodWriter.writeNewStrings();\n+\n+        for (ExpressionNode argumentNode : irStringConcatenationNode.getArgumentNodes()) {\n+            visit(argumentNode, writeScope);\n+            methodWriter.writeAppendStrings(argumentNode.getExpressionType());\n+        }\n+\n+        methodWriter.writeToStrings();\n+    }\n+\n+    @Override\n+    public void visitBoolean(BooleanNode irBooleanNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irBooleanNode.getLocation());\n+\n+        Operation operation = irBooleanNode.getOperation();\n+        ExpressionNode irLeftNode = irBooleanNode.getLeftNode();\n+        ExpressionNode irRightNode = irBooleanNode.getRightNode();\n+\n+        if (operation == Operation.AND) {\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else if (operation == Operation.OR) {\n+            Label tru = new Label();\n+            Label fals = new Label();\n+            Label end = new Label();\n+\n+            visit(irLeftNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFNE, tru);\n+            visit(irRightNode, writeScope);\n+            methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+            methodWriter.mark(tru);\n+            methodWriter.push(true);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(fals);\n+            methodWriter.push(false);\n+            methodWriter.mark(end);\n+        } else {\n+            throw new IllegalStateException(\"unexpected boolean operation [\" + operation + \"] \" +\n+                    \"for type [\" + irBooleanNode.getExpressionCanonicalTypeName() + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitComparison(ComparisonNode irComparisonNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irComparisonNode.getLocation());\n+\n+        Operation operation = irComparisonNode.getOperation();\n+        ExpressionNode irLeftNode = irComparisonNode.getLeftNode();\n+        ExpressionNode irRightNode = irComparisonNode.getRightNode();\n+\n+        visit(irLeftNode, writeScope);\n+\n+        if (irRightNode instanceof NullNode == false) {\n+            visit(irRightNode, writeScope);\n+        }\n+\n+        Label jump = new Label();\n+        Label end = new Label();\n+\n+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR);\n+        boolean ne = (operation == Operation.NE || operation == Operation.NER);\n+        boolean lt  = operation == Operation.LT;\n+        boolean lte = operation == Operation.LTE;\n+        boolean gt  = operation == Operation.GT;\n+        boolean gte = operation == Operation.GTE;\n+\n+        boolean writejump = true;\n+\n+        Class<?> comparisonType = irComparisonNode.getComparisonType();\n+        Type type = MethodWriter.getType(comparisonType);\n+\n+        if (comparisonType == void.class || comparisonType == byte.class\n+                || comparisonType == short.class || comparisonType == char.class) {\n+            throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                    \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+        } else if (comparisonType == boolean.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else if (comparisonType == int.class || comparisonType == long.class\n+                || comparisonType == float.class || comparisonType == double.class) {\n+            if (eq) methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+            else if (ne) methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+            else if (lt) methodWriter.ifCmp(type, MethodWriter.LT, jump);\n+            else if (lte) methodWriter.ifCmp(type, MethodWriter.LE, jump);\n+            else if (gt) methodWriter.ifCmp(type, MethodWriter.GT, jump);\n+            else if (gte) methodWriter.ifCmp(type, MethodWriter.GE, jump);\n+            else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+\n+        } else if (comparisonType == def.class) {\n+            Type booleanType = Type.getType(boolean.class);\n+            Type descriptor = Type.getMethodType(booleanType,\n+                    MethodWriter.getType(irLeftNode.getExpressionType()), MethodWriter.getType(irRightNode.getExpressionType()));\n+\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.EQ) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (irLeftNode instanceof NullNode == false && operation == Operation.NE) {\n+                    methodWriter.invokeDefCall(\"eq\", descriptor, DefBootstrap.BINARY_OPERATOR, DefBootstrap.OPERATOR_ALLOWS_NULL);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else if (lt) {\n+                methodWriter.invokeDefCall(\"lt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (lte) {\n+                methodWriter.invokeDefCall(\"lte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gt) {\n+                methodWriter.invokeDefCall(\"gt\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else if (gte) {\n+                methodWriter.invokeDefCall(\"gte\", descriptor, DefBootstrap.BINARY_OPERATOR, 0);\n+                writejump = false;\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        } else {\n+            if (eq) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNull(jump);\n+                } else if (operation == Operation.EQ) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    writejump = false;\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.EQ, jump);\n+                }\n+            } else if (ne) {\n+                if (irRightNode instanceof NullNode) {\n+                    methodWriter.ifNonNull(jump);\n+                } else if (operation == Operation.NE) {\n+                    methodWriter.invokeStatic(OBJECTS_TYPE, EQUALS);\n+                    methodWriter.ifZCmp(MethodWriter.EQ, jump);\n+                } else {\n+                    methodWriter.ifCmp(type, MethodWriter.NE, jump);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected comparison operation [\" + operation + \"] \" +\n+                        \"for type [\" + irComparisonNode.getExpressionCanonicalTypeName() + \"]\");\n+            }\n+        }\n+\n+        if (writejump) {\n+            methodWriter.push(false);\n+            methodWriter.goTo(end);\n+            methodWriter.mark(jump);\n+            methodWriter.push(true);\n+            methodWriter.mark(end);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCast(CastNode irCastNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        visit(irCastNode.getChildNode(), writeScope);\n+        methodWriter.writeDebugInfo(irCastNode.getLocation());\n+        methodWriter.writeCast(irCastNode.getCast());\n+    }\n+\n+    @Override\n+    public void visitInstanceof(InstanceofNode irInstanceofNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+\n+        ExpressionNode irChildNode = irInstanceofNode.getChildNode();\n+\n+        visit(irChildNode, writeScope);\n+\n+        Class<?> instanceType = irInstanceofNode.getInstanceType();\n+        Class<?> expressionType = irInstanceofNode.getExpressionType();\n+\n+        if (irInstanceofNode.getInstanceType() == def.class) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(true);\n+        } else if (irChildNode.getExpressionType().isPrimitive()) {\n+            methodWriter.writePop(MethodWriter.getType(expressionType).getSize());\n+            methodWriter.push(PainlessLookupUtility.typeToBoxedType(instanceType).isAssignableFrom(\n+                    PainlessLookupUtility.typeToBoxedType(irChildNode.getExpressionType())));\n+        } else {\n+            methodWriter.instanceOf(MethodWriter.getType(PainlessLookupUtility.typeToBoxedType(instanceType)));\n+        }\n+    }\n+\n+    @Override\n+    public void visitConditional(ConditionalNode irConditionalNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irConditionalNode.getLocation());\n+\n+        Label fals = new Label();\n+        Label end = new Label();\n+\n+        visit(irConditionalNode.getConditionNode(), writeScope);\n+        methodWriter.ifZCmp(Opcodes.IFEQ, fals);\n+\n+        visit(irConditionalNode.getLeftNode(), writeScope);\n+        methodWriter.goTo(end);\n+        methodWriter.mark(fals);\n+        visit(irConditionalNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitElvis(ElvisNode irElvisNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irElvisNode.getLocation());\n+\n+        Label end = new Label();\n+\n+        visit(irElvisNode.getLeftNode(), writeScope);\n+        methodWriter.dup();\n+        methodWriter.ifNonNull(end);\n+        methodWriter.pop();\n+        visit(irElvisNode.getRightNode(), writeScope);\n+        methodWriter.mark(end);\n+    }\n+\n+    @Override\n+    public void visitListInitialization(ListInitializationNode irListInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irListInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irListInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irListInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (ExpressionNode irArgumentNode : irListInitializationNode.getArgumentNodes()) {\n+            methodWriter.dup();\n+            visit(irArgumentNode, writeScope);\n+            methodWriter.invokeMethodCall(irListInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitMapInitialization(MapInitializationNode irMapInitializationNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irMapInitializationNode.getLocation());\n+\n+        PainlessConstructor painlessConstructor = irMapInitializationNode.getConstructor();\n+        methodWriter.newInstance(MethodWriter.getType(irMapInitializationNode.getExpressionType()));\n+        methodWriter.dup();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+\n+        for (int index = 0; index < irMapInitializationNode.getArgumentsSize(); ++index) {\n+            methodWriter.dup();\n+            visit(irMapInitializationNode.getKeyNode(index), writeScope);\n+            visit(irMapInitializationNode.getValueNode(index), writeScope);\n+            methodWriter.invokeMethodCall(irMapInitializationNode.getMethod());\n+            methodWriter.pop();\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewArray(NewArrayNode irNewArrayNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewArrayNode.getLocation());\n+\n+        List<ExpressionNode> irArgumentNodes = irNewArrayNode.getArgumentNodes();\n+        Class<?> expressionType = irNewArrayNode.getExpressionType();\n+\n+        if (irNewArrayNode.getInitialize()) {\n+            methodWriter.push(irNewArrayNode.getArgumentNodes().size());\n+            methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+\n+            for (int index = 0; index < irArgumentNodes.size(); ++index) {\n+                ExpressionNode irArgumentNode = irArgumentNodes.get(index);\n+\n+                methodWriter.dup();\n+                methodWriter.push(index);\n+                visit(irArgumentNode, writeScope);\n+                methodWriter.arrayStore(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        } else {\n+            for (ExpressionNode irArgumentNode : irArgumentNodes) {\n+                visit(irArgumentNode, writeScope);\n+            }\n+\n+            if (irArgumentNodes.size() > 1) {\n+                methodWriter.visitMultiANewArrayInsn(MethodWriter.getType(expressionType).getDescriptor(), irArgumentNodes.size());\n+            } else {\n+                methodWriter.newArray(MethodWriter.getType(expressionType.getComponentType()));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewObject(NewObjectNode irNewObjectNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irNewObjectNode.getLocation());\n+\n+        methodWriter.newInstance(MethodWriter.getType(irNewObjectNode.getExpressionType()));\n+\n+        if (irNewObjectNode.getRead()) {\n+            methodWriter.dup();\n+        }\n+\n+        for (ExpressionNode irArgumentNode : irNewObjectNode.getArgumentNodes()) {\n+            visit(irArgumentNode, writeScope);\n+        }\n+\n+        PainlessConstructor painlessConstructor = irNewObjectNode.getConstructor();\n+        methodWriter.invokeConstructor(\n+                Type.getType(painlessConstructor.javaConstructor.getDeclaringClass()),\n+                Method.getMethod(painlessConstructor.javaConstructor));\n+    }\n+\n+    @Override\n+    public void visitConstant(ConstantNode irConstantNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        Object constant = irConstantNode.getConstant();\n+\n+        if      (constant instanceof String)    methodWriter.push((String)constant);\n+        else if (constant instanceof Double)    methodWriter.push((double)constant);\n+        else if (constant instanceof Float)     methodWriter.push((float)constant);\n+        else if (constant instanceof Long)      methodWriter.push((long)constant);\n+        else if (constant instanceof Integer)   methodWriter.push((int)constant);\n+        else if (constant instanceof Character) methodWriter.push((char)constant);\n+        else if (constant instanceof Short)     methodWriter.push((short)constant);\n+        else if (constant instanceof Byte)      methodWriter.push((byte)constant);\n+        else if (constant instanceof Boolean)   methodWriter.push((boolean)constant);\n+        else {\n+            throw new IllegalStateException(\"unexpected constant [\" + constant + \"]\");\n+        }\n+    }\n+\n+    @Override\n+    public void visitNull(NullNode irNullNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.visitInsn(Opcodes.ACONST_NULL);\n+    }\n+\n+    @Override\n+    public void visitDefInterfaceReference(DefInterfaceReferenceNode irDefInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irDefInterfaceReferenceNode.getLocation());\n+\n+        // place holder for functional interface receiver\n+        // which is resolved and replace at runtime\n+        methodWriter.push((String)null);\n+\n+        for (String capture : irDefInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+    }\n+\n+    @Override\n+    public void visitTypedInterfaceReference(TypedInterfaceReferenceNode irTypedInterfaceReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedInterfaceReferenceNode.getLocation());\n+\n+        for (String capture : irTypedInterfaceReferenceNode.getCaptures()) {\n+            WriteScope.Variable variable = writeScope.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());\n+        }\n+\n+        methodWriter.invokeLambdaCall(irTypedInterfaceReferenceNode.getReference());\n+    }\n+\n+    @Override\n+    public void visitTypeCaptureReference(TypedCaptureReferenceNode irTypedCaptureReferenceNode, WriteScope writeScope) {\n+        MethodWriter methodWriter = writeScope.getMethodWriter();\n+        methodWriter.writeDebugInfo(irTypedCaptureReferenceNode.getLocation());\n+        Variable captured = writeScope.getVariable(irTypedCaptureReferenceNode.getCaptures().get(0));\n+\n+        methodWriter.visitVarInsn(captured.getAsmType().getOpcode(Opcodes.ILOAD), captured.getSlot());\n+        Type methodType = Type.getMethodType(MethodWriter.getType(irTypedCaptureReferenceNode.getExpressionType()), captured.getAsmType());\n+        methodWriter.invokeDefCall(irTypedCaptureReferenceNode.getMethodName(),\n+                methodType, DefBootstrap.REFERENCE, irTypedCaptureReferenceNode.getExpressionCanonicalTypeName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "originalPosition": 1192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjM2Mjkz", "url": "https://github.com/elastic/elasticsearch/pull/63512#pullrequestreview-510636293", "createdAt": "2020-10-16T16:44:19Z", "commit": {"oid": "883486155e6f1c304fe53b5c8ef09ee255964141"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e31faeae9f99ed35a64d812596604b342fbc63f1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e31faeae9f99ed35a64d812596604b342fbc63f1", "committedDate": "2020-10-16T19:07:24Z", "message": "Merge branch 'master' into proto2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16031ac02038b84fd67bdc650a3f374ba9c8b927", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/16031ac02038b84fd67bdc650a3f374ba9c8b927", "committedDate": "2020-10-16T19:07:32Z", "message": "Merge branch 'proto2' into proto3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "902b2ba328e4f9e3fc0a3d5f3809e257e396d2a4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/902b2ba328e4f9e3fc0a3d5f3809e257e396d2a4", "committedDate": "2020-10-16T19:51:59Z", "message": "response to pr comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4255, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}