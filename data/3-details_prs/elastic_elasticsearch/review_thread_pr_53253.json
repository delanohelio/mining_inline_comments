{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MTA0NTc3", "number": 53253, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNjoxOVrODmUvIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNzo0M1rODmUxpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTEyMjI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/action/EqlActionIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNjoxOVrOFzrQhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNjoxOVrOFzrQhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczMDQzNg==", "bodyText": "Leftover commented line?", "url": "https://github.com/elastic/elasticsearch/pull/53253#discussion_r389730436", "createdAt": "2020-03-09T14:36:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/action/EqlActionIT.java", "diffHunk": "@@ -7,60 +7,63 @@\n package org.elasticsearch.xpack.eql.action;\n \n import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n-import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import org.elasticsearch.Build;\n import org.elasticsearch.action.bulk.BulkRequestBuilder;\n import org.elasticsearch.action.bulk.BulkResponse;\n import org.elasticsearch.action.index.IndexRequest;\n import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n import org.elasticsearch.search.SearchHit;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.BeforeClass;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n+import java.util.HashMap;\n import java.util.List;\n \n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n \n public class EqlActionIT extends AbstractEqlIntegTestCase {\n \n     static final String indexPrefix = \"endgame\";\n     static final String testIndexName = indexPrefix + \"-1.4.0\";\n-    protected static final String PARAM_FORMATTING = \"%1$s.test\";\n-\n+    protected static final String PARAM_FORMATTING = \"%1$s.test -> %2$s\";\n \n     @BeforeClass\n     public static void checkForSnapshot() {\n         assumeTrue(\"Only works on snapshot builds for now\", Build.CURRENT.isSnapshot());\n     }\n \n     @Before\n+    @SuppressWarnings(\"unchecked\")\n     public void setUpData() throws Exception {\n         // Insert test data\n         ObjectMapper mapper = new ObjectMapper();\n         BulkRequestBuilder bulkBuilder = client().prepareBulk();\n-        JsonNode rootNode = mapper.readTree(EqlActionIT.class.getResourceAsStream(\"/test_data.json\"));\n-        Iterator<JsonNode> entries = rootNode.elements();\n-        while (entries.hasNext()) {\n-            JsonNode entry = entries.next();\n-\n-            // Adjust the structure of the document with additional event.category and @timestamp fields\n-            // Add event.category field\n-            ObjectNode objEvent = ((ObjectNode)entry).putObject(\"event\");\n-            JsonNode objEventType = entry.get(\"event_type\");\n-            objEvent.put(\"category\", objEventType.asText());\n-\n-            // Add @timestamp field\n-            JsonNode objTimestamp = entry.get(\"timestamp\");\n-            ((ObjectNode)entry).put(\"@timestamp\", objTimestamp.asLong());\n-\n-            bulkBuilder.add(new IndexRequest(testIndexName).source(entry.toString(), XContentType.JSON));\n+        try (XContentParser parser = createParser(JsonXContent.jsonXContent, EqlActionIT.class.getResourceAsStream(\"/test_data.json\"))) {\n+            List<Object> list = parser.list();\n+            for (Object item : list) {\n+                assertThat(item, instanceOf(HashMap.class));\n+\n+                HashMap<String, Object> entry = (HashMap<String, Object>) item;\n+\n+                // Adjust the structure of the document with additional event.category and @timestamp fields\n+                // Add event.category field\n+                HashMap<String, Object> objEvent = new HashMap<>();\n+                objEvent.put(\"category\", entry.get(\"event_type\"));\n+                entry.put(\"event\", objEvent);\n+\n+                // Add @timestamp field\n+                entry.put(\"@timestamp\", entry.get(\"timestamp\"));\n+\n+                //BytesReference bytes = XContentHelper.toXContent(entry, XContentType.JSON, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f66857619c50e1c7a81c6617d7e3809557835417"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTEyODcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/action/EqlActionIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNzo0M1rOFzrURg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNzo0M1rOFzrURg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczMTM5OA==", "bodyText": "len defined above, but not actually used here.", "url": "https://github.com/elastic/elasticsearch/pull/53253#discussion_r389731398", "createdAt": "2020-03-09T14:37:43Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/action/EqlActionIT.java", "diffHunk": "@@ -108,19 +111,24 @@ public EqlActionIT(int num, EqlSpec spec) {\n         this.spec = spec;\n     }\n \n-    public final void test() {\n-        EqlSearchResponse response = new EqlSearchRequestBuilder(client(), EqlSearchAction.INSTANCE)\n-            .indices(testIndexName).query(spec.query()).get();\n-\n-        List<SearchHit> events = response.hits().events();\n-        assertNotNull(events);\n-\n+    private static long[] extractIds(List<SearchHit> events) {\n         final int len = events.size();\n         final long ids[] = new long[len];\n         for (int i = 0; i < events.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f66857619c50e1c7a81c6617d7e3809557835417"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3350, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}