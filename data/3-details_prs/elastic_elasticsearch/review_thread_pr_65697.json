{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNDg2ODAy", "number": 65697, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMToxNTowMlrOE_z_Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMToxODoxNlrOE_0D1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzQ3NTM5OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMToxNTowMlrOH9ubIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo1MTo0NVrOH9voBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NTc5NA==", "bodyText": "NIT: we have CollectionUtils.appendToCopy(super.nodePlugins(clusterAlias), SearchListenerPlugin.class); to make this stuff one line", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534485794", "createdAt": "2020-12-02T21:15:02Z", "author": {"login": "original-brownbear"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.ccs;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexModule;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.SearchOperationListener;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.test.AbstractMultiClustersTestCase;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.NodeRoles;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+\n+public class CrossClusterSearchIT extends AbstractMultiClustersTestCase {\n+\n+    @Override\n+    protected Collection<String> remoteClusterAlias() {\n+        return List.of(\"cluster_a\");\n+    }\n+\n+    private int indexDocs(Client client, String index) {\n+        int numDocs = between(1, 10);\n+        for (int i = 0; i < numDocs; i++) {\n+            client.prepareIndex(index).setSource(\"f\", \"v\").get();\n+        }\n+        client.admin().indices().prepareRefresh(index).get();\n+        return numDocs;\n+    }\n+\n+    public void testRemoteClusterClientRole() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        final int demoDocs = indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\"));\n+        final int prodDocs = indexDocs(client(\"cluster_a\"), \"prod\");\n+        final InternalTestCluster localCluster = cluster(LOCAL_CLUSTER);\n+        final String pureDataNode = randomBoolean() ? localCluster.startDataOnlyNode() : null;\n+        final String nodeWithoutRemoteClusterClientRole = localCluster.startNode(NodeRoles.onlyRole(DiscoveryNodeRole.DATA_ROLE));\n+        ElasticsearchAssertions.assertFutureThrows(\n+            localCluster.client(nodeWithoutRemoteClusterClientRole)\n+                .prepareSearch(\"demo\", \"cluster_a:prod\")\n+                .setQuery(new MatchAllQueryBuilder())\n+                .setAllowPartialSearchResults(false)\n+                .setSize(1000)\n+                .execute(),\n+            IllegalArgumentException.class,\n+            RestStatus.BAD_REQUEST,\n+            \"node [\" + nodeWithoutRemoteClusterClientRole + \"] does not have the remote cluster client role enabled\"\n+        );\n+\n+        final String nodeWithRemoteClusterClientRole = randomFrom(\n+            StreamSupport.stream(localCluster.clusterService().state().nodes().spliterator(), false)\n+                .map(DiscoveryNode::getName)\n+                .filter(nodeName -> nodeWithoutRemoteClusterClientRole.equals(nodeName) == false)\n+                .filter(nodeName -> nodeName.equals(pureDataNode) == false)\n+                .collect(Collectors.toList()));\n+\n+        final SearchResponse resp = localCluster.client(nodeWithRemoteClusterClientRole)\n+            .prepareSearch(\"demo\", \"cluster_a:prod\")\n+            .setQuery(new MatchAllQueryBuilder())\n+            .setAllowPartialSearchResults(false)\n+            .setSize(1000)\n+            .get();\n+        assertHitCount(resp, demoDocs + prodDocs);\n+    }\n+\n+    public void testProxyConnectionDisconnect() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        final String remoteNode = cluster(\"cluster_a\").startDataOnlyNode();\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\")\n+            .setSettings(Settings.builder().put(\"index.routing.allocation.require._name\", remoteNode)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build()));\n+        indexDocs(client(\"cluster_a\"), \"prod\");\n+        SearchListenerPlugin.blockQueryPhase();\n+        try {\n+            PlainActionFuture<SearchResponse> future = new PlainActionFuture<>();\n+            SearchRequest searchRequest = new SearchRequest(\"demo\", \"cluster_a:prod\");\n+            searchRequest.allowPartialSearchResults(false);\n+            searchRequest.setCcsMinimizeRoundtrips(false);\n+            searchRequest.source(new SearchSourceBuilder().query(new MatchAllQueryBuilder()).size(1000));\n+            client(LOCAL_CLUSTER).search(searchRequest, future);\n+            SearchListenerPlugin.waitSearchStarted();\n+            disconnectFromRemoteClusters();\n+            assertBusy(() -> assertTrue(future.isDone()));\n+            configureAndConnectsToRemoteClusters();\n+        } finally {\n+            SearchListenerPlugin.allowQueryPhase();\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins(String clusterAlias) {\n+        if (clusterAlias.equals(LOCAL_CLUSTER)) {\n+            return super.nodePlugins(clusterAlias);\n+        } else {\n+            final List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins(clusterAlias));\n+            plugins.add(SearchListenerPlugin.class);\n+            return plugins;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6d2211c255d58dec20426d5abfe28a88710bb"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTQ3Ng==", "bodyText": "Nice, see 3e262a7", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534505476", "createdAt": "2020-12-02T21:51:45Z", "author": {"login": "dnhatn"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.ccs;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexModule;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.SearchOperationListener;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.test.AbstractMultiClustersTestCase;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.NodeRoles;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+\n+public class CrossClusterSearchIT extends AbstractMultiClustersTestCase {\n+\n+    @Override\n+    protected Collection<String> remoteClusterAlias() {\n+        return List.of(\"cluster_a\");\n+    }\n+\n+    private int indexDocs(Client client, String index) {\n+        int numDocs = between(1, 10);\n+        for (int i = 0; i < numDocs; i++) {\n+            client.prepareIndex(index).setSource(\"f\", \"v\").get();\n+        }\n+        client.admin().indices().prepareRefresh(index).get();\n+        return numDocs;\n+    }\n+\n+    public void testRemoteClusterClientRole() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        final int demoDocs = indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\"));\n+        final int prodDocs = indexDocs(client(\"cluster_a\"), \"prod\");\n+        final InternalTestCluster localCluster = cluster(LOCAL_CLUSTER);\n+        final String pureDataNode = randomBoolean() ? localCluster.startDataOnlyNode() : null;\n+        final String nodeWithoutRemoteClusterClientRole = localCluster.startNode(NodeRoles.onlyRole(DiscoveryNodeRole.DATA_ROLE));\n+        ElasticsearchAssertions.assertFutureThrows(\n+            localCluster.client(nodeWithoutRemoteClusterClientRole)\n+                .prepareSearch(\"demo\", \"cluster_a:prod\")\n+                .setQuery(new MatchAllQueryBuilder())\n+                .setAllowPartialSearchResults(false)\n+                .setSize(1000)\n+                .execute(),\n+            IllegalArgumentException.class,\n+            RestStatus.BAD_REQUEST,\n+            \"node [\" + nodeWithoutRemoteClusterClientRole + \"] does not have the remote cluster client role enabled\"\n+        );\n+\n+        final String nodeWithRemoteClusterClientRole = randomFrom(\n+            StreamSupport.stream(localCluster.clusterService().state().nodes().spliterator(), false)\n+                .map(DiscoveryNode::getName)\n+                .filter(nodeName -> nodeWithoutRemoteClusterClientRole.equals(nodeName) == false)\n+                .filter(nodeName -> nodeName.equals(pureDataNode) == false)\n+                .collect(Collectors.toList()));\n+\n+        final SearchResponse resp = localCluster.client(nodeWithRemoteClusterClientRole)\n+            .prepareSearch(\"demo\", \"cluster_a:prod\")\n+            .setQuery(new MatchAllQueryBuilder())\n+            .setAllowPartialSearchResults(false)\n+            .setSize(1000)\n+            .get();\n+        assertHitCount(resp, demoDocs + prodDocs);\n+    }\n+\n+    public void testProxyConnectionDisconnect() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        final String remoteNode = cluster(\"cluster_a\").startDataOnlyNode();\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\")\n+            .setSettings(Settings.builder().put(\"index.routing.allocation.require._name\", remoteNode)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build()));\n+        indexDocs(client(\"cluster_a\"), \"prod\");\n+        SearchListenerPlugin.blockQueryPhase();\n+        try {\n+            PlainActionFuture<SearchResponse> future = new PlainActionFuture<>();\n+            SearchRequest searchRequest = new SearchRequest(\"demo\", \"cluster_a:prod\");\n+            searchRequest.allowPartialSearchResults(false);\n+            searchRequest.setCcsMinimizeRoundtrips(false);\n+            searchRequest.source(new SearchSourceBuilder().query(new MatchAllQueryBuilder()).size(1000));\n+            client(LOCAL_CLUSTER).search(searchRequest, future);\n+            SearchListenerPlugin.waitSearchStarted();\n+            disconnectFromRemoteClusters();\n+            assertBusy(() -> assertTrue(future.isDone()));\n+            configureAndConnectsToRemoteClusters();\n+        } finally {\n+            SearchListenerPlugin.allowQueryPhase();\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins(String clusterAlias) {\n+        if (clusterAlias.equals(LOCAL_CLUSTER)) {\n+            return super.nodePlugins(clusterAlias);\n+        } else {\n+            final List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins(clusterAlias));\n+            plugins.add(SearchListenerPlugin.class);\n+            return plugins;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NTc5NA=="}, "originalCommit": {"oid": "dff6d2211c255d58dec20426d5abfe28a88710bb"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzQ4NjkzOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMToxODoxNlrOH9uh4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo1MTo1OFrOH9vohw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NzUyMg==", "bodyText": "NIT: Maybe put a timeout on these .await here and above and assertTrue to make test failures a little more obvious?", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534487522", "createdAt": "2020-12-02T21:18:16Z", "author": {"login": "original-brownbear"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.ccs;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexModule;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.SearchOperationListener;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.test.AbstractMultiClustersTestCase;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.NodeRoles;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+\n+public class CrossClusterSearchIT extends AbstractMultiClustersTestCase {\n+\n+    @Override\n+    protected Collection<String> remoteClusterAlias() {\n+        return List.of(\"cluster_a\");\n+    }\n+\n+    private int indexDocs(Client client, String index) {\n+        int numDocs = between(1, 10);\n+        for (int i = 0; i < numDocs; i++) {\n+            client.prepareIndex(index).setSource(\"f\", \"v\").get();\n+        }\n+        client.admin().indices().prepareRefresh(index).get();\n+        return numDocs;\n+    }\n+\n+    public void testRemoteClusterClientRole() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        final int demoDocs = indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\"));\n+        final int prodDocs = indexDocs(client(\"cluster_a\"), \"prod\");\n+        final InternalTestCluster localCluster = cluster(LOCAL_CLUSTER);\n+        final String pureDataNode = randomBoolean() ? localCluster.startDataOnlyNode() : null;\n+        final String nodeWithoutRemoteClusterClientRole = localCluster.startNode(NodeRoles.onlyRole(DiscoveryNodeRole.DATA_ROLE));\n+        ElasticsearchAssertions.assertFutureThrows(\n+            localCluster.client(nodeWithoutRemoteClusterClientRole)\n+                .prepareSearch(\"demo\", \"cluster_a:prod\")\n+                .setQuery(new MatchAllQueryBuilder())\n+                .setAllowPartialSearchResults(false)\n+                .setSize(1000)\n+                .execute(),\n+            IllegalArgumentException.class,\n+            RestStatus.BAD_REQUEST,\n+            \"node [\" + nodeWithoutRemoteClusterClientRole + \"] does not have the remote cluster client role enabled\"\n+        );\n+\n+        final String nodeWithRemoteClusterClientRole = randomFrom(\n+            StreamSupport.stream(localCluster.clusterService().state().nodes().spliterator(), false)\n+                .map(DiscoveryNode::getName)\n+                .filter(nodeName -> nodeWithoutRemoteClusterClientRole.equals(nodeName) == false)\n+                .filter(nodeName -> nodeName.equals(pureDataNode) == false)\n+                .collect(Collectors.toList()));\n+\n+        final SearchResponse resp = localCluster.client(nodeWithRemoteClusterClientRole)\n+            .prepareSearch(\"demo\", \"cluster_a:prod\")\n+            .setQuery(new MatchAllQueryBuilder())\n+            .setAllowPartialSearchResults(false)\n+            .setSize(1000)\n+            .get();\n+        assertHitCount(resp, demoDocs + prodDocs);\n+    }\n+\n+    public void testProxyConnectionDisconnect() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        final String remoteNode = cluster(\"cluster_a\").startDataOnlyNode();\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\")\n+            .setSettings(Settings.builder().put(\"index.routing.allocation.require._name\", remoteNode)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build()));\n+        indexDocs(client(\"cluster_a\"), \"prod\");\n+        SearchListenerPlugin.blockQueryPhase();\n+        try {\n+            PlainActionFuture<SearchResponse> future = new PlainActionFuture<>();\n+            SearchRequest searchRequest = new SearchRequest(\"demo\", \"cluster_a:prod\");\n+            searchRequest.allowPartialSearchResults(false);\n+            searchRequest.setCcsMinimizeRoundtrips(false);\n+            searchRequest.source(new SearchSourceBuilder().query(new MatchAllQueryBuilder()).size(1000));\n+            client(LOCAL_CLUSTER).search(searchRequest, future);\n+            SearchListenerPlugin.waitSearchStarted();\n+            disconnectFromRemoteClusters();\n+            assertBusy(() -> assertTrue(future.isDone()));\n+            configureAndConnectsToRemoteClusters();\n+        } finally {\n+            SearchListenerPlugin.allowQueryPhase();\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins(String clusterAlias) {\n+        if (clusterAlias.equals(LOCAL_CLUSTER)) {\n+            return super.nodePlugins(clusterAlias);\n+        } else {\n+            final List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins(clusterAlias));\n+            plugins.add(SearchListenerPlugin.class);\n+            return plugins;\n+        }\n+    }\n+\n+    @Before\n+    public void resetSearchListenerPlugin() throws Exception {\n+        SearchListenerPlugin.reset();\n+    }\n+\n+    public static class SearchListenerPlugin extends Plugin {\n+        private static final AtomicReference<CountDownLatch> startedLatch = new AtomicReference<>();\n+        private static final AtomicReference<CountDownLatch> queryLatch = new AtomicReference<>();\n+\n+        static void reset() {\n+            startedLatch.set(new CountDownLatch(1));\n+        }\n+\n+        static void blockQueryPhase() {\n+            queryLatch.set(new CountDownLatch(1));\n+        }\n+\n+        static void allowQueryPhase() {\n+            final CountDownLatch latch = queryLatch.get();\n+            if (latch != null) {\n+                latch.countDown();\n+            }\n+        }\n+\n+        static void waitSearchStarted() throws InterruptedException {\n+            startedLatch.get().await();\n+        }\n+\n+        @Override\n+        public void onIndexModule(IndexModule indexModule) {\n+            indexModule.addSearchOperationListener(new SearchOperationListener() {\n+                @Override\n+                public void onPreQueryPhase(SearchContext searchContext) {\n+                    startedLatch.get().countDown();\n+                    final CountDownLatch latch = queryLatch.get();\n+                    if (latch != null) {\n+                        try {\n+                            latch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6d2211c255d58dec20426d5abfe28a88710bb"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwNTYwNw==", "bodyText": "Sure, adjusted in 031bf82", "url": "https://github.com/elastic/elasticsearch/pull/65697#discussion_r534505607", "createdAt": "2020-12-02T21:51:58Z", "author": {"login": "dnhatn"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/ccs/CrossClusterSearchIT.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.ccs;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexModule;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.SearchOperationListener;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.test.AbstractMultiClustersTestCase;\n+import org.elasticsearch.test.InternalTestCluster;\n+import org.elasticsearch.test.NodeRoles;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\n+\n+public class CrossClusterSearchIT extends AbstractMultiClustersTestCase {\n+\n+    @Override\n+    protected Collection<String> remoteClusterAlias() {\n+        return List.of(\"cluster_a\");\n+    }\n+\n+    private int indexDocs(Client client, String index) {\n+        int numDocs = between(1, 10);\n+        for (int i = 0; i < numDocs; i++) {\n+            client.prepareIndex(index).setSource(\"f\", \"v\").get();\n+        }\n+        client.admin().indices().prepareRefresh(index).get();\n+        return numDocs;\n+    }\n+\n+    public void testRemoteClusterClientRole() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        final int demoDocs = indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\"));\n+        final int prodDocs = indexDocs(client(\"cluster_a\"), \"prod\");\n+        final InternalTestCluster localCluster = cluster(LOCAL_CLUSTER);\n+        final String pureDataNode = randomBoolean() ? localCluster.startDataOnlyNode() : null;\n+        final String nodeWithoutRemoteClusterClientRole = localCluster.startNode(NodeRoles.onlyRole(DiscoveryNodeRole.DATA_ROLE));\n+        ElasticsearchAssertions.assertFutureThrows(\n+            localCluster.client(nodeWithoutRemoteClusterClientRole)\n+                .prepareSearch(\"demo\", \"cluster_a:prod\")\n+                .setQuery(new MatchAllQueryBuilder())\n+                .setAllowPartialSearchResults(false)\n+                .setSize(1000)\n+                .execute(),\n+            IllegalArgumentException.class,\n+            RestStatus.BAD_REQUEST,\n+            \"node [\" + nodeWithoutRemoteClusterClientRole + \"] does not have the remote cluster client role enabled\"\n+        );\n+\n+        final String nodeWithRemoteClusterClientRole = randomFrom(\n+            StreamSupport.stream(localCluster.clusterService().state().nodes().spliterator(), false)\n+                .map(DiscoveryNode::getName)\n+                .filter(nodeName -> nodeWithoutRemoteClusterClientRole.equals(nodeName) == false)\n+                .filter(nodeName -> nodeName.equals(pureDataNode) == false)\n+                .collect(Collectors.toList()));\n+\n+        final SearchResponse resp = localCluster.client(nodeWithRemoteClusterClientRole)\n+            .prepareSearch(\"demo\", \"cluster_a:prod\")\n+            .setQuery(new MatchAllQueryBuilder())\n+            .setAllowPartialSearchResults(false)\n+            .setSize(1000)\n+            .get();\n+        assertHitCount(resp, demoDocs + prodDocs);\n+    }\n+\n+    public void testProxyConnectionDisconnect() throws Exception {\n+        assertAcked(client(LOCAL_CLUSTER).admin().indices().prepareCreate(\"demo\"));\n+        indexDocs(client(LOCAL_CLUSTER), \"demo\");\n+        final String remoteNode = cluster(\"cluster_a\").startDataOnlyNode();\n+        assertAcked(client(\"cluster_a\").admin().indices().prepareCreate(\"prod\")\n+            .setSettings(Settings.builder().put(\"index.routing.allocation.require._name\", remoteNode)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build()));\n+        indexDocs(client(\"cluster_a\"), \"prod\");\n+        SearchListenerPlugin.blockQueryPhase();\n+        try {\n+            PlainActionFuture<SearchResponse> future = new PlainActionFuture<>();\n+            SearchRequest searchRequest = new SearchRequest(\"demo\", \"cluster_a:prod\");\n+            searchRequest.allowPartialSearchResults(false);\n+            searchRequest.setCcsMinimizeRoundtrips(false);\n+            searchRequest.source(new SearchSourceBuilder().query(new MatchAllQueryBuilder()).size(1000));\n+            client(LOCAL_CLUSTER).search(searchRequest, future);\n+            SearchListenerPlugin.waitSearchStarted();\n+            disconnectFromRemoteClusters();\n+            assertBusy(() -> assertTrue(future.isDone()));\n+            configureAndConnectsToRemoteClusters();\n+        } finally {\n+            SearchListenerPlugin.allowQueryPhase();\n+        }\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins(String clusterAlias) {\n+        if (clusterAlias.equals(LOCAL_CLUSTER)) {\n+            return super.nodePlugins(clusterAlias);\n+        } else {\n+            final List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins(clusterAlias));\n+            plugins.add(SearchListenerPlugin.class);\n+            return plugins;\n+        }\n+    }\n+\n+    @Before\n+    public void resetSearchListenerPlugin() throws Exception {\n+        SearchListenerPlugin.reset();\n+    }\n+\n+    public static class SearchListenerPlugin extends Plugin {\n+        private static final AtomicReference<CountDownLatch> startedLatch = new AtomicReference<>();\n+        private static final AtomicReference<CountDownLatch> queryLatch = new AtomicReference<>();\n+\n+        static void reset() {\n+            startedLatch.set(new CountDownLatch(1));\n+        }\n+\n+        static void blockQueryPhase() {\n+            queryLatch.set(new CountDownLatch(1));\n+        }\n+\n+        static void allowQueryPhase() {\n+            final CountDownLatch latch = queryLatch.get();\n+            if (latch != null) {\n+                latch.countDown();\n+            }\n+        }\n+\n+        static void waitSearchStarted() throws InterruptedException {\n+            startedLatch.get().await();\n+        }\n+\n+        @Override\n+        public void onIndexModule(IndexModule indexModule) {\n+            indexModule.addSearchOperationListener(new SearchOperationListener() {\n+                @Override\n+                public void onPreQueryPhase(SearchContext searchContext) {\n+                    startedLatch.get().countDown();\n+                    final CountDownLatch latch = queryLatch.get();\n+                    if (latch != null) {\n+                        try {\n+                            latch.await();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NzUyMg=="}, "originalCommit": {"oid": "dff6d2211c255d58dec20426d5abfe28a88710bb"}, "originalPosition": 179}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1879, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}