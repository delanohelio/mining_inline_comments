{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0MDU4ODQ2", "number": 54256, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwOTo0NTo1NFrODrkLqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzo0MjozNFrODsjE4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDA4MTY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwOTo0NTo1NFrOF7-vhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0MToxMVrOF8KNEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQzODI3OQ==", "bodyText": "This whole step is kind of stupid now in 7.6+ because we don't write anything during INIT. Ideally (and I'd do that in a follow-up), we shouldn't move the snapshot to ABORTED here but instead just drop it from the cluster state right away and resolve the listener in beginSnapshot to not have the redundant CS updates from moving to ABORTED and then removing the snapshot from the CS in beginSnapshot.", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398438279", "createdAt": "2020-03-26T09:45:54Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1292,6 +1300,7 @@ public ClusterState execute(ClusterState currentState) {\n                         shards = snapshotEntry.shards();\n                         assert shards.isEmpty();\n                         failure = \"Snapshot was aborted during initialization\";\n+                        abortedDuringInit = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56f11059f053608b5926499176236ba1304ec4c3"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyNjA2NQ==", "bodyText": "The JavaDocs on beginSnapshot should be updated as well, as it claims that the snapshot is created in the repo.", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398626065", "createdAt": "2020-03-26T14:41:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1292,6 +1300,7 @@ public ClusterState execute(ClusterState currentState) {\n                         shards = snapshotEntry.shards();\n                         assert shards.isEmpty();\n                         failure = \"Snapshot was aborted during initialization\";\n+                        abortedDuringInit = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQzODI3OQ=="}, "originalCommit": {"oid": "56f11059f053608b5926499176236ba1304ec4c3"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQ2Njg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToyNzo1MFrOF8Cfww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToyNzo1MFrOF8Cfww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5OTc3OQ==", "bodyText": "This change will help debug future issues+test-failures more easily. If we're aborting we get a log sequence as below now (without the newly added information it was impossible to tell if the deletes were due to rerunning the delete after finishing the snapshot or due to REST client retries):\n[2020-03-26T11:45:02,542][INFO ][o.e.s.SnapshotsService   ] [asyncIntegTest-0] deleting snapshot [test_repository:test_snapshot/P5-mkax-TwupQvH2i4i6Kw] assuming repository generation [-1] and with priory [NORMAL]\n[2020-03-26T11:45:02,640][INFO ][o.e.s.SnapshotsService   ] [asyncIntegTest-0] snapshot [test_repository:test_snapshot/P5-mkax-TwupQvH2i4i6Kw] completed with state [SUCCESS]\n[2020-03-26T11:45:02,656][INFO ][o.e.s.SnapshotsService   ] [asyncIntegTest-0] deleting snapshot [test_repository:test_snapshot/P5-mkax-TwupQvH2i4i6Kw] assuming repository generation [0] and with priory [IMMEDIATE]", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398499779", "createdAt": "2020-03-26T11:27:50Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1227,12 +1233,15 @@ public void deleteSnapshot(final String repositoryName, final String snapshotNam\n      */\n     private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,\n                                 final boolean immediatePriority) {\n-        logger.info(\"deleting snapshot [{}]\", snapshot);\n         Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL;\n+        logger.info(\"deleting snapshot [{}] assuming repository generation [{}] and with priory [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTIxNzUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozMzoyNVrOF8J1tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozMzoyNVrOF8J1tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyMDA4Ng==", "bodyText": "s/priory/priority", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398620086", "createdAt": "2020-03-26T14:33:25Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1227,12 +1233,15 @@ public void deleteSnapshot(final String repositoryName, final String snapshotNam\n      */\n     private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,\n                                 final boolean immediatePriority) {\n-        logger.info(\"deleting snapshot [{}]\", snapshot);\n         Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL;\n+        logger.info(\"deleting snapshot [{}] assuming repository generation [{}] and with priory [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTMyMjg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1NToxM1rOF8K4iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMDoxNToxOFrOF8q2qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNzE5Mw==", "bodyText": "I'm not sure what cases this is supposed to cover. In particular, I'm wondering about the case where the current node failed (e.g. got disconnected from the rest of the cluster) and another master completed the snapshot. How are the listeners in snapshotCompletionListeners informed?", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398637193", "createdAt": "2020-03-26T14:55:13Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1366,14 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n-                                }\n-                            });\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzEzMA==", "bodyText": "I'm not sure what cases this is supposed to cover.\n\nThe only way I see of getting here is the one in the linked test failure.\nMaster tried to finalize the snapshot and ran into an IOException (or other but I don't see which one).\nThat said ... you're right, on master fail-over we can leak the snapshotCompletionListeners  (urgh ... I wonder if that explain the odd test failure of a hanging snapshot once a month) I'll open another PR for that?", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398657130", "createdAt": "2020-03-26T15:19:57Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1366,14 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n-                                }\n-                            });\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNzE5Mw=="}, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNTIxOQ==", "bodyText": "#54286 should do it here but I'd like a few hours of SnapshotsResiliencyTests to be sure :)", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r398715219", "createdAt": "2020-03-26T16:32:15Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1366,14 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n-                                }\n-                            });\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNzE5Mw=="}, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEyOTQ2MQ==", "bodyText": "By wrapping the original exception here, I wonder if we potentially turn a failing master (FailedToCommitClusterStateException / NotMasterException) into a SnapshotMissingException", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r399129461", "createdAt": "2020-03-27T09:19:32Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1366,14 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n-                                }\n-                            });\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNzE5Mw=="}, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEzNzE1Mg==", "bodyText": "That's a good point ... I wonder if we should just pass those two exceptions (failed to commit/ not master) as they come without wrapping. At this point, the delete has not in fact put anything into the cluster state aside from aborting the snapshot. So if we get here and run into one of those master fail-over exceptions, then retrying the delete request (master transport action will do that here) seems what we would actually want to happen right?", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r399137152", "createdAt": "2020-03-27T09:32:49Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1366,14 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n-                                }\n-                            });\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNzE5Mw=="}, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTAwMQ==", "bodyText": "Pushed 2a2422b for the above", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r399161001", "createdAt": "2020-03-27T10:15:18Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1366,14 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n-                                }\n-                            });\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                logger.warn(\"deleted snapshot failed\", e);\n+                                listener.onFailure(\n+                                    new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNzE5Mw=="}, "originalCommit": {"oid": "53e9ae10e3572bfd634e6375e9cfbc88e78ed021"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDM4NjI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzo0MjozNFrOF9dOAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODozNTo1M1rOF9fFdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk4NjE3OA==", "bodyText": "I think I would rather always bubble up the original exception, marking the deletion as failed (and have the client retry). This listener here can be called in a range of situations, and I don't think that in all cases it denotes that the snapshot has been deleted or fully aborted (especially because with waitForSnapshot we are supposed to wait until the snapshot has truly completed, whether exceptional or not).", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r399986178", "createdAt": "2020-03-30T07:42:34Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1365,21 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                if (ExceptionsHelper.unwrap(e, NotMasterException.class, FailedToCommitClusterStateException.class)\n+                                    != null) {\n+                                    logger.warn(\"master failover before deleted snapshot could complete\", e);\n+                                    // Just pass the exception to the transport handler as is so it is retried on the new master\n+                                    listener.onFailure(e);\n+                                } else {\n+                                    logger.warn(\"deleted snapshot failed\", e);\n+                                    listener.onFailure(\n+                                        new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e373a8834f6d0675ff0c6c99479ba3b08820920e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5NzYyMg==", "bodyText": "and I don't think that in all cases it denotes that the snapshot has been deleted or fully aborted\n\nI don't think that's true. With the exception of the master failover exceptions now handled above, all other exceptions method that snapshot finalization failed. Since we never retry the snapshot finalization except for on master fail-over we can be sure that the snapshot will never be created at this point.\nIf snapshot finalization failed, then the snapshot has not been finalized in the repo (i.e. is not part of the latest index-N) and hence will always throw SnapshotMissingException in deleteSnapshot`.\nWithout this change, the situation of a failed finalization will behave differently based on timing:\nIf the finalization fails before the delete comes in, then we get the SnapshotMissingException / 404.\nIf it fails after the delete comes in, we throw some other SnapshotException wrapping the SnapshotMissingException and needlessly try to find the snapshot in the repo.\n=> I think we can cleanly leverage the fact that recent changes made things deterministic here and not run deletes that we know will end up in a 404?\nNote: The reason I'm adding these simplifications is (outside of fixing some tests) so that the changes for concurrent snapshots become more obvious. For concurrent snapshot operations we will have to leverage the now very deterministic behavior around snapshot finalizations (and them failing) as well in exactly this way.", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r399997622", "createdAt": "2020-03-30T08:03:16Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1365,21 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                if (ExceptionsHelper.unwrap(e, NotMasterException.class, FailedToCommitClusterStateException.class)\n+                                    != null) {\n+                                    logger.warn(\"master failover before deleted snapshot could complete\", e);\n+                                    // Just pass the exception to the transport handler as is so it is retried on the new master\n+                                    listener.onFailure(e);\n+                                } else {\n+                                    logger.warn(\"deleted snapshot failed\", e);\n+                                    listener.onFailure(\n+                                        new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk4NjE3OA=="}, "originalCommit": {"oid": "e373a8834f6d0675ff0c6c99479ba3b08820920e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxNjc1Nw==", "bodyText": "OK, I tried to follow all paths through the code, and couldn't find an issue. The whole listener notification logic seems super brittle though.", "url": "https://github.com/elastic/elasticsearch/pull/54256#discussion_r400016757", "createdAt": "2020-03-30T08:35:53Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1356,19 +1365,21 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             );\n                         },\n                         e -> {\n-                            logger.warn(\"deleted snapshot failed - deleting files\", e);\n-                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {\n-                                try {\n-                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true);\n-                                } catch (SnapshotMissingException smex) {\n-                                    logger.info(() -> new ParameterizedMessage(\n-                                        \"Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.\",\n-                                        smex.getSnapshotName()), e);\n-                                    listener.onFailure(new SnapshotException(snapshot,\n-                                        \"Tried deleting in-progress snapshot [\" + smex.getSnapshotName() + \"], but it \" +\n-                                            \"could not be found after failing to abort.\", smex));\n+                            if (abortedDuringInit) {\n+                                logger.debug(() -> new ParameterizedMessage(\"Snapshot [{}] was aborted during INIT\", snapshot), e);\n+                                listener.onResponse(null);\n+                            } else {\n+                                if (ExceptionsHelper.unwrap(e, NotMasterException.class, FailedToCommitClusterStateException.class)\n+                                    != null) {\n+                                    logger.warn(\"master failover before deleted snapshot could complete\", e);\n+                                    // Just pass the exception to the transport handler as is so it is retried on the new master\n+                                    listener.onFailure(e);\n+                                } else {\n+                                    logger.warn(\"deleted snapshot failed\", e);\n+                                    listener.onFailure(\n+                                        new SnapshotMissingException(snapshot.getRepository(), snapshot.getSnapshotId(), e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk4NjE3OA=="}, "originalCommit": {"oid": "e373a8834f6d0675ff0c6c99479ba3b08820920e"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4122, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}