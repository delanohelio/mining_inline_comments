{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NjM5ODg1", "number": 52769, "title": "Clean and document sorting with partialy built buckets", "bodyText": "The terms aggregation can be sortd by the results of its\nsub-aggregations. Because it uses that sorting for filtering to the\ntop-n it tries not to construct all of the buckets for the child\naggregations. This has its own interesting problem around reduction, but\nthey aren't super relevant to this change. This change moves that\noptimization from the TermsAggregator and into the aggregators being\nsorted on. This should make it more clear what is going on and it\nunifies this optimization with validating the sort.\nFinally, this should enable some minor optimizations to save a few\ncomparisons when sorting multi-valued buckets. I'll get those in a\nfollow up because they are now fairly obvious. They probably won't be\na huge performance improvement, but it'll be nice anyway.", "createdAt": "2020-02-25T15:10:43Z", "url": "https://github.com/elastic/elasticsearch/pull/52769", "merged": true, "mergeCommit": {"oid": "4accedd01338c8cb22d9519733e118caa9ab926d"}, "closed": true, "closedAt": "2020-02-27T21:28:30Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHyCnqAH2gAyMzc5NjM5ODg1OmU3YjRhOWYwYzM3ZTk4Mzk0NmY5MTdiZTg4Zjg5YjFjZjQ1ZjM0NmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIfvKjgFqTM2NTkwMTY1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e7b4a9f0c37e983946f917be88f89b1cf45f346e", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7b4a9f0c37e983946f917be88f89b1cf45f346e", "committedDate": "2020-02-25T13:21:40Z", "message": "Clean and document sorting with partialy buckets\n\nThe `terms` aggregation can be sortd by the results of its\nsub-aggregations. Because it uses that sorting for filtering to the\ntop-n it tries not to construct all of the buckets for the child\naggregations. This has its own interesting problem around reduction, but\nthey aren't super relevant to this change. This change moves that\noptimization from the `TermsAggregator` and into the aggregators being\nsorted on. This should make it more clear what is going on and it\nunifies this optimization with validating the sort.\n\nFinally, this should enable some minor optimizations to save a few\ncomparisons when sorting multi-valued buckets. I'll get those in a\nfollow up because they are now *fairly* obvious. They probably won't be\na huge performance improvement, but it'll be nice anyway."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTYyMDEz", "url": "https://github.com/elastic/elasticsearch/pull/52769#pullrequestreview-364962013", "createdAt": "2020-02-26T14:51:21Z", "commit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MToyMVrOFuui_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1NjoxM1rOFuuwcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTQzNw==", "bodyText": "Would be nice to note when an aggregator should implement this, like the old doc.  Something like Aggregations that support sorting should override this, otherwise leave the default implementation maybe?", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384541437", "createdAt": "2020-02-26T14:51:21Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -130,15 +131,23 @@ public Aggregator resolveSortPath(AggregationPath.PathElement next, Iterator<Agg\n     }\n \n     /**\n-     * Validates the \"key\" portion of a sort on this aggregation.\n-     * <p>\n-     * The default implementation throws an exception but we override it on aggregations that support sorting.\n+     * Builds a comparator that compares two buckets aggregated by this {@linkplain Aggregator}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDg4MQ==", "bodyText": "This looks like we expect it to throw if the ordering is invalid for the given aggregator.  Presuming that's correct, let's note what we expect it to throw, even though it's unchecked.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384544881", "createdAt": "2020-02-26T14:56:13Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTM0NTAw", "url": "https://github.com/elastic/elasticsearch/pull/52769#pullrequestreview-365134500", "createdAt": "2020-02-26T18:23:50Z", "commit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMzo1MFrOFu25NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0MzowNVrOFu5lmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3ODE5Ng==", "bodyText": "Possible I'm missing something, but couldn't this NPE if an order isn't set?  E.g. order == null which means partiallyBuiltBucketComparator == null, and then later when we use it in a PQ we pass in a null comparator and the PQ chokes (because comparator.compare() NPEs)?", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384678196", "createdAt": "2020-02-26T18:23:50Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "diffHunk": "@@ -189,7 +183,8 @@ public TermsAggregator(String name, AggregatorFactories factories, SearchContext\n             List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {\n         super(name, factories, context, parent, pipelineAggregators, metaData);\n         this.bucketCountThresholds = bucketCountThresholds;\n-        this.order = InternalOrder.validate(order, this);\n+        this.order = order;\n+        partiallyBuiltBucketComparator = order == null ? null : order.partiallyBuiltBucketComparator(b -> b.bucketOrd, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMjM4OQ==", "bodyText": "Could we add small javadoc on this?  Just thinking that since it's private, someone might some day decide to escalate it public and a description of what it does will either be useful, or convince them not to escalate to public :)", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384702389", "createdAt": "2020-02-26T19:08:17Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/InternalOrder.java", "diffHunk": "@@ -244,34 +223,59 @@ public boolean equals(Object obj) {\n             CompoundOrder other = (CompoundOrder) obj;\n             return Objects.equals(orderElements, other.orderElements);\n         }\n+    }\n \n-        /**\n-         * {@code Comparator} for sorting buckets by multiple criteria.\n-         */\n-        static class CompoundOrderComparator implements Comparator<Bucket> {\n-\n-            private List<BucketOrder> compoundOrder;\n-            private Aggregator aggregator;\n-\n-            /**\n-             * Create a new {@code Comparator} for sorting buckets by multiple criteria.\n-             *\n-             * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.\n-             * @param aggregator    {@link BucketOrder#comparator(Aggregator)}\n-             */\n-            CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {\n-                this.compoundOrder = compoundOrder;\n-                this.aggregator = aggregator;\n-            }\n+    private static class SimpleOrder extends InternalOrder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ==", "bodyText": "Hmm, despite the warning it makes me a bit uncomfortable exposing this everywhere since only Terms needs it.  Perhaps we could have some kind of \"OrderBySubaggWrapper\" that Terms agg wraps over the order which implements this functionality?\nI'm not sure if that's possible (or a good idea), so I'm ok leaving this method + warning if we can't find a way to hide it.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384722329", "createdAt": "2020-02-26T19:43:05Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5211bf4e75904e555a213d2f6b98b939d01b460", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/a5211bf4e75904e555a213d2f6b98b939d01b460", "committedDate": "2020-02-27T15:53:03Z", "message": "Merge branch 'master' into terms_agg_path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e0e1eaaee7411232fe7bc019ece4d88e0cea546", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e0e1eaaee7411232fe7bc019ece4d88e0cea546", "committedDate": "2020-02-27T16:12:32Z", "message": "Moar javadoc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/bd02073c9b3e36bb54d83d949c21c032b0315175", "committedDate": "2020-02-24T22:56:58Z", "message": "Clean and document sorting with partialy buckets\n\nThe `terms` aggregation can be sortd by the results of its\nsub-aggregations. Because it uses that sorting for filtering to the\ntop-n it tries not to construct all of the buckets for the child\naggregations. This has its own interesting problem around reduction, but\nthey aren't super relevant to this change. This change moves that\noptimization from the `TermsAggregator` and into the aggregators being\nsorted on. This should make it more clear what is going on and it\nunifies this optimization with validating the sort.\n\nFinally, this should enable some minor optimizations to save a few\ncomparisons when sorting multi-valued buckets. I'll get those in a\nfollow up because they are now *fairly* obvious. They probably won't be\na huge performance improvement, but it'll be nice anyway."}, "afterCommit": {"oid": "0e0e1eaaee7411232fe7bc019ece4d88e0cea546", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e0e1eaaee7411232fe7bc019ece4d88e0cea546", "committedDate": "2020-02-27T16:12:32Z", "message": "Moar javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTAxNjU0", "url": "https://github.com/elastic/elasticsearch/pull/52769#pullrequestreview-365901654", "createdAt": "2020-02-27T18:36:03Z", "commit": {"oid": "0e0e1eaaee7411232fe7bc019ece4d88e0cea546"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2153, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}