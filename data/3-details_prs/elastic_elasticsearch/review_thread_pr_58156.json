{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MDYzMjE2", "number": 58156, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo0MTo0MFrOEF1zPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMDozMjozMlrOENoYXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTU5ODA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo0MTo0MFrOGkRSOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo0MTo0MFrOGkRSOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4NTExNQ==", "bodyText": "I think BWC code is required here so that: if target node is an old version, rewrite the roleDescriptor and limitedRoleDescriptors to be Map<String, Object>.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r440685115", "createdAt": "2020-06-16T08:41:40Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -145,6 +145,7 @@ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version v\n      * The original context is provided to the consumer. When this method returns, the original context is restored.\n      */\n     public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer, Version version) {\n+        // TODO: bwc here for API key metadata changes? i.e. deserialize the raw bytes into Map for older node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1319909f688780aebd6ef9d22a21fcb93394dcf4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTY0OTg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo1NDo0NVrOGkRzUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDoxMDoyNFrOGtIPjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MzU4NA==", "bodyText": "Is it possible that some fields, e.g. version or name, are completely missing from the source document? This parser requires all fields to present (null value is ok but it must present). In current code, all fields do present. I wonder whether this is true for older versions.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r440693584", "createdAt": "2020-06-16T08:54:45Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -929,4 +969,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {\n+\n+        static final InstantiatingObjectParser<ApiKeyDoc, Void> PARSER;\n+        static {\n+            InstantiatingObjectParser.Builder<ApiKeyDoc, Void> builder =\n+                InstantiatingObjectParser.builder(\"api_key_doc\", true, ApiKeyDoc.class);\n+            builder.declareString(constructorArg(), new ParseField(\"doc_type\"));\n+            builder.declareLong(constructorArg(), new ParseField(\"creation_time\"));\n+            builder.declareLongOrNull(constructorArg(), -1, new ParseField(\"expiration_time\"));\n+            builder.declareBoolean(constructorArg(), new ParseField(\"api_key_invalidated\"));\n+            builder.declareString(optionalConstructorArg(), new ParseField(\"api_key_hash\"));\n+            builder.declareString(constructorArg(), new ParseField(\"name\"));\n+            builder.declareInt(constructorArg(), new ParseField(\"version\"));\n+            ObjectParserHelper<ApiKeyDoc, Void> parserHelper = new ObjectParserHelper<>();\n+            parserHelper.declareRawObject(builder, optionalConstructorArg(), new ParseField(\"role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"limited_by_role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"creator\"));\n+            PARSER = builder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1688f97ef7da46c9191b4eb8d586ebae088baa5"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzMDgxNw==", "bodyText": "I suspect it's not true for all versions, or at least it might not be.\nWe'd probably want to generate an API key from v6.7 and check, but it might be safer to change the parser to be more accommodating of missing fields.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r448130817", "createdAt": "2020-07-01T05:54:36Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -929,4 +969,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {\n+\n+        static final InstantiatingObjectParser<ApiKeyDoc, Void> PARSER;\n+        static {\n+            InstantiatingObjectParser.Builder<ApiKeyDoc, Void> builder =\n+                InstantiatingObjectParser.builder(\"api_key_doc\", true, ApiKeyDoc.class);\n+            builder.declareString(constructorArg(), new ParseField(\"doc_type\"));\n+            builder.declareLong(constructorArg(), new ParseField(\"creation_time\"));\n+            builder.declareLongOrNull(constructorArg(), -1, new ParseField(\"expiration_time\"));\n+            builder.declareBoolean(constructorArg(), new ParseField(\"api_key_invalidated\"));\n+            builder.declareString(optionalConstructorArg(), new ParseField(\"api_key_hash\"));\n+            builder.declareString(constructorArg(), new ParseField(\"name\"));\n+            builder.declareInt(constructorArg(), new ParseField(\"version\"));\n+            ObjectParserHelper<ApiKeyDoc, Void> parserHelper = new ObjectParserHelper<>();\n+            parserHelper.declareRawObject(builder, optionalConstructorArg(), new ParseField(\"role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"limited_by_role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"creator\"));\n+            PARSER = builder.build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MzU4NA=="}, "originalCommit": {"oid": "b1688f97ef7da46c9191b4eb8d586ebae088baa5"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1ODE3OQ==", "bodyText": "I checked v6.7 and it looks fine, i.e. it has the same fields as in the master branch. But it might still be safer to have more leniency for missing fields? I'll see how it can be done.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r449958179", "createdAt": "2020-07-06T02:43:49Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -929,4 +969,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {\n+\n+        static final InstantiatingObjectParser<ApiKeyDoc, Void> PARSER;\n+        static {\n+            InstantiatingObjectParser.Builder<ApiKeyDoc, Void> builder =\n+                InstantiatingObjectParser.builder(\"api_key_doc\", true, ApiKeyDoc.class);\n+            builder.declareString(constructorArg(), new ParseField(\"doc_type\"));\n+            builder.declareLong(constructorArg(), new ParseField(\"creation_time\"));\n+            builder.declareLongOrNull(constructorArg(), -1, new ParseField(\"expiration_time\"));\n+            builder.declareBoolean(constructorArg(), new ParseField(\"api_key_invalidated\"));\n+            builder.declareString(optionalConstructorArg(), new ParseField(\"api_key_hash\"));\n+            builder.declareString(constructorArg(), new ParseField(\"name\"));\n+            builder.declareInt(constructorArg(), new ParseField(\"version\"));\n+            ObjectParserHelper<ApiKeyDoc, Void> parserHelper = new ObjectParserHelper<>();\n+            parserHelper.declareRawObject(builder, optionalConstructorArg(), new ParseField(\"role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"limited_by_role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"creator\"));\n+            PARSER = builder.build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MzU4NA=="}, "originalCommit": {"oid": "b1688f97ef7da46c9191b4eb8d586ebae088baa5"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NDE1OQ==", "bodyText": "It's actually fairly easily to make fields optional by using\nbuilder.declareString(ApiKeyDoc::setName, new ParseField(\"name\"))\ninstead of\nbuilder.declareString(constructorArg(), new ParseField(\"name\")).\nBut I ended up didn't make any of the fields optional because:\n\nAll of them exist from 6.7. So not sure which one I should pick for optional. (The only thing missing in 6.7 is creator.realm_type. But it is still wrapped inside a Map<String, Object> in the new implementation so it is not an issue).\nOnce a field made optional, it cannot be final and becomes an anomaly in current implementation. It's not a strong argument, just a personal preference.\n\nPlease let me know if you have concerns.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r449974159", "createdAt": "2020-07-06T04:10:24Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -929,4 +969,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {\n+\n+        static final InstantiatingObjectParser<ApiKeyDoc, Void> PARSER;\n+        static {\n+            InstantiatingObjectParser.Builder<ApiKeyDoc, Void> builder =\n+                InstantiatingObjectParser.builder(\"api_key_doc\", true, ApiKeyDoc.class);\n+            builder.declareString(constructorArg(), new ParseField(\"doc_type\"));\n+            builder.declareLong(constructorArg(), new ParseField(\"creation_time\"));\n+            builder.declareLongOrNull(constructorArg(), -1, new ParseField(\"expiration_time\"));\n+            builder.declareBoolean(constructorArg(), new ParseField(\"api_key_invalidated\"));\n+            builder.declareString(optionalConstructorArg(), new ParseField(\"api_key_hash\"));\n+            builder.declareString(constructorArg(), new ParseField(\"name\"));\n+            builder.declareInt(constructorArg(), new ParseField(\"version\"));\n+            ObjectParserHelper<ApiKeyDoc, Void> parserHelper = new ObjectParserHelper<>();\n+            parserHelper.declareRawObject(builder, optionalConstructorArg(), new ParseField(\"role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"limited_by_role_descriptors\"));\n+            parserHelper.declareRawObject(builder, constructorArg(), new ParseField(\"creator\"));\n+            PARSER = builder.build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MzU4NA=="}, "originalCommit": {"oid": "b1688f97ef7da46c9191b4eb8d586ebae088baa5"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDcwMDcxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyODo0NlrOGoEoeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyODo0NlrOGoEoeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MjEyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, Object> rewriteMetadataIfNecessary(Version version, Authentication authentication) {\n          \n          \n            \n                private Map<String, Object> rewriteMetadataIfNecessary(Version streamVersion, Authentication authentication) {\n          \n      \n    \n    \n  \n\nOther names are fine too (serializeVersion, bwcVersion), but I found the if below to be hard to read when it used such a generic name.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r444672121", "createdAt": "2020-06-24T06:28:46Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +156,25 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version version, Authentication authentication) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDc1ODY1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNTo1OTo0NVrOGosauQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNTo1OTo0NVrOGosauQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyMzk2MQ==", "bodyText": "I think it's best if the cache explicitly states that it is an API Key.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final RoleKey roleKey = new RoleKey(Set.of(roleDescriptorsHash), limitedBy ? \"limited_role_desc\" : \"role_desc\");\n          \n          \n            \n                    final RoleKey roleKey = new RoleKey(Set.of(\"apikey:\" + roleDescriptorsHash), limitedBy ? \"apikey_limited_role\" : \"apikey_role\");", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r445323961", "createdAt": "2020-06-25T05:59:45Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,21 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final BytesReference roleDescriptorsBytes = apiKeyService.getRoleDescriptorsBytesForApiKey(authentication, limitedBy);\n+        final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));\n+        final RoleKey roleKey = new RoleKey(Set.of(roleDescriptorsHash), limitedBy ? \"limited_role_desc\" : \"role_desc\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDc2MzY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNjowMjowOVrOGosd7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNDo0MDoxMlrOGtaN7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNDc4MA==", "bodyText": "BytesReference.toString() is not guaranteed to be what you want here.\nYou want either utf8ToString or just use the bytes directly.\nI'm not sure whether we really even need to hash these - we can, but it might not be necessary.\nI think the options are either:\n\nDon't bother hashing, but that will mean using a separate cache for API key roles (because the cache key is different)\n\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));\n          \n          \n            \n                    final BytesKey cacheKey = new BytesKey(BytesReference.toBytes(roleDescriptorsBytes));\n          \n      \n    \n    \n  \n\n\nHash using MessageDigest\n\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));\n          \n          \n            \n                    MessageDigest digest = MessageDigests.sha256();\n          \n          \n            \n                    digest.update(BytesReference.toBytes(roleDescriptorsBytes));\n          \n          \n            \n                    final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r445324780", "createdAt": "2020-06-25T06:02:09Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,21 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final BytesReference roleDescriptorsBytes = apiKeyService.getRoleDescriptorsBytesForApiKey(authentication, limitedBy);\n+        final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1OTQwMw==", "bodyText": "I really like BytesKey, unfortunately it is not compatible with the current cache and I don't want to add another cache and associated overhead just because of this incompatibility. So I'll prefer to your second suggestion, i.e. MessageDigest.sha256 where raw bytes are used.\nAlternatively, we could potential change RoleKey to have either Set<byte[]> names and byte[] source, so it can accomodate both regular roles and API key roles. But I am not sure whether it really gives us much unless we have a real concern for sha256 collision.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r449959403", "createdAt": "2020-07-06T02:49:50Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,21 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final BytesReference roleDescriptorsBytes = apiKeyService.getRoleDescriptorsBytesForApiKey(authentication, limitedBy);\n+        final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNDc4MA=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3MTk4NQ==", "bodyText": "I'm happy with the sha256 option. I also like BytesKey - it's simple and sensible, but I don't think it's the right fit here unless we change the cache to have aSet<?> as the key, or follow your idea of converting a Set<String> into a BytesKey", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450071985", "createdAt": "2020-07-06T08:42:50Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,21 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final BytesReference roleDescriptorsBytes = apiKeyService.getRoleDescriptorsBytesForApiKey(authentication, limitedBy);\n+        final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNDc4MA=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI2ODY1Mg==", "bodyText": "Cool let's keep the sha256 option then. It works and is simpler.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450268652", "createdAt": "2020-07-06T14:40:12Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,21 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final BytesReference roleDescriptorsBytes = apiKeyService.getRoleDescriptorsBytesForApiKey(authentication, limitedBy);\n+        final String roleDescriptorsHash = new String(Hasher.SHA256.hash(new SecureString(roleDescriptorsBytes.toString().toCharArray())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNDc4MA=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDc4MzgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNjoxMjoxM1rOGosqUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMjo0MjozMlrOGtHQTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNzk1NQ==", "bodyText": "We should use the version of convertToMap that takes an explicit XContentType.JSON", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r445327955", "createdAt": "2020-06-25T06:12:13Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +156,25 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version version, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && version.before(Version.V_7_9_0)) {\n+            metadata = new HashMap<>(metadata);\n+            metadata.put(\n+                API_KEY_ROLE_DESCRIPTORS_KEY,\n+                XContentHelper.convertToMap((BytesReference) metadata.get(API_KEY_ROLE_DESCRIPTORS_KEY), false).v2());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1Nzk2NQ==", "bodyText": "Updated this and a few other places of similar deprecated usage.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r449957965", "createdAt": "2020-07-06T02:42:32Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +156,25 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version version, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && version.before(Version.V_7_9_0)) {\n+            metadata = new HashMap<>(metadata);\n+            metadata.put(\n+                API_KEY_ROLE_DESCRIPTORS_KEY,\n+                XContentHelper.convertToMap((BytesReference) metadata.get(API_KEY_ROLE_DESCRIPTORS_KEY), false).v2());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyNzk1NQ=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDgwMjI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNjoyMDo0M1rOGos1rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTo0NjoxNVrOGtT8gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzMDg2MQ==", "bodyText": "I think having getRoleForApiKey, getRoleDescriptorsBytesForApiKey and getRoleDescriptorsForApiKey is confusing and likely to get us into trouble in the future.\nIs it necessary for the caller to have to know which method to use depending on the version of the Authentication object it has?\nI worry about the fragility of code that calls getRoleDescriptorsForApiKey and works on 7.9+ but then fails in a mixed cluster.\nWould it be possible to merge getRoleDescriptorsForApiKey and getRoleForApiKey into a single method, or at least make it save to call getRoleDescriptorsForApiKey on an old style Authentication object?", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r445330861", "createdAt": "2020-06-25T06:20:43Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -366,6 +375,20 @@ public void getRoleForApiKey(Authentication authentication, ActionListener<ApiKe\n         }\n     }\n \n+    public BytesReference getRoleDescriptorsBytesForApiKey(Authentication authentication, boolean limitedBy) {\n+        if (authentication.getAuthenticationType() != AuthenticationType.API_KEY) {\n+            throw new IllegalStateException(\"authentication type must be api key but is \" + authentication.getAuthenticationType());\n+        }\n+        final Map<String, Object> metadata = authentication.getMetadata();\n+        return (BytesReference) metadata.get(limitedBy ? API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY : API_KEY_ROLE_DESCRIPTORS_KEY);\n+    }\n+\n+    public List<RoleDescriptor> getRoleDescriptorsForApiKey(Authentication authentication, boolean limitedBy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk0NTQ4MQ==", "bodyText": "Short version: I removed getRoleDescriptorsForApiKey and renamed getRoleDescriptorsBytesForApiKey to getApiKeyIdAndBytes.\nLonger version: I agree the names are rather confusing. Initially, I completely removed getRoleForApiKey and List<RoleDescriptor> parseRoleDescriptors(String, Map<String, Object>) because they are used only for old style Authentication. But I had to add them back when I realised there were BWC issues. Anyway, we can and should remove them in 9.0.\nUnfortunately, it is not feasible to merge getRoleForApiKey and getRoleDescriptorsForApiKey even though they both return something related to role descriptors. The old getRoleForApiKey returns a ApiKeyRoleDescriptors object, which internally has two List<RoleDescriptors>, one for from-role and the other for limited-by. But this would be non-ideal for the new getRoleDescriptorsForApiKey which returns either from-role-descriptors or limited-by-role-descriptors. By returning them separately, we can cache and lookup them separately. That is, if multiple keys are created by the same user, their limited-by roles are only computed once and cached for all other keys. The reverse is also true (though maybe less likely), if multiple keys happen to have the from-role-descriptors even when they are created by different users, we only need compute the from-roles once.\nSo there is no shared code path between getRoleForApiKey and getRoleDescriptorsForApiKey they work like the follows:\n\nOld Authentication -> getRoleForApiKey -> parseRoleDescriptors(String, Map<String, Object>)\nNew Authentication -> getRoleDescriptorsBytesForApiKey -> if not cached -> getRoleDescriptorsForApiKey -> parseRoleDescriptors(String, ByteReference)\n\nI intentionally kept them separate so the old code path can be easily removed when the time comes.\nWith above being said, I do agree that the names are confusing. So I renamed getRoleDescriptorsBytesForApiKey to getApiKeyIdAndBytes and removed getRoleDescriptorsForApiKey by a direct call to parseRoleDescriptors(String, ByteReference) in the caller.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r449945481", "createdAt": "2020-07-06T01:33:05Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -366,6 +375,20 @@ public void getRoleForApiKey(Authentication authentication, ActionListener<ApiKe\n         }\n     }\n \n+    public BytesReference getRoleDescriptorsBytesForApiKey(Authentication authentication, boolean limitedBy) {\n+        if (authentication.getAuthenticationType() != AuthenticationType.API_KEY) {\n+            throw new IllegalStateException(\"authentication type must be api key but is \" + authentication.getAuthenticationType());\n+        }\n+        final Map<String, Object> metadata = authentication.getMetadata();\n+        return (BytesReference) metadata.get(limitedBy ? API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY : API_KEY_ROLE_DESCRIPTORS_KEY);\n+    }\n+\n+    public List<RoleDescriptor> getRoleDescriptorsForApiKey(Authentication authentication, boolean limitedBy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzMDg2MQ=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4MTI1MQ==", "bodyText": "If I understand correctly, getRoleForApiKey will only do the right thing for old style authentication.\nIf so, can we:\n\nAdd that to the javadoc\nAdd an assert authentication.getVersion().before(Version.V7_9_0) : \"This method only applies to authentication objects created before v7.9.0\";", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450081251", "createdAt": "2020-07-06T08:58:47Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -366,6 +375,20 @@ public void getRoleForApiKey(Authentication authentication, ActionListener<ApiKe\n         }\n     }\n \n+    public BytesReference getRoleDescriptorsBytesForApiKey(Authentication authentication, boolean limitedBy) {\n+        if (authentication.getAuthenticationType() != AuthenticationType.API_KEY) {\n+            throw new IllegalStateException(\"authentication type must be api key but is \" + authentication.getAuthenticationType());\n+        }\n+        final Map<String, Object> metadata = authentication.getMetadata();\n+        return (BytesReference) metadata.get(limitedBy ? API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY : API_KEY_ROLE_DESCRIPTORS_KEY);\n+    }\n+\n+    public List<RoleDescriptor> getRoleDescriptorsForApiKey(Authentication authentication, boolean limitedBy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzMDg2MQ=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2NTg5MQ==", "bodyText": "These are both good ideas. Will update accordingly. Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450165891", "createdAt": "2020-07-06T11:46:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -366,6 +375,20 @@ public void getRoleForApiKey(Authentication authentication, ActionListener<ApiKe\n         }\n     }\n \n+    public BytesReference getRoleDescriptorsBytesForApiKey(Authentication authentication, boolean limitedBy) {\n+        if (authentication.getAuthenticationType() != AuthenticationType.API_KEY) {\n+            throw new IllegalStateException(\"authentication type must be api key but is \" + authentication.getAuthenticationType());\n+        }\n+        final Map<String, Object> metadata = authentication.getMetadata();\n+        return (BytesReference) metadata.get(limitedBy ? API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY : API_KEY_ROLE_DESCRIPTORS_KEY);\n+    }\n+\n+    public List<RoleDescriptor> getRoleDescriptorsForApiKey(Authentication authentication, boolean limitedBy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzMDg2MQ=="}, "originalCommit": {"oid": "d2560d8acc141648c6ecb2211ff48dab1a94bf3d"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTk3NDY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo1MzozNVrOGtOlmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTo1MDo0MFrOGtUElQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3ODEwNQ==", "bodyText": "I don't think this is true even in 9.0 - we don't have anything in place that would automatically rewrite saved authentication objects from 7.x watcher jobs.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450078105", "createdAt": "2020-07-06T08:53:35Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -239,7 +239,7 @@ public void getRoles(User user, Authentication authentication, ActionListener<Ro\n                     },\n                     roleActionListener::onFailure\n                 ));\n-            } else {\n+            } else {  // TODO: the else branch is for bwc and can be deleted in 9.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50f170675220e8ee2ca6d9f6a61941b7ed12bd42"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2Nzk1Nw==", "bodyText": "You are right. I realised it a while ago, then I just forgot about it again. Thanks for reminding me.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450167957", "createdAt": "2020-07-06T11:50:40Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -239,7 +239,7 @@ public void getRoles(User user, Authentication authentication, ActionListener<Ro\n                     },\n                     roleActionListener::onFailure\n                 ));\n-            } else {\n+            } else {  // TODO: the else branch is for bwc and can be deleted in 9.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3ODEwNQ=="}, "originalCommit": {"oid": "50f170675220e8ee2ca6d9f6a61941b7ed12bd42"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTk4MTExOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo1NToxMFrOGtOpdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo1NToxMFrOGtOpdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3OTA5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Tuple<String, BytesReference> getApiKeyIdAndBytes(Authentication authentication, boolean limitedBy) {\n          \n          \n            \n                public Tuple<String, BytesReference> getApiKeyIdAndRoleBytes(Authentication authentication, boolean limitedBy) {\n          \n      \n    \n    \n  \n\n(or role descriptor, or ...)\nBut Bytes to me implies the whole API key JSON or something like that.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r450079095", "createdAt": "2020-07-06T08:55:10Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -375,18 +377,14 @@ public void getRoleForApiKey(Authentication authentication, ActionListener<ApiKe\n         }\n     }\n \n-    public BytesReference getRoleDescriptorsBytesForApiKey(Authentication authentication, boolean limitedBy) {\n+    public Tuple<String, BytesReference> getApiKeyIdAndBytes(Authentication authentication, boolean limitedBy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50f170675220e8ee2ca6d9f6a61941b7ed12bd42"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzExNTM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxNjo1NzoxOFrOGwVpiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwOTo1Nzo0M1rOGwhl-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMzOTUzMQ==", "bodyText": "The name rewriteMetadataIfNecessary is not very inspired; I have to read the code to know what this rewriting is about.\nMy suggestion: rewriteApiKeyAuthenticationRoleMetadata (drop \"if necessary\")\nI would also slightly prefer to move this to the Authentication class, and maybe have a static method there that takes an authentication and a version as parameters and returns a new authentication with that version, and any rewritings done. I would also define a new static constant on Version.V_7_9_0 inside Authentication as VERSION_API_KEY_ROLES_AS_STRING (see TokenService for examples).", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453339531", "createdAt": "2020-07-12T16:57:18Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +157,27 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version streamVersion, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && streamVersion.before(Version.V_7_9_0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQzNDEyMQ==", "bodyText": "These are all good suggestions. Will address accordingly.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453434121", "createdAt": "2020-07-13T04:55:19Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +157,27 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version streamVersion, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && streamVersion.before(Version.V_7_9_0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMzOTUzMQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2MTc5Mg==", "bodyText": "I renamed the method to rewriteMetadataForApiKeyRoleDescriptors. But after some thoughts, I decided to keep this method inside SecurityContext. Because I need to make it public if moved to Authentication and that feels a bit uneasy to me since SecurityContext is the only consumer and will probably keep it that way in future. So I feel it is better to stay within it and closer to the actual context. It is an unnecessary detail to put inside Authentication if people is not concerned of BWC. Similarly I added the new version constant to SecurityContext as well. Sorry for the back and forth.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453461792", "createdAt": "2020-07-13T06:36:19Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +157,27 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version streamVersion, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && streamVersion.before(Version.V_7_9_0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMzOTUzMQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUxNjAyOA==", "bodyText": "Okay, but the constant can sit inside Authentication to be referenced in the CompositeRolesStore too.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453516028", "createdAt": "2020-07-13T09:26:09Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +157,27 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version streamVersion, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && streamVersion.before(Version.V_7_9_0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMzOTUzMQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUzNTIyNw==", "bodyText": "Moved the new version constant to Authentication as suggested.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453535227", "createdAt": "2020-07-13T09:57:43Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -149,8 +157,27 @@ public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer\n         final Authentication authentication = getAuthentication();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(),\n+                rewriteMetadataIfNecessary(version, authentication)));\n             consumer.accept(original);\n         }\n     }\n+\n+    private Map<String, Object> rewriteMetadataIfNecessary(Version streamVersion, Authentication authentication) {\n+        Map<String, Object> metadata = authentication.getMetadata();\n+        if (authentication.getAuthenticationType() == AuthenticationType.API_KEY\n+            && authentication.getVersion().onOrAfter(Version.V_7_9_0)\n+            && streamVersion.before(Version.V_7_9_0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMzOTUzMQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzE1NTU1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQxNzo0ODo0M1rOGwV8zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjo1MToyOVrOGwdZHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM0NDQ2MQ==", "bodyText": "Why have you introduced this new class in this PR? Is it required for something?\nI'd obviously vote to get rid of the Map<String, Object> source any time of day, but this doesn't look like a great improvement, and it makes this PR harder to follow than necessary.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453344461", "createdAt": "2020-07-12T17:48:43Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -974,4 +1018,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NTE0OA==", "bodyText": "Yes, it is intentionally introduced and is more or less a centre piece of this PR, which is about improve the role cache efficiency for API keys, i.e. same role descriptors should only be cached once even when they are from different API keys. The current cache is basically keyed by ApiKey ID, which is unfit for the goal. The obvious choice is to use role descriptors themselves as the key, but it has a few downsides and also not compatible the existing cache. So alternatively, we could use the string representation of role descriptors as the key. To further reduce the memory cost, we actually use sha256 of the string representation as the key. More details can be found here\nSo this new class has roleDescriptors and limitedByRoeDescriptors as ByteReference to faciliate the calculation. By storing them as bytes instead of Map, it also helps avoid quite a few unncessary serialisation and deserialisation. So instead of four de/serialisation, it now only deserialises once. When security index is local to a node, all these de/serialisation operations are a noticable part of the total authentication time (> 20%).", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453445148", "createdAt": "2020-07-13T05:39:42Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -974,4 +1018,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM0NDQ2MQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2NjM5Nw==", "bodyText": "Okay, thank you for the explanation!\nI would've thought that you can get the BytesReference for a source field but haven't checked before asking and it turns out you can't, you must use a parser.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453466397", "createdAt": "2020-07-13T06:51:29Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -974,4 +1018,66 @@ private boolean verify(SecureString password) {\n             return hash != null && cacheHasher.verify(password, hash);\n         }\n     }\n+\n+    public static final class ApiKeyDoc {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM0NDQ2MQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzI2MDU3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMDowMToyMVrOGwWu4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwOTo1NDo0MlrOGwhe7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NzI4MQ==", "bodyText": "When can this be true?", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453357281", "createdAt": "2020-07-12T20:01:21Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -221,20 +224,40 @@ public void getRoles(User user, Authentication authentication, ActionListener<Ro\n \n         final Authentication.AuthenticationType authType = authentication.getAuthenticationType();\n         if (authType == Authentication.AuthenticationType.API_KEY) {\n-            apiKeyService.getRoleForApiKey(authentication, ActionListener.wrap(apiKeyRoleDescriptors -> {\n-                final List<RoleDescriptor> descriptors = apiKeyRoleDescriptors.getRoleDescriptors();\n-                if (descriptors == null) {\n-                    roleActionListener.onFailure(new IllegalStateException(\"missing role descriptors\"));\n-                } else if (apiKeyRoleDescriptors.getLimitedByRoleDescriptors() == null) {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\", roleActionListener);\n-                } else {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\",\n-                        ActionListener.wrap(role -> buildAndCacheRoleFromDescriptors(apiKeyRoleDescriptors.getLimitedByRoleDescriptors(),\n-                            apiKeyRoleDescriptors.getApiKeyId() + \"_limited_role_desc\", ActionListener.wrap(\n-                                limitedBy -> roleActionListener.onResponse(LimitedRole.createLimitedRole(role, limitedBy)),\n-                                roleActionListener::onFailure)), roleActionListener::onFailure));\n-                }\n-            }, roleActionListener::onFailure));\n+            if (authentication.getVersion().onOrAfter(Version.V_7_9_0)) {\n+                getOrBuildRoleForApiKey(authentication, false, ActionListener.wrap(\n+                    role -> {\n+                        if (role == Role.EMPTY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQzOTMxMw==", "bodyText": "When a list of role descriptor is empty, the role building method buildRoleFromDescriptors returns Role.EMPTY.\nAlso when an API key does not have its own role descriptors, its document will have {} for the role_descriptors field, which in turn will be converted to an empty list of RoleDescriptor.\nWhen the two work together, you can get Role.EMPTY.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453439313", "createdAt": "2020-07-13T05:16:56Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -221,20 +224,40 @@ public void getRoles(User user, Authentication authentication, ActionListener<Ro\n \n         final Authentication.AuthenticationType authType = authentication.getAuthenticationType();\n         if (authType == Authentication.AuthenticationType.API_KEY) {\n-            apiKeyService.getRoleForApiKey(authentication, ActionListener.wrap(apiKeyRoleDescriptors -> {\n-                final List<RoleDescriptor> descriptors = apiKeyRoleDescriptors.getRoleDescriptors();\n-                if (descriptors == null) {\n-                    roleActionListener.onFailure(new IllegalStateException(\"missing role descriptors\"));\n-                } else if (apiKeyRoleDescriptors.getLimitedByRoleDescriptors() == null) {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\", roleActionListener);\n-                } else {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\",\n-                        ActionListener.wrap(role -> buildAndCacheRoleFromDescriptors(apiKeyRoleDescriptors.getLimitedByRoleDescriptors(),\n-                            apiKeyRoleDescriptors.getApiKeyId() + \"_limited_role_desc\", ActionListener.wrap(\n-                                limitedBy -> roleActionListener.onResponse(LimitedRole.createLimitedRole(role, limitedBy)),\n-                                roleActionListener::onFailure)), roleActionListener::onFailure));\n-                }\n-            }, roleActionListener::onFailure));\n+            if (authentication.getVersion().onOrAfter(Version.V_7_9_0)) {\n+                getOrBuildRoleForApiKey(authentication, false, ActionListener.wrap(\n+                    role -> {\n+                        if (role == Role.EMPTY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NzI4MQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUwODg1NA==", "bodyText": "Got it! I have to check the code every single time to tell if the role_descriptors field or the limited_by_role_descriptors can be empty, the meanings are reversed in ApiKeyService#getRoleForApiKey.\nSince limitedByRole can never be null I would be building that first, for a minor branching simplification:\n         final Authentication.AuthenticationType authType = authentication.getAuthenticationType();\n         if (authType == Authentication.AuthenticationType.API_KEY) {\n             if (authentication.getVersion().onOrAfter(Version.V_7_9_0)) {\n-                buildAndCacheRoleForApiKey(authentication, false, ActionListener.wrap(\n-                    role -> {\n-                        if (role == Role.EMPTY) {\n-                            buildAndCacheRoleForApiKey(authentication, true, roleActionListener);\n-                        } else {\n-                            buildAndCacheRoleForApiKey(authentication, true, ActionListener.wrap(\n-                                limitedByRole -> roleActionListener.onResponse(\n-                                    limitedByRole == Role.EMPTY ? role : LimitedRole.createLimitedRole(role, limitedByRole)),\n-                                roleActionListener::onFailure\n+                buildAndCacheRoleForApiKey(authentication, true, ActionListener.wrap(\n+                        limitedByRole -> {\n+                            buildAndCacheRoleForApiKey(authentication, false, ActionListener.wrap(\n+                                    role -> roleActionListener.onResponse(\n+                                            role == Role.EMPTY ? limitedByRole : LimitedRole.createLimitedRole(role, limitedByRole)),\n+                                    roleActionListener::onFailure\n                             ));\n-                        }\n-                    },\n-                    roleActionListener::onFailure\n+                        },\n+                        roleActionListener::onFailure\n                 ));\n             } else {\n                 apiKeyService.getRoleForApiKey(authentication, ActionListener.wrap(apiKeyRoleDescriptors -> {\n\nFeel free to follow this suggestion or not.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453508854", "createdAt": "2020-07-13T09:14:40Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -221,20 +224,40 @@ public void getRoles(User user, Authentication authentication, ActionListener<Ro\n \n         final Authentication.AuthenticationType authType = authentication.getAuthenticationType();\n         if (authType == Authentication.AuthenticationType.API_KEY) {\n-            apiKeyService.getRoleForApiKey(authentication, ActionListener.wrap(apiKeyRoleDescriptors -> {\n-                final List<RoleDescriptor> descriptors = apiKeyRoleDescriptors.getRoleDescriptors();\n-                if (descriptors == null) {\n-                    roleActionListener.onFailure(new IllegalStateException(\"missing role descriptors\"));\n-                } else if (apiKeyRoleDescriptors.getLimitedByRoleDescriptors() == null) {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\", roleActionListener);\n-                } else {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\",\n-                        ActionListener.wrap(role -> buildAndCacheRoleFromDescriptors(apiKeyRoleDescriptors.getLimitedByRoleDescriptors(),\n-                            apiKeyRoleDescriptors.getApiKeyId() + \"_limited_role_desc\", ActionListener.wrap(\n-                                limitedBy -> roleActionListener.onResponse(LimitedRole.createLimitedRole(role, limitedBy)),\n-                                roleActionListener::onFailure)), roleActionListener::onFailure));\n-                }\n-            }, roleActionListener::onFailure));\n+            if (authentication.getVersion().onOrAfter(Version.V_7_9_0)) {\n+                getOrBuildRoleForApiKey(authentication, false, ActionListener.wrap(\n+                    role -> {\n+                        if (role == Role.EMPTY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NzI4MQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUzMzQyMg==", "bodyText": "You may be right. But I am not entirely sure when it comes to derived API keys. A derived keys will have limited by role descriptors from parent API key's roles. Since we now zero out API key's roles during authentication, we may end up having an empty limited by role descriptors as well. I have not tested, but I feel it is probably safer to keep the code as is for now.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453533422", "createdAt": "2020-07-13T09:54:42Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -221,20 +224,40 @@ public void getRoles(User user, Authentication authentication, ActionListener<Ro\n \n         final Authentication.AuthenticationType authType = authentication.getAuthenticationType();\n         if (authType == Authentication.AuthenticationType.API_KEY) {\n-            apiKeyService.getRoleForApiKey(authentication, ActionListener.wrap(apiKeyRoleDescriptors -> {\n-                final List<RoleDescriptor> descriptors = apiKeyRoleDescriptors.getRoleDescriptors();\n-                if (descriptors == null) {\n-                    roleActionListener.onFailure(new IllegalStateException(\"missing role descriptors\"));\n-                } else if (apiKeyRoleDescriptors.getLimitedByRoleDescriptors() == null) {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\", roleActionListener);\n-                } else {\n-                    buildAndCacheRoleFromDescriptors(descriptors, apiKeyRoleDescriptors.getApiKeyId() + \"_role_desc\",\n-                        ActionListener.wrap(role -> buildAndCacheRoleFromDescriptors(apiKeyRoleDescriptors.getLimitedByRoleDescriptors(),\n-                            apiKeyRoleDescriptors.getApiKeyId() + \"_limited_role_desc\", ActionListener.wrap(\n-                                limitedBy -> roleActionListener.onResponse(LimitedRole.createLimitedRole(role, limitedBy)),\n-                                roleActionListener::onFailure)), roleActionListener::onFailure));\n-                }\n-            }, roleActionListener::onFailure));\n+            if (authentication.getVersion().onOrAfter(Version.V_7_9_0)) {\n+                getOrBuildRoleForApiKey(authentication, false, ActionListener.wrap(\n+                    role -> {\n+                        if (role == Role.EMPTY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NzI4MQ=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzI2NjE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMDowODowMFrOGwWxiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwOTo0OTowN1rOGwhRuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Nzk2MA==", "bodyText": "Nit: you can can compute the digest in one line.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453357960", "createdAt": "2020-07-12T20:08:00Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,23 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final Tuple<String, BytesReference> apiKeyIdAndBytes = apiKeyService.getApiKeyIdAndRoleBytes(authentication, limitedBy);\n+        final MessageDigest digest = MessageDigests.sha256();\n+        digest.update(BytesReference.toBytes(apiKeyIdAndBytes.v2()));\n+        final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUwOTY4Mg==", "bodyText": "Even more succinct:\nfinal String roleDescriptorsHash = MessageDigests.toHexString(MessageDigests.sha256().digest(BytesReference.toBytes(apiKeyIdAndBytes.v2())));\n\nMessageDigests.sha256() is thread local and it's also reset before every use, so my objection was actually about minimising the scope of the digest instance.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453509682", "createdAt": "2020-07-13T09:15:52Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,23 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final Tuple<String, BytesReference> apiKeyIdAndBytes = apiKeyService.getApiKeyIdAndRoleBytes(authentication, limitedBy);\n+        final MessageDigest digest = MessageDigests.sha256();\n+        digest.update(BytesReference.toBytes(apiKeyIdAndBytes.v2()));\n+        final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Nzk2MA=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUzMDA0MQ==", "bodyText": "Updated as suggested. Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453530041", "createdAt": "2020-07-13T09:49:07Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,23 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final Tuple<String, BytesReference> apiKeyIdAndBytes = apiKeyService.getApiKeyIdAndRoleBytes(authentication, limitedBy);\n+        final MessageDigest digest = MessageDigests.sha256();\n+        digest.update(BytesReference.toBytes(apiKeyIdAndBytes.v2()));\n+        final String roleDescriptorsHash = MessageDigests.toHexString(digest.digest());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1Nzk2MA=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzI4NTQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQyMDozMjozMlrOGwW6sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwOToyNDo1NVrOGwgX0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2MDMwNA==", "bodyText": "Methods here don't have a clear interface, it could just as well not be methods at all; the limitedBy flag is really ruining every structure.\nI would move the full logic that obtains the Role for an API Keys from the CompositeRolesStore class to the ApiKeyService class.\nBut I realise I'm late to the party, we can do this in a follow-up.\n@tvernum would you agree merging this PR, and following up with a refactoring?", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453360304", "createdAt": "2020-07-12T20:32:32Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,23 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final Tuple<String, BytesReference> apiKeyIdAndBytes = apiKeyService.getApiKeyIdAndRoleBytes(authentication, limitedBy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQzNjg3NA==", "bodyText": "Role building has always been done inside CompositeRolesStore and I think it fits here since role building and caching are the main purposes of CompositeRolesStore. It only delegates retrieval of role descriptors to different roles providers, including ApiKeyService, which is the case for this method as well. Overall, I think the method name could use some help (maybe buildAndCacheRoleForApiKey to mirror the existing buildAndCacheRoleFromDescriptors?), but its content looks fine to me.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453436874", "createdAt": "2020-07-13T05:06:41Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,23 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final Tuple<String, BytesReference> apiKeyIdAndBytes = apiKeyService.getApiKeyIdAndRoleBytes(authentication, limitedBy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2MDMwNA=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUxNTIxOA==", "bodyText": "Good point! Yes, Role should stay inside the CompositeRolesStore.\nThen I think we can make ApiKeyRoleDescriptors lazily parse RoleDescriptor. Not sure what to do about the cache key. Let's leave this for the future us.", "url": "https://github.com/elastic/elasticsearch/pull/58156#discussion_r453515218", "createdAt": "2020-07-13T09:24:55Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -295,6 +318,23 @@ private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor>\n         }, listener::onFailure));\n     }\n \n+    private void getOrBuildRoleForApiKey(Authentication authentication, boolean limitedBy, ActionListener<Role> roleActionListener) {\n+        final Tuple<String, BytesReference> apiKeyIdAndBytes = apiKeyService.getApiKeyIdAndRoleBytes(authentication, limitedBy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM2MDMwNA=="}, "originalCommit": {"oid": "52698f4156d772dcdcb1d0253dfd85cda87026f9"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1491, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}