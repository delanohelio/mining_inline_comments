{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjUzNDAy", "number": 51100, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToxNzowN1rODYwXhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoxNzo1NVrODZ2Jqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mjg0ODY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToxNzowN1rOFey4Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMzoxNzo1OFrOFfeCBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg==", "bodyText": "should we disallow fielddata on this field ? It's an implementation details and I am not sure that we want to expose it in aggs or sorting ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835206", "createdAt": "2020-01-17T09:17:07Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTQxOA==", "bodyText": "Maybe keep it only for indices created before 8 to handle bwc ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835418", "createdAt": "2020-01-17T09:17:41Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3OTE0Nw==", "bodyText": "I'll remove it - indices created before 8 still use TypeFieldMapper, so BWC is handled that way", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367879147", "createdAt": "2020-01-17T10:57:27Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MjIxMw==", "bodyText": "I pushed 7ea0da8", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r368542213", "createdAt": "2020-01-20T13:17:58Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.plain.ConstantIndexFieldData;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTIwNg=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mjg1Mjk5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToxODo1NlrOFey7Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToxNTo1OFrOFe8IlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw==", "bodyText": "Can you switch to the NestedPathFieldMapper.TypeParser in this pr since you handle bwc in the new field type ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367835907", "createdAt": "2020-01-17T09:18:56Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "diffHunk": "@@ -157,6 +158,7 @@ public IndicesModule(List<MapperPlugin> mapperPlugins) {\n         builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser());\n         builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser());\n         builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NTAwNA==", "bodyText": "We may be able to in future, but I think we need to keep TypeFieldMapper around for the moment because it's still used for type queries, etc.", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367845004", "createdAt": "2020-01-17T09:39:29Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "diffHunk": "@@ -157,6 +158,7 @@ public IndicesModule(List<MapperPlugin> mapperPlugins) {\n         builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser());\n         builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser());\n         builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjgzNw==", "bodyText": "Ok I was confused because there are some logic to handle bwc in NestedPathFieldMapper.", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367986837", "createdAt": "2020-01-17T15:15:58Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesModule.java", "diffHunk": "@@ -157,6 +158,7 @@ public IndicesModule(List<MapperPlugin> mapperPlugins) {\n         builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser());\n         builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser());\n         builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzNTkwNw=="}, "originalCommit": {"oid": "0fff0cfd2dade3274c601991809ea9340599ad3d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzgyMDcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToxNDo0OFrOFe8GUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMzoxNzo0NlrOFfeBkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjI1Ng==", "bodyText": "For indices created in v8 we don't need to add any prefix since we use a dedicated field ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367986256", "createdAt": "2020-01-17T15:14:48Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java", "diffHunk": "@@ -335,9 +331,8 @@ protected static void parseProperties(ObjectMapper.Builder objBuilder, Map<Strin\n         } else {\n             this.mappers = CopyOnWriteHashMap.copyOf(mappers);\n         }\n-        this.nestedTypePathAsString = \"__\" + fullPath;\n-        this.nestedTypePathAsBytes = new BytesRef(nestedTypePathAsString);\n-        this.nestedTypeFilter = new TermQuery(new Term(TypeFieldMapper.NAME, nestedTypePathAsBytes));\n+        this.nestedTypePath = \"__\" + fullPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MjA5Ng==", "bodyText": "++ I pushed 7ea0da8", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r368542096", "createdAt": "2020-01-20T13:17:46Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java", "diffHunk": "@@ -335,9 +331,8 @@ protected static void parseProperties(ObjectMapper.Builder objBuilder, Map<Strin\n         } else {\n             this.mappers = CopyOnWriteHashMap.copyOf(mappers);\n         }\n-        this.nestedTypePathAsString = \"__\" + fullPath;\n-        this.nestedTypePathAsBytes = new BytesRef(nestedTypePathAsString);\n-        this.nestedTypeFilter = new TermQuery(new Term(TypeFieldMapper.NAME, nestedTypePathAsBytes));\n+        this.nestedTypePath = \"__\" + fullPath;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NjI1Ng=="}, "originalCommit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mzg0MzgyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNToyMTo0M1rOFe8UnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMzoxODoxMFrOFfeCYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTkxNw==", "bodyText": "I don't think we need to index root document in this field. We use the nested path to find nested documents but we don't use this field to detect root documents so this indexing would be redundant ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r367989917", "createdAt": "2020-01-17T15:21:43Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public boolean isSearchable() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new UnsupportedOperationException(\"Cannot run exists() query against the nested field path\");\n+        }\n+    }\n+\n+    private NestedPathFieldMapper(IndexSettings indexSettings, MappedFieldType existing) {\n+        this(existing == null ? defaultFieldType(indexSettings) : existing.clone(),\n+            indexSettings);\n+    }\n+\n+    private NestedPathFieldMapper(MappedFieldType fieldType, IndexSettings indexSettings) {\n+        super(name(indexSettings.getSettings()), fieldType, defaultFieldType(indexSettings), indexSettings.getSettings());\n+    }\n+\n+    private static MappedFieldType defaultFieldType(IndexSettings indexSettings) {\n+        MappedFieldType defaultFieldType = Defaults.FIELD_TYPE.clone();\n+        defaultFieldType.setIndexOptions(IndexOptions.NONE);\n+        defaultFieldType.setHasDocValues(false);\n+        defaultFieldType.setName(name(indexSettings.getSettings()));\n+        return defaultFieldType;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+        super.parse(context);\n+    }\n+\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        // we parse in pre parse\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        if (fieldType().indexOptions() == IndexOptions.NONE && !fieldType().stored()) {\n+            return;\n+        }\n+        fields.add(new Field(fieldType().name(), MapperService.SINGLE_MAPPING_NAME, fieldType()));\n+        if (fieldType().hasDocValues()) {\n+            fields.add(new SortedSetDocValuesField(fieldType().name(), new BytesRef(MapperService.SINGLE_MAPPING_NAME)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MjMwNA==", "bodyText": "++ I pushed 7ea0da8", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r368542304", "createdAt": "2020-01-20T13:18:10Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setStored(false);\n+            FIELD_TYPE.setOmitNorms(true);\n+            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+        @Override\n+        public MetadataFieldMapper.Builder<?,?> parse(String name, Map<String, Object> node,\n+                                                      ParserContext parserContext) throws MapperParsingException {\n+            throw new MapperParsingException(name(parserContext.mapperService().getIndexSettings().getSettings()) + \" is not configurable\");\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {\n+            final IndexSettings indexSettings = context.mapperService().getIndexSettings();\n+            return new NestedPathFieldMapper(indexSettings, fieldType);\n+        }\n+    }\n+\n+    public static final class NestedPathFieldType extends StringFieldType {\n+\n+        NestedPathFieldType() {\n+        }\n+\n+        protected NestedPathFieldType(NestedPathFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new NestedPathFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public boolean isSearchable() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new UnsupportedOperationException(\"Cannot run exists() query against the nested field path\");\n+        }\n+    }\n+\n+    private NestedPathFieldMapper(IndexSettings indexSettings, MappedFieldType existing) {\n+        this(existing == null ? defaultFieldType(indexSettings) : existing.clone(),\n+            indexSettings);\n+    }\n+\n+    private NestedPathFieldMapper(MappedFieldType fieldType, IndexSettings indexSettings) {\n+        super(name(indexSettings.getSettings()), fieldType, defaultFieldType(indexSettings), indexSettings.getSettings());\n+    }\n+\n+    private static MappedFieldType defaultFieldType(IndexSettings indexSettings) {\n+        MappedFieldType defaultFieldType = Defaults.FIELD_TYPE.clone();\n+        defaultFieldType.setIndexOptions(IndexOptions.NONE);\n+        defaultFieldType.setHasDocValues(false);\n+        defaultFieldType.setName(name(indexSettings.getSettings()));\n+        return defaultFieldType;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+        super.parse(context);\n+    }\n+\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        // we parse in pre parse\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        if (fieldType().indexOptions() == IndexOptions.NONE && !fieldType().stored()) {\n+            return;\n+        }\n+        fields.add(new Field(fieldType().name(), MapperService.SINGLE_MAPPING_NAME, fieldType()));\n+        if (fieldType().hasDocValues()) {\n+            fields.add(new SortedSetDocValuesField(fieldType().name(), new BytesRef(MapperService.SINGLE_MAPPING_NAME)));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTkxNw=="}, "originalCommit": {"oid": "7ea0da8acc167f8549d0ab77816c9717e5d2334b"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NDI3OTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoxNzoxMVrOFgdnMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoyNTo1OFrOFgd8kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MzkyMg==", "bodyText": "I think you need to preserve the sort order ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369583922", "createdAt": "2020-01-22T14:17:11Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -118,7 +118,7 @@\n     //TODO this needs to be cleaned up: _timestamp and _ttl are not supported anymore, _field_names, _seq_no, _version and _source are\n     //also missing, not sure if on purpose. See IndicesModule#getMetadataMappers\n     private static final String[] SORTED_META_FIELDS = new String[]{\n-        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\"\n+        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\", \"_nested_path\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4OTM5Mw==", "bodyText": "++, will fix.  I had a look at fixing the TODO above, but it's not all that straightforward unfortunately.", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369589393", "createdAt": "2020-01-22T14:25:58Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -118,7 +118,7 @@\n     //TODO this needs to be cleaned up: _timestamp and _ttl are not supported anymore, _field_names, _seq_no, _version and _source are\n     //also missing, not sure if on purpose. See IndicesModule#getMetadataMappers\n     private static final String[] SORTED_META_FIELDS = new String[]{\n-        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\"\n+        \"_id\", IgnoredFieldMapper.NAME, \"_index\", \"_routing\", \"_size\", \"_timestamp\", \"_ttl\", \"_type\", \"_nested_path\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MzkyMg=="}, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NDI4MjAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoxNzo1NVrOFgdo5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDoyOToyOFrOFgeFPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw==", "bodyText": "Should it bee IndexOptions.NONE ?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369584357", "createdAt": "2020-01-22T14:17:55Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4OTA3OA==", "bodyText": "We still need to search against it, so we need to store matching docs, unless I'm misunderstanding something?", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369589078", "createdAt": "2020-01-22T14:25:30Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw=="}, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MTYxNA==", "bodyText": "you're right, I mixed this with doc values, sorry for the noise.", "url": "https://github.com/elastic/elasticsearch/pull/51100#discussion_r369591614", "createdAt": "2020-01-22T14:29:28Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NestedPathFieldMapper.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.lucene.Lucene;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NestedPathFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME_PRE_V8 = \"_type\";\n+    public static final String NAME = \"_nested_path\";\n+\n+    public static String name(Settings settings) {\n+        if (Version.indexCreated(settings).before(Version.V_8_0_0)) {\n+            return NAME_PRE_V8;\n+        }\n+        return NAME;\n+    }\n+\n+    public static Query filter(Settings settings, String path) {\n+        return new TermQuery(new Term(name(settings), new BytesRef(path)));\n+    }\n+\n+    public static Field field(Settings settings, String path) {\n+        return new Field(name(settings), path, Defaults.FIELD_TYPE);\n+    }\n+\n+    public static class Defaults {\n+\n+        public static final MappedFieldType FIELD_TYPE = new NestedPathFieldType();\n+\n+        static {\n+            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4NDM1Nw=="}, "originalCommit": {"oid": "e59a3297806df9532e8130abd2475618b4d04971"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4478, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}