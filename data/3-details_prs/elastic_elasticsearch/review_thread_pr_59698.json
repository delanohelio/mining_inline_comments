{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMTk5MjU5", "number": 59698, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1NToyM1rOEPK0Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDo1MFrOEPLQSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQxMzI3OnYy", "diffSide": "RIGHT", "path": "docs/reference/modules/gateway.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1NToyM1rOGyu5Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1NToyM1rOGyu5Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MDI2Mw==", "bodyText": "I don't think we need this warning any more; at least, you probably already know you're doing something wrong before you get to the question of importing dangling indices.", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455850263", "createdAt": "2020-07-16T14:55:23Z", "author": {"login": "DaveCTurner"}, "path": "docs/reference/modules/gateway.asciidoc", "diffHunk": "@@ -56,29 +56,16 @@ NOTE: These settings only take effect on a full cluster restart.\n [[dangling-indices]]\n ==== Dangling indices\n \n-When a node joins the cluster, if it finds any shards stored in its local data\n-directory that do not already exist in the cluster, it will consider those\n-shards to be \"dangling\". Importing dangling indices\n-into the cluster using `gateway.auto_import_dangling_indices` is not safe.\n-Instead, use the <<dangling-indices-api,Dangling indices API>>. Neither\n-mechanism provides any guarantees as to whether the imported data truly\n-represents the latest state of the data when the index was still part of\n-the cluster.\n-\n-`gateway.auto_import_dangling_indices`::\n-\n-    deprecated:[7.9.0, This setting will be removed in 8.0. You should use the dedicated dangling indices API instead.]\n-    Whether to automatically import dangling indices into the cluster\n-    state, provided no indices already exist with the same name. Defaults\n-    to `false`.\n-\n-WARNING: The auto-import functionality was intended as a best effort to help users\n-who lose all master nodes. For example, if a new master node were to be\n-started which was unaware of the other indices in the cluster, adding the\n-old nodes would cause the old indices to be imported, instead of being\n-deleted. However there are several issues with automatic importing, and\n-its use is strongly discouraged in favour of the\n-<<dangling-indices-api,dedicated API>.\n-\n-WARNING: Losing all master nodes is a situation that should be avoided at\n-all costs, as it puts your cluster's metadata and data at risk.\n+When a node joins the cluster, if it finds any shards stored in its local\n+data directory that do not already exist in the cluster, it will consider\n+those shards to belong to a \"dangling\" index. You can list, import or\n+delete dangling indices using the <<dangling-indices-api,Dangling indices\n+API>>.\n+\n+NOTE: The API cannot offer any guarantees as to whether the imported data\n+truly represents the latest state of the data when the index was still part\n+of the cluster.\n+\n+WARNING: You should avoid situations that result in dangling indices (e.g.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b345ae3953877fc70fad661c423ddf703c23b66"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ0MDQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMToxNVrOGyvKWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMToxNVrOGyvKWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDY4Mw==", "bodyText": "Looks like the tests already mock out the ClusterService, so I think we could pass in the metadata via that mock, have them call getDanglingIndices() and thereby inline this. Or have DanglingIndicesState track a Supplier<ClusterState> rather than the full ClusterService and pass that in for the tests. Not sure which I prefer really, up to you.", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455854683", "createdAt": "2020-07-16T15:01:15Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "diffHunk": "@@ -47,234 +40,74 @@\n \n /**\n  * The dangling indices state is responsible for finding new dangling indices (indices that have\n- * their state written on disk, but don't exists in the metadata of the cluster), and importing\n- * them into the cluster.\n+ * their state written on disk, but don't exists in the metadata of the cluster).\n  */\n-public class DanglingIndicesState implements ClusterStateListener {\n+public class DanglingIndicesState {\n \n     private static final Logger logger = LogManager.getLogger(DanglingIndicesState.class);\n \n-    /**\n-     * Controls whether dangling indices should be automatically detected and imported into the cluster\n-     * state upon discovery. This setting is deprecated - use the <code>_dangling</code> API instead.\n-     * If disabled, dangling indices will not be automatically detected.\n-     *\n-     * @see org.elasticsearch.action.admin.indices.dangling\n-     */\n-    public static final Setting<Boolean> AUTO_IMPORT_DANGLING_INDICES_SETTING = Setting.boolSetting(\n-        \"gateway.auto_import_dangling_indices\",\n-        false,\n-        Setting.Property.NodeScope,\n-        Setting.Property.Deprecated\n-    );\n-\n-    private final NodeEnvironment nodeEnv;\n     private final MetaStateService metaStateService;\n-    private final LocalAllocateDangledIndices danglingIndicesAllocator;\n-    private final boolean isAutoImportDanglingIndicesEnabled;\n     private final ClusterService clusterService;\n \n-    private final Map<Index, IndexMetadata> danglingIndices = ConcurrentCollections.newConcurrentMap();\n-\n     @Inject\n-    public DanglingIndicesState(NodeEnvironment nodeEnv, MetaStateService metaStateService,\n-                                LocalAllocateDangledIndices danglingIndicesAllocator, ClusterService clusterService) {\n-        this.nodeEnv = nodeEnv;\n+    public DanglingIndicesState(MetaStateService metaStateService, ClusterService clusterService) {\n         this.metaStateService = metaStateService;\n-        this.danglingIndicesAllocator = danglingIndicesAllocator;\n         this.clusterService = clusterService;\n-\n-        this.isAutoImportDanglingIndicesEnabled = AUTO_IMPORT_DANGLING_INDICES_SETTING.get(clusterService.getSettings());\n-\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            clusterService.addListener(this);\n-        } else {\n-            logger.warn(\n-                AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey()\n-                    + \" is disabled, dangling indices will not be automatically detected or imported and must be managed manually\"\n-            );\n-        }\n-    }\n-\n-    boolean isAutoImportDanglingIndicesEnabled() {\n-        return this.isAutoImportDanglingIndicesEnabled;\n-    }\n-\n-    /**\n-     * Process dangling indices based on the provided meta data, handling cleanup, finding\n-     * new dangling indices, and allocating outstanding ones.\n-     */\n-    public void processDanglingIndices(final Metadata metadata) {\n-        assert this.isAutoImportDanglingIndicesEnabled;\n-\n-        if (nodeEnv.hasNodeFile() == false) {\n-            return;\n-        }\n-        cleanupAllocatedDangledIndices(metadata);\n-        findNewAndAddDanglingIndices(metadata);\n-        allocateDanglingIndices(metadata);\n     }\n \n     /**\n-     * Either return the current set of dangling indices, if auto-import is enabled, otherwise\n-     * scan for dangling indices right away.\n+     * Finds new dangling indices by iterating over the indices and trying to find indices\n+     * that have state on disk, but are not part of the provided metadata.\n      * @return a map of currently-known dangling indices\n      */\n     public Map<Index, IndexMetadata> getDanglingIndices() {\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            // This might be a good use case for CopyOnWriteHashMap\n-            return Map.copyOf(this.danglingIndices);\n-        } else {\n-            return findNewDanglingIndices(emptyMap(), this.clusterService.state().metadata());\n-        }\n-    }\n-\n-    /**\n-     * Cleans dangling indices if they are already allocated on the provided meta data.\n-     */\n-    void cleanupAllocatedDangledIndices(Metadata metadata) {\n-        for (Index index : danglingIndices.keySet()) {\n-            final IndexMetadata indexMetadata = metadata.index(index);\n-            if (indexMetadata != null && indexMetadata.getIndex().getName().equals(index.getName())) {\n-                if (indexMetadata.getIndex().getUUID().equals(index.getUUID()) == false) {\n-                    logger.warn(\"[{}] can not be imported as a dangling index, as there is already another index \" +\n-                        \"with the same name but a different uuid. local index will be ignored (but not deleted)\", index);\n-                } else {\n-                    logger.debug(\"[{}] no longer dangling (created), removing from dangling list\", index);\n-                }\n-                danglingIndices.remove(index);\n-            }\n-        }\n+        final Metadata metadata = this.clusterService.state().metadata();\n+        return findDanglingIndices(metadata);\n     }\n \n-    /**\n-     * Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices\n-     * to the currently tracked dangling indices.\n-     */\n-    void findNewAndAddDanglingIndices(final Metadata metadata) {\n-        final IndexGraveyard graveyard = metadata.indexGraveyard();\n+    // Extracted from getDanglingIndices() as a package-private method to allow easier testing testing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b345ae3953877fc70fad661c423ddf703c23b66"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ0Mjc4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/gateway/DanglingIndicesStateTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMTo0NFrOGyvLwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMTo0NFrOGyvLwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTA0Mg==", "bodyText": "Don't think we need to mock this any more.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455855042", "createdAt": "2020-07-16T15:01:44Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/gateway/DanglingIndicesStateTests.java", "diffHunk": "@@ -248,77 +148,20 @@ public void testDanglingIndicesStripAliases() throws Exception {\n             assertThat(dangledIndex.getAliases().size(), equalTo(1));\n \n             final Metadata metadata = Metadata.builder().build();\n-            Map<Index, IndexMetadata> newDanglingIndices = danglingState.findNewDanglingIndices(emptyMap(), metadata);\n+            Map<Index, IndexMetadata> newDanglingIndices = danglingState.findDanglingIndices(metadata);\n             assertThat(newDanglingIndices.size(), equalTo(1));\n             Map.Entry<Index, IndexMetadata> entry = newDanglingIndices.entrySet().iterator().next();\n             assertThat(entry.getKey().getName(), equalTo(\"test1\"));\n             assertThat(entry.getValue().getAliases().size(), equalTo(0));\n         }\n     }\n \n-    /**\n-     * Check that when auto-imports are disabled, then no change listener is registered with the cluster state.\n-     */\n-    public void testClusterStateListenerNotRegisterWhenSettingDisabled() throws Exception {\n-        try (NodeEnvironment env = newNodeEnvironment()) {\n-            MetaStateService metaStateService = new MetaStateService(env, xContentRegistry());\n-            LocalAllocateDangledIndices localAllocateDangledIndices = mock(LocalAllocateDangledIndices.class);\n-\n-            final Settings allocateSettings = Settings.builder().put(AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey(), false).build();\n-\n-            final ClusterService clusterServiceMock = mock(ClusterService.class);\n-            when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);\n-\n-            new DanglingIndicesState(\n-                env,\n-                metaStateService,\n-                localAllocateDangledIndices,\n-                clusterServiceMock\n-            );\n-\n-            verify(clusterServiceMock, never()).addListener(any());\n-        }\n-    }\n-\n-    /**\n-     * Check that when auto-imports are enabled, then dangling indices are automatically imported.\n-     */\n-    public void testDanglingIndicesAreAllocatedWhenEnabled() throws Exception {\n-        try (NodeEnvironment env = newNodeEnvironment()) {\n-            MetaStateService metaStateService = new MetaStateService(env, xContentRegistry());\n-            LocalAllocateDangledIndices localAllocateDangledIndices = mock(LocalAllocateDangledIndices.class);\n-            final Settings allocateSettings = Settings.builder().put(AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey(), true).build();\n-\n-            final ClusterService clusterServiceMock = mock(ClusterService.class);\n-            when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);\n-\n-            DanglingIndicesState danglingIndicesState = new DanglingIndicesState(\n-                env,\n-                metaStateService,\n-                localAllocateDangledIndices, clusterServiceMock\n-            );\n-\n-            assertTrue(\"Expected dangling imports to be enabled\", danglingIndicesState.isAutoImportDanglingIndicesEnabled());\n-\n-            final Settings.Builder settings = Settings.builder().put(indexSettings).put(IndexMetadata.SETTING_INDEX_UUID, \"test1UUID\");\n-            IndexMetadata dangledIndex = IndexMetadata.builder(\"test1\").settings(settings).build();\n-            metaStateService.writeIndex(\"test_write\", dangledIndex);\n-\n-            final Metadata metadata = Metadata.builder().build();\n-            danglingIndicesState.findNewAndAddDanglingIndices(metadata);\n-\n-            danglingIndicesState.allocateDanglingIndices(metadata);\n-\n-            verify(localAllocateDangledIndices).allocateDangled(any(), any());\n-        }\n-    }\n-\n-    private DanglingIndicesState createDanglingIndicesState(NodeEnvironment env, MetaStateService metaStateService) {\n-        final Settings allocateSettings = Settings.builder().put(AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey(), true).build();\n+    private DanglingIndicesState createDanglingIndicesState(MetaStateService metaStateService) {\n+        final Settings allocateSettings = Settings.builder().build();\n \n         final ClusterService clusterServiceMock = mock(ClusterService.class);\n         when(clusterServiceMock.getSettings()).thenReturn(allocateSettings);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b345ae3953877fc70fad661c423ddf703c23b66"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ1MDQwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMzoyOVrOGyvQgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMzoyOVrOGyvQgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NjI1OQ==", "bodyText": "I prefer the original:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Failed to list dangling indices\", e);\n          \n          \n            \n                        logger.warn(\"failed to list dangling indices\", e);", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455856259", "createdAt": "2020-07-16T15:03:29Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "diffHunk": "@@ -47,234 +40,74 @@\n \n /**\n  * The dangling indices state is responsible for finding new dangling indices (indices that have\n- * their state written on disk, but don't exists in the metadata of the cluster), and importing\n- * them into the cluster.\n+ * their state written on disk, but don't exists in the metadata of the cluster).\n  */\n-public class DanglingIndicesState implements ClusterStateListener {\n+public class DanglingIndicesState {\n \n     private static final Logger logger = LogManager.getLogger(DanglingIndicesState.class);\n \n-    /**\n-     * Controls whether dangling indices should be automatically detected and imported into the cluster\n-     * state upon discovery. This setting is deprecated - use the <code>_dangling</code> API instead.\n-     * If disabled, dangling indices will not be automatically detected.\n-     *\n-     * @see org.elasticsearch.action.admin.indices.dangling\n-     */\n-    public static final Setting<Boolean> AUTO_IMPORT_DANGLING_INDICES_SETTING = Setting.boolSetting(\n-        \"gateway.auto_import_dangling_indices\",\n-        false,\n-        Setting.Property.NodeScope,\n-        Setting.Property.Deprecated\n-    );\n-\n-    private final NodeEnvironment nodeEnv;\n     private final MetaStateService metaStateService;\n-    private final LocalAllocateDangledIndices danglingIndicesAllocator;\n-    private final boolean isAutoImportDanglingIndicesEnabled;\n     private final ClusterService clusterService;\n \n-    private final Map<Index, IndexMetadata> danglingIndices = ConcurrentCollections.newConcurrentMap();\n-\n     @Inject\n-    public DanglingIndicesState(NodeEnvironment nodeEnv, MetaStateService metaStateService,\n-                                LocalAllocateDangledIndices danglingIndicesAllocator, ClusterService clusterService) {\n-        this.nodeEnv = nodeEnv;\n+    public DanglingIndicesState(MetaStateService metaStateService, ClusterService clusterService) {\n         this.metaStateService = metaStateService;\n-        this.danglingIndicesAllocator = danglingIndicesAllocator;\n         this.clusterService = clusterService;\n-\n-        this.isAutoImportDanglingIndicesEnabled = AUTO_IMPORT_DANGLING_INDICES_SETTING.get(clusterService.getSettings());\n-\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            clusterService.addListener(this);\n-        } else {\n-            logger.warn(\n-                AUTO_IMPORT_DANGLING_INDICES_SETTING.getKey()\n-                    + \" is disabled, dangling indices will not be automatically detected or imported and must be managed manually\"\n-            );\n-        }\n-    }\n-\n-    boolean isAutoImportDanglingIndicesEnabled() {\n-        return this.isAutoImportDanglingIndicesEnabled;\n-    }\n-\n-    /**\n-     * Process dangling indices based on the provided meta data, handling cleanup, finding\n-     * new dangling indices, and allocating outstanding ones.\n-     */\n-    public void processDanglingIndices(final Metadata metadata) {\n-        assert this.isAutoImportDanglingIndicesEnabled;\n-\n-        if (nodeEnv.hasNodeFile() == false) {\n-            return;\n-        }\n-        cleanupAllocatedDangledIndices(metadata);\n-        findNewAndAddDanglingIndices(metadata);\n-        allocateDanglingIndices(metadata);\n     }\n \n     /**\n-     * Either return the current set of dangling indices, if auto-import is enabled, otherwise\n-     * scan for dangling indices right away.\n+     * Finds new dangling indices by iterating over the indices and trying to find indices\n+     * that have state on disk, but are not part of the provided metadata.\n      * @return a map of currently-known dangling indices\n      */\n     public Map<Index, IndexMetadata> getDanglingIndices() {\n-        if (this.isAutoImportDanglingIndicesEnabled) {\n-            // This might be a good use case for CopyOnWriteHashMap\n-            return Map.copyOf(this.danglingIndices);\n-        } else {\n-            return findNewDanglingIndices(emptyMap(), this.clusterService.state().metadata());\n-        }\n-    }\n-\n-    /**\n-     * Cleans dangling indices if they are already allocated on the provided meta data.\n-     */\n-    void cleanupAllocatedDangledIndices(Metadata metadata) {\n-        for (Index index : danglingIndices.keySet()) {\n-            final IndexMetadata indexMetadata = metadata.index(index);\n-            if (indexMetadata != null && indexMetadata.getIndex().getName().equals(index.getName())) {\n-                if (indexMetadata.getIndex().getUUID().equals(index.getUUID()) == false) {\n-                    logger.warn(\"[{}] can not be imported as a dangling index, as there is already another index \" +\n-                        \"with the same name but a different uuid. local index will be ignored (but not deleted)\", index);\n-                } else {\n-                    logger.debug(\"[{}] no longer dangling (created), removing from dangling list\", index);\n-                }\n-                danglingIndices.remove(index);\n-            }\n-        }\n+        final Metadata metadata = this.clusterService.state().metadata();\n+        return findDanglingIndices(metadata);\n     }\n \n-    /**\n-     * Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices\n-     * to the currently tracked dangling indices.\n-     */\n-    void findNewAndAddDanglingIndices(final Metadata metadata) {\n-        final IndexGraveyard graveyard = metadata.indexGraveyard();\n+    // Extracted from getDanglingIndices() as a package-private method to allow easier testing testing\n+    Map<Index, IndexMetadata> findDanglingIndices(Metadata metadata) {\n+        final Set<String> excludeIndexPathIds = new HashSet<>(metadata.indices().size());\n \n-        // If a tombstone is created for a dangling index, we need to make sure that the\n-        // index is no longer considered dangling.\n-        danglingIndices.keySet().removeIf(graveyard::containsIndex);\n-\n-        danglingIndices.putAll(findNewDanglingIndices(danglingIndices, metadata));\n-    }\n-\n-    /**\n-     * Finds new dangling indices by iterating over the indices and trying to find indices\n-     * that have state on disk, but are not part of the provided metadata, or not detected\n-     * as dangled already.\n-     */\n-    public Map<Index, IndexMetadata> findNewDanglingIndices(Map<Index, IndexMetadata> existingDanglingIndices, final Metadata metadata) {\n-        final Set<String> excludeIndexPathIds = new HashSet<>(metadata.indices().size() + danglingIndices.size());\n         for (ObjectCursor<IndexMetadata> cursor : metadata.indices().values()) {\n             excludeIndexPathIds.add(cursor.value.getIndex().getUUID());\n         }\n-        for (Index index : existingDanglingIndices.keySet()) {\n-            excludeIndexPathIds.add(index.getUUID());\n-        }\n+\n         try {\n             final List<IndexMetadata> indexMetadataList = metaStateService.loadIndicesStates(excludeIndexPathIds::contains);\n-            Map<Index, IndexMetadata> newIndices = new HashMap<>(indexMetadataList.size());\n+            final Map<Index, IndexMetadata> danglingIndices = new HashMap<>();\n             final IndexGraveyard graveyard = metadata.indexGraveyard();\n \n             for (IndexMetadata indexMetadata : indexMetadataList) {\n                 Index index = indexMetadata.getIndex();\n                 if (graveyard.containsIndex(index) == false) {\n-                    newIndices.put(index, stripAliases(indexMetadata));\n+                    danglingIndices.put(index, stripAliases(indexMetadata));\n                 }\n             }\n \n-            return newIndices;\n+            return danglingIndices;\n         } catch (IOException e) {\n-            logger.warn(\"failed to list dangling indices\", e);\n+            logger.warn(\"Failed to list dangling indices\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b345ae3953877fc70fad661c423ddf703c23b66"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ4NDkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDo1MFrOGyvmCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDo1MFrOGyvmCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTc2OQ==", "bodyText": "Hurrah!", "url": "https://github.com/elastic/elasticsearch/pull/59698#discussion_r455861769", "createdAt": "2020-07-16T15:10:50Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java", "diffHunk": "@@ -47,234 +40,74 @@\n \n /**\n  * The dangling indices state is responsible for finding new dangling indices (indices that have\n- * their state written on disk, but don't exists in the metadata of the cluster), and importing\n- * them into the cluster.\n+ * their state written on disk, but don't exists in the metadata of the cluster).\n  */\n-public class DanglingIndicesState implements ClusterStateListener {\n+public class DanglingIndicesState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b345ae3953877fc70fad661c423ddf703c23b66"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2253, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}