{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NjQ1MDc4", "number": 51751, "title": "Update persistent state document in the index the document belongs to", "bodyText": "Currently, the persistent state document is always indexed into the index pointed by an alias \".ml-state-write\".\nWe plan this alias->index mapping to change over time (as we introduce rollover).\nTherefore, we need to make sure we don't end up with two copies of the state document.\nThis PR achieves that by:\n\nsearching for the doc\neither indexing it into the current write index or updating it in its current index\n\nIn order to know the document's id, bytes from C++ stream must be parsed (but only until the first new line character).\nRelates #29938", "createdAt": "2020-01-31T15:49:24Z", "url": "https://github.com/elastic/elasticsearch/pull/51751", "merged": true, "mergeCommit": {"oid": "b85b12df5dde2685e87475b15cadd31f5dbade15"}, "closed": true, "closedAt": "2020-02-10T13:23:12Z", "author": {"login": "przemekwitek"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_xK63ABqjI5OTc1NTM0MDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcC8RTWAFqTM1NTg5NzMzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4657afd23d4429eeab1e47ca9d50acc5725fceba", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/4657afd23d4429eeab1e47ca9d50acc5725fceba", "committedDate": "2020-01-31T15:44:44Z", "message": "Update persistent state document in the index the document belongs to"}, "afterCommit": {"oid": "889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "committedDate": "2020-01-31T15:49:15Z", "message": "Update persistent state document in the index the document belongs to"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNjA3MTYx", "url": "https://github.com/elastic/elasticsearch/pull/51751#pullrequestreview-351607161", "createdAt": "2020-01-31T16:05:09Z", "commit": {"oid": "889df4f6fc65734da4f34d91b6f44c227f3b4bcd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowNTowOVrOFkQDwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNjowNTowOVrOFkQDwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU1NjE2MQ==", "bodyText": "This looks like a dangerous change.  Previously if the C++ wrote nothing but whitespace it was silently ignored.  Now it will cause the state processor to throw an exception and never process any subsequent state.\nI think the behaviour should be changed back to what it was for the pure whitespace case.  It's fine to throw an exception if a bulk metadata JSON object is invalid.  But if it's not present at all then I think we should maintain the previous behaviour of treating it as a no-op.  Otherwise a very careful audit of the C++ code will be required to find what situations it might write blank state.", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r373556161", "createdAt": "2020-01-31T16:05:09Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/IndexingStateProcessorTests.java", "diffHunk": "@@ -56,54 +64,92 @@\n \n     private IndexingStateProcessor stateProcessor;\n     private ResultsPersisterService resultsPersisterService;\n+    private SearchResponse searchResponse;\n \n     @Before\n     public void initialize() {\n+        searchResponse = mock(SearchResponse.class);\n+        when(searchResponse.status()).thenReturn(RestStatus.OK);\n         resultsPersisterService = mock(ResultsPersisterService.class);\n+        doReturn(searchResponse).when(resultsPersisterService).searchWithRetry(any(SearchRequest.class), any(), any(), any());\n+        doReturn(mock(BulkResponse.class)).when(resultsPersisterService).bulkIndexWithRetry(any(BulkRequest.class), any(), any(), any());\n         AnomalyDetectionAuditor auditor = mock(AnomalyDetectionAuditor.class);\n         stateProcessor = spy(new IndexingStateProcessor(JOB_ID, resultsPersisterService, auditor));\n-        when(resultsPersisterService.bulkIndexWithRetry(any(BulkRequest.class), any(), any(), any())).thenReturn(mock(BulkResponse.class));\n-        ThreadPool threadPool = mock(ThreadPool.class);\n-        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n     }\n \n     @After\n     public void verifyNoMoreClientInteractions() {\n-        Mockito.verifyNoMoreInteractions(resultsPersisterService);\n+        verifyNoMoreInteractions(resultsPersisterService);\n     }\n \n-    public void testStateRead() throws IOException {\n+    public void testExtractDocId() throws IOException {\n+        assertThat(IndexingStateProcessor.extractDocId(new BytesArray(STATE_SAMPLE.getBytes(StandardCharsets.UTF_8))), equalTo(\"1\"));\n+    }\n+\n+    private void testStateRead(SearchHits searchHits, String expectedIndexOrAlias) throws IOException {\n+        when(searchResponse.getHits()).thenReturn(searchHits);\n+\n         ByteArrayInputStream stream = new ByteArrayInputStream(STATE_SAMPLE.getBytes(StandardCharsets.UTF_8));\n         stateProcessor.process(stream);\n         ArgumentCaptor<BytesReference> bytesRefCaptor = ArgumentCaptor.forClass(BytesReference.class);\n-        verify(stateProcessor, times(3)).persist(bytesRefCaptor.capture());\n+        verify(stateProcessor, times(3)).persist(eq(expectedIndexOrAlias), bytesRefCaptor.capture());\n \n         String[] threeStates = STATE_SAMPLE.split(\"\\0\");\n         List<BytesReference> capturedBytes = bytesRefCaptor.getAllValues();\n         assertEquals(threeStates[0], capturedBytes.get(0).utf8ToString());\n         assertEquals(threeStates[1], capturedBytes.get(1).utf8ToString());\n         assertEquals(threeStates[2], capturedBytes.get(2).utf8ToString());\n+        verify(resultsPersisterService, times(3)).searchWithRetry(any(SearchRequest.class), any(), any(), any());\n         verify(resultsPersisterService, times(3)).bulkIndexWithRetry(any(BulkRequest.class), any(), any(), any());\n     }\n \n+    public void testStateRead_StateDocumentCreated() throws IOException {\n+        testStateRead(SearchHits.empty(), \".ml-state-write\");\n+    }\n+\n+    public void testStateRead_StateDocumentUpdated() throws IOException {\n+        testStateRead(\n+            new SearchHits(new SearchHit[]{ SearchHit.createFromMap(Map.of(\"_index\", \".ml-state-dummy\")) }, null, 0.0f),\n+            \".ml-state-dummy\");\n+    }\n+\n     public void testStateReadGivenConsecutiveZeroBytes() throws IOException {\n         String zeroBytes = \"\\0\\0\\0\\0\\0\\0\";\n         ByteArrayInputStream stream = new ByteArrayInputStream(zeroBytes.getBytes(StandardCharsets.UTF_8));\n \n         stateProcessor.process(stream);\n \n-        verify(stateProcessor, never()).persist(any());\n-        Mockito.verifyNoMoreInteractions(resultsPersisterService);\n+        verify(stateProcessor, never()).persist(any(), any());\n     }\n \n     public void testStateReadGivenConsecutiveSpacesFollowedByZeroByte() throws IOException {\n-        String zeroBytes = \"        \\n\\0\";\n-        ByteArrayInputStream stream = new ByteArrayInputStream(zeroBytes.getBytes(StandardCharsets.UTF_8));\n+        String bytes = \"        \\n\\0\";\n+        ByteArrayInputStream stream = new ByteArrayInputStream(bytes.getBytes(StandardCharsets.UTF_8));\n \n-        stateProcessor.process(stream);\n+        Exception e = expectThrows(IllegalStateException.class, () -> stateProcessor.process(stream));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "889df4f6fc65734da4f34d91b6f44c227f3b4bcd"}, "originalPosition": 116}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/889df4f6fc65734da4f34d91b6f44c227f3b4bcd", "committedDate": "2020-01-31T15:49:15Z", "message": "Update persistent state document in the index the document belongs to"}, "afterCommit": {"oid": "9095369cc4f29aec9ecfcf666a12e16889c27cd0", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/9095369cc4f29aec9ecfcf666a12e16889c27cd0", "committedDate": "2020-02-03T09:05:08Z", "message": "Apply review comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTE2ODk3", "url": "https://github.com/elastic/elasticsearch/pull/51751#pullrequestreview-352116897", "createdAt": "2020-02-03T09:30:29Z", "commit": {"oid": "9095369cc4f29aec9ecfcf666a12e16889c27cd0"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozMDoyOVrOFkq-YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOTozNzoyMFrOFkrKqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NzE1Mg==", "bodyText": "Note that isBlank was first added in Java 11 so for the backport you'll need to do this differently.", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r373997152", "createdAt": "2020-02-03T09:30:29Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/IndexingStateProcessor.java", "diffHunk": "@@ -117,12 +138,62 @@ void persist(BytesReference bytes) throws IOException {\n     }\n \n     private static int findNextZeroByte(BytesReference bytesRef, int searchFrom, int splitFrom) {\n-        for (int i = Math.max(searchFrom, splitFrom); i < bytesRef.length(); ++i) {\n-            if (bytesRef.get(i) == 0) {\n-                return i;\n+        return bytesRef.indexOf((byte)0, Math.max(searchFrom, splitFrom));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static String extractDocId(BytesReference bytesRef) throws IOException {\n+        String firstNonBlankLine = extractFirstNonBlankLine(bytesRef);\n+        if (firstNonBlankLine == null) {\n+            return null;\n+        }\n+        try (XContentParser parser =\n+                 JsonXContent.jsonXContent.createParser(\n+                     NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, firstNonBlankLine)) {\n+            Map<String, Object> map = parser.map();\n+            if ((map.get(\"index\") instanceof Map) == false) {\n+                throw new IllegalStateException(\"Could not extract \\\"index\\\" field out of [\" + firstNonBlankLine + \"]\");\n             }\n+            map = (Map<String, Object>)map.get(\"index\");\n+            if ((map.get(\"_id\") instanceof String) == false) {\n+                throw new IllegalStateException(\"Could not extract \\\"index._id\\\" field out of [\" + firstNonBlankLine + \"]\");\n+            }\n+            return (String)map.get(\"_id\");\n         }\n-        return -1;\n+    }\n+\n+    private static String extractFirstNonBlankLine(BytesReference bytesRef) {\n+        for (int searchFrom = 0; searchFrom < bytesRef.length();) {\n+            int newLineMarkerIndex = bytesRef.indexOf((byte) '\\n', searchFrom);\n+            int searchTo = newLineMarkerIndex != -1 ? newLineMarkerIndex : bytesRef.length();\n+            String line = bytesRef.slice(searchFrom, searchTo - searchFrom).utf8ToString();\n+            if (line.isBlank() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9095369cc4f29aec9ecfcf666a12e16889c27cd0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwMDI5OA==", "bodyText": "Please can you add a comment here explaining why we have to do this.  Today everyone in the team understands what an \"appropriate\" index is, but it won't be so obvious 2 years from now.\nKey points:\n\nSome types of state, for example data frame analytics state and categorizer state, are written multiple times with the same document ID\nOther types of state, for example anomaly detector state, are written with new document IDs each time\nThe code needs to work correctly when the state index is rolling over\nThe approach of having duplicate IDs in different state indices is tricky when we deliberately have no mappings on the state index, as we cannot sort and filter in a search\nThe state documents are large, so having dead documents with duplicate IDs is not ideal from a disk usage perspective either\n\nPossibly this could go in the top level class Javadoc comment and this method's comment could just say \"for what is meant by appropriate see the class documentation\".", "url": "https://github.com/elastic/elasticsearch/pull/51751#discussion_r374000298", "createdAt": "2020-02-03T09:37:20Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/IndexingStateProcessor.java", "diffHunk": "@@ -98,11 +110,20 @@ private BytesReference splitAndPersist(BytesReference bytesRef, int searchFrom)\n         return bytesRef.slice(splitFrom, bytesRef.length() - splitFrom);\n     }\n \n-    void persist(BytesReference bytes) throws IOException {\n-        BulkRequest bulkRequest = new BulkRequest();\n-        bulkRequest.add(bytes, AnomalyDetectorsIndex.jobStateIndexWriteAlias(), XContentType.JSON);\n+    void findAppropriateIndexAndPersist(BytesReference bytes) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9095369cc4f29aec9ecfcf666a12e16889c27cd0"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "304f344a6056bae6c6680ec0c5c7f31ca4fd10b6", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/304f344a6056bae6c6680ec0c5c7f31ca4fd10b6", "committedDate": "2020-02-10T10:15:03Z", "message": "Update persistent state document in the index the document belongs to"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "873af34ff6251d79e9c3375cbb7fc1e0e931d60d", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/873af34ff6251d79e9c3375cbb7fc1e0e931d60d", "committedDate": "2020-02-10T10:15:04Z", "message": "Apply review comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a97833d65f90cfbf263f0e96bca1f15da66357e", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a97833d65f90cfbf263f0e96bca1f15da66357e", "committedDate": "2020-02-10T12:21:34Z", "message": "Apply review comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9095369cc4f29aec9ecfcf666a12e16889c27cd0", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/9095369cc4f29aec9ecfcf666a12e16889c27cd0", "committedDate": "2020-02-03T09:05:08Z", "message": "Apply review comment"}, "afterCommit": {"oid": "8a97833d65f90cfbf263f0e96bca1f15da66357e", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a97833d65f90cfbf263f0e96bca1f15da66357e", "committedDate": "2020-02-10T12:21:34Z", "message": "Apply review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODk3MzMy", "url": "https://github.com/elastic/elasticsearch/pull/51751#pullrequestreview-355897332", "createdAt": "2020-02-10T12:27:08Z", "commit": {"oid": "8a97833d65f90cfbf263f0e96bca1f15da66357e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2928, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}