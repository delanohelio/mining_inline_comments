{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MzA4NjAz", "number": 51708, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDo1MDozM1rODchNNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMDoyMzoyMFrODcw5vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjMwNzc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDo1MDozM1rOFkmWLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNDozNDoyNVrOFkzZtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTMyNw==", "bodyText": "Can we skip these steps entirely? If so, we might not need to acquire an engine searcher, which potentially triggers a refresh.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r373921327", "createdAt": "2020-02-03T04:50:33Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -340,15 +360,59 @@ private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final Sea\n     }\n \n     public void executeQueryPhase(ShardSearchRequest request, SearchShardTask task, ActionListener<SearchPhaseResult> listener) {\n-        rewriteShardRequest(request, ActionListener.map(listener, r -> executeQueryPhase(r, task)));\n+        assert request.isMatchNoDocsReturnNullResponse() == false || request.numberOfShards() > 1\n+            : \"empty responses require more than one shard\";\n+        rewriteShardRequest(request, ActionListener.wrap(\n+            context -> {\n+                try {\n+                    ShardSearchRequest rewritten = context.request;\n+                    if (rewritten.isMatchNoDocsReturnNullResponse()\n+                            && canRewriteToMatchNone(rewritten.source())\n+                            && rewritten.source().query() instanceof MatchNoneQueryBuilder) {\n+                        onMatchNoDocs(context, listener);\n+                    } else {\n+                        // fork the execution in the search thread pool and wraps the searcher\n+                        // to execute the query\n+                        context.wrapSearcher().execute(() -> {\n+                            final SearchPhaseResult result;\n+                            try {\n+                                result = executeQueryPhase(context, task);\n+                            } catch (Exception exc) {\n+                                listener.onFailure(exc);\n+                                return;\n+                            }\n+                            listener.onResponse(result);\n+                        });\n+                    }\n+                } catch (Exception exc) {\n+                    // if the execution is rejected we need to close the searcher\n+                    IOUtils.closeWhileHandlingException(context.searcher);\n+                    listener.onFailure(exc);\n+                }\n+            }, listener::onFailure));\n+    }\n+\n+    private void onMatchNoDocs(SearchRewriteContext rewriteContext, ActionListener<SearchPhaseResult> listener) {\n+        // creates a lightweight search context that we use to inform context listeners\n+        // before closing\n+        SearchContext searchContext = createSearchContext(rewriteContext, defaultSearchTimeout);\n+        try (searchContext) {\n+            onNewContext(searchContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODQyMw==", "bodyText": "I added this to ensure that frozen indices are \"unregistered\" (nullify) when the context is freed. It should be easier when we move to a simple reader context ;).\nFor the refresh, I think this is required since we have to handle the search-idle case that automatically refreshes on the first query.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r373998423", "createdAt": "2020-02-03T09:33:14Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -340,15 +360,59 @@ private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final Sea\n     }\n \n     public void executeQueryPhase(ShardSearchRequest request, SearchShardTask task, ActionListener<SearchPhaseResult> listener) {\n-        rewriteShardRequest(request, ActionListener.map(listener, r -> executeQueryPhase(r, task)));\n+        assert request.isMatchNoDocsReturnNullResponse() == false || request.numberOfShards() > 1\n+            : \"empty responses require more than one shard\";\n+        rewriteShardRequest(request, ActionListener.wrap(\n+            context -> {\n+                try {\n+                    ShardSearchRequest rewritten = context.request;\n+                    if (rewritten.isMatchNoDocsReturnNullResponse()\n+                            && canRewriteToMatchNone(rewritten.source())\n+                            && rewritten.source().query() instanceof MatchNoneQueryBuilder) {\n+                        onMatchNoDocs(context, listener);\n+                    } else {\n+                        // fork the execution in the search thread pool and wraps the searcher\n+                        // to execute the query\n+                        context.wrapSearcher().execute(() -> {\n+                            final SearchPhaseResult result;\n+                            try {\n+                                result = executeQueryPhase(context, task);\n+                            } catch (Exception exc) {\n+                                listener.onFailure(exc);\n+                                return;\n+                            }\n+                            listener.onResponse(result);\n+                        });\n+                    }\n+                } catch (Exception exc) {\n+                    // if the execution is rejected we need to close the searcher\n+                    IOUtils.closeWhileHandlingException(context.searcher);\n+                    listener.onFailure(exc);\n+                }\n+            }, listener::onFailure));\n+    }\n+\n+    private void onMatchNoDocs(SearchRewriteContext rewriteContext, ActionListener<SearchPhaseResult> listener) {\n+        // creates a lightweight search context that we use to inform context listeners\n+        // before closing\n+        SearchContext searchContext = createSearchContext(rewriteContext, defaultSearchTimeout);\n+        try (searchContext) {\n+            onNewContext(searchContext);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTMyNw=="}, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEzNTIyMw==", "bodyText": "Ok, let's make this change later with the reader context.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374135223", "createdAt": "2020-02-03T14:34:25Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -340,15 +360,59 @@ private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final Sea\n     }\n \n     public void executeQueryPhase(ShardSearchRequest request, SearchShardTask task, ActionListener<SearchPhaseResult> listener) {\n-        rewriteShardRequest(request, ActionListener.map(listener, r -> executeQueryPhase(r, task)));\n+        assert request.isMatchNoDocsReturnNullResponse() == false || request.numberOfShards() > 1\n+            : \"empty responses require more than one shard\";\n+        rewriteShardRequest(request, ActionListener.wrap(\n+            context -> {\n+                try {\n+                    ShardSearchRequest rewritten = context.request;\n+                    if (rewritten.isMatchNoDocsReturnNullResponse()\n+                            && canRewriteToMatchNone(rewritten.source())\n+                            && rewritten.source().query() instanceof MatchNoneQueryBuilder) {\n+                        onMatchNoDocs(context, listener);\n+                    } else {\n+                        // fork the execution in the search thread pool and wraps the searcher\n+                        // to execute the query\n+                        context.wrapSearcher().execute(() -> {\n+                            final SearchPhaseResult result;\n+                            try {\n+                                result = executeQueryPhase(context, task);\n+                            } catch (Exception exc) {\n+                                listener.onFailure(exc);\n+                                return;\n+                            }\n+                            listener.onResponse(result);\n+                        });\n+                    }\n+                } catch (Exception exc) {\n+                    // if the execution is rejected we need to close the searcher\n+                    IOUtils.closeWhileHandlingException(context.searcher);\n+                    listener.onFailure(exc);\n+                }\n+            }, listener::onFailure));\n+    }\n+\n+    private void onMatchNoDocs(SearchRewriteContext rewriteContext, ActionListener<SearchPhaseResult> listener) {\n+        // creates a lightweight search context that we use to inform context listeners\n+        // before closing\n+        SearchContext searchContext = createSearchContext(rewriteContext, defaultSearchTimeout);\n+        try (searchContext) {\n+            onNewContext(searchContext);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTMyNw=="}, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjMwODM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDo1MToxNFrOFkmWjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxNDozMDozOFrOFkzRng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTQyMA==", "bodyText": "nit: can we use successfulOps instead? Also, I think we can have up to maxConcurrentRequestsPerNode responses instead of one. But I don't see a way to avoid this as any shard request can fail.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r373921420", "createdAt": "2020-02-03T04:51:14Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "diffHunk": "@@ -462,9 +464,10 @@ public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarg\n      * @param result the result returned form the shard\n      * @param shardIt the shard iterator\n      */\n-    private void onShardResult(Result result, SearchShardIterator shardIt) {\n+    protected void onShardResult(Result result, SearchShardIterator shardIt) {\n         assert result.getShardIndex() != -1 : \"shard index is not set\";\n         assert result.getSearchShardTarget() != null : \"search shard target must not be null\";\n+        hasShardResponse.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NjY1OQ==", "bodyText": "successfulOps is incremented when we skip a shard so we need to introduce another boolean to indicate that at least one shard returned a valid response. We only need one, when it is set, all subsequent shard requests can be ignored by the coordinator node.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r373996659", "createdAt": "2020-02-03T09:29:31Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "diffHunk": "@@ -462,9 +464,10 @@ public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarg\n      * @param result the result returned form the shard\n      * @param shardIt the shard iterator\n      */\n-    private void onShardResult(Result result, SearchShardIterator shardIt) {\n+    protected void onShardResult(Result result, SearchShardIterator shardIt) {\n         assert result.getShardIndex() != -1 : \"shard index is not set\";\n         assert result.getSearchShardTarget() != null : \"search shard target must not be null\";\n+        hasShardResponse.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTQyMA=="}, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEzMzE1MA==", "bodyText": "Ah, I missed that. Thanks for the explanation.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374133150", "createdAt": "2020-02-03T14:30:38Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "diffHunk": "@@ -462,9 +464,10 @@ public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarg\n      * @param result the result returned form the shard\n      * @param shardIt the shard iterator\n      */\n-    private void onShardResult(Result result, SearchShardIterator shardIt) {\n+    protected void onShardResult(Result result, SearchShardIterator shardIt) {\n         assert result.getShardIndex() != -1 : \"shard index is not set\";\n         assert result.getSearchShardTarget() != null : \"search shard target must not be null\";\n+        hasShardResponse.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTQyMA=="}, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMjMwOTIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwNDo1MjoxMVrOFkmXDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwOToyOTozOFrOFkq8pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTU0OA==", "bodyText": "nit: I think canReturnNullResponseIfMatchNoDocs is a better name.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r373921548", "createdAt": "2020-02-03T04:52:11Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -275,6 +286,19 @@ public String preference() {\n         return preference;\n     }\n \n+    /**\n+     * Returns true if the caller can handle null response {@link QuerySearchResult#nullInstance()}.\n+     * Defaults to false since the coordinator node needs at least one shard response to build the global\n+     * response.\n+     */\n+    public boolean isMatchNoDocsReturnNullResponse() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NjcwOQ==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r373996709", "createdAt": "2020-02-03T09:29:38Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -275,6 +286,19 @@ public String preference() {\n         return preference;\n     }\n \n+    /**\n+     * Returns true if the caller can handle null response {@link QuerySearchResult#nullInstance()}.\n+     * Defaults to false since the coordinator node needs at least one shard response to build the global\n+     * response.\n+     */\n+    public boolean isMatchNoDocsReturnNullResponse() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTU0OA=="}, "originalCommit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNDg3NjA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMDoyMjoxM1rOFk-u3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMDozNzo0NlrOFk_JPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyMDg2MQ==", "bodyText": "nit: I think both results and onShardResult() can stay private.", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374320861", "createdAt": "2020-02-03T20:22:13Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "diffHunk": "@@ -462,11 +464,12 @@ public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarg\n      * @param result the result returned form the shard\n      * @param shardIt the shard iterator\n      */\n-    private void onShardResult(Result result, SearchShardIterator shardIt) {\n+    protected void onShardResult(Result result, SearchShardIterator shardIt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyNzYxMw==", "bodyText": "Thanks, I pushed 662972c", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374327613", "createdAt": "2020-02-03T20:37:46Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java", "diffHunk": "@@ -462,11 +464,12 @@ public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarg\n      * @param result the result returned form the shard\n      * @param shardIt the shard iterator\n      */\n-    private void onShardResult(Result result, SearchShardIterator shardIt) {\n+    protected void onShardResult(Result result, SearchShardIterator shardIt) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyMDg2MQ=="}, "originalCommit": {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNDg3OTM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/frozen-indices/src/test/java/org/elasticsearch/index/engine/FrozenIndexTests.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMDoyMzoyMFrOFk-w8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMDozNzo0OVrOFk_JXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyMTM5Mw==", "bodyText": "Since we no longer execute requests concurrently, we can drop both latches and use a blocking get() instead of non-blocking execute().", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374321393", "createdAt": "2020-02-03T20:23:20Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/frozen-indices/src/test/java/org/elasticsearch/index/engine/FrozenIndexTests.java", "diffHunk": "@@ -122,26 +123,48 @@ public void testSearchAndGetAPIsAreThrottled() throws InterruptedException, IOEx\n         int numRefreshes = 0;\n         for (int i = 0; i < numRequests; i++) {\n             numRefreshes++;\n-            switch (randomIntBetween(0, 3)) {\n+            // make sure that we don't share the frozen reader in concurrent requests since we acquire the\n+            // searcher and rewrite the request outside of the search-throttle thread pool\n+            CountDownLatch reqLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyNzQ5OA==", "bodyText": "Indeed, thanks !", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374327498", "createdAt": "2020-02-03T20:37:31Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/frozen-indices/src/test/java/org/elasticsearch/index/engine/FrozenIndexTests.java", "diffHunk": "@@ -122,26 +123,48 @@ public void testSearchAndGetAPIsAreThrottled() throws InterruptedException, IOEx\n         int numRefreshes = 0;\n         for (int i = 0; i < numRequests; i++) {\n             numRefreshes++;\n-            switch (randomIntBetween(0, 3)) {\n+            // make sure that we don't share the frozen reader in concurrent requests since we acquire the\n+            // searcher and rewrite the request outside of the search-throttle thread pool\n+            CountDownLatch reqLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyMTM5Mw=="}, "originalCommit": {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyNzY0Nw==", "bodyText": "662972c", "url": "https://github.com/elastic/elasticsearch/pull/51708#discussion_r374327647", "createdAt": "2020-02-03T20:37:49Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/frozen-indices/src/test/java/org/elasticsearch/index/engine/FrozenIndexTests.java", "diffHunk": "@@ -122,26 +123,48 @@ public void testSearchAndGetAPIsAreThrottled() throws InterruptedException, IOEx\n         int numRefreshes = 0;\n         for (int i = 0; i < numRequests; i++) {\n             numRefreshes++;\n-            switch (randomIntBetween(0, 3)) {\n+            // make sure that we don't share the frozen reader in concurrent requests since we acquire the\n+            // searcher and rewrite the request outside of the search-throttle thread pool\n+            CountDownLatch reqLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyMTM5Mw=="}, "originalCommit": {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 156, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}