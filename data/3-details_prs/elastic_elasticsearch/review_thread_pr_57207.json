{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzODI5Nzg5", "number": 57207, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoxMDo1OVrOEA-O8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyNDozNVrOEA-eyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDU1MDkxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericIndexFieldData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoxMDo1OVrOGclROA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToyMzo0NlrOGcpNTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzkyOA==", "bodyText": "Maybe leave a comment in here about why half_floats need a custom comparator?  I'm assuming their encoding makes them non-ordered or something?", "url": "https://github.com/elastic/elasticsearch/pull/57207#discussion_r432623928", "createdAt": "2020-05-29T17:10:59Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericIndexFieldData.java", "diffHunk": "@@ -113,95 +101,29 @@ public final Index index() {\n         return index;\n     }\n \n-    /**\n-     * Returns the {@link SortField} to used for sorting.\n-     * Values are casted to the provided <code>targetNumericType</code> type if it doesn't\n-     * match the field's <code>numericType</code>.\n-     */\n-    public SortField sortField(NumericType targetNumericType, Object missingValue, MultiValueMode sortMode,\n-                               Nested nested, boolean reverse) {\n-        final XFieldComparatorSource source = comparatorSource(targetNumericType, missingValue, sortMode, nested);\n-\n-        /**\n-         * Check if we can use a simple {@link SortedNumericSortField} compatible with index sorting and\n-         * returns a custom sort field otherwise.\n-         */\n-        if (nested != null\n-                || (sortMode != MultiValueMode.MAX && sortMode != MultiValueMode.MIN)\n-                || numericType == NumericType.HALF_FLOAT\n-                || targetNumericType != numericType) {\n-            return new SortField(fieldName, source, reverse);\n-        }\n-\n-        final SortField sortField;\n-        final SortedNumericSelector.Type selectorType = sortMode == MultiValueMode.MAX ?\n-            SortedNumericSelector.Type.MAX : SortedNumericSelector.Type.MIN;\n-        switch (numericType) {\n-            case FLOAT:\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.FLOAT, reverse, selectorType);\n-                break;\n-\n-            case DOUBLE:\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.DOUBLE, reverse, selectorType);\n-                break;\n-\n-            default:\n-                assert !numericType.isFloatingPoint();\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.LONG, reverse, selectorType);\n-                break;\n-        }\n-        sortField.setMissingValue(source.missingObject(missingValue, reverse));\n-        return sortField;\n-    }\n-\n     @Override\n-    public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {\n-        return sortField(numericType, missingValue, sortMode, nested, reverse);\n-    }\n-\n-    /**\n-     * Builds a {@linkplain BucketedSort} for the {@code targetNumericType},\n-     * casting the values if their native type doesn't match.\n-     */\n-    public BucketedSort newBucketedSort(NumericType targetNumericType, BigArrays bigArrays, @Nullable Object missingValue,\n-            MultiValueMode sortMode, Nested nested, SortOrder sortOrder, DocValueFormat format,\n-            int bucketSize, BucketedSort.ExtraData extra) {\n-        return comparatorSource(targetNumericType, missingValue, sortMode, nested)\n-                .newBucketedSort(bigArrays, sortOrder, format, bucketSize, extra);\n+    protected boolean sortRequiresCustomComparator() {\n+        return numericType == NumericType.HALF_FLOAT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572f090b9cb4cf57db599ef9243cc25fd8a58218"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODQ2Mg==", "bodyText": "I believe that is so. I'll dig and leave a comment.", "url": "https://github.com/elastic/elasticsearch/pull/57207#discussion_r432688462", "createdAt": "2020-05-29T19:23:46Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericIndexFieldData.java", "diffHunk": "@@ -113,95 +101,29 @@ public final Index index() {\n         return index;\n     }\n \n-    /**\n-     * Returns the {@link SortField} to used for sorting.\n-     * Values are casted to the provided <code>targetNumericType</code> type if it doesn't\n-     * match the field's <code>numericType</code>.\n-     */\n-    public SortField sortField(NumericType targetNumericType, Object missingValue, MultiValueMode sortMode,\n-                               Nested nested, boolean reverse) {\n-        final XFieldComparatorSource source = comparatorSource(targetNumericType, missingValue, sortMode, nested);\n-\n-        /**\n-         * Check if we can use a simple {@link SortedNumericSortField} compatible with index sorting and\n-         * returns a custom sort field otherwise.\n-         */\n-        if (nested != null\n-                || (sortMode != MultiValueMode.MAX && sortMode != MultiValueMode.MIN)\n-                || numericType == NumericType.HALF_FLOAT\n-                || targetNumericType != numericType) {\n-            return new SortField(fieldName, source, reverse);\n-        }\n-\n-        final SortField sortField;\n-        final SortedNumericSelector.Type selectorType = sortMode == MultiValueMode.MAX ?\n-            SortedNumericSelector.Type.MAX : SortedNumericSelector.Type.MIN;\n-        switch (numericType) {\n-            case FLOAT:\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.FLOAT, reverse, selectorType);\n-                break;\n-\n-            case DOUBLE:\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.DOUBLE, reverse, selectorType);\n-                break;\n-\n-            default:\n-                assert !numericType.isFloatingPoint();\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.LONG, reverse, selectorType);\n-                break;\n-        }\n-        sortField.setMissingValue(source.missingObject(missingValue, reverse));\n-        return sortField;\n-    }\n-\n     @Override\n-    public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {\n-        return sortField(numericType, missingValue, sortMode, nested, reverse);\n-    }\n-\n-    /**\n-     * Builds a {@linkplain BucketedSort} for the {@code targetNumericType},\n-     * casting the values if their native type doesn't match.\n-     */\n-    public BucketedSort newBucketedSort(NumericType targetNumericType, BigArrays bigArrays, @Nullable Object missingValue,\n-            MultiValueMode sortMode, Nested nested, SortOrder sortOrder, DocValueFormat format,\n-            int bucketSize, BucketedSort.ExtraData extra) {\n-        return comparatorSource(targetNumericType, missingValue, sortMode, nested)\n-                .newBucketedSort(bigArrays, sortOrder, format, bucketSize, extra);\n+    protected boolean sortRequiresCustomComparator() {\n+        return numericType == NumericType.HALF_FLOAT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzkyOA=="}, "originalCommit": {"oid": "572f090b9cb4cf57db599ef9243cc25fd8a58218"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDU5MTQ2OnYy", "diffSide": "LEFT", "path": "modules/mapper-extras/src/test/resources/rest-api-spec/test/scaled_float/10_basic.yml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyNDozNVrOGclsCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyNDozNVrOGclsCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMDc5Mw==", "bodyText": "thanks", "url": "https://github.com/elastic/elasticsearch/pull/57207#discussion_r432630793", "createdAt": "2020-05-29T17:24:35Z", "author": {"login": "jimczi"}, "path": "modules/mapper-extras/src/test/resources/rest-api-spec/test/scaled_float/10_basic.yml", "diffHunk": "@@ -97,8 +97,28 @@ setup:\n \n   - do:\n       search:\n-        rest_total_hits_as_int: true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572f090b9cb4cf57db599ef9243cc25fd8a58218"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3922, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}