{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxNDczMzU5", "number": 59816, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo1NDo1NFrOEQMdzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo1NDo1NFrOEQMdzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDE2OTA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo1NDo1NFrOG0N47g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowODowMFrOG0SD0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwNjcwMg==", "bodyText": "functions are cool, but couldn't we have a shared method that does the boiler-plate range conversion, which is called when creating the lucene query?", "url": "https://github.com/elastic/elasticsearch/pull/59816#discussion_r457406702", "createdAt": "2020-07-20T13:54:54Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -906,6 +880,51 @@ public static long objectToLong(Object value, boolean coerce) {\n             String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n             return Numbers.toLong(stringValue, coerce);\n         }\n+\n+        @FunctionalInterface\n+        public interface RangeQueryBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "462e937dcdf0c5c2575a2491ac4a9ab4dbbe19ff"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwNzU1MA==", "bodyText": "potentially, that could even be pushed upstream? I would love to not have changes to this mapper as part of the feature branch, if possible.", "url": "https://github.com/elastic/elasticsearch/pull/59816#discussion_r457407550", "createdAt": "2020-07-20T13:55:44Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -906,6 +880,51 @@ public static long objectToLong(Object value, boolean coerce) {\n             String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n             return Numbers.toLong(stringValue, coerce);\n         }\n+\n+        @FunctionalInterface\n+        public interface RangeQueryBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwNjcwMg=="}, "originalCommit": {"oid": "462e937dcdf0c5c2575a2491ac4a9ab4dbbe19ff"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxMzk0Mg==", "bodyText": "I think Elasticsearch is mostly responsible for the Object to long stuff. I don't think that is something Lucene wants but I could certainly be wrong.\n\nI would love to not have changes to this mapper as part of the feature branch, if possible.\n\nI could copy and paste the code but I think that'd be dangerous as it'd get out of sync if someone made a chance to the mapper.\n\nfunctions are cool, but couldn't we have a shared method that does the boiler-plate range conversion, which is called when creating the lucene query?\n\nI think that is what this is. I could probably write it in a way that doesn't use the functional interface if you'd prefer, but it'll be a little more jumbled. It might still be more clear just because we avoid the indirection.", "url": "https://github.com/elastic/elasticsearch/pull/59816#discussion_r457413942", "createdAt": "2020-07-20T14:02:39Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -906,6 +880,51 @@ public static long objectToLong(Object value, boolean coerce) {\n             String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n             return Numbers.toLong(stringValue, coerce);\n         }\n+\n+        @FunctionalInterface\n+        public interface RangeQueryBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwNjcwMg=="}, "originalCommit": {"oid": "462e937dcdf0c5c2575a2491ac4a9ab4dbbe19ff"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQyMDgyMg==", "bodyText": "maybe I was not too careful looking, but it looked like you were calling the function last in the method, which made me think that you could rather have one method to convert the ranges, though what is the return type of that method going to be? Maybe I start to see how a function simplifies it. I don't have a strong opinion. Maybe make it a BiFunction ?", "url": "https://github.com/elastic/elasticsearch/pull/59816#discussion_r457420822", "createdAt": "2020-07-20T14:09:48Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -906,6 +880,51 @@ public static long objectToLong(Object value, boolean coerce) {\n             String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n             return Numbers.toLong(stringValue, coerce);\n         }\n+\n+        @FunctionalInterface\n+        public interface RangeQueryBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwNjcwMg=="}, "originalCommit": {"oid": "462e937dcdf0c5c2575a2491ac4a9ab4dbbe19ff"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NTAyNA==", "bodyText": "I've pushed a BiFunction. Do you think that is better?", "url": "https://github.com/elastic/elasticsearch/pull/59816#discussion_r457475024", "createdAt": "2020-07-20T15:08:00Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java", "diffHunk": "@@ -906,6 +880,51 @@ public static long objectToLong(Object value, boolean coerce) {\n             String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n             return Numbers.toLong(stringValue, coerce);\n         }\n+\n+        @FunctionalInterface\n+        public interface RangeQueryBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwNjcwMg=="}, "originalCommit": {"oid": "462e937dcdf0c5c2575a2491ac4a9ab4dbbe19ff"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2207, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}