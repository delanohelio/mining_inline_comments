{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MDM4MTYw", "number": 58477, "title": "Allows SparseFileTracker to progressively execute listeners during Gap processing", "bodyText": "Today SparseFileTracker allows to wait for a range to become available before executing a given listener. In the case of searchable snapshot, we'd like to be able to wait for a large range to be filled (ie, downloaded and written to disk) while being able to execute the listener as soon as a smaller range is available.\nThis pull request is an extract from #58164 which introduces a ProgressListenableActionFuture that is used internally by  SparseFileTracker. The progressive listenable future allows to register listeners attached to SparseFileTracker.Gap so that they are executed once the Gap is completed (with success or failure) or as soon as the Gap progress reaches a given progress value. This progress value is defined when the tracker.waitForRange() method is called; this method has been modified to accept a range and another listener's range to operate on.\nThis pull request does not modify how CacheFile requests ranges from the SparseFileTracker, this should be done in another pull request. Therefore CacheFile uses a listener's range that is equal to the range to be written and a //TODO has been added.", "createdAt": "2020-06-24T08:10:55Z", "url": "https://github.com/elastic/elasticsearch/pull/58477", "merged": true, "mergeCommit": {"oid": "b01322e55f67fdcdd7103afae31c829791e2ec38"}, "closed": true, "closedAt": "2020-06-26T09:53:58Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuU5HSgH2gAyNDM5MDM4MTYwOjNiM2RjNTBmZTAxOWUyNzJhY2I4OTUzNjUwZTA2YTc5N2ViZGQwZGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcu_UGFAH2gAyNDM5MDM4MTYwOmEzYmFjNmJhMjk1NmViOTg5MTY3ZjY3N2EzMzJiZTE5ZWFiZDA5YTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b3dc50fe019e272acb8953650e06a797ebdd0dd", "committedDate": "2020-06-24T07:27:05Z", "message": "Add ProgressListenableActionFuture"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NTA0OTgw", "url": "https://github.com/elastic/elasticsearch/pull/58477#pullrequestreview-436504980", "createdAt": "2020-06-24T10:04:33Z", "commit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowNDozM1rOGoLlaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDoyMjowOFrOGoMJdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjAyNw==", "bodyText": "I think there might be an off-by-one error lurking here. IMO we should report progress of value when the range \u27e8start, value\u27e9 is available, noting that our ranges are inclusive at the start and exclusive at the end. This means I think we can start with progress == start (not null) indicating that the available range is empty, and require start < value below.\nProbably a good idea to document this here too.", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444786027", "createdAt": "2020-06-24T10:04:33Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ListenableActionFuture;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> implements ListenableActionFuture<Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile @Nullable Long progress; // null if never updated\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            if (progress != null) {\n+                assert start <= progress : start + \" <= \" + progress;\n+                assert progress <= end : progress + \" <= \" + end;\n+                assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Updates the progress of the current {@link ActionFuture} with the given value. Calling this method\n+     * potentially triggers the execution of one or more listeners that are waiting for the progress\n+     * to reach a value lower than the one just updated.\n+     *\n+     * @param value the new progress value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NzU0NQ==", "bodyText": "Let's require the subrange to be non-null, it's only null in tests AFAICT.", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444787545", "createdAt": "2020-06-24T10:07:21Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -57,19 +57,50 @@ private long computeLengthOfRanges() {\n     }\n \n     /**\n-     * Called before reading a range from the file to ensure that this range is present. Returns a list of gaps for the caller to fill.\n+     * Called before reading a range from the file to ensure that this range is present. Returns a list of gaps for the caller to fill. The\n+     * range from the file is defined by {@code range} but the listener can be executed as soon as a smaller sub range {@code subRange}\n+     * becomes available. When no {@code subRange} is provided the listener is executed once the full range is available.\n      *\n-     * @param start    The (inclusive) start of the desired range\n-     * @param end      The (exclusive) end of the desired range\n-     * @param listener Listener for when this range is fully available\n+     * @param range    A tuple that contains the (inclusive) start and (exclusive) end of the desired range\n+     * @param subRange A tuple that contains the (inclusive) start and (exclusive) end of the listener's range\n+     * @param listener Listener for when the listening range is fully available\n      * @return A collection of gaps that the client should fill in to satisfy this range\n      * @throws IllegalArgumentException if invalid range is requested\n      */\n-    public List<Gap> waitForRange(final long start, final long end, final ActionListener<Void> listener) {\n+    public List<Gap> waitForRange(\n+        final Tuple<Long, Long> range,\n+        @Nullable final Tuple<Long, Long> subRange,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4ODg4OA==", "bodyText": "I expected this constructor to make a completed range whereas in fact we use the other one and pass null as the listener. There's only a couple of call-sites, I'd prefer to inline this to avoid that confusion.", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444788888", "createdAt": "2020-06-24T10:09:51Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -358,9 +432,13 @@ public String toString() {\n         long end;\n \n         @Nullable // if not pending\n-        final PlainListenableActionFuture<Void> completionListener;\n+        final ProgressListenableActionFuture completionListener;\n+\n+        Range(long start, long end) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4OTcyNA==", "bodyText": "I think this shouldn't happen, so should be an assertion. Maybe just remove it since we assert it in onGapProgress anyway.", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444789724", "createdAt": "2020-06-24T10:11:31Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -330,12 +399,17 @@ public String toString() {\n             this.end = end;\n         }\n \n-        @Override\n-        public void onResponse(Void aVoid) {\n+        public void onCompletion() {\n             onGapSuccess(start, end);\n         }\n \n-        @Override\n+        public void onProgress(long value) {\n+            if (value < start || end < value) {\n+                throw new IllegalArgumentException(\"Cannot update progress [\" + value + \"] for gap [\" + start + '-' + end + ']');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MTM4Mw==", "bodyText": "Seems strange to have to look up the range corresponding with the gap here, maybe Gap should keep hold of the corresponding Range so it can call the listener directly.", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444791383", "createdAt": "2020-06-24T10:14:52Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/SparseFileTracker.java", "diffHunk": "@@ -249,11 +299,30 @@ private void onGapSuccess(final long start, final long end) {\n             assert invariant();\n         }\n \n-        completionListener.onResponse(null);\n+        completionListener.onResponse(end);\n+    }\n+\n+    private void onGapProgress(long start, long end, long value) {\n+        final ProgressListenableActionFuture completionListener;\n+\n+        synchronized (mutex) {\n+            assert invariant();\n+\n+            final Range range = new Range(start, end, null);\n+            final SortedSet<Range> existingRanges = ranges.tailSet(range);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjQzOA==", "bodyText": "Can we drop this (and the implements ListenableActionFuture<Long> that requires it)? I think callers should always specify their target endpoint.", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444792438", "createdAt": "2020-06-24T10:16:55Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ListenableActionFuture;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> implements ListenableActionFuture<Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile @Nullable Long progress; // null if never updated\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            if (progress != null) {\n+                assert start <= progress : start + \" <= \" + progress;\n+                assert progress <= end : progress + \" <= \" + end;\n+                assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Updates the progress of the current {@link ActionFuture} with the given value. Calling this method\n+     * potentially triggers the execution of one or more listeners that are waiting for the progress\n+     * to reach a value lower than the one just updated.\n+     *\n+     * @param value the new progress value\n+     */\n+    public void onProgress(final long value) {\n+        ensureNotCompleted();\n+\n+        if (value < start) {\n+            assert false : value + \" < \" + start;\n+            throw new IllegalArgumentException(\"Cannot update progress with a value less than [start=\" + start + ']');\n+        }\n+        if (end < value) {\n+            assert false : end + \" < \" + value;\n+            throw new IllegalArgumentException(\"Cannot update progress with a value greater than [end=\" + end + ']');\n+        }\n+\n+        List<ActionListener<Long>> listenersToExecute = null;\n+        synchronized (this) {\n+            assert progress == null || progress < value : progress + \" < \" + value;\n+            this.progress = value;\n+\n+            final List<Tuple<Long, ActionListener<Long>>> listeners = this.listeners;\n+            if (listeners != null) {\n+                List<Tuple<Long, ActionListener<Long>>> listenersToKeep = null;\n+                for (Tuple<Long, ActionListener<Long>> listener : listeners) {\n+                    if (value < listener.v1()) {\n+                        if (listenersToKeep == null) {\n+                            listenersToKeep = new ArrayList<>();\n+                        }\n+                        listenersToKeep.add(listener);\n+                    } else {\n+                        if (listenersToExecute == null) {\n+                            listenersToExecute = new ArrayList<>();\n+                        }\n+                        listenersToExecute.add(listener.v2());\n+                    }\n+                }\n+                this.listeners = listenersToKeep;\n+            }\n+        }\n+        if (listenersToExecute != null) {\n+            listenersToExecute.forEach(listener -> executeListener(listener, () -> value));\n+        }\n+        assert invariant();\n+    }\n+\n+    @Override\n+    public void onResponse(Long result) {\n+        ensureNotCompleted();\n+        super.onResponse(result);\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        ensureNotCompleted();\n+        super.onFailure(e);\n+    }\n+\n+    private void ensureNotCompleted() {\n+        if (completed) {\n+            throw new IllegalStateException(\"Future is already completed\");\n+        }\n+    }\n+\n+    @Override\n+    protected void done() {\n+        super.done();\n+        final List<Tuple<Long, ActionListener<Long>>> listenersToExecute;\n+        synchronized (this) {\n+            completed = true;\n+            listenersToExecute = this.listeners;\n+            listeners = null;\n+        }\n+        if (listenersToExecute != null) {\n+            listenersToExecute.stream().map(Tuple::v2).forEach(listener -> executeListener(listener, () -> actionGet(0L)));\n+        }\n+        assert invariant();\n+    }\n+\n+    /**\n+     * Attach a {@link ActionListener} to the current future. The listener will be executed once the future is completed.\n+     *\n+     * @param listener the {@link ActionListener} to add\n+     */\n+    @Override\n+    public void addListener(final ActionListener<Long> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTI1Mg==", "bodyText": "Here's the off-by-one error: when fileContents[i] is available we should do this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                gap.onProgress(i);\n          \n          \n            \n                                gap.onProgress(i + 1);", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r444795252", "createdAt": "2020-06-24T10:22:08Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/SparseFileTrackerTests.java", "diffHunk": "@@ -111,15 +165,150 @@ public void testCallsListenerWhenWholeRangeIsAvailable() {\n                 if (gapIndex == gaps.size() - 1) {\n                     expectNotification.set(true);\n                 }\n-                gap.onResponse(null);\n+                gap.onCompletion();\n             }\n             assertTrue(wasNotified.get());\n         }\n \n         final AtomicBoolean wasNotified = new AtomicBoolean();\n         final List<SparseFileTracker.Gap> gaps = sparseFileTracker.waitForRange(\n-            start,\n-            end,\n+            range,\n+            subRange,\n+            ActionListener.wrap(ignored -> assertTrue(wasNotified.compareAndSet(false, true)), e -> { throw new AssertionError(e); })\n+        );\n+        assertThat(gaps, empty());\n+        assertTrue(wasNotified.get());\n+    }\n+\n+    public void testCallsListenerWhenRangeIsAvailable() {\n+        final byte[] fileContents = new byte[between(0, 1000)];\n+        final SparseFileTracker sparseFileTracker = new SparseFileTracker(\"test\", fileContents.length);\n+\n+        final Set<AtomicBoolean> listenersCalled = new HashSet<>();\n+        for (int i = between(0, 10); i > 0; i--) {\n+            waitForRandomRange(fileContents, sparseFileTracker, listenersCalled::add, gap -> processGap(fileContents, gap));\n+            assertTrue(listenersCalled.stream().allMatch(AtomicBoolean::get));\n+        }\n+\n+        final Tuple<Long, Long> range;\n+        {\n+            final long start = randomLongBetween(0L, Math.max(0L, fileContents.length - 1));\n+            range = Tuple.tuple(start, randomLongBetween(start, fileContents.length));\n+        }\n+\n+        final Tuple<Long, Long> subRange;\n+        {\n+            final long rangeLength = range.v2() - range.v1();\n+            if (rangeLength > 1L) {\n+                final long start = randomLongBetween(range.v1(), range.v2() - 1L);\n+                subRange = Tuple.tuple(start, randomLongBetween(start + 1L, range.v2()));\n+            } else {\n+                subRange = Tuple.tuple(range.v1(), range.v2());\n+            }\n+        }\n+\n+        boolean pending = false;\n+        for (long i = subRange.v1(); i < subRange.v2(); i++) {\n+            if (fileContents[Math.toIntExact(i)] == UNAVAILABLE) {\n+                pending = true;\n+            }\n+        }\n+\n+        if (pending == false) {\n+            final AtomicBoolean wasNotified = new AtomicBoolean();\n+            final List<SparseFileTracker.Gap> gaps = sparseFileTracker.waitForRange(\n+                range,\n+                subRange,\n+                ActionListener.wrap(ignored -> assertTrue(wasNotified.compareAndSet(false, true)), e -> { throw new AssertionError(e); })\n+            );\n+\n+            assertTrue(\n+                \"All bytes of the sub range \" + subRange + \" are available, listener must be executed immediately\",\n+                wasNotified.get()\n+            );\n+\n+            for (final SparseFileTracker.Gap gap : gaps) {\n+                assertThat(gap.start, greaterThanOrEqualTo(range.v1()));\n+                assertThat(gap.end, lessThanOrEqualTo(range.v2()));\n+\n+                for (long i = gap.start; i < gap.end; i++) {\n+                    assertThat(fileContents[Math.toIntExact(i)], equalTo(UNAVAILABLE));\n+                    fileContents[Math.toIntExact(i)] = AVAILABLE;\n+                    assertTrue(wasNotified.get());\n+                    gap.onProgress(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 172}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/e787d1cb3d882dc908b751efc2100d32b2595dac", "committedDate": "2020-06-25T11:29:51Z", "message": "apply feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NDA4OTQz", "url": "https://github.com/elastic/elasticsearch/pull/58477#pullrequestreview-437408943", "createdAt": "2020-06-25T11:37:52Z", "commit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMTozNzo1MlrOGo2zPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMTo1NzozOVrOGo3ZWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDA3OQ==", "bodyText": "Should we rename the parameter progress to align it with the {@code progress} in the paragraph above?", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445494079", "createdAt": "2020-06-25T11:37:52Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ListenableActionFuture;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> implements ListenableActionFuture<Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile @Nullable Long progress; // null if never updated\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            if (progress != null) {\n+                assert start <= progress : start + \" <= \" + progress;\n+                assert progress <= end : progress + \" <= \" + end;\n+                assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Updates the progress of the current {@link ActionFuture} with the given value. Calling this method\n+     * potentially triggers the execution of one or more listeners that are waiting for the progress\n+     * to reach a value lower than the one just updated.\n+     *\n+     * @param value the new progress value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjAyNw=="}, "originalCommit": {"oid": "3b3dc50fe019e272acb8953650e06a797ebdd0dd"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDU3NQ==", "bodyText": "Should we require completed == false || progress == end too?", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445494575", "createdAt": "2020-06-25T11:38:58Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/cache/ProgressListenableActionFuture.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.AdapterActionFuture;\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * An {@link ActionFuture} that listeners can be attached to. Listeners are executed when the future is completed\n+ * or when a given progress is reached. Progression is updated using the {@link #onProgress(long)} method.\n+ *\n+ * Listeners are executed within the thread that triggers the completion, the failure or the progress update and\n+ * the progress value passed to the listeners on execution is the last updated value.\n+ */\n+class ProgressListenableActionFuture extends AdapterActionFuture<Long, Long> {\n+\n+    protected final long start;\n+    protected final long end;\n+\n+    // modified under 'this' mutex\n+    private volatile List<Tuple<Long, ActionListener<Long>>> listeners;\n+    protected volatile long progress;\n+    private volatile boolean completed;\n+\n+    /**\n+     * Creates a {@link ProgressListenableActionFuture} that accepts the progression\n+     * to be within {@code start} (inclusive) and {@code end} (exclusive) values.\n+     *\n+     * @param start the start (inclusive)\n+     * @param end   the end (exclusive)\n+     */\n+    ProgressListenableActionFuture(long start, long end) {\n+        super();\n+        this.start = start;\n+        this.end = end;\n+        this.progress = start;\n+        this.completed = false;\n+        assert invariant();\n+    }\n+\n+    private boolean invariant() {\n+        assert start < end : start + \" < \" + end;\n+        synchronized (this) {\n+            assert completed == false || listeners == null;\n+            assert start <= progress : start + \" <= \" + progress;\n+            assert progress <= end : progress + \" <= \" + end;\n+            assert listeners == null || listeners.stream().allMatch(listener -> progress < listener.v1());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMTAzNA==", "bodyText": "Should we also have a test that partially completes and then fails and verify that some listeners completed successfully and others failed?", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445501034", "createdAt": "2020-06-25T11:52:15Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMjUwMA==", "bodyText": "Maybe also a test that we call the listener immediately if its progress target is already reached?", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445502500", "createdAt": "2020-06-25T11:55:02Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n+                    future.onProgress(progress);\n+                }\n+                future.onResponse(future.end);\n+            } catch (Throwable t) {\n+                logger.error(\"Failed to update progress\", t);\n+                if (future.isDone() == false) {\n+                    future.onFailure(new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\"));\n+                }\n+                throw new AssertionError(t);\n+            }\n+        });\n+        progressUpdaterThread.start();\n+\n+        startLatch.countDown();\n+\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        progressUpdaterThread.join();\n+        assertTrue(future.isDone());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterResponse() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+        future.onResponse(randomLongBetween(future.start, future.end));\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerResponse.get(), equalTo(future.get()));\n+        assertThat(listenerFailure.get(), nullValue());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterFailure() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMjk3MQ==", "bodyText": "Perhaps simpler:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n          \n          \n            \n                                progress += randomLongBetween(progress + 1L, future.end));", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445502971", "createdAt": "2020-06-25T11:55:54Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzYwMQ==", "bodyText": "Don't think we need a random limit on the randomness here; also 1TB should be enough for anyone :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(randomIntBetween(1, 10)));\n          \n          \n            \n                    final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(1));", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445503601", "createdAt": "2020-06-25T11:57:10Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n+                    future.onProgress(progress);\n+                }\n+                future.onResponse(future.end);\n+            } catch (Throwable t) {\n+                logger.error(\"Failed to update progress\", t);\n+                if (future.isDone() == false) {\n+                    future.onFailure(new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\"));\n+                }\n+                throw new AssertionError(t);\n+            }\n+        });\n+        progressUpdaterThread.start();\n+\n+        startLatch.countDown();\n+\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        progressUpdaterThread.join();\n+        assertTrue(future.isDone());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterResponse() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+        future.onResponse(randomLongBetween(future.start, future.end));\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerResponse.get(), equalTo(future.get()));\n+        assertThat(listenerFailure.get(), nullValue());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterFailure() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Exception failure = new ElasticsearchException(\"simulated\");\n+        future.onFailure(failure);\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerFailure.get(), sameInstance(failure));\n+        assertThat(listenerResponse.get(), nullValue());\n+    }\n+\n+    private static ProgressListenableActionFuture randomFuture() {\n+        final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(randomIntBetween(1, 10)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUwMzgzNQ==", "bodyText": "Do we really want negative numbers here?", "url": "https://github.com/elastic/elasticsearch/pull/58477#discussion_r445503835", "createdAt": "2020-06-25T11:57:39Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/ProgressListenableActionFutureTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.index.store.cache;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.unit.ByteSizeUnit;\n+import org.elasticsearch.common.util.concurrent.AtomicArray;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class ProgressListenableActionFutureTests extends ESTestCase {\n+\n+    public void testOnResponseCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Long> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    progress -> listenersResponses.setOnce(listenerIndex, progress),\n+                    e -> listenersResponses.setOnce(listenerIndex, null)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+        future.onResponse(future.end);\n+        assertTrue(listenersResponses.asList().stream().allMatch(value -> value <= future.end));\n+\n+        final IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onResponse(future.end));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testOnFailureCallsListeners() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final AtomicArray<Exception> listenersResponses = new AtomicArray<>(between(0, 50));\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            final int listenerIndex = i;\n+            future.addListener(\n+                ActionListener.wrap(\n+                    o -> listenersResponses.setOnce(listenerIndex, null),\n+                    e -> listenersResponses.setOnce(listenerIndex, e)\n+                ),\n+                randomLongBetween(future.start, future.end)\n+            );\n+        }\n+        assertTrue(listenersResponses.asList().stream().allMatch(Objects::isNull));\n+\n+        final Exception exception = new ElasticsearchException(\"simulated\");\n+        future.onFailure(exception);\n+\n+        for (int i = 0; i < listenersResponses.length(); i++) {\n+            assertThat(listenersResponses.get(i), sameInstance(exception));\n+        }\n+\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> future.onFailure(exception));\n+        assertThat(ise.getMessage(), containsString(\"Future is already completed\"));\n+    }\n+\n+    public void testProgressUpdatesCallsListeners() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Thread[] threads = new Thread[between(1, 5)];\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(() -> {\n+                try {\n+                    startLatch.await();\n+                    while (future.isDone() == false) {\n+                        final long expectedProgress = randomLongBetween(future.start, future.end);\n+                        final PlainActionFuture<Long> listener = new PlainActionFuture<>();\n+                        future.addListener(ActionListener.wrap(listener::onResponse, listener::onFailure), expectedProgress);\n+                        assertThat(listener.get(), greaterThanOrEqualTo(expectedProgress));\n+                    }\n+                } catch (Throwable t) {\n+                    logger.error(\"Failed to wait for progress to be reached\", t);\n+                    if (future.isDone() == false) {\n+                        future.onFailure(\n+                            new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\")\n+                        );\n+                    }\n+                    throw new AssertionError(t);\n+                }\n+            });\n+        }\n+\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+\n+        final Thread progressUpdaterThread = new Thread(() -> {\n+            try {\n+                startLatch.await();\n+                long progress = future.start;\n+                while (progress < future.end) {\n+                    progress += randomLongBetween(1L, Math.max(1L, future.end - progress));\n+                    future.onProgress(progress);\n+                }\n+                future.onResponse(future.end);\n+            } catch (Throwable t) {\n+                logger.error(\"Failed to update progress\", t);\n+                if (future.isDone() == false) {\n+                    future.onFailure(new Exception(\"Failed to update progress [\" + t.getClass().getName() + ':' + t.getMessage() + \"]\"));\n+                }\n+                throw new AssertionError(t);\n+            }\n+        });\n+        progressUpdaterThread.start();\n+\n+        startLatch.countDown();\n+\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        progressUpdaterThread.join();\n+        assertTrue(future.isDone());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterResponse() throws Exception {\n+        final ProgressListenableActionFuture future = randomFuture();\n+        future.onResponse(randomLongBetween(future.start, future.end));\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerResponse.get(), equalTo(future.get()));\n+        assertThat(listenerFailure.get(), nullValue());\n+    }\n+\n+    public void testListenerCalledImmediatelyAfterFailure() {\n+        final ProgressListenableActionFuture future = randomFuture();\n+\n+        final Exception failure = new ElasticsearchException(\"simulated\");\n+        future.onFailure(failure);\n+        assertTrue(future.isDone());\n+\n+        final SetOnce<Exception> listenerFailure = new SetOnce<>();\n+        final SetOnce<Long> listenerResponse = new SetOnce<>();\n+\n+        future.addListener(ActionListener.wrap(listenerResponse::set, listenerFailure::set), randomLongBetween(future.start, future.end));\n+\n+        assertThat(listenerFailure.get(), sameInstance(failure));\n+        assertThat(listenerResponse.get(), nullValue());\n+    }\n+\n+    private static ProgressListenableActionFuture randomFuture() {\n+        final long delta = randomLongBetween(1L, ByteSizeUnit.TB.toBytes(randomIntBetween(1, 10)));\n+        final long start = randomLongBetween(Long.MIN_VALUE, Long.MAX_VALUE - delta);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e787d1cb3d882dc908b751efc2100d32b2595dac"}, "originalPosition": 169}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45a9f058efd2b584cf9df8d163db9e0eceb21485", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/45a9f058efd2b584cf9df8d163db9e0eceb21485", "committedDate": "2020-06-25T15:43:00Z", "message": "apply feedback (bis)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5b29d5c1233e39e1d870f6dd58d6b844964772a", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/a5b29d5c1233e39e1d870f6dd58d6b844964772a", "committedDate": "2020-06-25T16:07:51Z", "message": "more strict on progress updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzUwNDgx", "url": "https://github.com/elastic/elasticsearch/pull/58477#pullrequestreview-437750481", "createdAt": "2020-06-25T18:25:27Z", "commit": {"oid": "a5b29d5c1233e39e1d870f6dd58d6b844964772a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3bac6ba2956eb989167f677a332be19eabd09a0", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/a3bac6ba2956eb989167f677a332be19eabd09a0", "committedDate": "2020-06-26T08:52:34Z", "message": "missing in last commit"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 388, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}