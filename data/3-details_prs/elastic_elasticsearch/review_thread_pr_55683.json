{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MDI5NTUx", "number": 55683, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyNjozNlrOD18XGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyODozMFrOD18ZoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODkwMDcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchTask.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyNjozNlrOGLn_wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMTowNjoxN1rOGLpPVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA==", "bodyText": "Why do we apply a top level reduce here ? We want it to be applied on demand (when the user gets a partial response) in order to avoid doing work when it's not needed. We should keep the pointer to the serialized aggs so that we don't double the memory in async search ?", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414842818", "createdAt": "2020-04-24T20:26:36Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchTask.java", "diffHunk": "@@ -354,32 +355,30 @@ protected void onListShards(List<SearchShard> shards, List<SearchShard> skipped,\n             // best effort to cancel expired tasks\n             checkCancellation();\n             searchResponse.compareAndSet(null,\n-                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters,\n-                    aggReduceContextSupplier, threadPool.getThreadContext()));\n+                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters, threadPool.getThreadContext()));\n             executeInitListeners();\n         }\n \n         @Override\n-        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits, InternalAggregations aggs, int reducePhase) {\n+        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits,\n+                DelayableWriteable.Serialized<InternalAggregations> aggregations, int reducePhase) {\n             // best effort to cancel expired tasks\n             checkCancellation();\n-            searchResponse.get().updatePartialResponse(shards.size(),\n-                new InternalSearchResponse(new SearchHits(SearchHits.EMPTY, totalHits, Float.NaN), aggs,\n-                    null, null, false, null, reducePhase), aggs == null);\n+            Supplier<InternalAggregations> reducedAggs = () -> aggregations == null ?\n+                    null : InternalAggregations.topLevelReduce(singletonList(aggregations.get()), aggReduceContextSupplier.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0OTMzNw==", "bodyText": "It is on demand via the Supplier<> foo = () -> part. At least, I thought it was.", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414849337", "createdAt": "2020-04-24T20:39:13Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchTask.java", "diffHunk": "@@ -354,32 +355,30 @@ protected void onListShards(List<SearchShard> shards, List<SearchShard> skipped,\n             // best effort to cancel expired tasks\n             checkCancellation();\n             searchResponse.compareAndSet(null,\n-                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters,\n-                    aggReduceContextSupplier, threadPool.getThreadContext()));\n+                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters, threadPool.getThreadContext()));\n             executeInitListeners();\n         }\n \n         @Override\n-        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits, InternalAggregations aggs, int reducePhase) {\n+        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits,\n+                DelayableWriteable.Serialized<InternalAggregations> aggregations, int reducePhase) {\n             // best effort to cancel expired tasks\n             checkCancellation();\n-            searchResponse.get().updatePartialResponse(shards.size(),\n-                new InternalSearchResponse(new SearchHits(SearchHits.EMPTY, totalHits, Float.NaN), aggs,\n-                    null, null, false, null, reducePhase), aggs == null);\n+            Supplier<InternalAggregations> reducedAggs = () -> aggregations == null ?\n+                    null : InternalAggregations.topLevelReduce(singletonList(aggregations.get()), aggReduceContextSupplier.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA=="}, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MTczOA==", "bodyText": "I understand now, the final reduce is a supplier. Although the () -> aggregations == null is hard to read, maybe rewrite it into () -> (aggregations == null) ?", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414851738", "createdAt": "2020-04-24T20:43:51Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchTask.java", "diffHunk": "@@ -354,32 +355,30 @@ protected void onListShards(List<SearchShard> shards, List<SearchShard> skipped,\n             // best effort to cancel expired tasks\n             checkCancellation();\n             searchResponse.compareAndSet(null,\n-                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters,\n-                    aggReduceContextSupplier, threadPool.getThreadContext()));\n+                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters, threadPool.getThreadContext()));\n             executeInitListeners();\n         }\n \n         @Override\n-        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits, InternalAggregations aggs, int reducePhase) {\n+        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits,\n+                DelayableWriteable.Serialized<InternalAggregations> aggregations, int reducePhase) {\n             // best effort to cancel expired tasks\n             checkCancellation();\n-            searchResponse.get().updatePartialResponse(shards.size(),\n-                new InternalSearchResponse(new SearchHits(SearchHits.EMPTY, totalHits, Float.NaN), aggs,\n-                    null, null, false, null, reducePhase), aggs == null);\n+            Supplier<InternalAggregations> reducedAggs = () -> aggregations == null ?\n+                    null : InternalAggregations.topLevelReduce(singletonList(aggregations.get()), aggReduceContextSupplier.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA=="}, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2MzE5MQ==", "bodyText": "I'll rewrite it with good stuff like comments!", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414863191", "createdAt": "2020-04-24T21:06:17Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchTask.java", "diffHunk": "@@ -354,32 +355,30 @@ protected void onListShards(List<SearchShard> shards, List<SearchShard> skipped,\n             // best effort to cancel expired tasks\n             checkCancellation();\n             searchResponse.compareAndSet(null,\n-                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters,\n-                    aggReduceContextSupplier, threadPool.getThreadContext()));\n+                new MutableSearchResponse(shards.size() + skipped.size(), skipped.size(), clusters, threadPool.getThreadContext()));\n             executeInitListeners();\n         }\n \n         @Override\n-        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits, InternalAggregations aggs, int reducePhase) {\n+        public void onPartialReduce(List<SearchShard> shards, TotalHits totalHits,\n+                DelayableWriteable.Serialized<InternalAggregations> aggregations, int reducePhase) {\n             // best effort to cancel expired tasks\n             checkCancellation();\n-            searchResponse.get().updatePartialResponse(shards.size(),\n-                new InternalSearchResponse(new SearchHits(SearchHits.EMPTY, totalHits, Float.NaN), aggs,\n-                    null, null, false, null, reducePhase), aggs == null);\n+            Supplier<InternalAggregations> reducedAggs = () -> aggregations == null ?\n+                    null : InternalAggregations.topLevelReduce(singletonList(aggregations.get()), aggReduceContextSupplier.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MjgxOA=="}, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODkwNDU1OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyNzo0NFrOGLoB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDo0NToxM1rOGLolNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzM3MQ==", "bodyText": "We should still apply the final reduce here.", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414843371", "createdAt": "2020-04-24T20:27:44Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -141,23 +130,35 @@ void addShardFailure(int shardIndex, ShardSearchFailure failure) {\n      * This method is synchronized to ensure that we don't perform final reduces concurrently.\n      */\n     synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task, long expirationTime) {\n-        final SearchResponse resp;\n-        if (totalShards != -1) {\n-            if (sections.aggregations() != null && isFinalReduce == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MjQwNw==", "bodyText": "It's applied below.", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414852407", "createdAt": "2020-04-24T20:45:13Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -141,23 +130,35 @@ void addShardFailure(int shardIndex, ShardSearchFailure failure) {\n      * This method is synchronized to ensure that we don't perform final reduces concurrently.\n      */\n     synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task, long expirationTime) {\n-        final SearchResponse resp;\n-        if (totalShards != -1) {\n-            if (sections.aggregations() != null && isFinalReduce == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzM3MQ=="}, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODkwNzIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyODozMFrOGLoDbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDo0NDo1N1rOGLokkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0Mzc1OQ==", "bodyText": "Where are we reducing the aggs ?", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414843759", "createdAt": "2020-04-24T20:28:30Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -141,23 +130,35 @@ void addShardFailure(int shardIndex, ShardSearchFailure failure) {\n      * This method is synchronized to ensure that we don't perform final reduces concurrently.\n      */\n     synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task, long expirationTime) {\n-        final SearchResponse resp;\n-        if (totalShards != -1) {\n-            if (sections.aggregations() != null && isFinalReduce == false) {\n-                InternalAggregations oldAggs = (InternalAggregations) sections.aggregations();\n-                InternalAggregations newAggs = topLevelReduce(singletonList(oldAggs), aggReduceContextSupplier.get());\n-                sections = new InternalSearchResponse(sections.hits(), newAggs, sections.suggest(),\n-                    null, sections.timedOut(), sections.terminatedEarly(), sections.getNumReducePhases());\n-                isFinalReduce = true;\n-            }\n-            long tookInMillis = TimeValue.timeValueNanos(System.nanoTime() - task.getStartTimeNanos()).getMillis();\n-            resp = new SearchResponse(sections, null, totalShards, successfulShards,\n-                skippedShards, tookInMillis, buildShardFailures(), clusters);\n-        } else {\n-            resp = null;\n+        SearchResponse response = findOrBuildResponse(task);\n+        return new AsyncSearchResponse(task.getSearchId().getEncoded(), response,\n+                failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n+    }\n+\n+    private SearchResponse findOrBuildResponse(AsyncSearchTask task) {\n+        if (finalResponse != null) {\n+            // We have a final response, use it.\n+            return finalResponse;\n+        }\n+        if (clusters == null) {\n+            // An error occurred before we got the shard list \n+            return null;\n         }\n-        return new AsyncSearchResponse(task.getSearchId().getEncoded(), resp, failure, isPartial,\n-            frozen == false, task.getStartTime(), expirationTime);\n+        /*\n+         * Build the response, reducing aggs if we haven't already and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MjI0MA==", "bodyText": "My bad, I did not understand what the supplier was doing. It's all clear now.", "url": "https://github.com/elastic/elasticsearch/pull/55683#discussion_r414852240", "createdAt": "2020-04-24T20:44:57Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -141,23 +130,35 @@ void addShardFailure(int shardIndex, ShardSearchFailure failure) {\n      * This method is synchronized to ensure that we don't perform final reduces concurrently.\n      */\n     synchronized AsyncSearchResponse toAsyncSearchResponse(AsyncSearchTask task, long expirationTime) {\n-        final SearchResponse resp;\n-        if (totalShards != -1) {\n-            if (sections.aggregations() != null && isFinalReduce == false) {\n-                InternalAggregations oldAggs = (InternalAggregations) sections.aggregations();\n-                InternalAggregations newAggs = topLevelReduce(singletonList(oldAggs), aggReduceContextSupplier.get());\n-                sections = new InternalSearchResponse(sections.hits(), newAggs, sections.suggest(),\n-                    null, sections.timedOut(), sections.terminatedEarly(), sections.getNumReducePhases());\n-                isFinalReduce = true;\n-            }\n-            long tookInMillis = TimeValue.timeValueNanos(System.nanoTime() - task.getStartTimeNanos()).getMillis();\n-            resp = new SearchResponse(sections, null, totalShards, successfulShards,\n-                skippedShards, tookInMillis, buildShardFailures(), clusters);\n-        } else {\n-            resp = null;\n+        SearchResponse response = findOrBuildResponse(task);\n+        return new AsyncSearchResponse(task.getSearchId().getEncoded(), response,\n+                failure, isPartial, frozen == false, task.getStartTime(), expirationTime);\n+    }\n+\n+    private SearchResponse findOrBuildResponse(AsyncSearchTask task) {\n+        if (finalResponse != null) {\n+            // We have a final response, use it.\n+            return finalResponse;\n+        }\n+        if (clusters == null) {\n+            // An error occurred before we got the shard list \n+            return null;\n         }\n-        return new AsyncSearchResponse(task.getSearchId().getEncoded(), resp, failure, isPartial,\n-            frozen == false, task.getStartTime(), expirationTime);\n+        /*\n+         * Build the response, reducing aggs if we haven't already and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0Mzc1OQ=="}, "originalCommit": {"oid": "8314fc8c766cf03fd0b70d6a5a476723587092d3"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2695, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}