{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MTY3OTg1", "number": 52417, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNzo1ODo0NFrODg-HkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODowNjozNFrODg-PUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODk4NzY5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndexTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNzo1ODo0NFrOFreIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODozMjoyNVrOFrfABw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEyNjg1NA==", "bodyText": "nit: maybe a constant for .ml-state so its easier to change", "url": "https://github.com/elastic/elasticsearch/pull/52417#discussion_r381126854", "createdAt": "2020-02-19T07:58:44Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndexTests.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.job.persistence;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.Alias;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesAction;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest.AliasActions;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexAction;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.AdminClient;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.IndicesAdminClient;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InOrder;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class AnomalyDetectorsIndexTests extends ESTestCase {\n+\n+    private ThreadPool threadPool;\n+    private IndicesAdminClient indicesAdminClient;\n+    private AdminClient adminClient;\n+    private Client client;\n+    private ActionListener<Boolean> finalListener;\n+\n+    private ArgumentCaptor<CreateIndexRequest> createRequestCaptor;\n+    private ArgumentCaptor<IndicesAliasesRequest> aliasesRequestCaptor;\n+\n+    @Before\n+    public void setUpMocks() {\n+        threadPool = mock(ThreadPool.class);\n+        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n+\n+        indicesAdminClient = mock(IndicesAdminClient.class);\n+        when(indicesAdminClient.prepareCreate(\".ml-state\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6bcec40010839a5bc2cba24e2202904c2c58dbf"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE0MDk5OQ==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/52417#discussion_r381140999", "createdAt": "2020-02-19T08:32:25Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndexTests.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.job.persistence;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.Alias;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesAction;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest.AliasActions;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexAction;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.AdminClient;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.IndicesAdminClient;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InOrder;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class AnomalyDetectorsIndexTests extends ESTestCase {\n+\n+    private ThreadPool threadPool;\n+    private IndicesAdminClient indicesAdminClient;\n+    private AdminClient adminClient;\n+    private Client client;\n+    private ActionListener<Boolean> finalListener;\n+\n+    private ArgumentCaptor<CreateIndexRequest> createRequestCaptor;\n+    private ArgumentCaptor<IndicesAliasesRequest> aliasesRequestCaptor;\n+\n+    @Before\n+    public void setUpMocks() {\n+        threadPool = mock(ThreadPool.class);\n+        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n+\n+        indicesAdminClient = mock(IndicesAdminClient.class);\n+        when(indicesAdminClient.prepareCreate(\".ml-state\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEyNjg1NA=="}, "originalCommit": {"oid": "c6bcec40010839a5bc2cba24e2202904c2c58dbf"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1OTAwNzU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndexTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODowNjozNFrOFreVJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODozNToyM1rOFrfFWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEzMDAyMQ==", "bodyText": "nit: its confusing to prefix with test as this is usually the entry point (if public) for a unit test. I tend towards naming inner methods like this assert...", "url": "https://github.com/elastic/elasticsearch/pull/52417#discussion_r381130021", "createdAt": "2020-02-19T08:06:34Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndexTests.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.job.persistence;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.Alias;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesAction;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest.AliasActions;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexAction;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.AdminClient;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.IndicesAdminClient;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InOrder;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class AnomalyDetectorsIndexTests extends ESTestCase {\n+\n+    private ThreadPool threadPool;\n+    private IndicesAdminClient indicesAdminClient;\n+    private AdminClient adminClient;\n+    private Client client;\n+    private ActionListener<Boolean> finalListener;\n+\n+    private ArgumentCaptor<CreateIndexRequest> createRequestCaptor;\n+    private ArgumentCaptor<IndicesAliasesRequest> aliasesRequestCaptor;\n+\n+    @Before\n+    public void setUpMocks() {\n+        threadPool = mock(ThreadPool.class);\n+        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n+\n+        indicesAdminClient = mock(IndicesAdminClient.class);\n+        when(indicesAdminClient.prepareCreate(\".ml-state\"))\n+            .thenReturn(new CreateIndexRequestBuilder(client, CreateIndexAction.INSTANCE, \".ml-state\"));\n+        doAnswer(withResponse(new CreateIndexResponse(true, true, \".ml-state\"))).when(indicesAdminClient).create(any(), any());\n+        when(indicesAdminClient.prepareAliases()).thenReturn(new IndicesAliasesRequestBuilder(client, IndicesAliasesAction.INSTANCE));\n+        doAnswer(withResponse(new AcknowledgedResponse(true))).when(indicesAdminClient).aliases(any(), any());\n+\n+        adminClient = mock(AdminClient.class);\n+        when(adminClient.indices()).thenReturn(indicesAdminClient);\n+\n+        client = mock(Client.class);\n+        when(client.threadPool()).thenReturn(threadPool);\n+        when(client.admin()).thenReturn(adminClient);\n+\n+        finalListener = mock(ActionListener.class);\n+\n+        createRequestCaptor = ArgumentCaptor.forClass(CreateIndexRequest.class);\n+        aliasesRequestCaptor = ArgumentCaptor.forClass(IndicesAliasesRequest.class);\n+    }\n+\n+    @After\n+    public void verifyNoMoreInteractionsWithMocks() {\n+        verifyNoMoreInteractions(indicesAdminClient, finalListener);\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_CleanState() {\n+        ClusterState clusterState = createClusterState(Collections.emptyMap());\n+        AnomalyDetectorsIndex.createStateIndexAndAliasIfNecessary(client, clusterState, finalListener);\n+\n+        InOrder inOrder = inOrder(indicesAdminClient, finalListener);\n+        inOrder.verify(indicesAdminClient).prepareCreate(\".ml-state\");\n+        inOrder.verify(indicesAdminClient).create(createRequestCaptor.capture(), any());\n+        inOrder.verify(finalListener).onResponse(true);\n+\n+        CreateIndexRequest createRequest = createRequestCaptor.getValue();\n+        assertThat(createRequest.index(), equalTo(\".ml-state\"));\n+        assertThat(createRequest.aliases(), equalTo(Collections.singleton(new Alias(\".ml-state-write\"))));\n+    }\n+\n+    private void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(String indexName) {\n+        ClusterState clusterState = createClusterState(Collections.singletonMap(indexName, createIndexMetaDataWithAlias(indexName)));\n+        AnomalyDetectorsIndex.createStateIndexAndAliasIfNecessary(client, clusterState, finalListener);\n+\n+        InOrder inOrder = inOrder(finalListener);\n+        inOrder.verify(finalListener).onResponse(false);\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExistsAndPointsAtInitialStateIndex() {\n+        testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(\".ml-state-000001\");\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExistsAndPointsAtSubsequentStateIndex() {\n+        testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(\".ml-state-000007\");\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExistsAndPointsAtDummyIndex() {\n+        testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(\"dummy-index\");\n+    }\n+\n+    private void testCreateStateIndexAndAliasIfNecessary_WriteAliasDoesNotExist(List<String> existingIndexNames,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6bcec40010839a5bc2cba24e2202904c2c58dbf"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE0MjM2MA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/52417#discussion_r381142360", "createdAt": "2020-02-19T08:35:23Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndexTests.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.job.persistence;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.Alias;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesAction;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest.AliasActions;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexAction;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.AdminClient;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.IndicesAdminClient;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InOrder;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class AnomalyDetectorsIndexTests extends ESTestCase {\n+\n+    private ThreadPool threadPool;\n+    private IndicesAdminClient indicesAdminClient;\n+    private AdminClient adminClient;\n+    private Client client;\n+    private ActionListener<Boolean> finalListener;\n+\n+    private ArgumentCaptor<CreateIndexRequest> createRequestCaptor;\n+    private ArgumentCaptor<IndicesAliasesRequest> aliasesRequestCaptor;\n+\n+    @Before\n+    public void setUpMocks() {\n+        threadPool = mock(ThreadPool.class);\n+        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));\n+\n+        indicesAdminClient = mock(IndicesAdminClient.class);\n+        when(indicesAdminClient.prepareCreate(\".ml-state\"))\n+            .thenReturn(new CreateIndexRequestBuilder(client, CreateIndexAction.INSTANCE, \".ml-state\"));\n+        doAnswer(withResponse(new CreateIndexResponse(true, true, \".ml-state\"))).when(indicesAdminClient).create(any(), any());\n+        when(indicesAdminClient.prepareAliases()).thenReturn(new IndicesAliasesRequestBuilder(client, IndicesAliasesAction.INSTANCE));\n+        doAnswer(withResponse(new AcknowledgedResponse(true))).when(indicesAdminClient).aliases(any(), any());\n+\n+        adminClient = mock(AdminClient.class);\n+        when(adminClient.indices()).thenReturn(indicesAdminClient);\n+\n+        client = mock(Client.class);\n+        when(client.threadPool()).thenReturn(threadPool);\n+        when(client.admin()).thenReturn(adminClient);\n+\n+        finalListener = mock(ActionListener.class);\n+\n+        createRequestCaptor = ArgumentCaptor.forClass(CreateIndexRequest.class);\n+        aliasesRequestCaptor = ArgumentCaptor.forClass(IndicesAliasesRequest.class);\n+    }\n+\n+    @After\n+    public void verifyNoMoreInteractionsWithMocks() {\n+        verifyNoMoreInteractions(indicesAdminClient, finalListener);\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_CleanState() {\n+        ClusterState clusterState = createClusterState(Collections.emptyMap());\n+        AnomalyDetectorsIndex.createStateIndexAndAliasIfNecessary(client, clusterState, finalListener);\n+\n+        InOrder inOrder = inOrder(indicesAdminClient, finalListener);\n+        inOrder.verify(indicesAdminClient).prepareCreate(\".ml-state\");\n+        inOrder.verify(indicesAdminClient).create(createRequestCaptor.capture(), any());\n+        inOrder.verify(finalListener).onResponse(true);\n+\n+        CreateIndexRequest createRequest = createRequestCaptor.getValue();\n+        assertThat(createRequest.index(), equalTo(\".ml-state\"));\n+        assertThat(createRequest.aliases(), equalTo(Collections.singleton(new Alias(\".ml-state-write\"))));\n+    }\n+\n+    private void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(String indexName) {\n+        ClusterState clusterState = createClusterState(Collections.singletonMap(indexName, createIndexMetaDataWithAlias(indexName)));\n+        AnomalyDetectorsIndex.createStateIndexAndAliasIfNecessary(client, clusterState, finalListener);\n+\n+        InOrder inOrder = inOrder(finalListener);\n+        inOrder.verify(finalListener).onResponse(false);\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExistsAndPointsAtInitialStateIndex() {\n+        testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(\".ml-state-000001\");\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExistsAndPointsAtSubsequentStateIndex() {\n+        testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(\".ml-state-000007\");\n+    }\n+\n+    public void testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExistsAndPointsAtDummyIndex() {\n+        testCreateStateIndexAndAliasIfNecessary_WriteAliasAlreadyExists(\"dummy-index\");\n+    }\n+\n+    private void testCreateStateIndexAndAliasIfNecessary_WriteAliasDoesNotExist(List<String> existingIndexNames,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEzMDAyMQ=="}, "originalCommit": {"oid": "c6bcec40010839a5bc2cba24e2202904c2c58dbf"}, "originalPosition": 130}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3930, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}