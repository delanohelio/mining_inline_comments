{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNzk5Nzkw", "number": 51123, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyMzozOFrODY1QRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMDo0NTozMVrODY_jQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY0OTM0OnYy", "diffSide": "RIGHT", "path": "distribution/packages/src/common/scripts/postinst", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyMzozOFrOFe6eQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyMzozOFrOFe6eQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1OTYxOQ==", "bodyText": "Tiny nit / observation - is it worth putting the command in quotes?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      echo \" Please run elasticsearch-keystore upgrade and enter password\" 1>&2\n          \n          \n            \n                      echo \" Please run 'elasticsearch-keystore upgrade' and enter password\" 1>&2", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r367959619", "createdAt": "2020-01-17T14:23:38Z", "author": {"login": "pugnascotia"}, "path": "distribution/packages/src/common/scripts/postinst", "diffHunk": "@@ -108,7 +108,12 @@ if [ \"$PACKAGE\" = \"deb\" ]; then\n         chmod 660 \"${ES_PATH_CONF}\"/elasticsearch.keystore\n         md5sum \"${ES_PATH_CONF}\"/elasticsearch.keystore > \"${ES_PATH_CONF}\"/.elasticsearch.keystore.initial_md5sum\n     else\n-        /usr/share/elasticsearch/bin/elasticsearch-keystore upgrade\n+        if /usr/share/elasticsearch/bin/elasticsearch-keystore has-passwd --silent ; then\n+          echo \"### Warning: unable to upgrade encrypted keystore\" 1>&2\n+          echo \" Please run elasticsearch-keystore upgrade and enter password\" 1>&2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY5MTg1OnYy", "diffSide": "RIGHT", "path": "distribution/src/bin/elasticsearch", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDozNjozN1rOFe638w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjozNjoyNVrOFgtc1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2NjE5NQ==", "bodyText": "This feels a bit fragile to me. What about something like:\nCHECK_KEYSTORE=false\nfor option in \"$@\"; do\n  case \"$option\" in\n    -h|--help|-V|--version)\n      CHECK_KEYSTORE=true\n      ;;\n  esac\ndone\nif [[ $CHECK_KEYSTORE == true ]] \\\n    && \"`dirname \"$0\"`\"/elasticsearch-keystore has-passwd --silent\n  # etc", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r367966195", "createdAt": "2020-01-17T14:36:37Z", "author": {"login": "pugnascotia"}, "path": "distribution/src/bin/elasticsearch", "diffHunk": "@@ -20,6 +20,19 @@ if [ -z \"$ES_TMPDIR\" ]; then\n   ES_TMPDIR=`\"$JAVA\" -cp \"$ES_CLASSPATH\" org.elasticsearch.tools.launchers.TempDirectory`\n fi\n \n+# get keystore password before setting java options to avoid\n+# conflicting GC configurations for the keystore tools\n+unset KEYSTORE_PASSWORD\n+KEYSTORE_PASSWORD=\n+if ! echo $* | grep -E -q '(^-h |-h$| -h |--help$|--help |^-V |-V$| -V |--version$|--version )' \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0MzQxMg==", "bodyText": "I copied a pattern checking for daemonization below. I'd like to put this off for a follow-up PR so it can be discussed with some other team members in isolation. That being said I don't have any objection to doing a loop over options and it seems to work just fine in my quick local tests.", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369843412", "createdAt": "2020-01-22T22:36:25Z", "author": {"login": "williamrandolph"}, "path": "distribution/src/bin/elasticsearch", "diffHunk": "@@ -20,6 +20,19 @@ if [ -z \"$ES_TMPDIR\" ]; then\n   ES_TMPDIR=`\"$JAVA\" -cp \"$ES_CLASSPATH\" org.elasticsearch.tools.launchers.TempDirectory`\n fi\n \n+# get keystore password before setting java options to avoid\n+# conflicting GC configurations for the keystore tools\n+unset KEYSTORE_PASSWORD\n+KEYSTORE_PASSWORD=\n+if ! echo $* | grep -E -q '(^-h |-h$| -h |--help$|--help |^-V |-V$| -V |--version$|--version )' \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2NjE5NQ=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzcxMjA4OnYy", "diffSide": "RIGHT", "path": "distribution/tools/keystore-cli/src/main/java/org/elasticsearch/common/settings/CreateKeyStoreCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDo0Mjo1MFrOFe7Efg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwOTozMTowMVrOFgVczw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2OTQwNg==", "bodyText": "Should be we capitalizing \"elasticsearch\" here, and elsewhere?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {\n          \n          \n            \n                            if (terminal.promptYesNo(\"An Elasticsearch keystore already exists. Overwrite?\", false) == false) {", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r367969406", "createdAt": "2020-01-17T14:42:50Z", "author": {"login": "pugnascotia"}, "path": "distribution/tools/keystore-cli/src/main/java/org/elasticsearch/common/settings/CreateKeyStoreCommand.java", "diffHunk": "@@ -21,41 +21,44 @@\n \n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.Arrays;\n \n import joptsimple.OptionSet;\n-import org.elasticsearch.cli.EnvironmentAwareCommand;\n+import joptsimple.OptionSpec;\n+import org.elasticsearch.cli.ExitCodes;\n+import org.elasticsearch.cli.KeyStoreAwareCommand;\n import org.elasticsearch.cli.Terminal;\n+import org.elasticsearch.cli.UserException;\n import org.elasticsearch.env.Environment;\n \n /**\n- * A subcommand for the keystore cli to create a new keystore.\n+ * A sub-command for the keystore cli to create a new keystore.\n  */\n-class CreateKeyStoreCommand extends EnvironmentAwareCommand {\n+class CreateKeyStoreCommand extends KeyStoreAwareCommand {\n+\n+    private final OptionSpec<Void> passwordOption;\n \n     CreateKeyStoreCommand() {\n         super(\"Creates a new elasticsearch keystore\");\n+        this.passwordOption = parser.acceptsAll(Arrays.asList(\"p\", \"password\"), \"Prompt for password to encrypt the keystore\");\n     }\n \n     @Override\n     protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {\n-        Path keystoreFile = KeyStoreWrapper.keystorePath(env.configFile());\n-        if (Files.exists(keystoreFile)) {\n-            if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {\n-                terminal.println(\"Exiting without creating keystore.\");\n-                return;\n+        try (SecureString password = options.has(passwordOption) ?\n+            readPassword(terminal, true) : new SecureString(new char[0])) {\n+            Path keystoreFile = KeyStoreWrapper.keystorePath(env.configFile());\n+            if (Files.exists(keystoreFile)) {\n+                if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1MDE5MQ==", "bodyText": "I think we use non-capitalized elasticsearch everywhere else in our logs, prompts ,etc.", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369450191", "createdAt": "2020-01-22T09:31:01Z", "author": {"login": "jkakavas"}, "path": "distribution/tools/keystore-cli/src/main/java/org/elasticsearch/common/settings/CreateKeyStoreCommand.java", "diffHunk": "@@ -21,41 +21,44 @@\n \n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.Arrays;\n \n import joptsimple.OptionSet;\n-import org.elasticsearch.cli.EnvironmentAwareCommand;\n+import joptsimple.OptionSpec;\n+import org.elasticsearch.cli.ExitCodes;\n+import org.elasticsearch.cli.KeyStoreAwareCommand;\n import org.elasticsearch.cli.Terminal;\n+import org.elasticsearch.cli.UserException;\n import org.elasticsearch.env.Environment;\n \n /**\n- * A subcommand for the keystore cli to create a new keystore.\n+ * A sub-command for the keystore cli to create a new keystore.\n  */\n-class CreateKeyStoreCommand extends EnvironmentAwareCommand {\n+class CreateKeyStoreCommand extends KeyStoreAwareCommand {\n+\n+    private final OptionSpec<Void> passwordOption;\n \n     CreateKeyStoreCommand() {\n         super(\"Creates a new elasticsearch keystore\");\n+        this.passwordOption = parser.acceptsAll(Arrays.asList(\"p\", \"password\"), \"Prompt for password to encrypt the keystore\");\n     }\n \n     @Override\n     protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {\n-        Path keystoreFile = KeyStoreWrapper.keystorePath(env.configFile());\n-        if (Files.exists(keystoreFile)) {\n-            if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {\n-                terminal.println(\"Exiting without creating keystore.\");\n-                return;\n+        try (SecureString password = options.has(passwordOption) ?\n+            readPassword(terminal, true) : new SecureString(new char[0])) {\n+            Path keystoreFile = KeyStoreWrapper.keystorePath(env.configFile());\n+            if (Files.exists(keystoreFile)) {\n+                if (terminal.promptYesNo(\"An elasticsearch keystore already exists. Overwrite?\", false) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2OTQwNg=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDAxNzg2OnYy", "diffSide": "RIGHT", "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddFileKeyStoreCommandTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjoxNTo1NlrOFe-BuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwOTo0MTo0N1rOFgVxhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNzg0OQ==", "bodyText": "Nit-pick - I first read this test name as meaning that the file being added doesn't exist. Could we tweak it, e.g.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testForceNonExistent() throws Exception {\n          \n          \n            \n                public void testForceDoesNotAlreadyExist() throws Exception {\n          \n      \n    \n    \n  \n\nMore generally, it'd be great if these tests had Javadoc comments that briefly explained each scenario / expectation, but I'll leave that up to you.", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368017849", "createdAt": "2020-01-17T16:15:56Z", "author": {"login": "pugnascotia"}, "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddFileKeyStoreCommandTests.java", "diffHunk": "@@ -53,110 +53,156 @@ private Path createRandomFile() throws IOException {\n         return file;\n     }\n \n-    private void addFile(KeyStoreWrapper keystore, String setting, Path file) throws Exception {\n+    private void addFile(KeyStoreWrapper keystore, String setting, Path file, String password) throws Exception {\n         keystore.setFile(setting, Files.readAllBytes(file));\n-        keystore.save(env.configFile(), new char[0]);\n+        keystore.save(env.configFile(), password.toCharArray());\n     }\n \n-    public void testMissingPromptCreate() throws Exception {\n+    public void testMissingCreateWithEmptyPasswordWhenPrompted() throws Exception {\n+        String password = \"\";\n         Path file1 = createRandomFile();\n         terminal.addTextInput(\"y\");\n         execute(\"foo\", file1.toString());\n-        assertSecureFile(\"foo\", file1);\n+        assertSecureFile(\"foo\", file1, password);\n     }\n \n-    public void testMissingForceCreate() throws Exception {\n+    public void testMissingCreateWithEmptyPasswordWithoutPromptIfForced() throws Exception {\n+        String password = \"\";\n         Path file1 = createRandomFile();\n-        terminal.addSecretInput(\"bar\");\n         execute(\"-f\", \"foo\", file1.toString());\n-        assertSecureFile(\"foo\", file1);\n+        assertSecureFile(\"foo\", file1, password);\n     }\n \n     public void testMissingNoCreate() throws Exception {\n+        terminal.addSecretInput(randomFrom(\"\", \"keystorepassword\"));\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n         assertNull(KeyStoreWrapper.load(env.configFile()));\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file, password);\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\", \"path/dne\");\n-        assertSecureFile(\"foo\", file);\n+        assertSecureFile(\"foo\", file, password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file, password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\", \"path/dne\");\n-        assertSecureFile(\"foo\", file);\n+        assertSecureFile(\"foo\", file, password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"y\");\n         Path file2 = createRandomFile();\n         execute(\"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n         Path file2 = createRandomFile();\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         execute(\"-f\", \"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n         Path file2 = createRandomFile();\n+        terminal.addSecretInput(password);\n         execute(\"--force\", \"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testForceNonExistent() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NTQ5Mw==", "bodyText": "I think this is a generic problem for a lot of our tests. It's not quite obvious all the time what the test does and the method name can only have so many words in it. However, very few of our tests have javadocs.\nIn this case I think we can get away with editing the method names but feel free to argue against it", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369455493", "createdAt": "2020-01-22T09:41:47Z", "author": {"login": "jkakavas"}, "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddFileKeyStoreCommandTests.java", "diffHunk": "@@ -53,110 +53,156 @@ private Path createRandomFile() throws IOException {\n         return file;\n     }\n \n-    private void addFile(KeyStoreWrapper keystore, String setting, Path file) throws Exception {\n+    private void addFile(KeyStoreWrapper keystore, String setting, Path file, String password) throws Exception {\n         keystore.setFile(setting, Files.readAllBytes(file));\n-        keystore.save(env.configFile(), new char[0]);\n+        keystore.save(env.configFile(), password.toCharArray());\n     }\n \n-    public void testMissingPromptCreate() throws Exception {\n+    public void testMissingCreateWithEmptyPasswordWhenPrompted() throws Exception {\n+        String password = \"\";\n         Path file1 = createRandomFile();\n         terminal.addTextInput(\"y\");\n         execute(\"foo\", file1.toString());\n-        assertSecureFile(\"foo\", file1);\n+        assertSecureFile(\"foo\", file1, password);\n     }\n \n-    public void testMissingForceCreate() throws Exception {\n+    public void testMissingCreateWithEmptyPasswordWithoutPromptIfForced() throws Exception {\n+        String password = \"\";\n         Path file1 = createRandomFile();\n-        terminal.addSecretInput(\"bar\");\n         execute(\"-f\", \"foo\", file1.toString());\n-        assertSecureFile(\"foo\", file1);\n+        assertSecureFile(\"foo\", file1, password);\n     }\n \n     public void testMissingNoCreate() throws Exception {\n+        terminal.addSecretInput(randomFrom(\"\", \"keystorepassword\"));\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n         assertNull(KeyStoreWrapper.load(env.configFile()));\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file, password);\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\", \"path/dne\");\n-        assertSecureFile(\"foo\", file);\n+        assertSecureFile(\"foo\", file, password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file, password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\", \"path/dne\");\n-        assertSecureFile(\"foo\", file);\n+        assertSecureFile(\"foo\", file, password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"y\");\n         Path file2 = createRandomFile();\n         execute(\"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n         Path file2 = createRandomFile();\n+        terminal.addSecretInput(password);\n+        terminal.addSecretInput(password);\n         execute(\"-f\", \"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n+        String password = \"keystorepassword\";\n         Path file1 = createRandomFile();\n-        KeyStoreWrapper keystore = createKeystore(\"\");\n-        addFile(keystore, \"foo\", file1);\n+        KeyStoreWrapper keystore = createKeystore(password);\n+        addFile(keystore, \"foo\", file1, password);\n         Path file2 = createRandomFile();\n+        terminal.addSecretInput(password);\n         execute(\"--force\", \"foo\", file2.toString());\n-        assertSecureFile(\"foo\", file2);\n+        assertSecureFile(\"foo\", file2, password);\n     }\n \n     public void testForceNonExistent() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNzg0OQ=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDAzNzQ5OnYy", "diffSide": "LEFT", "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddStringKeyStoreCommandTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjoyMjozOVrOFe-OPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwODo1Njo1NlrOFgUgMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTA1Mw==", "bodyText": "What happened to these tests?", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368021053", "createdAt": "2020-01-17T16:22:39Z", "author": {"login": "pugnascotia"}, "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddStringKeyStoreCommandTests.java", "diffHunk": "@@ -70,105 +80,92 @@ public void testMissingNoCreate() throws Exception {\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n         terminal.addTextInput(\"y\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"-f\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"and yet another secret value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"and yet another secret value\");\n+        assertSecureString(\"foo\", \"and yet another secret value\", password);\n     }\n \n     public void testForceNonExistent() throws Exception {\n-        createKeystore(\"\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password);\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"value\");\n+        assertSecureString(\"foo\", \"value\", password);\n     }\n \n     public void testPromptForValue() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"secret value\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"secret value\");\n+        assertSecureString(\"foo\", \"secret value\", password);\n     }\n \n     public void testStdinShort() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 1\");\n         execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 1\");\n+        assertSecureString(\"foo\", \"secret value 1\", password);\n     }\n \n     public void testStdinLong() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 2\");\n         execute(\"--stdin\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 2\");\n-    }\n-\n-    public void testStdinNoInput() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"\");\n-    }\n-\n-    public void testStdinInputWithLineBreaks() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\n\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testStdinInputWithCarriageReturn() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\r\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testAddUtf8String() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxODczMg==", "bodyText": "These were removed in #38498 but apparently by mistake, I don't remember removing them for a reason. I'll push them back in", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369418732", "createdAt": "2020-01-22T08:17:55Z", "author": {"login": "jkakavas"}, "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddStringKeyStoreCommandTests.java", "diffHunk": "@@ -70,105 +80,92 @@ public void testMissingNoCreate() throws Exception {\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n         terminal.addTextInput(\"y\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"-f\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"and yet another secret value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"and yet another secret value\");\n+        assertSecureString(\"foo\", \"and yet another secret value\", password);\n     }\n \n     public void testForceNonExistent() throws Exception {\n-        createKeystore(\"\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password);\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"value\");\n+        assertSecureString(\"foo\", \"value\", password);\n     }\n \n     public void testPromptForValue() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"secret value\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"secret value\");\n+        assertSecureString(\"foo\", \"secret value\", password);\n     }\n \n     public void testStdinShort() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 1\");\n         execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 1\");\n+        assertSecureString(\"foo\", \"secret value 1\", password);\n     }\n \n     public void testStdinLong() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 2\");\n         execute(\"--stdin\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 2\");\n-    }\n-\n-    public void testStdinNoInput() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"\");\n-    }\n-\n-    public void testStdinInputWithLineBreaks() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\n\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testStdinInputWithCarriageReturn() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\r\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testAddUtf8String() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTA1Mw=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQzNDY3Mw==", "bodyText": "Good catch @pugnascotia ! Not only these were removed by mistake, but the removal was hiding a bug \ud83d\ude4f", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369434673", "createdAt": "2020-01-22T08:56:56Z", "author": {"login": "jkakavas"}, "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/AddStringKeyStoreCommandTests.java", "diffHunk": "@@ -70,105 +80,92 @@ public void testMissingNoCreate() throws Exception {\n     }\n \n     public void testOverwritePromptDefault() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitNo() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addTextInput(\"n\"); // explicit no\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"bar\");\n+        assertSecureString(\"foo\", \"bar\", password);\n     }\n \n     public void testOverwritePromptExplicitYes() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n         terminal.addTextInput(\"y\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceShort() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"newvalue\");\n         execute(\"-f\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"newvalue\");\n+        assertSecureString(\"foo\", \"newvalue\", password);\n     }\n \n     public void testOverwriteForceLong() throws Exception {\n-        createKeystore(\"\", \"foo\", \"bar\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password, \"foo\", \"bar\");\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"and yet another secret value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"and yet another secret value\");\n+        assertSecureString(\"foo\", \"and yet another secret value\", password);\n     }\n \n     public void testForceNonExistent() throws Exception {\n-        createKeystore(\"\");\n+        String password = \"keystorepassword\";\n+        createKeystore(password);\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"value\");\n         execute(\"--force\", \"foo\"); // force\n-        assertSecureString(\"foo\", \"value\");\n+        assertSecureString(\"foo\", \"value\", password);\n     }\n \n     public void testPromptForValue() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         terminal.addSecretInput(\"secret value\");\n         execute(\"foo\");\n-        assertSecureString(\"foo\", \"secret value\");\n+        assertSecureString(\"foo\", \"secret value\", password);\n     }\n \n     public void testStdinShort() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 1\");\n         execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 1\");\n+        assertSecureString(\"foo\", \"secret value 1\", password);\n     }\n \n     public void testStdinLong() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n+        String password = \"keystorepassword\";\n+        KeyStoreWrapper.create().save(env.configFile(), password.toCharArray());\n+        terminal.addSecretInput(password);\n         setInput(\"secret value 2\");\n         execute(\"--stdin\", \"foo\");\n-        assertSecureString(\"foo\", \"secret value 2\");\n-    }\n-\n-    public void testStdinNoInput() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"\");\n-    }\n-\n-    public void testStdinInputWithLineBreaks() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\n\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testStdinInputWithCarriageReturn() throws Exception {\n-        KeyStoreWrapper.create().save(env.configFile(), new char[0]);\n-        setInput(\"Typedthisandhitenter\\r\");\n-        execute(\"-x\", \"foo\");\n-        assertSecureString(\"foo\", \"Typedthisandhitenter\");\n-    }\n-\n-    public void testAddUtf8String() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTA1Mw=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDA3MDQ2OnYy", "diffSide": "RIGHT", "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/HasPasswordKeyStoreCommandTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjozMjo1NFrOFe-ibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjozMjo1NFrOFe-ibg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNjIyMg==", "bodyText": "Maybe not hard-code the expected exit code in the message? Very nit-picky, I realise.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(\"Exit code should be 1\", HasPasswordKeyStoreCommand.NO_PASSWORD_EXIT_CODE, e.exitCode);\n          \n          \n            \n                    assertEquals(\"Unexpected exit code\", HasPasswordKeyStoreCommand.NO_PASSWORD_EXIT_CODE, e.exitCode);", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368026222", "createdAt": "2020-01-17T16:32:54Z", "author": {"login": "pugnascotia"}, "path": "distribution/tools/keystore-cli/src/test/java/org/elasticsearch/common/settings/HasPasswordKeyStoreCommandTests.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.settings;\n+\n+import org.elasticsearch.cli.Command;\n+import org.elasticsearch.cli.UserException;\n+import org.elasticsearch.env.Environment;\n+\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.emptyString;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class HasPasswordKeyStoreCommandTests extends KeyStoreCommandTestCase {\n+    @Override\n+    protected Command newCommand() {\n+        return new HasPasswordKeyStoreCommand() {\n+            @Override\n+            protected Environment createEnv(Map<String, String> settings) throws UserException {\n+                return env;\n+            }\n+        };\n+    }\n+\n+    public void testFailsWithNoKeystore() throws Exception {\n+        UserException e = expectThrows(UserException.class, this::execute);\n+        assertEquals(\"Exit code should be 1\", HasPasswordKeyStoreCommand.NO_PASSWORD_EXIT_CODE, e.exitCode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDA4MDI3OnYy", "diffSide": "RIGHT", "path": "docs/reference/cluster/nodes-reload-secure-settings.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjozNTo1N1rOFe-oog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjozNTo1N1rOFe-oog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNzgxMA==", "bodyText": "This API page should follow the format specified in https://github.com/elastic/docs/blob/master/shared/api-ref-ex.asciidoc (similar to the other cluster APIs).  This cleanup can occur in a subsequent PR, however.", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368027810", "createdAt": "2020-01-17T16:35:57Z", "author": {"login": "lcawl"}, "path": "docs/reference/cluster/nodes-reload-secure-settings.asciidoc", "diffHunk": "@@ -1,13 +1,11 @@\n [[cluster-nodes-reload-secure-settings]]\n-== Nodes Reload Secure Settings\n+=== Nodes reload secure settings API\n+++++", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDE1MTI2OnYy", "diffSide": "RIGHT", "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1OTozOFrOFe_U6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1OTozOFrOFe_U6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzOTE0Nw==", "bodyText": "Should we extract some of the other standard error messages too?", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368039147", "createdAt": "2020-01-17T16:59:38Z", "author": {"login": "pugnascotia"}, "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.packaging.test;\n+\n+import org.elasticsearch.packaging.util.Distribution;\n+import org.elasticsearch.packaging.util.Docker;\n+import org.elasticsearch.packaging.util.FileUtils;\n+import org.elasticsearch.packaging.util.Installation;\n+import org.elasticsearch.packaging.util.Platforms;\n+import org.elasticsearch.packaging.util.ServerUtils;\n+import org.elasticsearch.packaging.util.Shell;\n+import org.junit.Ignore;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Map;\n+\n+import static org.elasticsearch.packaging.util.Archives.ARCHIVE_OWNER;\n+import static org.elasticsearch.packaging.util.Archives.installArchive;\n+import static org.elasticsearch.packaging.util.Archives.verifyArchiveInstallation;\n+import static org.elasticsearch.packaging.util.Docker.assertPermissionsAndOwnership;\n+import static org.elasticsearch.packaging.util.Docker.runContainer;\n+import static org.elasticsearch.packaging.util.Docker.runContainerExpectingFailure;\n+import static org.elasticsearch.packaging.util.Docker.waitForElasticsearch;\n+import static org.elasticsearch.packaging.util.Docker.waitForPathToExist;\n+import static org.elasticsearch.packaging.util.FileMatcher.Fileness.File;\n+import static org.elasticsearch.packaging.util.FileMatcher.file;\n+import static org.elasticsearch.packaging.util.FileMatcher.p660;\n+import static org.elasticsearch.packaging.util.FileUtils.getTempDir;\n+import static org.elasticsearch.packaging.util.FileUtils.rm;\n+import static org.elasticsearch.packaging.util.Packages.assertInstalled;\n+import static org.elasticsearch.packaging.util.Packages.assertRemoved;\n+import static org.elasticsearch.packaging.util.Packages.installPackage;\n+import static org.elasticsearch.packaging.util.Packages.verifyPackageInstallation;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class KeystoreManagementTests extends PackagingTestCase {\n+\n+    private static final String PASSWORD_ERROR_MESSAGE = \"Provided keystore password was incorrect\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDE3NTU3OnYy", "diffSide": "RIGHT", "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzowODoyMVrOFe_j6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMToxNzoxOVrOFgrSYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0Mjk4Nw==", "bodyText": "Is it not sufficient to just ensure that Elasticsearch has started? Do we need to also run the tests?", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368042987", "createdAt": "2020-01-17T17:08:21Z", "author": {"login": "pugnascotia"}, "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.packaging.test;\n+\n+import org.elasticsearch.packaging.util.Distribution;\n+import org.elasticsearch.packaging.util.Docker;\n+import org.elasticsearch.packaging.util.FileUtils;\n+import org.elasticsearch.packaging.util.Installation;\n+import org.elasticsearch.packaging.util.Platforms;\n+import org.elasticsearch.packaging.util.ServerUtils;\n+import org.elasticsearch.packaging.util.Shell;\n+import org.junit.Ignore;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Map;\n+\n+import static org.elasticsearch.packaging.util.Archives.ARCHIVE_OWNER;\n+import static org.elasticsearch.packaging.util.Archives.installArchive;\n+import static org.elasticsearch.packaging.util.Archives.verifyArchiveInstallation;\n+import static org.elasticsearch.packaging.util.Docker.assertPermissionsAndOwnership;\n+import static org.elasticsearch.packaging.util.Docker.runContainer;\n+import static org.elasticsearch.packaging.util.Docker.runContainerExpectingFailure;\n+import static org.elasticsearch.packaging.util.Docker.waitForElasticsearch;\n+import static org.elasticsearch.packaging.util.Docker.waitForPathToExist;\n+import static org.elasticsearch.packaging.util.FileMatcher.Fileness.File;\n+import static org.elasticsearch.packaging.util.FileMatcher.file;\n+import static org.elasticsearch.packaging.util.FileMatcher.p660;\n+import static org.elasticsearch.packaging.util.FileUtils.getTempDir;\n+import static org.elasticsearch.packaging.util.FileUtils.rm;\n+import static org.elasticsearch.packaging.util.Packages.assertInstalled;\n+import static org.elasticsearch.packaging.util.Packages.assertRemoved;\n+import static org.elasticsearch.packaging.util.Packages.installPackage;\n+import static org.elasticsearch.packaging.util.Packages.verifyPackageInstallation;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class KeystoreManagementTests extends PackagingTestCase {\n+\n+    private static final String PASSWORD_ERROR_MESSAGE = \"Provided keystore password was incorrect\";\n+\n+    /** Test initial archive state */\n+    public void test10InstallArchiveDistribution() throws Exception {\n+        assumeTrue(distribution().isArchive());\n+\n+        installation = installArchive(sh, distribution);\n+        verifyArchiveInstallation(installation, distribution());\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate missing keystore\",\n+            r.stderr, containsString(\"ERROR: Elasticsearch keystore not found\"));\n+    }\n+\n+    /** Test initial package state */\n+    public void test11InstallPackageDistribution() throws Exception {\n+        assumeTrue(distribution().isPackage());\n+\n+        assertRemoved(distribution);\n+        installation = installPackage(sh, distribution);\n+        assertInstalled(distribution);\n+        verifyPackageInstallation(installation, distribution, sh);\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate unprotected keystore\",\n+            r.stderr, containsString(\"ERROR: Keystore is not password-protected\"));\n+        Shell.Result r2 = bin.keystoreTool.run(\"list\");\n+        assertThat(r2.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    /** Test initial Docker state */\n+    public void test12InstallDockerDistribution() throws Exception {\n+        assumeTrue(distribution().isDocker());\n+\n+        installation = Docker.runContainer(distribution());\n+\n+        try {\n+            waitForPathToExist(installation.config(\"elasticsearch.keystore\"));\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate unprotected keystore\",\n+            r.stdout, containsString(\"ERROR: Keystore is not password-protected\"));\n+        Shell.Result r2 = bin.keystoreTool.run(\"list\");\n+        assertThat(r2.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test20CreateKeystoreManually() throws Exception {\n+        rmKeystoreIfExists();\n+        createKeystore();\n+\n+        final Installation.Executables bin = installation.executables();\n+        verifyKeystorePermissions();\n+\n+        Shell.Result r = bin.keystoreTool.run(\"list\");\n+        assertThat(r.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test30AutoCreateKeystore() throws Exception {\n+        assumeTrue(\"Packages and docker are installed with a keystore file\", distribution.isArchive());\n+        rmKeystoreIfExists();\n+\n+        startElasticsearch();\n+        stopElasticsearch();\n+\n+        Platforms.onWindows(() -> sh.chown(installation.config(\"elasticsearch.keystore\")));\n+\n+        verifyKeystorePermissions();\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = bin.keystoreTool.run(\"list\");\n+        assertThat(r.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test40KeystorePasswordOnStandardInput() throws Exception {\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        String password = \"^|<>\\\\&exit\"; // code insertion on Windows if special characters are not escaped\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        awaitElasticsearchStartup(startElasticsearchStandardInputPassword(password));\n+        ServerUtils.runElasticsearchTests();\n+        stopElasticsearch();\n+    }\n+\n+    public void test41WrongKeystorePasswordOnStandardInput() {\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        assertPasswordProtectedKeystore();\n+\n+        Shell.Result result = startElasticsearchStandardInputPassword(\"wrong\");\n+        assertElasticsearchFailure(result, PASSWORD_ERROR_MESSAGE);\n+    }\n+\n+    @Ignore /* Ignored for feature branch, awaits fix: https://github.com/elastic/elasticsearch/issues/49340 */\n+    public void test42KeystorePasswordOnTty() throws Exception {\n+        assumeTrue(\"expect command isn't on Windows\",\n+            distribution.platform != Distribution.Platform.WINDOWS);\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        String password = \"keystorepass\";\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        awaitElasticsearchStartup(startElasticsearchTtyPassword(password));\n+        ServerUtils.runElasticsearchTests();\n+        stopElasticsearch();\n+    }\n+\n+    @Ignore /* Ignored for feature branch, awaits fix: https://github.com/elastic/elasticsearch/issues/49340 */\n+    public void test43WrongKeystorePasswordOnTty() throws Exception {\n+        assumeTrue(\"expect command isn't on Windows\",\n+            distribution.platform != Distribution.Platform.WINDOWS);\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        assertPasswordProtectedKeystore();\n+\n+        Shell.Result result = startElasticsearchTtyPassword(\"wrong\");\n+        // error will be on stdout for \"expect\"\n+        assertThat(result.stdout, containsString(PASSWORD_ERROR_MESSAGE));\n+    }\n+\n+    public void test50KeystorePasswordFromFile() throws Exception {\n+        assumeTrue(\"only for systemd\", Platforms.isSystemd() && distribution().isPackage());\n+        String password = \"!@#$%^&*()|\\\\<>/?\";\n+        Path esKeystorePassphraseFile = installation.config.resolve(\"eks\");\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        try {\n+            sh.run(\"sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=\" + esKeystorePassphraseFile);\n+\n+            Files.createFile(esKeystorePassphraseFile);\n+            Files.write(esKeystorePassphraseFile,\n+                (password + System.lineSeparator()).getBytes(StandardCharsets.UTF_8),\n+                StandardOpenOption.WRITE);\n+\n+            startElasticsearch();\n+            ServerUtils.runElasticsearchTests();\n+            stopElasticsearch();\n+        } finally {\n+            sh.run(\"sudo systemctl unset-environment ES_KEYSTORE_PASSPHRASE_FILE\");\n+        }\n+    }\n+\n+    public void test51WrongKeystorePasswordFromFile() throws Exception {\n+        assumeTrue(\"only for systemd\", Platforms.isSystemd() && distribution().isPackage());\n+        Path esKeystorePassphraseFile = installation.config.resolve(\"eks\");\n+\n+        assertPasswordProtectedKeystore();\n+\n+        try {\n+            sh.run(\"sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=\" + esKeystorePassphraseFile);\n+\n+            if (Files.exists(esKeystorePassphraseFile)) {\n+                rm(esKeystorePassphraseFile);\n+            }\n+\n+            Files.createFile(esKeystorePassphraseFile);\n+            Files.write(esKeystorePassphraseFile,\n+                (\"wrongpassword\" + System.lineSeparator()).getBytes(StandardCharsets.UTF_8),\n+                StandardOpenOption.WRITE);\n+\n+            Shell.Result result = runElasticsearchStartCommand();\n+            assertElasticsearchFailure(result, PASSWORD_ERROR_MESSAGE);\n+        } finally {\n+            sh.run(\"sudo systemctl unset-environment ES_KEYSTORE_PASSPHRASE_FILE\");\n+        }\n+    }\n+\n+    /**\n+     * Check that we can mount a password-protected keystore to a docker image\n+     * and provide a password via an environment variable.\n+     */\n+    public void test60DockerEnvironmentVariablePassword() throws Exception {\n+        assumeTrue(distribution().isDocker());\n+        String password = \"password\";\n+        Path dockerKeystore = installation.config(\"elasticsearch.keystore\");\n+\n+        Path localKeystoreFile = getKeystoreFileFromDockerContainer(password, dockerKeystore);\n+\n+        // restart ES with password and mounted keystore\n+        Map<Path, Path> volumes = Map.of(localKeystoreFile, dockerKeystore);\n+        Map<String, String> envVars = Map.of(\"KEYSTORE_PASSWORD\", password);\n+        runContainer(distribution(), volumes, envVars);\n+        waitForElasticsearch(installation);\n+        ServerUtils.runElasticsearchTests();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwNzk3MA==", "bodyText": "I don't see the downside in checking that Elasticsearch is not just running but minimally functional as well.", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369807970", "createdAt": "2020-01-22T21:17:19Z", "author": {"login": "williamrandolph"}, "path": "qa/os/src/test/java/org/elasticsearch/packaging/test/KeystoreManagementTests.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.packaging.test;\n+\n+import org.elasticsearch.packaging.util.Distribution;\n+import org.elasticsearch.packaging.util.Docker;\n+import org.elasticsearch.packaging.util.FileUtils;\n+import org.elasticsearch.packaging.util.Installation;\n+import org.elasticsearch.packaging.util.Platforms;\n+import org.elasticsearch.packaging.util.ServerUtils;\n+import org.elasticsearch.packaging.util.Shell;\n+import org.junit.Ignore;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Map;\n+\n+import static org.elasticsearch.packaging.util.Archives.ARCHIVE_OWNER;\n+import static org.elasticsearch.packaging.util.Archives.installArchive;\n+import static org.elasticsearch.packaging.util.Archives.verifyArchiveInstallation;\n+import static org.elasticsearch.packaging.util.Docker.assertPermissionsAndOwnership;\n+import static org.elasticsearch.packaging.util.Docker.runContainer;\n+import static org.elasticsearch.packaging.util.Docker.runContainerExpectingFailure;\n+import static org.elasticsearch.packaging.util.Docker.waitForElasticsearch;\n+import static org.elasticsearch.packaging.util.Docker.waitForPathToExist;\n+import static org.elasticsearch.packaging.util.FileMatcher.Fileness.File;\n+import static org.elasticsearch.packaging.util.FileMatcher.file;\n+import static org.elasticsearch.packaging.util.FileMatcher.p660;\n+import static org.elasticsearch.packaging.util.FileUtils.getTempDir;\n+import static org.elasticsearch.packaging.util.FileUtils.rm;\n+import static org.elasticsearch.packaging.util.Packages.assertInstalled;\n+import static org.elasticsearch.packaging.util.Packages.assertRemoved;\n+import static org.elasticsearch.packaging.util.Packages.installPackage;\n+import static org.elasticsearch.packaging.util.Packages.verifyPackageInstallation;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class KeystoreManagementTests extends PackagingTestCase {\n+\n+    private static final String PASSWORD_ERROR_MESSAGE = \"Provided keystore password was incorrect\";\n+\n+    /** Test initial archive state */\n+    public void test10InstallArchiveDistribution() throws Exception {\n+        assumeTrue(distribution().isArchive());\n+\n+        installation = installArchive(sh, distribution);\n+        verifyArchiveInstallation(installation, distribution());\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate missing keystore\",\n+            r.stderr, containsString(\"ERROR: Elasticsearch keystore not found\"));\n+    }\n+\n+    /** Test initial package state */\n+    public void test11InstallPackageDistribution() throws Exception {\n+        assumeTrue(distribution().isPackage());\n+\n+        assertRemoved(distribution);\n+        installation = installPackage(sh, distribution);\n+        assertInstalled(distribution);\n+        verifyPackageInstallation(installation, distribution, sh);\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate unprotected keystore\",\n+            r.stderr, containsString(\"ERROR: Keystore is not password-protected\"));\n+        Shell.Result r2 = bin.keystoreTool.run(\"list\");\n+        assertThat(r2.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    /** Test initial Docker state */\n+    public void test12InstallDockerDistribution() throws Exception {\n+        assumeTrue(distribution().isDocker());\n+\n+        installation = Docker.runContainer(distribution());\n+\n+        try {\n+            waitForPathToExist(installation.config(\"elasticsearch.keystore\"));\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = sh.runIgnoreExitCode(bin.keystoreTool.toString() + \" has-passwd\");\n+        assertFalse(\"has-passwd should fail\", r.isSuccess());\n+        assertThat(\"has-passwd should indicate unprotected keystore\",\n+            r.stdout, containsString(\"ERROR: Keystore is not password-protected\"));\n+        Shell.Result r2 = bin.keystoreTool.run(\"list\");\n+        assertThat(r2.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test20CreateKeystoreManually() throws Exception {\n+        rmKeystoreIfExists();\n+        createKeystore();\n+\n+        final Installation.Executables bin = installation.executables();\n+        verifyKeystorePermissions();\n+\n+        Shell.Result r = bin.keystoreTool.run(\"list\");\n+        assertThat(r.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test30AutoCreateKeystore() throws Exception {\n+        assumeTrue(\"Packages and docker are installed with a keystore file\", distribution.isArchive());\n+        rmKeystoreIfExists();\n+\n+        startElasticsearch();\n+        stopElasticsearch();\n+\n+        Platforms.onWindows(() -> sh.chown(installation.config(\"elasticsearch.keystore\")));\n+\n+        verifyKeystorePermissions();\n+\n+        final Installation.Executables bin = installation.executables();\n+        Shell.Result r = bin.keystoreTool.run(\"list\");\n+        assertThat(r.stdout, containsString(\"keystore.seed\"));\n+    }\n+\n+    public void test40KeystorePasswordOnStandardInput() throws Exception {\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        String password = \"^|<>\\\\&exit\"; // code insertion on Windows if special characters are not escaped\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        awaitElasticsearchStartup(startElasticsearchStandardInputPassword(password));\n+        ServerUtils.runElasticsearchTests();\n+        stopElasticsearch();\n+    }\n+\n+    public void test41WrongKeystorePasswordOnStandardInput() {\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        assertPasswordProtectedKeystore();\n+\n+        Shell.Result result = startElasticsearchStandardInputPassword(\"wrong\");\n+        assertElasticsearchFailure(result, PASSWORD_ERROR_MESSAGE);\n+    }\n+\n+    @Ignore /* Ignored for feature branch, awaits fix: https://github.com/elastic/elasticsearch/issues/49340 */\n+    public void test42KeystorePasswordOnTty() throws Exception {\n+        assumeTrue(\"expect command isn't on Windows\",\n+            distribution.platform != Distribution.Platform.WINDOWS);\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        String password = \"keystorepass\";\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        awaitElasticsearchStartup(startElasticsearchTtyPassword(password));\n+        ServerUtils.runElasticsearchTests();\n+        stopElasticsearch();\n+    }\n+\n+    @Ignore /* Ignored for feature branch, awaits fix: https://github.com/elastic/elasticsearch/issues/49340 */\n+    public void test43WrongKeystorePasswordOnTty() throws Exception {\n+        assumeTrue(\"expect command isn't on Windows\",\n+            distribution.platform != Distribution.Platform.WINDOWS);\n+        assumeTrue(\"packages will use systemd, which doesn't handle stdin\",\n+            distribution.isArchive());\n+        assumeThat(installation, is(notNullValue()));\n+\n+        assertPasswordProtectedKeystore();\n+\n+        Shell.Result result = startElasticsearchTtyPassword(\"wrong\");\n+        // error will be on stdout for \"expect\"\n+        assertThat(result.stdout, containsString(PASSWORD_ERROR_MESSAGE));\n+    }\n+\n+    public void test50KeystorePasswordFromFile() throws Exception {\n+        assumeTrue(\"only for systemd\", Platforms.isSystemd() && distribution().isPackage());\n+        String password = \"!@#$%^&*()|\\\\<>/?\";\n+        Path esKeystorePassphraseFile = installation.config.resolve(\"eks\");\n+\n+        rmKeystoreIfExists();\n+        createKeystore();\n+        setKeystorePassword(password);\n+\n+        assertPasswordProtectedKeystore();\n+\n+        try {\n+            sh.run(\"sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=\" + esKeystorePassphraseFile);\n+\n+            Files.createFile(esKeystorePassphraseFile);\n+            Files.write(esKeystorePassphraseFile,\n+                (password + System.lineSeparator()).getBytes(StandardCharsets.UTF_8),\n+                StandardOpenOption.WRITE);\n+\n+            startElasticsearch();\n+            ServerUtils.runElasticsearchTests();\n+            stopElasticsearch();\n+        } finally {\n+            sh.run(\"sudo systemctl unset-environment ES_KEYSTORE_PASSPHRASE_FILE\");\n+        }\n+    }\n+\n+    public void test51WrongKeystorePasswordFromFile() throws Exception {\n+        assumeTrue(\"only for systemd\", Platforms.isSystemd() && distribution().isPackage());\n+        Path esKeystorePassphraseFile = installation.config.resolve(\"eks\");\n+\n+        assertPasswordProtectedKeystore();\n+\n+        try {\n+            sh.run(\"sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=\" + esKeystorePassphraseFile);\n+\n+            if (Files.exists(esKeystorePassphraseFile)) {\n+                rm(esKeystorePassphraseFile);\n+            }\n+\n+            Files.createFile(esKeystorePassphraseFile);\n+            Files.write(esKeystorePassphraseFile,\n+                (\"wrongpassword\" + System.lineSeparator()).getBytes(StandardCharsets.UTF_8),\n+                StandardOpenOption.WRITE);\n+\n+            Shell.Result result = runElasticsearchStartCommand();\n+            assertElasticsearchFailure(result, PASSWORD_ERROR_MESSAGE);\n+        } finally {\n+            sh.run(\"sudo systemctl unset-environment ES_KEYSTORE_PASSPHRASE_FILE\");\n+        }\n+    }\n+\n+    /**\n+     * Check that we can mount a password-protected keystore to a docker image\n+     * and provide a password via an environment variable.\n+     */\n+    public void test60DockerEnvironmentVariablePassword() throws Exception {\n+        assumeTrue(distribution().isDocker());\n+        String password = \"password\";\n+        Path dockerKeystore = installation.config(\"elasticsearch.keystore\");\n+\n+        Path localKeystoreFile = getKeystoreFileFromDockerContainer(password, dockerKeystore);\n+\n+        // restart ES with password and mounted keystore\n+        Map<Path, Path> volumes = Map.of(localKeystoreFile, dockerKeystore);\n+        Map<String, String> envVars = Map.of(\"KEYSTORE_PASSWORD\", password);\n+        runContainer(distribution(), volumes, envVars);\n+        waitForElasticsearch(installation);\n+        ServerUtils.runElasticsearchTests();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0Mjk4Nw=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTMzMDc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cli/KeyStoreAwareCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMDoyNjowOFrOFfKWLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwODowMzowOFrOFgTNsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxOTY5Mg==", "bodyText": "Any particular reason we're not using '\\0' here, like we do in other places that we zero out an array?", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368219692", "createdAt": "2020-01-18T10:26:08Z", "author": {"login": "pugnascotia"}, "path": "server/src/main/java/org/elasticsearch/cli/KeyStoreAwareCommand.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cli;\n+\n+import joptsimple.OptionSet;\n+import org.elasticsearch.common.settings.KeyStoreWrapper;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.env.Environment;\n+\n+import javax.crypto.AEADBadTagException;\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import java.util.Arrays;\n+\n+/**\n+ * An {@link org.elasticsearch.cli.EnvironmentAwareCommand} that needs to access the elasticsearch keystore, possibly\n+ * decrypting it if it is password protected.\n+ */\n+public abstract class KeyStoreAwareCommand extends EnvironmentAwareCommand {\n+    public KeyStoreAwareCommand(String description) {\n+        super(description);\n+    }\n+\n+    /** Arbitrarily chosen maximum passphrase length */\n+    public static final int MAX_PASSPHRASE_LENGTH = 128;\n+\n+    /**\n+     * Reads the keystore password from the {@link Terminal}, prompting for verification where applicable and returns it as a\n+     * {@link SecureString}.\n+     *\n+     * @param terminal         the terminal to use for user inputs\n+     * @param withVerification whether the user should be prompted for password verification\n+     * @return a SecureString with the password the user entered\n+     * @throws UserException If the user is prompted for verification and enters a different password\n+     */\n+    protected static SecureString readPassword(Terminal terminal, boolean withVerification) throws UserException {\n+        final char[] passwordArray;\n+        if (withVerification) {\n+            passwordArray = terminal.readSecret(\"Enter new password for the elasticsearch keystore (empty for no password): \",\n+                MAX_PASSPHRASE_LENGTH);\n+            char[] passwordVerification = terminal.readSecret(\"Enter same password again: \",\n+                MAX_PASSPHRASE_LENGTH);\n+            if (Arrays.equals(passwordArray, passwordVerification) == false) {\n+                throw new UserException(ExitCodes.DATA_ERROR, \"Passwords are not equal, exiting.\");\n+            }\n+            Arrays.fill(passwordVerification, '\\u0000');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMzU1Mw==", "bodyText": "No reason, both are the null character denoted as a decimal or a hexadecimal. I think I have introduced all the \\u0000 instances as this is a convention I had been using", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369413553", "createdAt": "2020-01-22T08:03:08Z", "author": {"login": "jkakavas"}, "path": "server/src/main/java/org/elasticsearch/cli/KeyStoreAwareCommand.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cli;\n+\n+import joptsimple.OptionSet;\n+import org.elasticsearch.common.settings.KeyStoreWrapper;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.env.Environment;\n+\n+import javax.crypto.AEADBadTagException;\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import java.util.Arrays;\n+\n+/**\n+ * An {@link org.elasticsearch.cli.EnvironmentAwareCommand} that needs to access the elasticsearch keystore, possibly\n+ * decrypting it if it is password protected.\n+ */\n+public abstract class KeyStoreAwareCommand extends EnvironmentAwareCommand {\n+    public KeyStoreAwareCommand(String description) {\n+        super(description);\n+    }\n+\n+    /** Arbitrarily chosen maximum passphrase length */\n+    public static final int MAX_PASSPHRASE_LENGTH = 128;\n+\n+    /**\n+     * Reads the keystore password from the {@link Terminal}, prompting for verification where applicable and returns it as a\n+     * {@link SecureString}.\n+     *\n+     * @param terminal         the terminal to use for user inputs\n+     * @param withVerification whether the user should be prompted for password verification\n+     * @return a SecureString with the password the user entered\n+     * @throws UserException If the user is prompted for verification and enters a different password\n+     */\n+    protected static SecureString readPassword(Terminal terminal, boolean withVerification) throws UserException {\n+        final char[] passwordArray;\n+        if (withVerification) {\n+            passwordArray = terminal.readSecret(\"Enter new password for the elasticsearch keystore (empty for no password): \",\n+                MAX_PASSPHRASE_LENGTH);\n+            char[] passwordVerification = terminal.readSecret(\"Enter same password again: \",\n+                MAX_PASSPHRASE_LENGTH);\n+            if (Arrays.equals(passwordArray, passwordVerification) == false) {\n+                throw new UserException(ExitCodes.DATA_ERROR, \"Passwords are not equal, exiting.\");\n+            }\n+            Arrays.fill(passwordVerification, '\\u0000');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxOTY5Mg=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTMzNjMyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/action/admin/ReloadSecureSettingsIT.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxMDo0NTozMVrOFfKYxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxNTo1M1rOFgW3pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMDM1Nw==", "bodyText": "Tiny nit: you can use hasSize.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    assertThat(nodesMap.size(), equalTo(1));\n          \n          \n            \n                                    assertThat(nodesMap, hasSize(1));", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r368220357", "createdAt": "2020-01-18T10:45:31Z", "author": {"login": "pugnascotia"}, "path": "server/src/test/java/org/elasticsearch/action/admin/ReloadSecureSettingsIT.java", "diffHunk": "@@ -109,83 +115,213 @@ public void testInvalidKeystoreFile() throws Exception {\n             Files.copy(keystore, KeyStoreWrapper.keystorePath(environment.configFile()), StandardCopyOption.REPLACE_EXISTING);\n         }\n         final CountDownLatch latch = new CountDownLatch(1);\n-        client().admin().cluster().prepareReloadSecureSettings().execute(\n-                new ActionListener<NodesReloadSecureSettingsResponse>() {\n-                    @Override\n-                    public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n-                        try {\n-                            assertThat(nodesReloadResponse, notNullValue());\n-                            final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n-                            assertThat(nodesMap.size(), equalTo(cluster().size()));\n-                            for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n-                                assertThat(nodeResponse.reloadException(), notNullValue());\n-                            }\n-                        } catch (final AssertionError e) {\n-                            reloadSettingsError.set(e);\n-                        } finally {\n-                            latch.countDown();\n+        final SecureString emptyPassword = randomBoolean() ? new SecureString(new char[0]) : null;\n+        client().admin().cluster().prepareReloadSecureSettings().setSecureStorePassword(emptyPassword)\n+            .setNodesIds(Strings.EMPTY_ARRAY).execute(\n+            new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(cluster().size()));\n+                        for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n+                            assertThat(nodeResponse.reloadException(), notNullValue());\n                         }\n+                    } catch (final AssertionError e) {\n+                        reloadSettingsError.set(e);\n+                    } finally {\n+                        latch.countDown();\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request failed\", e));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        // in the invalid keystore format case no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadAllNodesWithPasswordWithoutTLSFails() throws Exception {\n+        final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class);\n+        final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class)\n+            .stream().findFirst().get();\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final int initialReloadCount = mockReloadablePlugin.getReloadCount();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            // No filter should try to hit all nodes\n+            .setNodesIds(Strings.EMPTY_ARRAY)\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request succeeded when it should have failed\", null));\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(ElasticsearchException.class));\n+                    assertThat(e.getMessage(),\n+                        containsString(\"Secure settings cannot be updated cluster wide when TLS for the transport layer is not enabled\"));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        //no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadLocalNodeWithPasswordWithoutTLSSucceeds() throws Exception {\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            .setNodesIds(\"_local\")\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NjI3Nw==", "bodyText": "Actually there is no hasSize for  Matcher<java.util.Map<? extends K,? extends V>>", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369466277", "createdAt": "2020-01-22T10:02:32Z", "author": {"login": "jkakavas"}, "path": "server/src/test/java/org/elasticsearch/action/admin/ReloadSecureSettingsIT.java", "diffHunk": "@@ -109,83 +115,213 @@ public void testInvalidKeystoreFile() throws Exception {\n             Files.copy(keystore, KeyStoreWrapper.keystorePath(environment.configFile()), StandardCopyOption.REPLACE_EXISTING);\n         }\n         final CountDownLatch latch = new CountDownLatch(1);\n-        client().admin().cluster().prepareReloadSecureSettings().execute(\n-                new ActionListener<NodesReloadSecureSettingsResponse>() {\n-                    @Override\n-                    public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n-                        try {\n-                            assertThat(nodesReloadResponse, notNullValue());\n-                            final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n-                            assertThat(nodesMap.size(), equalTo(cluster().size()));\n-                            for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n-                                assertThat(nodeResponse.reloadException(), notNullValue());\n-                            }\n-                        } catch (final AssertionError e) {\n-                            reloadSettingsError.set(e);\n-                        } finally {\n-                            latch.countDown();\n+        final SecureString emptyPassword = randomBoolean() ? new SecureString(new char[0]) : null;\n+        client().admin().cluster().prepareReloadSecureSettings().setSecureStorePassword(emptyPassword)\n+            .setNodesIds(Strings.EMPTY_ARRAY).execute(\n+            new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(cluster().size()));\n+                        for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n+                            assertThat(nodeResponse.reloadException(), notNullValue());\n                         }\n+                    } catch (final AssertionError e) {\n+                        reloadSettingsError.set(e);\n+                    } finally {\n+                        latch.countDown();\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request failed\", e));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        // in the invalid keystore format case no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadAllNodesWithPasswordWithoutTLSFails() throws Exception {\n+        final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class);\n+        final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class)\n+            .stream().findFirst().get();\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final int initialReloadCount = mockReloadablePlugin.getReloadCount();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            // No filter should try to hit all nodes\n+            .setNodesIds(Strings.EMPTY_ARRAY)\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request succeeded when it should have failed\", null));\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(ElasticsearchException.class));\n+                    assertThat(e.getMessage(),\n+                        containsString(\"Secure settings cannot be updated cluster wide when TLS for the transport layer is not enabled\"));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        //no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadLocalNodeWithPasswordWithoutTLSSucceeds() throws Exception {\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            .setNodesIds(\"_local\")\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMDM1Nw=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzQ0NQ==", "bodyText": "Ah, there's aMapWithSize(). Don't know if that's an improvement \ud83e\udd37\u200d\u2642", "url": "https://github.com/elastic/elasticsearch/pull/51123#discussion_r369473445", "createdAt": "2020-01-22T10:15:53Z", "author": {"login": "pugnascotia"}, "path": "server/src/test/java/org/elasticsearch/action/admin/ReloadSecureSettingsIT.java", "diffHunk": "@@ -109,83 +115,213 @@ public void testInvalidKeystoreFile() throws Exception {\n             Files.copy(keystore, KeyStoreWrapper.keystorePath(environment.configFile()), StandardCopyOption.REPLACE_EXISTING);\n         }\n         final CountDownLatch latch = new CountDownLatch(1);\n-        client().admin().cluster().prepareReloadSecureSettings().execute(\n-                new ActionListener<NodesReloadSecureSettingsResponse>() {\n-                    @Override\n-                    public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n-                        try {\n-                            assertThat(nodesReloadResponse, notNullValue());\n-                            final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n-                            assertThat(nodesMap.size(), equalTo(cluster().size()));\n-                            for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n-                                assertThat(nodeResponse.reloadException(), notNullValue());\n-                            }\n-                        } catch (final AssertionError e) {\n-                            reloadSettingsError.set(e);\n-                        } finally {\n-                            latch.countDown();\n+        final SecureString emptyPassword = randomBoolean() ? new SecureString(new char[0]) : null;\n+        client().admin().cluster().prepareReloadSecureSettings().setSecureStorePassword(emptyPassword)\n+            .setNodesIds(Strings.EMPTY_ARRAY).execute(\n+            new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(cluster().size()));\n+                        for (final NodesReloadSecureSettingsResponse.NodeResponse nodeResponse : nodesReloadResponse.getNodes()) {\n+                            assertThat(nodeResponse.reloadException(), notNullValue());\n                         }\n+                    } catch (final AssertionError e) {\n+                        reloadSettingsError.set(e);\n+                    } finally {\n+                        latch.countDown();\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request failed\", e));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        // in the invalid keystore format case no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadAllNodesWithPasswordWithoutTLSFails() throws Exception {\n+        final PluginsService pluginsService = internalCluster().getInstance(PluginsService.class);\n+        final MockReloadablePlugin mockReloadablePlugin = pluginsService.filterPlugins(MockReloadablePlugin.class)\n+            .stream().findFirst().get();\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final int initialReloadCount = mockReloadablePlugin.getReloadCount();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            // No filter should try to hit all nodes\n+            .setNodesIds(Strings.EMPTY_ARRAY)\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    reloadSettingsError.set(new AssertionError(\"Nodes request succeeded when it should have failed\", null));\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(ElasticsearchException.class));\n+                    assertThat(e.getMessage(),\n+                        containsString(\"Secure settings cannot be updated cluster wide when TLS for the transport layer is not enabled\"));\n+                    latch.countDown();\n+                }\n+            });\n+        latch.await();\n+        if (reloadSettingsError.get() != null) {\n+            throw reloadSettingsError.get();\n+        }\n+        //no reload should be triggered\n+        assertThat(mockReloadablePlugin.getReloadCount(), equalTo(initialReloadCount));\n+    }\n+\n+    public void testReloadLocalNodeWithPasswordWithoutTLSSucceeds() throws Exception {\n+        final Environment environment = internalCluster().getInstance(Environment.class);\n+        final AtomicReference<AssertionError> reloadSettingsError = new AtomicReference<>();\n+        final char[] password = randomAlphaOfLength(12).toCharArray();\n+        writeEmptyKeystore(environment, password);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        client().admin()\n+            .cluster()\n+            .prepareReloadSecureSettings()\n+            .setNodesIds(\"_local\")\n+            .setSecureStorePassword(new SecureString(password))\n+            .execute(new ActionListener<NodesReloadSecureSettingsResponse>() {\n+                @Override\n+                public void onResponse(NodesReloadSecureSettingsResponse nodesReloadResponse) {\n+                    try {\n+                        assertThat(nodesReloadResponse, notNullValue());\n+                        final Map<String, NodesReloadSecureSettingsResponse.NodeResponse> nodesMap = nodesReloadResponse.getNodesMap();\n+                        assertThat(nodesMap.size(), equalTo(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIyMDM1Nw=="}, "originalCommit": {"oid": "81458e78e18f2ac6ff6ded38e8b944ecf073eb57"}, "originalPosition": 212}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4499, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}