{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMDcxNjY1", "number": 51029, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoxNTozNVrODYJ7uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowODoyM1rODYk_gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjU1MTYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/SqlQueryRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoxNTozNVrOFd2aNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODo1MToxM1rOFfW8gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NDQ3MA==", "bodyText": "I think this formatting change is wrong?", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r366844470", "createdAt": "2020-01-15T12:15:35Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/SqlQueryRequest.java", "diffHunk": "@@ -61,8 +61,8 @@ public SqlQueryRequest() {\n     }\n \n     public SqlQueryRequest(String query, List<SqlTypedParamValue> params, QueryBuilder filter, ZoneId zoneId,\n-                           int fetchSize, TimeValue requestTimeout, TimeValue pageTimeout, Boolean columnar,\n-                           String cursor, RequestInfo requestInfo, boolean fieldMultiValueLeniency, boolean indexIncludeFrozen) {\n+            int fetchSize, TimeValue requestTimeout, TimeValue pageTimeout, Boolean columnar,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef9a553ff8c86eb3f005a29c768d5d7f43c50df"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyNjExNQ==", "bodyText": "I'll change it.", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r368426115", "createdAt": "2020-01-20T08:51:13Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/SqlQueryRequest.java", "diffHunk": "@@ -61,8 +61,8 @@ public SqlQueryRequest() {\n     }\n \n     public SqlQueryRequest(String query, List<SqlTypedParamValue> params, QueryBuilder filter, ZoneId zoneId,\n-                           int fetchSize, TimeValue requestTimeout, TimeValue pageTimeout, Boolean columnar,\n-                           String cursor, RequestInfo requestInfo, boolean fieldMultiValueLeniency, boolean indexIncludeFrozen) {\n+            int fetchSize, TimeValue requestTimeout, TimeValue pageTimeout, Boolean columnar,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NDQ3MA=="}, "originalCommit": {"oid": "2ef9a553ff8c86eb3f005a29c768d5d7f43c50df"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjU1NTI3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/sql-proto/src/main/java/org/elasticsearch/xpack/sql/proto/SqlTypedParamValue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoxNzowMFrOFd2cWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoxNzowMFrOFd2cWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NTAxNg==", "bodyText": "tokenLocation shouldn't be part of equals and hashCode?", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r366845016", "createdAt": "2020-01-15T12:17:00Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/sql-proto/src/main/java/org/elasticsearch/xpack/sql/proto/SqlTypedParamValue.java", "diffHunk": "@@ -65,12 +89,14 @@ public boolean equals(Object o) {\n             return false;\n         }\n         SqlTypedParamValue that = (SqlTypedParamValue) o;\n-        return Objects.equals(value, that.value) && Objects.equals(type, that.type);\n+        return Objects.equals(value, that.value)\n+                && Objects.equals(type, that.type)\n+                && Objects.equals(hasExplicitType, that.hasExplicitType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef9a553ff8c86eb3f005a29c768d5d7f43c50df"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjYwNDY4OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/endpoints/rest.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjozNjo1MlrOFd26HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjozNjo1MlrOFd26HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1MjYzNw==", "bodyText": "I would add a statement to mention that this is the recommended way of passing parameters to avoid hacking or SQL injection (which does not apply to us but nevertheless).", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r366852637", "createdAt": "2020-01-15T12:36:52Z", "author": {"login": "costin"}, "path": "docs/reference/sql/endpoints/rest.asciidoc", "diffHunk": "@@ -442,6 +443,34 @@ Which looks like:\n --------------------------------------------------\n // TESTRESPONSE[s/46ToAwFzQERYRjFaWEo1UVc1a1JtVjBZMmdCQUFBQUFBQUFBQUVXWjBaNlFXbzNOV0pVY21Wa1NUZDJhV2t3V2xwblp3PT3\\/\\/\\/\\/\\/DwQBZgZhdXRob3IBBHRleHQAAAFmBG5hbWUBBHRleHQAAAFmCnBhZ2VfY291bnQBBGxvbmcBAAFmDHJlbGVhc2VfZGF0ZQEIZGF0ZXRpbWUBAAEP/$body.cursor/]\n \n+[[sql-rest-params]]\n+=== Passing parameters to a query\n+\n+Using values in a query condition, for example, or in a `HAVING` statement can be done \"inline\",\n+by integrating the value in the query string itself:\n+\n+[source,console]\n+--------------------------------------------------\n+POST /_sql?format=txt\n+{\n+\t\"query\": \"SELECT YEAR(release_date) AS year FROM library WHERE page_count > 300 AND author = 'Frank Herbert' GROUP BY year HAVING COUNT(*) > 0\"\n+}\n+--------------------------------------------------\n+// TEST[setup:library]\n+\n+or it can be done by extracting the values in a separate list of parameters and using question mark placeholders (`?`) in the query string:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef9a553ff8c86eb3f005a29c768d5d7f43c50df"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDk3NTExOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowNToyM1rOFeg6nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODo1MDo0MlrOFfW7ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MDg5Mg==", "bodyText": "was the extra space intended?", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r367540892", "createdAt": "2020-01-16T17:05:23Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -75,11 +81,11 @@ public AbstractSqlQueryRequest(String query, List<SqlTypedParamValue> params, Qu\n         parser.declareString(AbstractSqlQueryRequest::query, QUERY);\n         parser.declareString((request, mode) -> request.mode(Mode.fromString(mode)), MODE);\n         parser.declareString((request, clientId) -> request.clientId(clientId), CLIENT_ID);\n-        parser.declareObjectArray(AbstractSqlQueryRequest::params, (p, c) -> SqlTypedParamValue.fromXContent(p), PARAMS);\n+        parser.declareField(AbstractSqlQueryRequest::params, p -> AbstractSqlQueryRequest.parseParams(p), PARAMS, ValueType.VALUE_ARRAY);\n         parser.declareString((request, zoneId) -> request.zoneId(ZoneId.of(zoneId)), TIME_ZONE);\n         parser.declareInt(AbstractSqlQueryRequest::fetchSize, FETCH_SIZE);\n         parser.declareString((request, timeout) -> request.requestTimeout(TimeValue.parseTimeValue(timeout, Protocol.REQUEST_TIMEOUT,\n-            \"request_timeout\")), REQUEST_TIMEOUT);\n+                \"request_timeout\")), REQUEST_TIMEOUT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyNTgyOQ==", "bodyText": "Yes, to have a uniform formatting for the field parsers' declaration. See here the initial formatting.", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r368425829", "createdAt": "2020-01-20T08:50:42Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -75,11 +81,11 @@ public AbstractSqlQueryRequest(String query, List<SqlTypedParamValue> params, Qu\n         parser.declareString(AbstractSqlQueryRequest::query, QUERY);\n         parser.declareString((request, mode) -> request.mode(Mode.fromString(mode)), MODE);\n         parser.declareString((request, clientId) -> request.clientId(clientId), CLIENT_ID);\n-        parser.declareObjectArray(AbstractSqlQueryRequest::params, (p, c) -> SqlTypedParamValue.fromXContent(p), PARAMS);\n+        parser.declareField(AbstractSqlQueryRequest::params, p -> AbstractSqlQueryRequest.parseParams(p), PARAMS, ValueType.VALUE_ARRAY);\n         parser.declareString((request, zoneId) -> request.zoneId(ZoneId.of(zoneId)), TIME_ZONE);\n         parser.declareInt(AbstractSqlQueryRequest::fetchSize, FETCH_SIZE);\n         parser.declareString((request, timeout) -> request.requestTimeout(TimeValue.parseTimeValue(timeout, Protocol.REQUEST_TIMEOUT,\n-            \"request_timeout\")), REQUEST_TIMEOUT);\n+                \"request_timeout\")), REQUEST_TIMEOUT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MDg5Mg=="}, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDk3NTcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowNTozM1rOFeg6-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODo1MzozOVrOFfXAew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MDk4Nw==", "bodyText": "Was wondering if this was meant as ... for the first param that doesn't meet ..., since an object could occur at any point in the array.", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r367540987", "createdAt": "2020-01-16T17:05:33Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -117,6 +123,86 @@ public AbstractSqlQueryRequest params(List<SqlTypedParamValue> params) {\n         this.params = params;\n         return this;\n     }\n+    \n+    private static List<SqlTypedParamValue> parseParams(XContentParser p) throws IOException {\n+        List<SqlTypedParamValue> result = new ArrayList<>();\n+        Token token = p.currentToken();\n+        \n+        if (token == Token.START_ARRAY) {\n+            Object value = null;\n+            String type = null;\n+            SqlTypedParamValue previousParam = null;\n+            \n+            while ((token = p.nextToken()) != Token.END_ARRAY) {\n+                XContentLocation loc = p.getTokenLocation();\n+                \n+                if (token == Token.START_OBJECT) {\n+                    // we are at the start of a value/type pair... hopefully\n+                    SqlTypedParamValue s = SqlTypedParamValue.fromXContent(p);\n+                    /*\n+                     * Set the xcontentlocation for the first param just in case the first one doesn't meet the parsing rules", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyNzEzMQ==", "bodyText": "I rephrased this section for, hopefully, better clarity.", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r368427131", "createdAt": "2020-01-20T08:53:39Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -117,6 +123,86 @@ public AbstractSqlQueryRequest params(List<SqlTypedParamValue> params) {\n         this.params = params;\n         return this;\n     }\n+    \n+    private static List<SqlTypedParamValue> parseParams(XContentParser p) throws IOException {\n+        List<SqlTypedParamValue> result = new ArrayList<>();\n+        Token token = p.currentToken();\n+        \n+        if (token == Token.START_ARRAY) {\n+            Object value = null;\n+            String type = null;\n+            SqlTypedParamValue previousParam = null;\n+            \n+            while ((token = p.nextToken()) != Token.END_ARRAY) {\n+                XContentLocation loc = p.getTokenLocation();\n+                \n+                if (token == Token.START_OBJECT) {\n+                    // we are at the start of a value/type pair... hopefully\n+                    SqlTypedParamValue s = SqlTypedParamValue.fromXContent(p);\n+                    /*\n+                     * Set the xcontentlocation for the first param just in case the first one doesn't meet the parsing rules", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MDk4Nw=="}, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDk3NTkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowNTozN1rOFeg7Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwODo1ODoyOVrOFfXIsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTAyNg==", "bodyText": "This code executes in both if/else branches, it might be worth considering taking it out.\nAnother nit: a switch with all the top enums (object, string, number, bool, null) might also arguably simplify the code.", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r367541026", "createdAt": "2020-01-16T17:05:37Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -117,6 +123,86 @@ public AbstractSqlQueryRequest params(List<SqlTypedParamValue> params) {\n         this.params = params;\n         return this;\n     }\n+    \n+    private static List<SqlTypedParamValue> parseParams(XContentParser p) throws IOException {\n+        List<SqlTypedParamValue> result = new ArrayList<>();\n+        Token token = p.currentToken();\n+        \n+        if (token == Token.START_ARRAY) {\n+            Object value = null;\n+            String type = null;\n+            SqlTypedParamValue previousParam = null;\n+            \n+            while ((token = p.nextToken()) != Token.END_ARRAY) {\n+                XContentLocation loc = p.getTokenLocation();\n+                \n+                if (token == Token.START_OBJECT) {\n+                    // we are at the start of a value/type pair... hopefully\n+                    SqlTypedParamValue s = SqlTypedParamValue.fromXContent(p);\n+                    /*\n+                     * Set the xcontentlocation for the first param just in case the first one doesn't meet the parsing rules\n+                     * that are checked later in validateParams method and, also, the xcontentlocation of the param that is \n+                     * different from the previous param in list when it comes to its type being explicitly set or inferred.\n+                     */\n+                    if ((previousParam != null && previousParam.hasExplicitType() == false) || result.isEmpty()) {\n+                        s.tokenLocation(loc);\n+                    }\n+                    result.add(s);\n+                    previousParam = s;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyOTIzMg==", "bodyText": "I've extracted the common code, but I kept the if/else approach. I find it a bit more clear than a switch.", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r368429232", "createdAt": "2020-01-20T08:58:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -117,6 +123,86 @@ public AbstractSqlQueryRequest params(List<SqlTypedParamValue> params) {\n         this.params = params;\n         return this;\n     }\n+    \n+    private static List<SqlTypedParamValue> parseParams(XContentParser p) throws IOException {\n+        List<SqlTypedParamValue> result = new ArrayList<>();\n+        Token token = p.currentToken();\n+        \n+        if (token == Token.START_ARRAY) {\n+            Object value = null;\n+            String type = null;\n+            SqlTypedParamValue previousParam = null;\n+            \n+            while ((token = p.nextToken()) != Token.END_ARRAY) {\n+                XContentLocation loc = p.getTokenLocation();\n+                \n+                if (token == Token.START_OBJECT) {\n+                    // we are at the start of a value/type pair... hopefully\n+                    SqlTypedParamValue s = SqlTypedParamValue.fromXContent(p);\n+                    /*\n+                     * Set the xcontentlocation for the first param just in case the first one doesn't meet the parsing rules\n+                     * that are checked later in validateParams method and, also, the xcontentlocation of the param that is \n+                     * different from the previous param in list when it comes to its type being explicitly set or inferred.\n+                     */\n+                    if ((previousParam != null && previousParam.hasExplicitType() == false) || result.isEmpty()) {\n+                        s.tokenLocation(loc);\n+                    }\n+                    result.add(s);\n+                    previousParam = s;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTAyNg=="}, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDk4NDk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowODoyM1rOFehA2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwOTowMTozOFrOFfXONg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MjQ4OA==", "bodyText": "Could the second arg also be a method reference?", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r367542488", "createdAt": "2020-01-16T17:08:23Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -75,11 +81,11 @@ public AbstractSqlQueryRequest(String query, List<SqlTypedParamValue> params, Qu\n         parser.declareString(AbstractSqlQueryRequest::query, QUERY);\n         parser.declareString((request, mode) -> request.mode(Mode.fromString(mode)), MODE);\n         parser.declareString((request, clientId) -> request.clientId(clientId), CLIENT_ID);\n-        parser.declareObjectArray(AbstractSqlQueryRequest::params, (p, c) -> SqlTypedParamValue.fromXContent(p), PARAMS);\n+        parser.declareField(AbstractSqlQueryRequest::params, p -> AbstractSqlQueryRequest.parseParams(p), PARAMS, ValueType.VALUE_ARRAY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQzMDY0Ng==", "bodyText": "Indeed", "url": "https://github.com/elastic/elasticsearch/pull/51029#discussion_r368430646", "createdAt": "2020-01-20T09:01:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-action/src/main/java/org/elasticsearch/xpack/sql/action/AbstractSqlQueryRequest.java", "diffHunk": "@@ -75,11 +81,11 @@ public AbstractSqlQueryRequest(String query, List<SqlTypedParamValue> params, Qu\n         parser.declareString(AbstractSqlQueryRequest::query, QUERY);\n         parser.declareString((request, mode) -> request.mode(Mode.fromString(mode)), MODE);\n         parser.declareString((request, clientId) -> request.clientId(clientId), CLIENT_ID);\n-        parser.declareObjectArray(AbstractSqlQueryRequest::params, (p, c) -> SqlTypedParamValue.fromXContent(p), PARAMS);\n+        parser.declareField(AbstractSqlQueryRequest::params, p -> AbstractSqlQueryRequest.parseParams(p), PARAMS, ValueType.VALUE_ARRAY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MjQ4OA=="}, "originalCommit": {"oid": "08b74d0b33e50efd4ac01528e95b955d8277e23d"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4597, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}