{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MTAyNjE1", "number": 51244, "title": "Preserve ApiKey credentials for async verification", "bodyText": "The ApiKeyService would aggressively \"close\" ApiKeyCredentials objects\nduring processing. However, under rare circumstances, the verfication\nof the secret key would be performed asychronously and may need access\nto the SecureString after it had been closed by the caller.\nThe trigger for this would be if the cache already held a Future for\nthat ApiKey, but the future was not yet complete. In this case the\nverification of the secret key would take place asynchronously on the\ngeneric thread pool.\nThis commit moves the \"close\" of the credentials to the body of the\nlistener so that it only occurs after key verification is complete.", "createdAt": "2020-01-21T05:32:43Z", "url": "https://github.com/elastic/elasticsearch/pull/51244", "merged": true, "mergeCommit": {"oid": "f68f5130642fd31da49859beab55a0d42801170f"}, "closed": true, "closedAt": "2020-01-24T05:50:55Z", "author": {"login": "tvernum"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8aPA7gH2gAyMzY1MTAyNjE1OjQ1OTYzZTIwMDMzZGNiNzE2MjBlNmI5OTFjYTE1YWM4OTlmNzg5NGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9Xo6mgH2gAyMzY1MTAyNjE1OmEzMDNiZDRiOWM5ZmM0MGFiYzU5MWNlZjdkYzM1MzNmYWRiYzdkNjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/45963e20033dcb71620e6b991ca15ac899f7894f", "committedDate": "2020-01-21T05:24:19Z", "message": "Preserve ApiKey credentials for async verification\n\nThe ApiKeyService would aggressively \"close\" ApiKeyCredentials objects\nduring processing. However, under rare circumstances, the verfication\nof the secret key would be performed asychronously and may need access\nto the SecureString after it had been closed by the caller.\n\nThe trigger for this would be if the cache already held a Future for\nthat ApiKey, but the future was not yet complete. In this case the\nverification of the secret key would take place asynchronously on the\ngeneric thread pool.\n\nThis commit moves the \"close\" of the credentials to the body of the\nlistener so that it only occurs after key verification is complete."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjQzOTY2", "url": "https://github.com/elastic/elasticsearch/pull/51244#pullrequestreview-345643966", "createdAt": "2020-01-21T05:41:14Z", "commit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNTo0MToxNFrOFfu8Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNTo0MToxNFrOFfu8Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxOTIxMA==", "bodyText": "Without the fix to not close the credentials, this line would fail with:\n\nSecureString has already been closed", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368819210", "createdAt": "2020-01-21T05:41:14Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Nzc4MjMw", "url": "https://github.com/elastic/elasticsearch/pull/51244#pullrequestreview-345778230", "createdAt": "2020-01-21T10:36:41Z", "commit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDozNjo0MVrOFf1XQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxMDozNjo0MVrOFf1XQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyNDQ4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Call the top level method because it has been know to be buggy in async situations\n          \n          \n            \n                    // Call the top level method because it has been known to be buggy in async situations", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368924480", "createdAt": "2020-01-21T10:36:41Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0858ef206455d32aa58d6a2d76e53f190a808433", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/0858ef206455d32aa58d6a2d76e53f190a808433", "committedDate": "2020-01-23T05:21:59Z", "message": "Merge branch 'master' into fix/api-key-sync-close"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b585ab8a1abfeebd85647f73fd506cb0e820fbb9", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/b585ab8a1abfeebd85647f73fd506cb0e820fbb9", "committedDate": "2020-01-23T05:22:47Z", "message": "Fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4100f2c58627b584fbe291fbbe12be814d85ebea", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/4100f2c58627b584fbe291fbbe12be814d85ebea", "committedDate": "2020-01-23T10:24:22Z", "message": "Merge branch 'master' into fix/api-key-sync-close"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Njg1MzEx", "url": "https://github.com/elastic/elasticsearch/pull/51244#pullrequestreview-345685311", "createdAt": "2020-01-21T07:55:15Z", "commit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzo1NToxNVrOFfw9Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODowOTo0MFrOFfxPtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1MjMxNA==", "bodyText": "A minor comment: Is it worthwhile to wrap the ActionListeners earlier on so that we don't have to call credentials.close() in multiple places. That is once we know credentials is not null, we can have:\nvar credentialsClosingListener = ActionListener.wrap(...);\nThen just use the new listener in subsequent code. At this point, it may be worthwhile to extract this part of code into a new method.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368852314", "createdAt": "2020-01-21T07:55:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java", "diffHunk": "@@ -301,10 +301,15 @@ void authenticateWithApiKeyIfPresent(ThreadContext ctx, ActionListener<Authentic\n                         .request();\n                 executeAsyncWithOrigin(ctx, SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {\n                     if (response.isExists()) {\n-                        try (ApiKeyCredentials ignore = credentials) {\n-                            final Map<String, Object> source = response.getSource();\n-                            validateApiKeyCredentials(docId, source, credentials, clock, listener);\n-                        }\n+                        final Map<String, Object> source = response.getSource();\n+                        validateApiKeyCredentials(docId, source, credentials, clock, ActionListener.wrap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NjM5NA==", "bodyText": "Mainly curious: it really takes 2 seconds for the notify to work?", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368856394", "createdAt": "2020-01-21T08:07:46Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();\n+        final AtomicInteger hashCounter = new AtomicInteger(0);\n+        doAnswer(invocationOnMock -> {\n+            hashCounter.incrementAndGet();\n+            synchronized (hashWait) {\n+                hashWait.wait();\n+            }\n+            return invocationOnMock.callRealMethod();\n+        }).when(service).verifyKeyAgainstHash(any(String.class), any(ApiKeyCredentials.class));\n+\n+        final ApiKeyCredentials creds = new ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        final PlainActionFuture<AuthenticationResult> future1 = new PlainActionFuture<>();\n+\n+        // Call the top level method because it has been know to be buggy in async situations\n+        writeCredentialsToThreadContext(creds);\n+        mockSourceDocument(creds.getId(), sourceMap);\n+\n+        // This needs to be done in another thread, because we need it to not complete until we say so, but it should not block this test\n+        this.threadPool.generic().execute(() -> service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future1));\n+\n+        // Wait for the first credential validation to get to the blocked state\n+        assertBusy(() -> assertThat(hashCounter.get(), equalTo(1)));\n+        if (future1.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future1.actionGet());\n+        }\n+\n+        // The second authentication should pass (but not immediately, but will not block)\n+        PlainActionFuture<AuthenticationResult> future2 = new PlainActionFuture<>();\n+\n+        service.authenticateWithApiKeyIfPresent(threadPool.getThreadContext(), future2);\n+\n+        assertThat(hashCounter.get(), equalTo(1));\n+        if (future2.isDone()) {\n+            // We do this [ rather than assertFalse(isDone) ] so we can get a reasonable failure message\n+            fail(\"Expected authentication to be blocked, but was \" + future2.actionGet());\n+        }\n+\n+        synchronized (hashWait) {\n+            hashWait.notify();\n+        }\n+\n+        assertThat(future1.actionGet(TimeValue.timeValueSeconds(2)).isAuthenticated(), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NzAxMw==", "bodyText": "Trivial: Could probably replace this with a CompletableFuture object? If so, could save a couple of lines.", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r368857013", "createdAt": "2020-01-21T08:09:40Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java", "diffHunk": "@@ -488,6 +482,66 @@ public void testApiKeyCache() {\n         assertThat(service.getFromCache(creds.getId()).success, is(true));\n     }\n \n+    public void testAuthenticateWhileCacheBeingPopulated() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = buildApiKeySourceDoc(hash);\n+\n+        ApiKeyService realService = createApiKeyService(Settings.EMPTY);\n+        ApiKeyService service  = Mockito.spy(realService);\n+\n+        final Object hashWait = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963e20033dcb71620e6b991ca15ac899f7894f"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbf164a5c9bd52ed0f85db0cc9e77aafc4129a6c", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/dbf164a5c9bd52ed0f85db0cc9e77aafc4129a6c", "committedDate": "2020-01-24T03:54:14Z", "message": "Address feedback\n\n- Wrap the listener in 1 place\n- Use a semaphore instead of Object.wait"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfe8e763f7d7d7a99c296c6aca875a9b15074831", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/cfe8e763f7d7d7a99c296c6aca875a9b15074831", "committedDate": "2020-01-24T03:55:09Z", "message": "Merge branch 'master' into fix/api-key-sync-close"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b59c67ac4d042e70f0b642df5d631b363b4b5b37", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/b59c67ac4d042e70f0b642df5d631b363b4b5b37", "committedDate": "2020-01-24T04:07:43Z", "message": "Fix import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NzUwOTkx", "url": "https://github.com/elastic/elasticsearch/pull/51244#pullrequestreview-347750991", "createdAt": "2020-01-24T04:56:31Z", "commit": {"oid": "b59c67ac4d042e70f0b642df5d631b363b4b5b37"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDo1NjozMVrOFhT7XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDo1NjozMVrOFhT7XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3MzgyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public  HttpProxy(String host, Integer port, Scheme scheme) {\n          \n          \n            \n                public HttpProxy(String host, Integer port, Scheme scheme) {", "url": "https://github.com/elastic/elasticsearch/pull/51244#discussion_r370473820", "createdAt": "2020-01-24T04:56:31Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpProxy.java", "diffHunk": "@@ -32,7 +32,7 @@ public HttpProxy(String host, Integer port) {\n         this.port = port;\n     }\n \n-    public HttpProxy(String host, Integer port, Scheme scheme) {\n+    public  HttpProxy(String host, Integer port, Scheme scheme) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b59c67ac4d042e70f0b642df5d631b363b4b5b37"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a303bd4b9c9fc40abc591cef7dc3533fadbc7d63", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/a303bd4b9c9fc40abc591cef7dc3533fadbc7d63", "committedDate": "2020-01-24T04:56:49Z", "message": "Update x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpProxy.java"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2774, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}