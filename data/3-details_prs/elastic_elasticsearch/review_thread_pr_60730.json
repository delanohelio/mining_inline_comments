{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMzE0NjI2", "number": 60730, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxNjo0N1rOEVXpQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTozNToyMlrOEVX_Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODQyOTQ3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/lease/Releasables.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxNjo0N1rOG8FRlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxNjo0N1rOG8FRlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY1NDE2NQ==", "bodyText": "Same optimization already added to IOUtils for a single Releasable since we now use that heavily in closing the releasable stream.", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465654165", "createdAt": "2020-08-05T11:16:47Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/common/lease/Releasables.java", "diffHunk": "@@ -46,6 +47,15 @@ public static void close(Iterable<? extends Releasable> releasables) {\n         close(releasables, false);\n     }\n \n+    /** Release the provided {@link Releasable}. */\n+    public static void close(@Nullable Releasable releasable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODQzNDkwOnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxODo0M1rOG8FU3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxODo0M1rOG8FU3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY1NTAwNA==", "bodyText": "This was really inefficient before. The cache key would usually be ~100b but be written with buffers of sizes 8, 56 and then 1xx, then copied again below.", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465655004", "createdAt": "2020-08-05T11:18:43Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -342,15 +341,20 @@ public void canReturnNullResponseIfMatchNoDocs(boolean value) {\n         this.canReturnNullResponseIfMatchNoDocs = value;\n     }\n \n+    private static final ThreadLocal<BytesStreamOutput> scratch = ThreadLocal.withInitial(BytesStreamOutput::new);\n+\n     /**\n      * Returns the cache key for this shard search request, based on its content\n      */\n     public BytesReference cacheKey() throws IOException {\n-        BytesStreamOutput out = new BytesStreamOutput();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODQzNjI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/TcpHeader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxOToxMFrOG8FVrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToxOToxMFrOG8FVrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY1NTIxNQ==", "bodyText": "Obviously somewhat trivial but why not save some bounds checks.", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465655215", "createdAt": "2020-08-05T11:19:10Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/transport/TcpHeader.java", "diffHunk": "@@ -60,10 +60,11 @@ public static int headerSize(Version version) {\n         }\n     }\n \n+    private static final byte[] PREFIX = {(byte) 'E', (byte) 'S'};\n+\n     public static void writeHeader(StreamOutput output, long requestId, byte status, Version version, int contentSize,\n                                    int variableHeaderSize) throws IOException {\n-        output.writeByte((byte)'E');\n-        output.writeByte((byte)'S');\n+        output.writeBytes(PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODQ1ODA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToyNjoyOVrOG8FjGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToyNjoyOVrOG8FjGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY1ODY1MQ==", "bodyText": "Tiny nit - this could be declared inside the try.", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465658651", "createdAt": "2020-08-05T11:26:29Z", "author": {"login": "pugnascotia"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java", "diffHunk": "@@ -143,6 +150,27 @@ public BytesReference bytes() {\n         return new PagedBytesReference(bytes, count);\n     }\n \n+    /**\n+     * Like {@link #bytes()} but copies the bytes to a freshly allocated buffer.\n+     *\n+     * @return copy of the bytes in this instances\n+     */\n+    public BytesReference copyBytes() {\n+        final byte[] keyBytes = new byte[count];\n+        int offset = 0;\n+        final BytesRefIterator iterator = bytes().iterator();\n+        BytesRef slice;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODQ2Njg3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMToyOToyNFrOG8FoaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTozMDo0M1rOG8FrDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2MDAwOA==", "bodyText": "Is this comment supposed to be here?", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465660008", "createdAt": "2020-08-05T11:29:24Z", "author": {"login": "pugnascotia"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java", "diffHunk": "@@ -143,6 +150,27 @@ public BytesReference bytes() {\n         return new PagedBytesReference(bytes, count);\n     }\n \n+    /**\n+     * Like {@link #bytes()} but copies the bytes to a freshly allocated buffer.\n+     *\n+     * @return copy of the bytes in this instances\n+     */\n+    public BytesReference copyBytes() {\n+        final byte[] keyBytes = new byte[count];\n+        int offset = 0;\n+        final BytesRefIterator iterator = bytes().iterator();\n+        BytesRef slice;\n+        try {\n+            while ((slice = iterator.next()) != null) {\n+                System.arraycopy(slice.bytes, slice.offset, keyBytes, offset, slice.length);\n+                offset += slice.length;\n+            }\n+        } catch (IOException e) {\n+            throw new AssertionError(e);\n+        }\n+        return new BytesArray(keyBytes);// do a deep copy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2MDY4NQ==", "bodyText": "no :)", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465660685", "createdAt": "2020-08-05T11:30:43Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java", "diffHunk": "@@ -143,6 +150,27 @@ public BytesReference bytes() {\n         return new PagedBytesReference(bytes, count);\n     }\n \n+    /**\n+     * Like {@link #bytes()} but copies the bytes to a freshly allocated buffer.\n+     *\n+     * @return copy of the bytes in this instances\n+     */\n+    public BytesReference copyBytes() {\n+        final byte[] keyBytes = new byte[count];\n+        int offset = 0;\n+        final BytesRefIterator iterator = bytes().iterator();\n+        BytesRef slice;\n+        try {\n+            while ((slice = iterator.next()) != null) {\n+                System.arraycopy(slice.bytes, slice.offset, keyBytes, offset, slice.length);\n+                offset += slice.length;\n+            }\n+        } catch (IOException e) {\n+            throw new AssertionError(e);\n+        }\n+        return new BytesArray(keyBytes);// do a deep copy", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2MDAwOA=="}, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODQ4NTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/transport/TransportKeepAlive.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMTozNToyMlrOG8Fz7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozODo0NlrOG8Hybw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2Mjk1OA==", "bodyText": "What is the purpose of this block? Is it just to generate a BytesReference containing \"ES\"? If so, could we not just do:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final BytesReference PING_MESSAGE;\n          \n          \n            \n            \n          \n          \n            \n                static {\n          \n          \n            \n                    try (BytesStreamOutput out = new BytesStreamOutput()) {\n          \n          \n            \n                        out.writeByte((byte) 'E');\n          \n          \n            \n                        out.writeByte((byte) 'S');\n          \n          \n            \n                        out.writeInt(PING_DATA_SIZE);\n          \n          \n            \n                        PING_MESSAGE = out.copyBytes();\n          \n          \n            \n                    } catch (IOException e) {\n          \n          \n            \n                        throw new AssertionError(e.getMessage(), e); // won't happen\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private static final BytesReference PING_MESSAGE = new BytesArray(\"ES\");", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465662958", "createdAt": "2020-08-05T11:35:22Z", "author": {"login": "pugnascotia"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportKeepAlive.java", "diffHunk": "@@ -48,28 +48,31 @@\n \n     static final int PING_DATA_SIZE = -1;\n \n+    private static final BytesReference PING_MESSAGE;\n+\n+    static {\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            out.writeByte((byte) 'E');\n+            out.writeByte((byte) 'S');\n+            out.writeInt(PING_DATA_SIZE);\n+            PING_MESSAGE = out.copyBytes();\n+        } catch (IOException e) {\n+            throw new AssertionError(e.getMessage(), e); // won't happen\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2MzczNw==", "bodyText": "We also have the int PING_DATA_SIZE, but yea the only purpose of the block is setting up the message but I don't think we have a nicer way of building it right at this point.", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465663737", "createdAt": "2020-08-05T11:37:05Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportKeepAlive.java", "diffHunk": "@@ -48,28 +48,31 @@\n \n     static final int PING_DATA_SIZE = -1;\n \n+    private static final BytesReference PING_MESSAGE;\n+\n+    static {\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            out.writeByte((byte) 'E');\n+            out.writeByte((byte) 'S');\n+            out.writeInt(PING_DATA_SIZE);\n+            PING_MESSAGE = out.copyBytes();\n+        } catch (IOException e) {\n+            throw new AssertionError(e.getMessage(), e); // won't happen\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2Mjk1OA=="}, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5NTM0Mw==", "bodyText": "Oh, I missed the part where it writes the size as well.", "url": "https://github.com/elastic/elasticsearch/pull/60730#discussion_r465695343", "createdAt": "2020-08-05T12:38:46Z", "author": {"login": "pugnascotia"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportKeepAlive.java", "diffHunk": "@@ -48,28 +48,31 @@\n \n     static final int PING_DATA_SIZE = -1;\n \n+    private static final BytesReference PING_MESSAGE;\n+\n+    static {\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            out.writeByte((byte) 'E');\n+            out.writeByte((byte) 'S');\n+            out.writeInt(PING_DATA_SIZE);\n+            PING_MESSAGE = out.copyBytes();\n+        } catch (IOException e) {\n+            throw new AssertionError(e.getMessage(), e); // won't happen\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2Mjk1OA=="}, "originalCommit": {"oid": "c237272e321c933e1a1382949196f60fc32a76ea"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2562, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}