{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MjMwMTIx", "number": 62282, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjowMzo0MVrOEjF4wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxMjo1OFrOEjGGBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjMyMDY0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjowMzo0MVrOHRQhGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo1NToxMVrOHRVd-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1ODQ1Ng==", "bodyText": "The existing code seems to accept that addTimeoutListener is called multiple times for the same listener. It is not entirely clear to me that this cannot happen? If it does, a previous notifyTImeout will now go lost and not be cancelled.\nWe should at least add an assert here to verify, but maybe you can also do a bit of checking of whether there are legitimate cases where this could happen?", "url": "https://github.com/elastic/elasticsearch/pull/62282#discussion_r487858456", "createdAt": "2020-09-14T12:03:41Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java", "diffHunk": "@@ -291,12 +274,11 @@ public void addTimeoutListener(@Nullable final TimeValue timeout, final TimeoutC\n             threadPoolExecutor.execute(new SourcePrioritizedRunnable(Priority.HIGH, \"_add_listener_\") {\n                 @Override\n                 public void run() {\n+                    final NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                     if (timeout != null) {\n-                        NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                         notifyTimeout.cancellable = threadPool.schedule(notifyTimeout, timeout, ThreadPool.Names.GENERIC);\n-                        onGoingTimeouts.add(notifyTimeout);\n                     }\n-                    timeoutClusterStateListeners.add(listener);\n+                    timeoutClusterStateListeners.put(listener, notifyTimeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60361a50229c1a200103effb437d95b40394c26c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzOTU3OQ==", "bodyText": "I think tit's impossible for this to happen. Only ClusterStateObserver uses this method and it's using this code to make sure we only add a listener for it once:\n            final ObservingContext context = new ObservingContext(listener, statePredicate);\n            if (!observingContext.compareAndSet(null, context)) {\n                throw new ElasticsearchException(\"already waiting for a cluster state change\");\n            }\n            clusterApplierService.addTimeoutListener(timeoutTimeLeftMS == null ?\n                null : new TimeValue(timeoutTimeLeftMS), clusterStateListener);\n-> I'm adding an assertion, I think that should be fine.", "url": "https://github.com/elastic/elasticsearch/pull/62282#discussion_r487939579", "createdAt": "2020-09-14T13:55:11Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java", "diffHunk": "@@ -291,12 +274,11 @@ public void addTimeoutListener(@Nullable final TimeValue timeout, final TimeoutC\n             threadPoolExecutor.execute(new SourcePrioritizedRunnable(Priority.HIGH, \"_add_listener_\") {\n                 @Override\n                 public void run() {\n+                    final NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                     if (timeout != null) {\n-                        NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                         notifyTimeout.cancellable = threadPool.schedule(notifyTimeout, timeout, ThreadPool.Names.GENERIC);\n-                        onGoingTimeouts.add(notifyTimeout);\n                     }\n-                    timeoutClusterStateListeners.add(listener);\n+                    timeoutClusterStateListeners.put(listener, notifyTimeout);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1ODQ1Ng=="}, "originalCommit": {"oid": "60361a50229c1a200103effb437d95b40394c26c"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjM1NDYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoxMjo1OFrOHRQ1AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzo1NTo0MlrOHRVgOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2MzU1Mw==", "bodyText": "Is there not a race here in that the scheduled task could run before adding the listener to the map below and the scheduled task could have called removeTimeoutListener before it is put into the map?\nI recognize this preserves existing behavior, but if you agree I think it is worth fixing in this PR.", "url": "https://github.com/elastic/elasticsearch/pull/62282#discussion_r487863553", "createdAt": "2020-09-14T12:12:58Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java", "diffHunk": "@@ -291,12 +274,11 @@ public void addTimeoutListener(@Nullable final TimeValue timeout, final TimeoutC\n             threadPoolExecutor.execute(new SourcePrioritizedRunnable(Priority.HIGH, \"_add_listener_\") {\n                 @Override\n                 public void run() {\n+                    final NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                     if (timeout != null) {\n-                        NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                         notifyTimeout.cancellable = threadPool.schedule(notifyTimeout, timeout, ThreadPool.Names.GENERIC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60361a50229c1a200103effb437d95b40394c26c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDE1NA==", "bodyText": "Yea it's a trivial fix I think, I'll clean it up here.", "url": "https://github.com/elastic/elasticsearch/pull/62282#discussion_r487940154", "createdAt": "2020-09-14T13:55:42Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java", "diffHunk": "@@ -291,12 +274,11 @@ public void addTimeoutListener(@Nullable final TimeValue timeout, final TimeoutC\n             threadPoolExecutor.execute(new SourcePrioritizedRunnable(Priority.HIGH, \"_add_listener_\") {\n                 @Override\n                 public void run() {\n+                    final NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                     if (timeout != null) {\n-                        NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout);\n                         notifyTimeout.cancellable = threadPool.schedule(notifyTimeout, timeout, ThreadPool.Names.GENERIC);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2MzU1Mw=="}, "originalCommit": {"oid": "60361a50229c1a200103effb437d95b40394c26c"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1521, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}