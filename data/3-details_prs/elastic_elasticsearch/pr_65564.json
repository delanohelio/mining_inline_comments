{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MjE2NzA3", "number": 65564, "title": "Record timestamp field range in index metadata", "bodyText": "Queries including a filter by timestamp range are common in time-series\ndata. Moreover older time-series indices are typically made read-only so\nthat the timestamp range becomes immutable. By recording in the index\nmetadata the range of timestamps covered by each index we can very\nefficiently skip shards on the coordinating node, even if those shards\nare not assigned.\nThis commit computes the timestamp range of immutable indices and\nrecords it in the index metadata as the shards start for the first time.\nNote that the only indices it considers immutable today are ones using\nthe ReadOnlyEngine, which includes frozen indices and searchable\nsnapshots but not regular indices with a write block.", "createdAt": "2020-11-26T18:04:17Z", "url": "https://github.com/elastic/elasticsearch/pull/65564", "merged": true, "mergeCommit": {"oid": "b902d807039d3adc3ae16f14af931d9748b0e92f"}, "closed": true, "closedAt": "2020-12-01T15:41:49Z", "author": {"login": "DaveCTurner"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgW4rjAH2gAyNTI4MjE2NzA3OjFmMWQ1ZjdmOGY4NjdlMDM4ODJjOTY0MGY5NWViMTcyNTA2MzgzMTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh6I8eAH2gAyNTI4MjE2NzA3Ojk2MmNhZTE4ZTAxNDI3NTk5OTliMWU1NmM2MmI0OGUyM2U0MjQ3YzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/1f1d5f7f8f867e03882c9640f95eb17250638315", "committedDate": "2020-11-26T18:02:38Z", "message": "Record timestamp field range in index metadata\n\nQueries including a filter by timestamp range are common in time-series\ndata. Moreover older time-series indices are typically made read-only so\nthat the timestamp range becomes immutable. By recording in the index\nmetadata the range of timestamps covered by each index we can very\nefficiently skip shards on the coordinating node, even if those shards\nare not assigned.\n\nThis commit computes the timestamp range of immutable indices and\nrecords it in the index metadata as the shards start for the first time.\nNote that the only indices it considers immutable today are ones using\nthe `ReadOnlyEngine`, which includes frozen indices and searchable\nsnapshots but not regular indices with a write block."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNjc2NDc4", "url": "https://github.com/elastic/elasticsearch/pull/65564#pullrequestreview-540676478", "createdAt": "2020-11-30T08:16:00Z", "commit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwODoxNjowMVrOH7v2Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwOToxMzoyOVrOH7x0Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxMTk4Ng==", "bodyText": "Is there a reason we do not return MUTABLE here instead?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532411986", "createdAt": "2020-11-30T08:16:01Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -1713,6 +1716,46 @@ public RecoveryState recoveryState() {\n         return this.recoveryState;\n     }\n \n+    @Override\n+    public ShardLongFieldRange getTimestampMillisRange() {\n+        assert isReadAllowed();\n+\n+        if (mapperService() == null) {\n+            return ShardLongFieldRange.MUTABLE; // no mapper service, no idea if the field even exists\n+        }\n+        final MappedFieldType mappedFieldType = mapperService().fieldType(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD);\n+        final boolean hasMappedTimestampField = mappedFieldType instanceof DateFieldMapper.DateFieldType;\n+\n+        final Engine engine = getEngine();\n+        final ShardLongFieldRange rawTimestampFieldRange;\n+        try {\n+            rawTimestampFieldRange = engine.getRawFieldRange(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, hasMappedTimestampField);\n+        } catch (IOException e) {\n+            logger.debug(\"exception obtaining range for timestamp field\", e);\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.MUTABLE) {\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.EMPTY) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+\n+        if (hasMappedTimestampField == false) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+        final DateFieldMapper.DateFieldType dateFieldType = (DateFieldMapper.DateFieldType) mappedFieldType;\n+\n+        try {\n+            return ShardLongFieldRange.of(\n+                    dateFieldType.resolution().roundDownToMillis(rawTimestampFieldRange.getMin()),\n+                    dateFieldType.resolution().roundUpToMillis(rawTimestampFieldRange.getMax()));\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(new ParameterizedMessage(\"could not convert {} to a millisecond time range\", rawTimestampFieldRange), e);\n+            return ShardLongFieldRange.of(Long.MIN_VALUE, Long.MAX_VALUE); // any search might match this shard", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxNDM1NA==", "bodyText": "Can we also add following?\nassert shards != null || this == MUTABLE;", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532414354", "createdAt": "2020-11-30T08:20:40Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);\n+\n+    @Nullable // if this range includes all shards\n+    private final int[] shards;\n+    private final long min, max;\n+\n+    private IndexLongFieldRange(int[] shards, long min, long max) {\n+        assert (min == Long.MAX_VALUE && max == Long.MIN_VALUE) || min <= max : min + \" vs \" + max;\n+        assert shards == null || shards.length > 0 || (min == Long.MAX_VALUE && max == Long.MIN_VALUE);\n+        assert shards == null || Arrays.equals(shards, Arrays.stream(shards).sorted().distinct().toArray()) : Arrays.toString(shards);\n+        this.shards = shards;\n+        this.min = min;\n+        this.max = max;\n+    }\n+\n+    /**\n+     * @return whether this range includes information from all shards yet.\n+     */\n+    public boolean isComplete() {\n+        return shards == null;\n+    }\n+\n+    // exposed for testing\n+    int[] getShards() {\n+        return shards;\n+    }\n+\n+    // exposed for testing\n+    long getMinUnsafe() {\n+        return min;\n+    }\n+\n+    // exposed for testing\n+    long getMaxUnsafe() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) minimum of this range.\n+     */\n+    public long getMin() {\n+        assert shards == null : \"min is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"min is meaningless if range is empty\";\n+        assert this != MUTABLE : \"min is meaningless if range is mutable\";\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) maximum of this range.\n+     */\n+    public long getMax() {\n+        assert shards == null : \"max is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"max is meaningless if range is empty\";\n+        assert this != MUTABLE : \"max is meaningless if range is mutable\";\n+        return max;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        if (out.getVersion().onOrAfter(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            if (this == UNKNOWN) {\n+                out.writeByte((byte) 1);\n+            } else if (this == MUTABLE) {\n+                out.writeByte((byte) 2);\n+            } else if (this == EMPTY) {\n+                out.writeByte((byte) 3);\n+            } else {\n+                out.writeByte((byte) 0);\n+                if (shards == null) {\n+                    out.writeBoolean(false);\n+                } else {\n+                    out.writeBoolean(true);\n+                    out.writeVIntArray(shards);\n+                }\n+                out.writeZLong(min);\n+                out.writeZLong(max);\n+            }\n+        }\n+    }\n+\n+    public static IndexLongFieldRange readFrom(StreamInput in) throws IOException {\n+        if (in.getVersion().before(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            // conservative treatment for BWC\n+            return MUTABLE;\n+        }\n+\n+        final byte type = in.readByte();\n+        switch (type) {\n+            case 1:\n+                return UNKNOWN;\n+            case 2:\n+                return MUTABLE;\n+            case 3:\n+                return EMPTY;\n+            case 0:\n+                return new IndexLongFieldRange(in.readBoolean() ? in.readVIntArray() : null, in.readZLong(), in.readZLong());\n+            default:\n+                throw new IllegalStateException(\"type [\" + type + \"] not known\");\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        if (this == MUTABLE) {\n+            builder.field(\"mutable\", true);\n+        } else if (this == EMPTY) {\n+            builder.field(\"empty\", true);\n+        } else if (this == UNKNOWN) {\n+            builder.startArray(\"shards\");\n+            builder.endArray();\n+        } else {\n+            builder.field(\"min\", min);\n+            builder.field(\"max\", max);\n+            if (shards != null) {\n+                builder.startArray(\"shards\");\n+                for (int shard : shards) {\n+                    builder.value(shard);\n+                }\n+                builder.endArray();\n+            }\n+        }\n+        return builder;\n+    }\n+\n+    public static IndexLongFieldRange fromXContent(XContentParser parser) throws IOException {\n+        XContentParser.Token token;\n+        String currentFieldName = null;\n+        Boolean isMutable = null;\n+        Boolean isEmpty = null;\n+        Long min = null;\n+        Long max = null;\n+        List<Integer> shardsList = null;\n+        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n+            if (token == XContentParser.Token.FIELD_NAME) {\n+                currentFieldName = parser.currentName();\n+            } else if (token.isValue()) {\n+                if (\"mutable\".equals(currentFieldName)) {\n+                    if (Boolean.FALSE.equals(isMutable)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'mutable'\");\n+                    } else {\n+                        isMutable = Boolean.TRUE;\n+                        isEmpty = Boolean.FALSE;\n+                    }\n+                } else if (\"empty\".equals(currentFieldName)) {\n+                    if (Boolean.FALSE.equals(isEmpty)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'empty'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.TRUE;\n+                    }\n+                } else if (\"min\".equals(currentFieldName)) {\n+                    if (Boolean.TRUE.equals(isMutable) || Boolean.TRUE.equals(isEmpty)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'min'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.FALSE;\n+                        min = parser.longValue();\n+                    }\n+                } else if (\"max\".equals(currentFieldName)) {\n+                    if (Boolean.TRUE.equals(isMutable) || Boolean.TRUE.equals(isEmpty)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'max'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.FALSE;\n+                        max = parser.longValue();\n+                    }\n+                }\n+            } else if (token == XContentParser.Token.START_ARRAY) {\n+                if (\"shards\".equals(currentFieldName)) {\n+                    if (Boolean.TRUE.equals(isMutable) || Boolean.TRUE.equals(isEmpty) || shardsList != null) {\n+                        throw new IllegalArgumentException(\"unexpected array 'shards'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.FALSE;\n+                        shardsList = new ArrayList<>();\n+                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n+                            if (token.isValue()) {\n+                                shardsList.add(parser.intValue());\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected array: \" + currentFieldName);\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Unexpected token: \" + token);\n+            }\n+        }\n+\n+        if (Boolean.TRUE.equals(isMutable)) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert min == null && max == null && shardsList == null && Boolean.FALSE.equals(isEmpty);\n+            return MUTABLE;\n+        } else if (Boolean.TRUE.equals(isEmpty)) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert min == null && max == null && shardsList == null && Boolean.FALSE.equals(isMutable);\n+            return EMPTY;\n+        } else if (shardsList != null && shardsList.isEmpty()) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert min == null && max == null && Boolean.FALSE.equals(isEmpty) && Boolean.FALSE.equals(isMutable);\n+            return UNKNOWN;\n+        } else if (min != null) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert Boolean.FALSE.equals(isMutable) && Boolean.FALSE.equals(isEmpty);\n+            if (max == null) {\n+                throw new IllegalArgumentException(\"field 'max' unexpectedly missing\");\n+            }\n+            final int[] shards;\n+            if (shardsList != null) {\n+                shards = shardsList.stream().mapToInt(i -> i).toArray();\n+                assert shards.length > 0;\n+            } else {\n+                shards = null;\n+            }\n+            return new IndexLongFieldRange(shards, min, max);\n+        } else {\n+            throw new IllegalArgumentException(\"field range contents unexpectedly missing\");\n+        }\n+    }\n+\n+    public IndexLongFieldRange extendWithShardRange(int shardId, int shardCount, ShardLongFieldRange shardFieldRange) {\n+        if (shardFieldRange == ShardLongFieldRange.MUTABLE) {\n+            assert shards == null || Arrays.stream(shards).noneMatch(i -> i == shardId) : Arrays.toString(shards);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxODE1MA==", "bodyText": "Can we assert that when all shards are started in routing table, the timestamp range is also complete?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532418150", "createdAt": "2020-11-30T08:27:45Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java", "diffHunk": "@@ -578,6 +608,17 @@ public ShardStartedClusterStateTaskExecutor(AllocationService allocationService,\n             ClusterState maybeUpdatedState = currentState;\n             try {\n                 maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);\n+\n+                if (updatedTimestampRanges.isEmpty() == false) {\n+                    final Metadata.Builder metadataBuilder = Metadata.builder(maybeUpdatedState.metadata());\n+                    for (Map.Entry<Index, IndexLongFieldRange> updatedTimestampRangeEntry : updatedTimestampRanges.entrySet()) {\n+                        metadataBuilder.put(IndexMetadata", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQzNjEyMA==", "bodyText": "I think toNanoSeconds on the up-rounded value can result in IllegalArgumentException?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532436120", "createdAt": "2020-11-30T08:59:21Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/DateFieldMapperTests.java", "diffHunk": "@@ -333,4 +338,27 @@ public void testFetchDocValuesNanos() throws IOException {\n         assertEquals(List.of(date), fetchFromDocValues(mapperService, ft, format, date));\n         assertEquals(List.of(\"2020-05-15T21:33:02.123Z\"), fetchFromDocValues(mapperService, ft, format, 1589578382123L));\n     }\n+\n+    public void testResolutionRounding() {\n+        final long millis = randomLong();\n+        assertThat(DateFieldMapper.Resolution.MILLISECONDS.roundDownToMillis(millis), equalTo(millis));\n+        assertThat(DateFieldMapper.Resolution.MILLISECONDS.roundUpToMillis(millis), equalTo(millis));\n+\n+        final long nanos = randomNonNegativeLong();\n+        final long down = DateFieldMapper.Resolution.NANOSECONDS.roundDownToMillis(nanos);\n+        assertThat(DateUtils.toNanoSeconds(down), lessThanOrEqualTo(nanos));\n+        try {\n+            assertThat(DateUtils.toNanoSeconds(down + 1), greaterThan(nanos));\n+        } catch (IllegalArgumentException e) {\n+            // ok, down+1 was out of range\n+        }\n+\n+        final long up = DateFieldMapper.Resolution.NANOSECONDS.roundUpToMillis(nanos);\n+        assertThat(DateUtils.toNanoSeconds(up), greaterThanOrEqualTo(nanos));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ0NDIzNQ==", "bodyText": "Maybe also return EMPTY sometimes?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532444235", "createdAt": "2020-11-30T09:13:29Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/shard/IndexLongFieldRangeWireTests.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.checkForSameInstances;\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.randomRange;\n+\n+public class IndexLongFieldRangeWireTests extends AbstractWireSerializingTestCase<IndexLongFieldRange> {\n+    @Override\n+    protected Writeable.Reader<IndexLongFieldRange> instanceReader() {\n+        return IndexLongFieldRange::readFrom;\n+    }\n+\n+    @Override\n+    protected IndexLongFieldRange createTestInstance() {\n+        return randomRange();\n+    }\n+\n+    @Override\n+    protected IndexLongFieldRange mutateInstance(IndexLongFieldRange instance) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe4caef3dd19f7bab5d2c65d676a7a5066427d22", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe4caef3dd19f7bab5d2c65d676a7a5066427d22", "committedDate": "2020-11-30T10:43:19Z", "message": "Merge branch 'master' into 2020-11-24-record-timestamp-field-range-in-index-metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27b7f3868af7bf6cbdc803c35f1c4e3b5cfabeea", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/27b7f3868af7bf6cbdc803c35f1c4e3b5cfabeea", "committedDate": "2020-11-30T10:50:10Z", "message": "Stronger assertion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acfa17b451ba2352162eb6e47afa61d64cda2df7", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/acfa17b451ba2352162eb6e47afa61d64cda2df7", "committedDate": "2020-11-30T10:56:12Z", "message": "Assert timestamp range complete when all primaries started"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "214b6b79783afbd6f77e286221cb2fcdddaf08cd", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/214b6b79783afbd6f77e286221cb2fcdddaf08cd", "committedDate": "2020-11-30T11:02:28Z", "message": "Deal with rounding up out-of-range"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb48dca4976d8d3e27fedb5d090fa03800a8297f", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/fb48dca4976d8d3e27fedb5d090fa03800a8297f", "committedDate": "2020-11-30T13:05:16Z", "message": "Assertion message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6585ecbcc71d55689cbe598b8be04497a2a0f15", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/d6585ecbcc71d55689cbe598b8be04497a2a0f15", "committedDate": "2020-11-30T13:05:57Z", "message": "Oops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3d35f9add7e67613a5ea5bb376f933cf1955e48", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3d35f9add7e67613a5ea5bb376f933cf1955e48", "committedDate": "2020-11-30T13:05:57Z", "message": "Introduce ILFR#removeShard"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c07217570099e0d17b1e224d27320e49c683d1f2", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c07217570099e0d17b1e224d27320e49c683d1f2", "committedDate": "2020-11-30T13:05:58Z", "message": "Remove shard from range when allocating stale primary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "committedDate": "2020-11-30T13:15:02Z", "message": "Precommit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNzY4NTk1", "url": "https://github.com/elastic/elasticsearch/pull/65564#pullrequestreview-540768595", "createdAt": "2020-11-30T10:18:44Z", "commit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMToyMTowMlrOH72rDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzozMjoyNVrOH77OQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUyMzc4OA==", "bodyText": "nit: can we extract these constants to a static field?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532523788", "createdAt": "2020-11-30T11:21:02Z", "author": {"login": "fcofdez"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);\n+\n+    @Nullable // if this range includes all shards\n+    private final int[] shards;\n+    private final long min, max;\n+\n+    private IndexLongFieldRange(int[] shards, long min, long max) {\n+        assert (min == Long.MAX_VALUE && max == Long.MIN_VALUE) || min <= max : min + \" vs \" + max;\n+        assert shards == null || shards.length > 0 || (min == Long.MAX_VALUE && max == Long.MIN_VALUE);\n+        assert shards == null || Arrays.equals(shards, Arrays.stream(shards).sorted().distinct().toArray()) : Arrays.toString(shards);\n+        this.shards = shards;\n+        this.min = min;\n+        this.max = max;\n+    }\n+\n+    /**\n+     * @return whether this range includes information from all shards yet.\n+     */\n+    public boolean isComplete() {\n+        return shards == null;\n+    }\n+\n+    // exposed for testing\n+    int[] getShards() {\n+        return shards;\n+    }\n+\n+    // exposed for testing\n+    long getMinUnsafe() {\n+        return min;\n+    }\n+\n+    // exposed for testing\n+    long getMaxUnsafe() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) minimum of this range.\n+     */\n+    public long getMin() {\n+        assert shards == null : \"min is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"min is meaningless if range is empty\";\n+        assert this != MUTABLE : \"min is meaningless if range is mutable\";\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) maximum of this range.\n+     */\n+    public long getMax() {\n+        assert shards == null : \"max is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"max is meaningless if range is empty\";\n+        assert this != MUTABLE : \"max is meaningless if range is mutable\";\n+        return max;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        if (out.getVersion().onOrAfter(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            if (this == UNKNOWN) {\n+                out.writeByte((byte) 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214b6b79783afbd6f77e286221cb2fcdddaf08cd"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njg2OA==", "bodyText": "I was thinking that we might want to consider EMPTY and MUTABLE sentinel values as incomplete, so we can avoid triggering the query rewrite on the coordinator in the cases where we don't know the field range. wdyt @DaveCTurner ?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532596868", "createdAt": "2020-11-30T13:30:03Z", "author": {"login": "fcofdez"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NzQ1MA==", "bodyText": "nit: can we extract these constants to a static field?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532597450", "createdAt": "2020-11-30T13:30:58Z", "author": {"login": "fcofdez"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ShardLongFieldRange.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in a single shard.\n+ */\n+public class ShardLongFieldRange implements Writeable {\n+\n+    static final Version LONG_FIELD_RANGE_VERSION_INTRODUCED = Version.V_8_0_0;\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values.\n+     */\n+    public static final ShardLongFieldRange EMPTY = new ShardLongFieldRange(Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final ShardLongFieldRange MUTABLE = new ShardLongFieldRange(Long.MIN_VALUE, Long.MAX_VALUE);\n+\n+    /**\n+     * Construct a new {@link ShardLongFieldRange} with the given (inclusive) minimum and maximum.\n+     */\n+    public static ShardLongFieldRange of(long min, long max) {\n+        assert min <= max : min + \" vs \" + max;\n+        return new ShardLongFieldRange(min, max);\n+    }\n+\n+    private final long min, max;\n+\n+    private ShardLongFieldRange(long min, long max) {\n+        this.min = min;\n+        this.max = max;\n+    }\n+\n+    /**\n+     * @return the (inclusive) minimum of this range.\n+     */\n+    public long getMin() {\n+        assert this != EMPTY && this != MUTABLE && min <= max: \"must not use actual min of sentinel values\";\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) maximum of this range.\n+     */\n+    public long getMax() {\n+        assert this != EMPTY && this != MUTABLE && min <= max : \"must not use actual max of sentinel values\";\n+        return max;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this == MUTABLE) {\n+            return \"MUTABLE\";\n+        } else if (this == EMPTY) {\n+            return \"EMPTY\";\n+        } else {\n+            return \"[\" + min + \"-\" + max + \"]\";\n+        }\n+    }\n+\n+    public static ShardLongFieldRange readFrom(StreamInput in) throws IOException {\n+        if (in.getVersion().before(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            // conservative treatment for BWC\n+            return MUTABLE;\n+        }\n+\n+        final byte type = in.readByte();\n+        switch (type) {\n+            case 1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5ODMzNg==", "bodyText": "maybe ShardLongFieldRange belongs to RecoveryState?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532598336", "createdAt": "2020-11-30T13:32:25Z", "author": {"login": "fcofdez"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -271,7 +272,7 @@ public static StartRecoveryRequest getStartRecoveryRequest(Logger logger, Discov\n     }\n \n     public interface RecoveryListener {\n-        void onRecoveryDone(RecoveryState state);\n+        void onRecoveryDone(RecoveryState state, ShardLongFieldRange timestampMillisFieldRange);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a978aea54f52d357ab41bbc38d89fd26df3dd797", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/a978aea54f52d357ab41bbc38d89fd26df3dd797", "committedDate": "2020-11-30T13:51:05Z", "message": "Name the magic numbers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cfdcf3617be57d1b74dc547567d6f5a71b2d0d9", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/9cfdcf3617be57d1b74dc547567d6f5a71b2d0d9", "committedDate": "2020-11-30T14:23:37Z", "message": "Fix serialization test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bf52c084fc792fedd1d6ddbdc4ff9f3e0f4f2ae", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/9bf52c084fc792fedd1d6ddbdc4ff9f3e0f4f2ae", "committedDate": "2020-11-30T14:46:18Z", "message": "Wipe out range when closing indices too"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e40f9a13a5de3b4cda3ca44c81dd5aeaca21d409", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/e40f9a13a5de3b4cda3ca44c81dd5aeaca21d409", "committedDate": "2020-11-30T15:39:48Z", "message": "Fix assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc47717ee2f31eaa7f6a41761bebed906f1e9b53", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/dc47717ee2f31eaa7f6a41761bebed906f1e9b53", "committedDate": "2020-11-30T17:25:34Z", "message": "Merge branch 'master' into 2020-11-24-record-timestamp-field-range-in-index-metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4e43c01123ebb684994d43a5a1729d943ec1548", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4e43c01123ebb684994d43a5a1729d943ec1548", "committedDate": "2020-11-30T17:56:04Z", "message": "D'oh"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNjcwOTI4", "url": "https://github.com/elastic/elasticsearch/pull/65564#pullrequestreview-541670928", "createdAt": "2020-12-01T08:55:21Z", "commit": {"oid": "a4e43c01123ebb684994d43a5a1729d943ec1548"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwODo1NToyMVrOH8eSIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoyMTo1OFrOH8lErQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ==", "bodyText": "I think this should be MUTABLE? We should only return empty when mappedFieldType == null.", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533172771", "createdAt": "2020-12-01T08:55:21Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -1715,6 +1718,46 @@ public RecoveryState recoveryState() {\n         return this.recoveryState;\n     }\n \n+    @Override\n+    public ShardLongFieldRange getTimestampMillisRange() {\n+        assert isReadAllowed();\n+\n+        if (mapperService() == null) {\n+            return ShardLongFieldRange.MUTABLE; // no mapper service, no idea if the field even exists\n+        }\n+        final MappedFieldType mappedFieldType = mapperService().fieldType(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD);\n+        final boolean hasMappedTimestampField = mappedFieldType instanceof DateFieldMapper.DateFieldType;\n+\n+        final Engine engine = getEngine();\n+        final ShardLongFieldRange rawTimestampFieldRange;\n+        try {\n+            rawTimestampFieldRange = engine.getRawFieldRange(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, hasMappedTimestampField);\n+        } catch (IOException e) {\n+            logger.debug(\"exception obtaining range for timestamp field\", e);\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.MUTABLE) {\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.EMPTY) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+\n+        if (hasMappedTimestampField == false) {\n+            return ShardLongFieldRange.EMPTY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4e43c01123ebb684994d43a5a1729d943ec1548"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2ODE2NA==", "bodyText": "I would prefer to rename MUTABLE to UNKNOWN and use UNFILLED (or a nicer english word) for the no information case.\nI think UNKNOWN better captures the state where we do started shards but do not know the range.", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533268164", "createdAt": "2020-12-01T10:08:33Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4e43c01123ebb684994d43a5a1729d943ec1548"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NTIwMA==", "bodyText": "I think we could allow going from MUTABLE to UNKNOWN in the single shard case, i.e., move this below the if-statement below?", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533275200", "createdAt": "2020-12-01T10:14:35Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -335,4 +342,30 @@ public int hashCode() {\n         result = 31 * result + Arrays.hashCode(shards);\n         return result;\n     }\n+\n+    /**\n+     * Remove the given shard from the set of known shards, possibly without adjusting the min and max. Used when allocating a stale primary\n+     * which may have a different range from the original, so we must allow the range to grow. Note that this doesn't usually allow the\n+     * range to shrink, so we may in theory hit this shard more than needed after allocating a stale primary.\n+     */\n+    public IndexLongFieldRange removeShard(int shardId, int numberOfShards) {\n+        assert 0 <= shardId && shardId < numberOfShards : shardId + \" vs \" + numberOfShards;\n+\n+        if (shards != null && Arrays.stream(shards).noneMatch(i -> i == shardId)) {\n+            return this;\n+        }\n+        if (this == MUTABLE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4e43c01123ebb684994d43a5a1729d943ec1548"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI4NDAxMw==", "bodyText": "I added a suggestion to rename MUTABLE below, I think having this difference between essentially unknown timestamp ranges is unnecessary.", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533284013", "createdAt": "2020-12-01T10:21:58Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -1713,6 +1716,46 @@ public RecoveryState recoveryState() {\n         return this.recoveryState;\n     }\n \n+    @Override\n+    public ShardLongFieldRange getTimestampMillisRange() {\n+        assert isReadAllowed();\n+\n+        if (mapperService() == null) {\n+            return ShardLongFieldRange.MUTABLE; // no mapper service, no idea if the field even exists\n+        }\n+        final MappedFieldType mappedFieldType = mapperService().fieldType(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD);\n+        final boolean hasMappedTimestampField = mappedFieldType instanceof DateFieldMapper.DateFieldType;\n+\n+        final Engine engine = getEngine();\n+        final ShardLongFieldRange rawTimestampFieldRange;\n+        try {\n+            rawTimestampFieldRange = engine.getRawFieldRange(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, hasMappedTimestampField);\n+        } catch (IOException e) {\n+            logger.debug(\"exception obtaining range for timestamp field\", e);\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.MUTABLE) {\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.EMPTY) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+\n+        if (hasMappedTimestampField == false) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+        final DateFieldMapper.DateFieldType dateFieldType = (DateFieldMapper.DateFieldType) mappedFieldType;\n+\n+        try {\n+            return ShardLongFieldRange.of(\n+                    dateFieldType.resolution().roundDownToMillis(rawTimestampFieldRange.getMin()),\n+                    dateFieldType.resolution().roundUpToMillis(rawTimestampFieldRange.getMax()));\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(new ParameterizedMessage(\"could not convert {} to a millisecond time range\", rawTimestampFieldRange), e);\n+            return ShardLongFieldRange.of(Long.MIN_VALUE, Long.MAX_VALUE); // any search might match this shard", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxMTk4Ng=="}, "originalCommit": {"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2f71d92730008334491d736f7dfb081d729f1bb", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/f2f71d92730008334491d736f7dfb081d729f1bb", "committedDate": "2020-12-01T11:47:47Z", "message": "Merge branch 'master' into 2020-11-24-record-timestamp-field-range-in-index-metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c08ee780013b8c270a1d381612bc9386a3c685d", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c08ee780013b8c270a1d381612bc9386a3c685d", "committedDate": "2020-12-01T11:56:38Z", "message": "Rename ILFR: UNKNOWN -> NO_SHARDS and MUTABLE -> UNKNOWN"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2d15b258161f4714682d47949b0d3734d8aff33", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c2d15b258161f4714682d47949b0d3734d8aff33", "committedDate": "2020-12-01T11:58:52Z", "message": "Rename SLFR: MUTABLE -> UNKNOWN"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bc657e3a069cbb97683897cb41308c36ce80cbe", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/5bc657e3a069cbb97683897cb41308c36ce80cbe", "committedDate": "2020-12-01T12:03:00Z", "message": "One-shard case can move back to NO_SHARDS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0b0ea373b142a03796db0bdc852d19bffe307d7", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0b0ea373b142a03796db0bdc852d19bffe307d7", "committedDate": "2020-12-01T12:18:53Z", "message": "UNKNOWN if timestamp field isn't a timestamp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04bd7541a4aeaa05850e364054df9fe9c019694b", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/04bd7541a4aeaa05850e364054df9fe9c019694b", "committedDate": "2020-12-01T12:24:36Z", "message": "Never false, so assert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c4b497e0a241429082f5ac43bf0b8e5487ffe50b", "committedDate": "2020-12-01T12:55:46Z", "message": "Return UNKNOWN if field is missing or not a date"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxODc1MTA2", "url": "https://github.com/elastic/elasticsearch/pull/65564#pullrequestreview-541875106", "createdAt": "2020-12-01T13:07:05Z", "commit": {"oid": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzowNzowNVrOH8rulQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzowNzo1OFrOH8rwgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzA0NQ==", "bodyText": "nit: rename:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testMutableShardImpliesMutableIndex() {\n          \n          \n            \n                public void testUnknownShardImpliesUnknownIndex() {", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533393045", "createdAt": "2020-12-01T13:07:05Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/shard/IndexLongFieldRangeTests.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.randomSpecificRange;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class IndexLongFieldRangeTests extends ESTestCase {\n+\n+    public void testMutableShardImpliesMutableIndex() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzUzOQ==", "bodyText": "nit: rename:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testExtendMutableRangeIsNoOp() {\n          \n          \n            \n                public void testExtendUnknownRangeIsNoOp() {", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533393539", "createdAt": "2020-12-01T13:07:58Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/shard/IndexLongFieldRangeTests.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.randomSpecificRange;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class IndexLongFieldRangeTests extends ESTestCase {\n+\n+    public void testMutableShardImpliesMutableIndex() {\n+        final IndexLongFieldRange range = randomSpecificRange(false);\n+        assertThat(range.extendWithShardRange(\n+                IntStream.of(range.getShards()).max().orElse(0) + 1,\n+                between(1, 10),\n+                ShardLongFieldRange.UNKNOWN),\n+                sameInstance(IndexLongFieldRange.UNKNOWN));\n+    }\n+\n+    public void testExtendWithKnownShardIsNoOp() {\n+        IndexLongFieldRange range = randomSpecificRange();\n+        if (range == IndexLongFieldRange.NO_SHARDS) {\n+            // need at least one known shard\n+            range = range.extendWithShardRange(between(0, 5), 5, ShardLongFieldRange.EMPTY);\n+        }\n+\n+        final ShardLongFieldRange shardRange;\n+        if (range.getMinUnsafe() == IndexLongFieldRange.EMPTY.getMinUnsafe()\n+                && range.getMaxUnsafe() == IndexLongFieldRange.EMPTY.getMaxUnsafe()) {\n+            shardRange = ShardLongFieldRange.EMPTY;\n+        } else {\n+            final long min = randomLongBetween(range.getMinUnsafe(), range.getMaxUnsafe());\n+            final long max = randomLongBetween(min, range.getMaxUnsafe());\n+            shardRange = randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(min, max);\n+        }\n+\n+        assertThat(range.extendWithShardRange(\n+                range.isComplete() ? between(1, 10) : randomFrom(IntStream.of(range.getShards()).boxed().collect(Collectors.toList())),\n+                between(1, 10),\n+                shardRange),\n+                sameInstance(range));\n+    }\n+\n+    public void testExtendMutableRangeIsNoOp() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "962cae18e0142759999b1e56c62b48e23e4247c0", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/962cae18e0142759999b1e56c62b48e23e4247c0", "committedDate": "2020-12-01T13:41:00Z", "message": "Test names"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4329, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}