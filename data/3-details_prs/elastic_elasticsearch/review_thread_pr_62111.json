{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMTIyNTYz", "number": 62111, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo0NjozMFrOEhZB1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo1MjoyMFrOEhZJgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDQ4NTM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo0NjozMVrOHOrnSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODoxNDozOVrOHO74Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ==", "bodyText": "Can we keep the name as is for now. I understand that we want to call it query failures after this change but we may also want to provide a way to return partial top hits in the future. My point being that we might reintroduce fetch failures when they make sense.", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485156681", "createdAt": "2020-09-08T19:46:31Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -35,7 +35,7 @@\n     private final int totalShards;\n     private final int skippedShards;\n     private final Clusters clusters;\n-    private final AtomicArray<ShardSearchFailure> shardFailures;\n+    private final AtomicArray<ShardSearchFailure> queryFailures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5OTA5Mg==", "bodyText": "this is not a huge deal, but can we not rename it back to shardFailures in the future once we introduce a way to return partial top hits?", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485399092", "createdAt": "2020-09-09T07:33:53Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -35,7 +35,7 @@\n     private final int totalShards;\n     private final int skippedShards;\n     private final Clusters clusters;\n-    private final AtomicArray<ShardSearchFailure> shardFailures;\n+    private final AtomicArray<ShardSearchFailure> queryFailures;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ=="}, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQwOTYwNQ==", "bodyText": "As you want, that's not a big deal I agree but I wanted to raise the awareness that returning partial top hits is still in the air.", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485409605", "createdAt": "2020-09-09T07:51:43Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -35,7 +35,7 @@\n     private final int totalShards;\n     private final int skippedShards;\n     private final Clusters clusters;\n-    private final AtomicArray<ShardSearchFailure> shardFailures;\n+    private final AtomicArray<ShardSearchFailure> queryFailures;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ=="}, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzE5OQ==", "bodyText": "Thanks, I am aware, and I probably would have made the same comment if you had made this same change :)", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485423199", "createdAt": "2020-09-09T08:14:39Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -35,7 +35,7 @@\n     private final int totalShards;\n     private final int skippedShards;\n     private final Clusters clusters;\n-    private final AtomicArray<ShardSearchFailure> shardFailures;\n+    private final AtomicArray<ShardSearchFailure> queryFailures;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ=="}, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDUwNDk2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo1MjoyMFrOHOry_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODoxNDo1NVrOHO75Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw==", "bodyText": "nit: you could derive it from the index name instead ?", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485159677", "createdAt": "2020-09-08T19:52:20Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SearchPlugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.fetch.FetchSubPhaseProcessor;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchAction;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AsyncSearchSingleNodeTests extends ESSingleNodeTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return List.of(AsyncSearch.class, SubFetchPhasePlugin.class);\n+    }\n+\n+    public void testFetchFailuresAllShards() throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertTrue(asyncSearchResponse.isPartial());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(10, searchResponse.getSuccessfulShards());\n+        assertEquals(0, searchResponse.getFailedShards());\n+        assertEquals(0, searchResponse.getShardFailures().length);\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(0, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertNotNull(asyncSearchResponse.getFailure());\n+        assertThat(asyncSearchResponse.getFailure(), CoreMatchers.instanceOf(ElasticsearchStatusException.class));\n+        ElasticsearchStatusException statusException = (ElasticsearchStatusException) asyncSearchResponse.getFailure();\n+        assertEquals(RestStatus.INTERNAL_SERVER_ERROR, statusException.status());\n+        assertThat(asyncSearchResponse.getFailure().getCause(), CoreMatchers.instanceOf(SearchPhaseExecutionException.class));\n+        SearchPhaseExecutionException phaseExecutionException = (SearchPhaseExecutionException) asyncSearchResponse.getFailure().getCause();\n+        assertEquals(\"fetch\", phaseExecutionException.getPhaseName());\n+        assertEquals(\"boom\", phaseExecutionException.getCause().getMessage());\n+        assertEquals(10, phaseExecutionException.shardFailures().length);\n+        for (ShardSearchFailure shardSearchFailure : phaseExecutionException.shardFailures()) {\n+            assertEquals(\"boom\", shardSearchFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public void testFetchFailuresOnlySomeShards() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"index\" + i).id(\"index\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertFalse(asyncSearchResponse.isPartial());\n+        assertNull(asyncSearchResponse.getFailure());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(5, searchResponse.getSuccessfulShards());\n+        assertEquals(5, searchResponse.getFailedShards());\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(5, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertEquals(5, searchResponse.getShardFailures().length);\n+        for (ShardSearchFailure shardFailure : searchResponse.getShardFailures()) {\n+            assertEquals(\"boom\", shardFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public static final class SubFetchPhasePlugin extends Plugin implements SearchPlugin {\n+        @Override\n+        public List<FetchSubPhase> getFetchSubPhases(FetchPhaseConstructionContext context) {\n+            return Collections.singletonList(searchContext -> new FetchSubPhaseProcessor() {\n+                @Override\n+                public void setNextReader(LeafReaderContext readerContext) {}\n+\n+                @Override\n+                public void process(FetchSubPhase.HitContext hitContext) {\n+                    if (hitContext.hit().getId().startsWith(\"boom\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5ODQwNg==", "bodyText": "that is what I thought too but it turns out the index is null, no idea why.", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485398406", "createdAt": "2020-09-09T07:32:37Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SearchPlugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.fetch.FetchSubPhaseProcessor;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchAction;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AsyncSearchSingleNodeTests extends ESSingleNodeTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return List.of(AsyncSearch.class, SubFetchPhasePlugin.class);\n+    }\n+\n+    public void testFetchFailuresAllShards() throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertTrue(asyncSearchResponse.isPartial());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(10, searchResponse.getSuccessfulShards());\n+        assertEquals(0, searchResponse.getFailedShards());\n+        assertEquals(0, searchResponse.getShardFailures().length);\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(0, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertNotNull(asyncSearchResponse.getFailure());\n+        assertThat(asyncSearchResponse.getFailure(), CoreMatchers.instanceOf(ElasticsearchStatusException.class));\n+        ElasticsearchStatusException statusException = (ElasticsearchStatusException) asyncSearchResponse.getFailure();\n+        assertEquals(RestStatus.INTERNAL_SERVER_ERROR, statusException.status());\n+        assertThat(asyncSearchResponse.getFailure().getCause(), CoreMatchers.instanceOf(SearchPhaseExecutionException.class));\n+        SearchPhaseExecutionException phaseExecutionException = (SearchPhaseExecutionException) asyncSearchResponse.getFailure().getCause();\n+        assertEquals(\"fetch\", phaseExecutionException.getPhaseName());\n+        assertEquals(\"boom\", phaseExecutionException.getCause().getMessage());\n+        assertEquals(10, phaseExecutionException.shardFailures().length);\n+        for (ShardSearchFailure shardSearchFailure : phaseExecutionException.shardFailures()) {\n+            assertEquals(\"boom\", shardSearchFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public void testFetchFailuresOnlySomeShards() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"index\" + i).id(\"index\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertFalse(asyncSearchResponse.isPartial());\n+        assertNull(asyncSearchResponse.getFailure());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(5, searchResponse.getSuccessfulShards());\n+        assertEquals(5, searchResponse.getFailedShards());\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(5, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertEquals(5, searchResponse.getShardFailures().length);\n+        for (ShardSearchFailure shardFailure : searchResponse.getShardFailures()) {\n+            assertEquals(\"boom\", shardFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public static final class SubFetchPhasePlugin extends Plugin implements SearchPlugin {\n+        @Override\n+        public List<FetchSubPhase> getFetchSubPhases(FetchPhaseConstructionContext context) {\n+            return Collections.singletonList(searchContext -> new FetchSubPhaseProcessor() {\n+                @Override\n+                public void setNextReader(LeafReaderContext readerContext) {}\n+\n+                @Override\n+                public void process(FetchSubPhase.HitContext hitContext) {\n+                    if (hitContext.hit().getId().startsWith(\"boom\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw=="}, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxMTY4NA==", "bodyText": "do you mean hitContext.hit().getIndex() is null ?", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485411684", "createdAt": "2020-09-09T07:55:01Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SearchPlugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.fetch.FetchSubPhaseProcessor;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchAction;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AsyncSearchSingleNodeTests extends ESSingleNodeTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return List.of(AsyncSearch.class, SubFetchPhasePlugin.class);\n+    }\n+\n+    public void testFetchFailuresAllShards() throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertTrue(asyncSearchResponse.isPartial());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(10, searchResponse.getSuccessfulShards());\n+        assertEquals(0, searchResponse.getFailedShards());\n+        assertEquals(0, searchResponse.getShardFailures().length);\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(0, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertNotNull(asyncSearchResponse.getFailure());\n+        assertThat(asyncSearchResponse.getFailure(), CoreMatchers.instanceOf(ElasticsearchStatusException.class));\n+        ElasticsearchStatusException statusException = (ElasticsearchStatusException) asyncSearchResponse.getFailure();\n+        assertEquals(RestStatus.INTERNAL_SERVER_ERROR, statusException.status());\n+        assertThat(asyncSearchResponse.getFailure().getCause(), CoreMatchers.instanceOf(SearchPhaseExecutionException.class));\n+        SearchPhaseExecutionException phaseExecutionException = (SearchPhaseExecutionException) asyncSearchResponse.getFailure().getCause();\n+        assertEquals(\"fetch\", phaseExecutionException.getPhaseName());\n+        assertEquals(\"boom\", phaseExecutionException.getCause().getMessage());\n+        assertEquals(10, phaseExecutionException.shardFailures().length);\n+        for (ShardSearchFailure shardSearchFailure : phaseExecutionException.shardFailures()) {\n+            assertEquals(\"boom\", shardSearchFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public void testFetchFailuresOnlySomeShards() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"index\" + i).id(\"index\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertFalse(asyncSearchResponse.isPartial());\n+        assertNull(asyncSearchResponse.getFailure());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(5, searchResponse.getSuccessfulShards());\n+        assertEquals(5, searchResponse.getFailedShards());\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(5, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertEquals(5, searchResponse.getShardFailures().length);\n+        for (ShardSearchFailure shardFailure : searchResponse.getShardFailures()) {\n+            assertEquals(\"boom\", shardFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public static final class SubFetchPhasePlugin extends Plugin implements SearchPlugin {\n+        @Override\n+        public List<FetchSubPhase> getFetchSubPhases(FetchPhaseConstructionContext context) {\n+            return Collections.singletonList(searchContext -> new FetchSubPhaseProcessor() {\n+                @Override\n+                public void setNextReader(LeafReaderContext readerContext) {}\n+\n+                @Override\n+                public void process(FetchSubPhase.HitContext hitContext) {\n+                    if (hitContext.hit().getId().startsWith(\"boom\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw=="}, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzM2Ng==", "bodyText": "yes pretty much everything is null in the hit besides the id", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485423366", "createdAt": "2020-09-09T08:14:55Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SearchPlugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.fetch.FetchSubPhaseProcessor;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchAction;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AsyncSearchSingleNodeTests extends ESSingleNodeTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return List.of(AsyncSearch.class, SubFetchPhasePlugin.class);\n+    }\n+\n+    public void testFetchFailuresAllShards() throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertTrue(asyncSearchResponse.isPartial());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(10, searchResponse.getSuccessfulShards());\n+        assertEquals(0, searchResponse.getFailedShards());\n+        assertEquals(0, searchResponse.getShardFailures().length);\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(0, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertNotNull(asyncSearchResponse.getFailure());\n+        assertThat(asyncSearchResponse.getFailure(), CoreMatchers.instanceOf(ElasticsearchStatusException.class));\n+        ElasticsearchStatusException statusException = (ElasticsearchStatusException) asyncSearchResponse.getFailure();\n+        assertEquals(RestStatus.INTERNAL_SERVER_ERROR, statusException.status());\n+        assertThat(asyncSearchResponse.getFailure().getCause(), CoreMatchers.instanceOf(SearchPhaseExecutionException.class));\n+        SearchPhaseExecutionException phaseExecutionException = (SearchPhaseExecutionException) asyncSearchResponse.getFailure().getCause();\n+        assertEquals(\"fetch\", phaseExecutionException.getPhaseName());\n+        assertEquals(\"boom\", phaseExecutionException.getCause().getMessage());\n+        assertEquals(10, phaseExecutionException.shardFailures().length);\n+        for (ShardSearchFailure shardSearchFailure : phaseExecutionException.shardFailures()) {\n+            assertEquals(\"boom\", shardSearchFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public void testFetchFailuresOnlySomeShards() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"index\" + i).id(\"index\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertFalse(asyncSearchResponse.isPartial());\n+        assertNull(asyncSearchResponse.getFailure());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(5, searchResponse.getSuccessfulShards());\n+        assertEquals(5, searchResponse.getFailedShards());\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(5, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertEquals(5, searchResponse.getShardFailures().length);\n+        for (ShardSearchFailure shardFailure : searchResponse.getShardFailures()) {\n+            assertEquals(\"boom\", shardFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public static final class SubFetchPhasePlugin extends Plugin implements SearchPlugin {\n+        @Override\n+        public List<FetchSubPhase> getFetchSubPhases(FetchPhaseConstructionContext context) {\n+            return Collections.singletonList(searchContext -> new FetchSubPhaseProcessor() {\n+                @Override\n+                public void setNextReader(LeafReaderContext readerContext) {}\n+\n+                @Override\n+                public void process(FetchSubPhase.HitContext hitContext) {\n+                    if (hitContext.hit().getId().startsWith(\"boom\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw=="}, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 126}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1673, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}