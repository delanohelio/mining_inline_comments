{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNTQ2MDk0", "number": 58808, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMToyNzowNlrOEKeNew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTo1MzowMlrOEKesuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDE2MTg3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMToyNzowNlrOGrh8kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjoyMDoxNFrOGrsyQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODEyOA==", "bodyText": "Why autoManageMasterNodes = false?", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448298128", "createdAt": "2020-07-01T11:27:06Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3NTcxMg==", "bodyText": "That was the only scenario where I was able to reproduce the failure consistently. I was missing the gateway.recover_after_data_nodes piece", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448475712", "createdAt": "2020-07-01T16:20:14Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODEyOA=="}, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDE2ODYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMToyOTowM1rOGriAsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMToyOTowM1rOGriAsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTE4NA==", "bodyText": "I think all the randomization above here is not needed and just unnecessarily making the test more complicated than need be. Just use string literals directly in the code.", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448299184", "createdAt": "2020-07-01T11:29:03Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDE3NTE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTozMToxMFrOGriEnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTozMToxMFrOGriEnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDE4OA==", "bodyText": "add a note that this restriction can be lifted when #55142 is resolved.", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448300188", "createdAt": "2020-07-01T11:31:10Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDI0MTg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTo1MzowMlrOGritNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo1MzoxMFrOGrry7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxMDU4MQ==", "bodyText": "Isn't this racing against state recovery and the actual allocation taking place? We might be adding the listener too late. Perhaps we should delay state recovery (for example by setting gateway.recover_after_data_nodes to 3 on restart, and start up a third data node after the listener is registered (on the master)).", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448310581", "createdAt": "2020-07-01T11:53:02Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = between(10, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"foo\", randomBoolean() ? \"bar\" : \"baz\"));\n+        }\n+        indexRandom(true, true, indexRequestBuilders);\n+        refresh(indexName);\n+\n+        CreateSnapshotResponse createSnapshotResponse = client().admin()\n+            .cluster()\n+            .prepareCreateSnapshot(fsRepoName, snapshotName)\n+            .setWaitForCompletion(true)\n+            .get();\n+        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo();\n+        assertThat(snapshotInfo.successfulShards(), greaterThan(0));\n+        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()));\n+\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        Settings.Builder indexSettingsBuilder = Settings.builder()\n+            .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), false)\n+            .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+        final MountSearchableSnapshotRequest req = new MountSearchableSnapshotRequest(\n+            restoredIndexName,\n+            fsRepoName,\n+            snapshotInfo.snapshotId().getName(),\n+            indexName,\n+            indexSettingsBuilder.build(),\n+            Strings.EMPTY_ARRAY,\n+            true\n+        );\n+\n+        final RestoreSnapshotResponse restoreSnapshotResponse = client().execute(MountSearchableSnapshotAction.INSTANCE, req).get();\n+        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n+\n+        ensureGreen(restoredIndexName);\n+\n+        // In order to reproduce this issue we need to force a full cluster restart so the new elected master\n+        // sends the entire ClusterState in one message, including assigned shards and repositories.\n+        internalCluster().fullRestart();\n+\n+        List<UnassignedInfo.Reason> unassignedReasons = new ArrayList<>();\n+        internalCluster().clusterService().addListener(event -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTUwMw==", "bodyText": "I wasn't aware of that setting, I'll use that approach.", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448459503", "createdAt": "2020-07-01T15:53:10Z", "author": {"login": "fcofdez"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = between(10, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"foo\", randomBoolean() ? \"bar\" : \"baz\"));\n+        }\n+        indexRandom(true, true, indexRequestBuilders);\n+        refresh(indexName);\n+\n+        CreateSnapshotResponse createSnapshotResponse = client().admin()\n+            .cluster()\n+            .prepareCreateSnapshot(fsRepoName, snapshotName)\n+            .setWaitForCompletion(true)\n+            .get();\n+        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo();\n+        assertThat(snapshotInfo.successfulShards(), greaterThan(0));\n+        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()));\n+\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        Settings.Builder indexSettingsBuilder = Settings.builder()\n+            .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), false)\n+            .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+        final MountSearchableSnapshotRequest req = new MountSearchableSnapshotRequest(\n+            restoredIndexName,\n+            fsRepoName,\n+            snapshotInfo.snapshotId().getName(),\n+            indexName,\n+            indexSettingsBuilder.build(),\n+            Strings.EMPTY_ARRAY,\n+            true\n+        );\n+\n+        final RestoreSnapshotResponse restoreSnapshotResponse = client().execute(MountSearchableSnapshotAction.INSTANCE, req).get();\n+        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n+\n+        ensureGreen(restoredIndexName);\n+\n+        // In order to reproduce this issue we need to force a full cluster restart so the new elected master\n+        // sends the entire ClusterState in one message, including assigned shards and repositories.\n+        internalCluster().fullRestart();\n+\n+        List<UnassignedInfo.Reason> unassignedReasons = new ArrayList<>();\n+        internalCluster().clusterService().addListener(event -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxMDU4MQ=="}, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2181, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}