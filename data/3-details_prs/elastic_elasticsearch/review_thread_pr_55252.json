{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzOTE1ODAy", "number": 55252, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowMTo1M1rODyaFzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowMTo1M1rODyaFzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTgyODYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SnapshotRetentionTaskTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowMTo1M1rOGGbm0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTozNDo0OFrOGGrOyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5Njk0Nw==", "bodyText": "I found this confusing, but I see it's just how getAllRetainableSnapshots does the listener callback, so maybe it's a discussion we should have on a separate ocasion", "url": "https://github.com/elastic/elasticsearch/pull/55252#discussion_r409396947", "createdAt": "2020-04-16T09:01:53Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SnapshotRetentionTaskTests.java", "diffHunk": "@@ -375,6 +384,114 @@ public void testOkToDeleteSnapshots() {\n         assertThat(SnapshotRetentionTask.okayToDeleteSnapshots(state), equalTo(true));\n     }\n \n+    public void testErrStillRunsFailureHandlerWhenRetrieving() throws Exception {\n+        ThreadPool threadPool = new TestThreadPool(\"slm-test\");\n+        final String policyId = \"policy\";\n+        final String repoId = \"repo\";\n+        try (ClusterService clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+             Client noOpClient = new NoOpClient(\"slm-test\") {\n+\n+                 @Override\n+                 @SuppressWarnings(\"unchecked\")\n+                 protected <Request extends ActionRequest, Response extends ActionResponse>\n+                 void doExecute(ActionType<Response> action, Request request, ActionListener<Response> listener) {\n+                     if (request instanceof GetSnapshotsRequest) {\n+                         logger.info(\"--> called\");\n+                         listener.onResponse((Response) new GetSnapshotsResponse(\n+                             Collections.singleton(GetSnapshotsResponse.Response.snapshots(repoId, Collections.emptyList()))));\n+                     } else {\n+                         super.doExecute(action, request, listener);\n+                     }\n+                 }\n+             }) {\n+            SnapshotLifecyclePolicy policy = new SnapshotLifecyclePolicy(policyId, \"snap\", \"1 * * * * ?\",\n+                repoId, null, new SnapshotRetentionConfiguration(TimeValue.timeValueDays(30), null, null));\n+\n+            ClusterState state = createState(policy);\n+            ClusterServiceUtils.setState(clusterService, state);\n+\n+            SnapshotRetentionTask task = new SnapshotRetentionTask(noOpClient, clusterService,\n+                System::nanoTime,\n+                new SnapshotLifecycleTaskTests.VerifyingHistoryStore(noOpClient, ZoneOffset.UTC,\n+                    (historyItem) -> fail(\"should never write history\")),\n+                threadPool);\n+\n+            AtomicReference<Exception> errHandlerCalled = new AtomicReference<>(null);\n+            task.getAllRetainableSnapshots(Collections.singleton(repoId), new ActionListener<>() {\n+                @Override\n+                public void onResponse(Map<String, List<SnapshotInfo>> stringListMap) {\n+                    logger.info(\"--> forcing failure\");\n+                    throw new ElasticsearchException(\"forced failure\");\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"we have another err handler that should have been called\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8e19cedb97df2b05d4fbb6a3e262ec8239d2de3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY1MjkzOA==", "bodyText": "Yeah, we can do that maybe in future work since it's technically not really a bugfix.", "url": "https://github.com/elastic/elasticsearch/pull/55252#discussion_r409652938", "createdAt": "2020-04-16T15:34:48Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SnapshotRetentionTaskTests.java", "diffHunk": "@@ -375,6 +384,114 @@ public void testOkToDeleteSnapshots() {\n         assertThat(SnapshotRetentionTask.okayToDeleteSnapshots(state), equalTo(true));\n     }\n \n+    public void testErrStillRunsFailureHandlerWhenRetrieving() throws Exception {\n+        ThreadPool threadPool = new TestThreadPool(\"slm-test\");\n+        final String policyId = \"policy\";\n+        final String repoId = \"repo\";\n+        try (ClusterService clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+             Client noOpClient = new NoOpClient(\"slm-test\") {\n+\n+                 @Override\n+                 @SuppressWarnings(\"unchecked\")\n+                 protected <Request extends ActionRequest, Response extends ActionResponse>\n+                 void doExecute(ActionType<Response> action, Request request, ActionListener<Response> listener) {\n+                     if (request instanceof GetSnapshotsRequest) {\n+                         logger.info(\"--> called\");\n+                         listener.onResponse((Response) new GetSnapshotsResponse(\n+                             Collections.singleton(GetSnapshotsResponse.Response.snapshots(repoId, Collections.emptyList()))));\n+                     } else {\n+                         super.doExecute(action, request, listener);\n+                     }\n+                 }\n+             }) {\n+            SnapshotLifecyclePolicy policy = new SnapshotLifecyclePolicy(policyId, \"snap\", \"1 * * * * ?\",\n+                repoId, null, new SnapshotRetentionConfiguration(TimeValue.timeValueDays(30), null, null));\n+\n+            ClusterState state = createState(policy);\n+            ClusterServiceUtils.setState(clusterService, state);\n+\n+            SnapshotRetentionTask task = new SnapshotRetentionTask(noOpClient, clusterService,\n+                System::nanoTime,\n+                new SnapshotLifecycleTaskTests.VerifyingHistoryStore(noOpClient, ZoneOffset.UTC,\n+                    (historyItem) -> fail(\"should never write history\")),\n+                threadPool);\n+\n+            AtomicReference<Exception> errHandlerCalled = new AtomicReference<>(null);\n+            task.getAllRetainableSnapshots(Collections.singleton(repoId), new ActionListener<>() {\n+                @Override\n+                public void onResponse(Map<String, List<SnapshotInfo>> stringListMap) {\n+                    logger.info(\"--> forcing failure\");\n+                    throw new ElasticsearchException(\"forced failure\");\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"we have another err handler that should have been called\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5Njk0Nw=="}, "originalCommit": {"oid": "f8e19cedb97df2b05d4fbb6a3e262ec8239d2de3"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1055, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}