{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNDk2MzIy", "number": 53860, "title": "Uncouple CacheDirectory from SearchableSnapshotDirectory", "bodyText": "Today CacheDirectory is implemented as a FilterDirectory that caches files locally while delegating the read operations to SearchableSnapshotDirectory.\nThis was very useful to separate concerns like caching Lucene files on disk from reading Lucene files from a blob store repository, but it comes with additional complexity:\n\nIndexInput are buffered within each directory, making it difficult to understand the reading pattern\nin case of cache evictions, the CacheDirectory attempts to directly read N bytes from the IndexInput but because of the SearchableSnapshotDirectory read ahead it might in fact download more bytes than needed\nthe direct read bytes stat does not exactly reflect the bytes read by the underlying BlobContainer\nchanges like #53492 are a bit more complex than necessary\n\nThis pull request is a first step forward merging CacheDirectory into SearchableSnapshotDirectory. It changes the cache directory so that it does not rely on the searchable snapshot directory anymore and instead read the bytes directly from the BlobContainer. It also adds two more base classes that group common class attributes for directories and index inputs.", "createdAt": "2020-03-20T12:04:23Z", "url": "https://github.com/elastic/elasticsearch/pull/53860", "merged": true, "mergeCommit": {"oid": "8c732d094a9a95718c74a973d3ccbf1037004bab"}, "closed": true, "closedAt": "2020-03-20T14:58:19Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPd9umgH2gAyMzkxNDk2MzIyOjYxYzg5MDc4MGU3NDZkYmM5YWEwNTBhMGU3NzY5MDhiOGM3ZWJmZjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPhw6FAFqTM3ODU1NDM2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/61c890780e746dbc9aa050a0e776908b8c7ebff3", "committedDate": "2020-03-20T10:29:37Z", "message": "CacheDirectory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDI2NzYx", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378426761", "createdAt": "2020-03-20T12:06:06Z", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowNjowN1rOF5RGhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowNjowN1rOF5RGhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5MzM1MA==", "bodyText": "This abstract class has been introduced in order to contain common attributes of existing directories and in order to unify the existing constructors. It should become a concrete SearchableSnapshotDirectory when the cache logic and the searchable snapshot logic will be merged together.", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395593350", "createdAt": "2020-03-20T12:06:07Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BaseDirectory;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.store.SingleInstanceLockFactory;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public abstract class BaseSearchableSnapshotDirectory extends BaseDirectory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDI3NjQ1", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378427645", "createdAt": "2020-03-20T12:07:44Z", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowNzo0NFrOF5RJRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowNzo0NFrOF5RJRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDA1NQ==", "bodyText": "With this pull request, CacheDirectory reads blobs using the BlobContainer and does not need to wrap the SearchableSnapshotDirectory anymore.", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395594055", "createdAt": "2020-03-20T12:07:44Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -158,11 +79,13 @@ public static Directory create(RepositoriesService repositories,\n             SNAPSHOT_SNAPSHOT_ID_SETTING.get(indexSettings.getSettings()));\n         final BlobStoreIndexShardSnapshot snapshot = blobStoreRepository.loadShardSnapshot(blobContainer, snapshotId);\n \n-        Directory directory = new SearchableSnapshotDirectory(snapshot, blobContainer);\n+        final Directory directory;\n         if (SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings.getSettings())) {\n             final Path cacheDir = shardPath.getDataPath().resolve(\"snapshots\").resolve(snapshotId.getUUID());\n-            directory = new CacheDirectory(directory, cache, cacheDir, snapshotId, indexId, shardPath.getShardId(),\n+            directory = new CacheDirectory(snapshot, blobContainer, cache, cacheDir, snapshotId, indexId, shardPath.getShardId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDI3ODc4", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378427878", "createdAt": "2020-03-20T12:08:08Z", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowODowOFrOF5RKEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowODowOFrOF5RKEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDI1OQ==", "bodyText": "I'll revert this spotless formatting", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395594259", "createdAt": "2020-03-20T12:08:08Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotIndexInput.java", "diffHunk": "@@ -61,17 +60,21 @@\n     private static final long NO_SEQUENTIAL_READ_OPTIMIZATION = 0L;\n \n \n-    SearchableSnapshotIndexInput(final BlobContainer blobContainer, final FileInfo fileInfo, long sequentialReadSize, int bufferSize) {\n-        this(\"SearchableSnapshotIndexInput(\" + fileInfo.physicalName() + \")\", blobContainer, fileInfo, 0L, 0L, fileInfo.length(),\n+    SearchableSnapshotIndexInput(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDI4MTg4", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378428188", "createdAt": "2020-03-20T12:08:37Z", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowODozN1rOF5RLGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjowODozN1rOF5RLGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDUyMg==", "bodyText": "This is the main purpose of this pull request :)", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395594522", "createdAt": "2020-03-20T12:08:37Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -39,7 +43,7 @@\n /**\n  * {@link CacheDirectory} uses a {@link CacheService} to cache Lucene files provided by another {@link Directory}.\n  */\n-public class CacheDirectory extends FilterDirectory {\n+public class CacheDirectory extends BaseSearchableSnapshotDirectory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDI5ODc3", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378429877", "createdAt": "2020-03-20T12:11:24Z", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjoxMToyNVrOF5RQQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjoxMToyNVrOF5RQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NTg0MQ==", "bodyText": "There is an important change here: by reading the range to cache on disk using the BlobContainer only the required bytes are downloaded in a (usually) single request (unless the range spans over multiple blob parts) and there is no read ahead engaged here.", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395595841", "createdAt": "2020-03-20T12:11:25Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -287,23 +293,21 @@ int readCacheFile(FileChannel fc, long end, long position, byte[] buffer, int of\n         @SuppressForbidden(reason = \"Use positional writes on purpose\")\n         void writeCacheFile(FileChannel fc, long start, long end) throws IOException {\n             assert assertFileChannelOpen(fc);\n-            final byte[] copyBuffer = new byte[Math.toIntExact(Math.min(COPY_BUFFER_SIZE, end - start))];\n+            final long length = end - start;\n+            final byte[] copyBuffer = new byte[Math.toIntExact(Math.min(COPY_BUFFER_SIZE, length))];\n             logger.trace(() -> new ParameterizedMessage(\"writing range [{}-{}] to cache file [{}]\", start, end, cacheFileReference));\n \n             int bytesCopied = 0;\n-            try (IndexInput input = in.openInput(cacheFileReference.getFileName(), ioContext)) {\n+            final long startTimeNanos = currentTimeNanosSupplier.getAsLong();\n+            try (InputStream input = openInputStream(start, length)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fa4928481988f2ad00463c319515a784cecc3be", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/6fa4928481988f2ad00463c319515a784cecc3be", "committedDate": "2020-03-20T12:56:39Z", "message": "Merge branch 'feature/searchable-snapshots' into cache-directory-use-blob-container"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDQ1NjU2", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378445656", "createdAt": "2020-03-20T12:37:46Z", "commit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjozNzo0NlrOF5SAYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzowMzozN1rOF5Sy7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwODE2MQ==", "bodyText": "Can we assert false here too?", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395608161", "createdAt": "2020-03-20T12:37:46Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BaseDirectory;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.store.SingleInstanceLockFactory;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public abstract class BaseSearchableSnapshotDirectory extends BaseDirectory {\n+\n+    protected final BlobStoreIndexShardSnapshot snapshot;\n+    protected final BlobContainer blobContainer;\n+    private final AtomicBoolean closed;\n+\n+    public BaseSearchableSnapshotDirectory(BlobContainer blobContainer, BlobStoreIndexShardSnapshot snapshot) {\n+        super(new SingleInstanceLockFactory());\n+        this.snapshot = Objects.requireNonNull(snapshot);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.closed = new AtomicBoolean(false);\n+    }\n+\n+    protected final FileInfo fileInfo(final String name) throws FileNotFoundException {\n+        return snapshot.indexFiles()\n+            .stream()\n+            .filter(fileInfo -> fileInfo.physicalName().equals(name))\n+            .findFirst()\n+            .orElseThrow(() -> new FileNotFoundException(name));\n+    }\n+\n+    @Override\n+    public final String[] listAll() {\n+        ensureOpen();\n+        return snapshot.indexFiles().stream().map(FileInfo::physicalName).sorted(String::compareTo).toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public final long fileLength(final String name) throws IOException {\n+        ensureOpen();\n+        return fileInfo(name).length();\n+    }\n+\n+    @Override\n+    public Set<String> getPendingDeletions() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void sync(Collection<String> names) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void syncMetaData() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void deleteFile(String name) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createOutput(String name, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void rename(String source, String dest) {\n+        throw unsupportedException();\n+    }\n+\n+    private static UnsupportedOperationException unsupportedException() {\n+        return new UnsupportedOperationException(\"Searchable snapshot directory does not support this operation\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwOTU5NA==", "bodyText": "Could we do this already? Seems like it'd be nicer to use a ByteArrayIndexInput straight away.", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395609594", "createdAt": "2020-03-20T12:40:49Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BufferedIndexInput;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+import org.elasticsearch.index.snapshots.blobstore.SlicedInputStream;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Objects;\n+\n+public abstract class BaseSearchableSnapshotIndexInput extends BufferedIndexInput {\n+\n+    protected final BlobContainer blobContainer;\n+    protected final FileInfo fileInfo;\n+    protected final IOContext context;\n+\n+    public BaseSearchableSnapshotIndexInput(String resourceDesc, BlobContainer blobContainer, FileInfo fileInfo, IOContext context) {\n+        super(resourceDesc, context);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.fileInfo = Objects.requireNonNull(fileInfo);\n+        this.context = Objects.requireNonNull(context);\n+    }\n+\n+    public BaseSearchableSnapshotIndexInput(\n+        String resourceDesc,\n+        BlobContainer blobContainer,\n+        FileInfo fileInfo,\n+        IOContext context,\n+        int bufferSize\n+    ) {\n+        this(resourceDesc, blobContainer, fileInfo, context);\n+        setBufferSize(bufferSize);\n+    }\n+\n+    protected InputStream openInputStream(final long position, final long length) throws IOException {\n+        // TODO move this at the Directory level", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxODIzMQ==", "bodyText": "Can we assert that this isn't called and throw UnsupportedOperationException if it is? getBlobLength() looks expensive, and I don't think we actually call this do we?", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395618231", "createdAt": "2020-03-20T12:58:00Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheBufferedIndexInputTests.java", "diffHunk": "@@ -56,145 +69,110 @@ public void testRandomReads() throws IOException {\n                     }\n                 }\n \n-                if (directory instanceof CountingDirectory) {\n+                if (blobContainer instanceof CountingBlobContainer) {\n                     long numberOfRanges = numberOfRanges(input.length, cacheService.getRangeSize());\n                     assertThat(\"Expected \" + numberOfRanges + \" ranges fetched from the source\",\n-                        ((CountingDirectory) directory).totalOpens.sum(), equalTo(numberOfRanges));\n+                        ((CountingBlobContainer) blobContainer).totalOpens.sum(), equalTo(numberOfRanges));\n                     assertThat(\"All bytes should have been read from source\",\n-                        ((CountingDirectory) directory).totalBytes.sum(), equalTo((long) input.length));\n+                        ((CountingBlobContainer) blobContainer).totalBytes.sum(), equalTo((long) input.length));\n                 }\n-\n-                directory.close();\n             }\n         }\n     }\n \n-    /**\n-     * FilterDirectory that provides a single IndexInput with a given name and content.\n-     */\n-    private static class SingleFileDirectory  extends FilterDirectory {\n-\n-        private final String fileName;\n-        private final byte[] fileContent;\n-\n-        SingleFileDirectory(final String fileName, final byte[] fileContent) {\n-            super(null);\n-            this.fileName = Objects.requireNonNull(fileName);\n-            this.fileContent = Objects.requireNonNull(fileContent);\n-        }\n-\n-        @Override\n-        public String[] listAll() {\n-            return new String[]{fileName};\n-        }\n-\n-        @Override\n-        public long fileLength(String name) throws IOException {\n-            if (name.equals(fileName)) {\n-                return fileContent.length;\n-            }\n-            throw new FileNotFoundException(name);\n-        }\n-\n-        @Override\n-        public IndexInput openInput(String name, IOContext context) throws IOException {\n-            if (name.equals(fileName)) {\n-                return new ByteArrayIndexInput(fileName, fileContent);\n-            }\n-            throw new FileNotFoundException(name);\n-        }\n-\n-        @Override\n-        public void close() {\n-        }\n-    }\n \n     /**\n-     * FilterDirectory that counts the number of IndexInput it opens, as well as the\n+     * BlobContainer that counts the number of {@link java.io.InputStream} it opens, as well as the\n      * total number of bytes read from them.\n      */\n-    private static class CountingDirectory extends FilterDirectory {\n+    private static class CountingBlobContainer extends BlobContainerWrapper {\n \n         private final LongAdder totalBytes = new LongAdder();\n         private final LongAdder totalOpens = new LongAdder();\n \n         private final int rangeSize;\n \n-        CountingDirectory(Directory in, int rangeSize) {\n+        CountingBlobContainer(BlobContainer in, int rangeSize) {\n             super(in);\n             this.rangeSize = rangeSize;\n         }\n \n         @Override\n-        public IndexInput openInput(String name, IOContext context) throws IOException {\n-            return new CountingIndexInput(this, super.openInput(name, context), rangeSize);\n+        public InputStream readBlob(String name) throws IOException {\n+            return new CountingInputStream(this, super.readBlob(name), getBlobLength(name), rangeSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxOTk1Nw==", "bodyText": "This is only used if index.store.snapshot.cache.enabled is false. Maybe we can remove that setting and this whole class?", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395619957", "createdAt": "2020-03-20T13:01:16Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -50,95 +42,24 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseDirectory {\n-\n-    private final BlobStoreIndexShardSnapshot snapshot;\n-    private final BlobContainer blobContainer;\n+public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fa4928481988f2ad00463c319515a784cecc3be"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyMDQ5OA==", "bodyText": "I for one welcome our new spotless overlords \ud83d\udc1c", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395620498", "createdAt": "2020-03-20T13:02:19Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotIndexInput.java", "diffHunk": "@@ -61,17 +60,21 @@\n     private static final long NO_SEQUENTIAL_READ_OPTIMIZATION = 0L;\n \n \n-    SearchableSnapshotIndexInput(final BlobContainer blobContainer, final FileInfo fileInfo, long sequentialReadSize, int bufferSize) {\n-        this(\"SearchableSnapshotIndexInput(\" + fileInfo.physicalName() + \")\", blobContainer, fileInfo, 0L, 0L, fileInfo.length(),\n+    SearchableSnapshotIndexInput(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDI1OQ=="}, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYyMTEwMQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395621101", "createdAt": "2020-03-20T13:03:37Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -287,23 +293,21 @@ int readCacheFile(FileChannel fc, long end, long position, byte[] buffer, int of\n         @SuppressForbidden(reason = \"Use positional writes on purpose\")\n         void writeCacheFile(FileChannel fc, long start, long end) throws IOException {\n             assert assertFileChannelOpen(fc);\n-            final byte[] copyBuffer = new byte[Math.toIntExact(Math.min(COPY_BUFFER_SIZE, end - start))];\n+            final long length = end - start;\n+            final byte[] copyBuffer = new byte[Math.toIntExact(Math.min(COPY_BUFFER_SIZE, length))];\n             logger.trace(() -> new ParameterizedMessage(\"writing range [{}-{}] to cache file [{}]\", start, end, cacheFileReference));\n \n             int bytesCopied = 0;\n-            try (IndexInput input = in.openInput(cacheFileReference.getFileName(), ioContext)) {\n+            final long startTimeNanos = currentTimeNanosSupplier.getAsLong();\n+            try (InputStream input = openInputStream(start, length)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NTg0MQ=="}, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDkyOTgz", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378492983", "createdAt": "2020-03-20T13:43:34Z", "commit": {"oid": "6fa4928481988f2ad00463c319515a784cecc3be"}, "state": "DISMISSED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0MzozNFrOF5UNXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0NDowOFrOF5UO4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDI1NA==", "bodyText": "We discussed this in another channel and decided to leave it for a followup in which we consolidate how we choose between all the different IndexInput implementations.", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395644254", "createdAt": "2020-03-20T13:43:34Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotIndexInput.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.index.store;\n+\n+import org.apache.lucene.store.BufferedIndexInput;\n+import org.apache.lucene.store.IOContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n+import org.elasticsearch.index.snapshots.blobstore.SlicedInputStream;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Objects;\n+\n+public abstract class BaseSearchableSnapshotIndexInput extends BufferedIndexInput {\n+\n+    protected final BlobContainer blobContainer;\n+    protected final FileInfo fileInfo;\n+    protected final IOContext context;\n+\n+    public BaseSearchableSnapshotIndexInput(String resourceDesc, BlobContainer blobContainer, FileInfo fileInfo, IOContext context) {\n+        super(resourceDesc, context);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.fileInfo = Objects.requireNonNull(fileInfo);\n+        this.context = Objects.requireNonNull(context);\n+    }\n+\n+    public BaseSearchableSnapshotIndexInput(\n+        String resourceDesc,\n+        BlobContainer blobContainer,\n+        FileInfo fileInfo,\n+        IOContext context,\n+        int bufferSize\n+    ) {\n+        this(resourceDesc, blobContainer, fileInfo, context);\n+        setBufferSize(bufferSize);\n+    }\n+\n+    protected InputStream openInputStream(final long position, final long length) throws IOException {\n+        // TODO move this at the Directory level", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYwOTU5NA=="}, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDUyMg==", "bodyText": "We discussed this in another channel and agreed to defer this to a followup.", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395644522", "createdAt": "2020-03-20T13:43:58Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -50,95 +42,24 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseDirectory {\n-\n-    private final BlobStoreIndexShardSnapshot snapshot;\n-    private final BlobContainer blobContainer;\n+public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxOTk1Nw=="}, "originalCommit": {"oid": "6fa4928481988f2ad00463c319515a784cecc3be"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDY0MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/53860#discussion_r395644641", "createdAt": "2020-03-20T13:44:08Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -158,11 +79,13 @@ public static Directory create(RepositoriesService repositories,\n             SNAPSHOT_SNAPSHOT_ID_SETTING.get(indexSettings.getSettings()));\n         final BlobStoreIndexShardSnapshot snapshot = blobStoreRepository.loadShardSnapshot(blobContainer, snapshotId);\n \n-        Directory directory = new SearchableSnapshotDirectory(snapshot, blobContainer);\n+        final Directory directory;\n         if (SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings.getSettings())) {\n             final Path cacheDir = shardPath.getDataPath().resolve(\"snapshots\").resolve(snapshotId.getUUID());\n-            directory = new CacheDirectory(directory, cache, cacheDir, snapshotId, indexId, shardPath.getShardId(),\n+            directory = new CacheDirectory(snapshot, blobContainer, cache, cacheDir, snapshotId, indexId, shardPath.getShardId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NDA1NQ=="}, "originalCommit": {"oid": "61c890780e746dbc9aa050a0e776908b8c7ebff3"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDk2MTg0", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378496184", "createdAt": "2020-03-20T13:47:18Z", "commit": {"oid": "6fa4928481988f2ad00463c319515a784cecc3be"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e62549aa974de96e50464f0e5f74c1a335a0b9e1", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/e62549aa974de96e50464f0e5f74c1a335a0b9e1", "committedDate": "2020-03-20T13:52:25Z", "message": "apply feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTU0MzYy", "url": "https://github.com/elastic/elasticsearch/pull/53860#pullrequestreview-378554362", "createdAt": "2020-03-20T14:55:14Z", "commit": {"oid": "e62549aa974de96e50464f0e5f74c1a335a0b9e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1895, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}