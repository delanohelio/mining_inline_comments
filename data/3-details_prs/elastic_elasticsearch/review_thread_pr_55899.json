{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMzkyNTQz", "number": 55899, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODo1MToxMVrOD3iNvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTo1NzozN1rOD3x4rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTU4ODQ0OnYy", "diffSide": "RIGHT", "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODo1MToxMVrOGN1iTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzozODoxNFrOGN_O1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTgwNw==", "bodyText": "I think we should remove recursion here altogether, that way we can avoid stack overflows without using additional threads and context switching. As this is tail recursion it is fairly easy and straightforward:\npublic String toRegex(String grokPattern) {\n    StringBuilder res= new StringBuilder();\n    while (true) {\n        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n\n        int result;\n        try {\n            matcherWatchdog.register(matcher);\n            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n        } finally {\n            matcherWatchdog.unregister(matcher);\n        }\n\n        if (result < 0) {\n            return res.append(grokPattern).toString();\n        }\n\n        Region region = matcher.getEagerRegion();\n        String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n        String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);// TODO(tal): Support definitions\n        @SuppressWarnings(\"unused\")\n        String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n        String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n        String pattern = patternBank.get(patternName);\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"Unable to find pattern [\" + patternName + \"] in Grok's pattern dictionary\");\n        }\n        if (pattern.contains(\"%{\" + patternName + \"}\") || pattern.contains(\"%{\" + patternName + \":\")) {\n            throw new IllegalArgumentException(\"circular reference in pattern back [\" + patternName + \"]\");\n        }\n        String grokPart;\n        if (namedCaptures && subName != null) {\n            grokPart = String.format(Locale.US, \"(?<%s>%s)\", namedPatternRef, pattern);\n        } else if (namedCaptures) {\n            grokPart = String.format(Locale.US, \"(?:%s)\", pattern);\n        } else {\n            grokPart = String.format(Locale.US, \"(?<%s>%s)\", patternName + \"_\" + result, pattern);\n        }\n        String start = new String(grokPatternBytes, 0, result, StandardCharsets.UTF_8);\n        String rest = new String(grokPatternBytes, region.end[0], grokPatternBytes.length - region.end[0], StandardCharsets.UTF_8);\n        grokPattern = grokPart+rest;\n        res.append(start);\n    }\n}", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417161807", "createdAt": "2020-04-29T08:51:11Z", "author": {"login": "probakowski"}, "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -162,49 +164,63 @@ public String groupMatch(String name, Region region, String pattern) {\n      *\n      * @return named regex expression\n      */\n-    public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n-\n-        int result;\n-        try {\n-            matcherWatchdog.register(matcher);\n-            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n-        } finally {\n-            matcherWatchdog.unregister(matcher);\n-        }\n-        if (result >= 0) {\n-            Region region = matcher.getEagerRegion();\n-            String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n-            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n-            // TODO(tal): Support definitions\n-            @SuppressWarnings(\"unused\")\n-            String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n-            String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n+    public String toRegex(String grokPattern, int recurseCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ebfd4cfc02eed53e6bbd09a22a20dae56e9389"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyMDY2MA==", "bodyText": "thanks @probakowski I will switch the implementation based on this.", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417320660", "createdAt": "2020-04-29T13:38:14Z", "author": {"login": "jakelandis"}, "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -162,49 +164,63 @@ public String groupMatch(String name, Region region, String pattern) {\n      *\n      * @return named regex expression\n      */\n-    public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n-\n-        int result;\n-        try {\n-            matcherWatchdog.register(matcher);\n-            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n-        } finally {\n-            matcherWatchdog.unregister(matcher);\n-        }\n-        if (result >= 0) {\n-            Region region = matcher.getEagerRegion();\n-            String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n-            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n-            // TODO(tal): Support definitions\n-            @SuppressWarnings(\"unused\")\n-            String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n-            String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n+    public String toRegex(String grokPattern, int recurseCount) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTgwNw=="}, "originalCommit": {"oid": "b9ebfd4cfc02eed53e6bbd09a22a20dae56e9389"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODE1MzgzOnYy", "diffSide": "RIGHT", "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTo1NzowMFrOGOOsZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTo1NzowMFrOGOOsZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3Mzk4OQ==", "bodyText": "consider changing this to for loop instead of while and moving exception to the end of the method\nfor (int i = 0; i < MAX_TO_REGEX_ITERATIONS; i++) {\n    ...\n}\nthrow new IllegalArgumentException(\"Can not convert grok patterns to regular expression\");", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417573989", "createdAt": "2020-04-29T19:57:00Z", "author": {"login": "probakowski"}, "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -163,48 +164,53 @@ public String groupMatch(String name, Region region, String pattern) {\n      * @return named regex expression\n      */\n     public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n+        StringBuilder res = new StringBuilder();\n+        int i = 0;\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13266fdc89322f8307dd77c5453d1cea8044fa0d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODE1NTk3OnYy", "diffSide": "RIGHT", "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTo1NzozN1rOGOOtwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTo1NzozN1rOGOOtwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3NDMzOA==", "bodyText": "This TODO should be moved to new line like it was before (sorry, this was unintentional change in my comment)", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417574338", "createdAt": "2020-04-29T19:57:37Z", "author": {"login": "probakowski"}, "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -163,48 +164,53 @@ public String groupMatch(String name, Region region, String pattern) {\n      * @return named regex expression\n      */\n     public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n+        StringBuilder res = new StringBuilder();\n+        int i = 0;\n+        while (true) {\n+            if (i++ >= MAX_TO_REGEX_ITERATIONS) {\n+                throw new IllegalArgumentException(\"Can not convert grok patterns to regular expression\");\n+            }\n+            byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n+            Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n+\n+            int result;\n+            try {\n+                matcherWatchdog.register(matcher);\n+                result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n+            } finally {\n+                matcherWatchdog.unregister(matcher);\n+            }\n+\n+            if (result < 0) {\n+                return res.append(grokPattern).toString();\n+            }\n \n-        int result;\n-        try {\n-            matcherWatchdog.register(matcher);\n-            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n-        } finally {\n-            matcherWatchdog.unregister(matcher);\n-        }\n-        if (result >= 0) {\n             Region region = matcher.getEagerRegion();\n             String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n-            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n-            // TODO(tal): Support definitions\n+            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);// TODO(tal): Support definitions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13266fdc89322f8307dd77c5453d1cea8044fa0d"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2491, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}