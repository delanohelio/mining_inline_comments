{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNDcyNDQ3", "number": 53851, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDo0NTo0MFrODp5Wig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1ODoxM1rODqXZTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjU3ODY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDo0NTo0MFrOF5WrGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDo0NTo0MFrOF5WrGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NDYzMg==", "bodyText": "We should normalize all term-based query like  KeywordFieldType.\nAlso @cbuescher added the support in StringFieldType to mask special characters (*)  during normalization so we should reuse here ?", "url": "https://github.com/elastic/elasticsearch/pull/53851#discussion_r395684632", "createdAt": "2020-03-20T14:45:40Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "diffHunk": "@@ -327,6 +376,12 @@ public boolean equals(Object obj) {\n \n         @Override\n         public Query wildcardQuery(String wildcardPattern, RewriteMethod method, QueryShardContext context) {\n+            try {\n+                wildcardPattern = normalize(wildcardPattern);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffc75372aa6ef5462903a3b2a22c84b352cce806"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzQ5ODI5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1NzozMlrOF6ELNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1NzozMlrOF6ELNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzMDEzMw==", "bodyText": "Can we try to expose something reusable (a static function ?) in StringFieldType ?", "url": "https://github.com/elastic/elasticsearch/pull/53851#discussion_r396430133", "createdAt": "2020-03-23T12:57:32Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "diffHunk": "@@ -467,7 +526,63 @@ public Query termsQuery(List<?> values, QueryShardContext context) {\n                         CircuitBreakerService breakerService, MapperService mapperService) {\n                     return new WildcardBytesBinaryDVIndexFieldData(indexSettings.getIndex(), fieldType.name());\n                 }};\n-        }        \n+        }\n+\n+\n+        String normalize(String value) throws IOException {\n+            if (normalizer != null) {\n+                try (TokenStream ts = normalizer.tokenStream(name(), value)) {\n+                    final CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n+                    ts.reset();\n+                    if (ts.incrementToken() == false) {\n+                      throw new IllegalStateException(\"The normalization token stream is \"\n+                          + \"expected to produce exactly 1 token, but got 0 for analyzer \"\n+                          + normalizer + \" and input \\\"\" + value + \"\\\"\");\n+                    }\n+                    final String newValue = termAtt.toString();\n+                    if (ts.incrementToken()) {\n+                      throw new IllegalStateException(\"The normalization token stream is \"\n+                          + \"expected to produce exactly 1 token, but got 2+ for analyzer \"\n+                          + normalizer + \" and input \\\"\" + value + \"\\\"\");\n+                    }\n+                    ts.end();\n+                    return newValue;\n+                }\n+            }\n+            return value;\n+        }       \n+        \n+        private static final Pattern WILDCARD_PATTERN = Pattern.compile(\"(\\\\\\\\.)|([?*]+)\");\n+        \n+        String normalizeWildcardPattern(String value) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3172c32cb993713af9aec45046fde365a3a3fa"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzUwMDkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1ODoxM1rOF6EM1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1ODoxM1rOF6EM1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzMDU0OA==", "bodyText": "You also need to override checkCompatibility in order to ensure that the normalizer doesn't change ?", "url": "https://github.com/elastic/elasticsearch/pull/53851#discussion_r396430548", "createdAt": "2020-03-23T12:58:13Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "diffHunk": "@@ -206,13 +235,37 @@ public WildcardFieldType() {\n \n         protected WildcardFieldType(WildcardFieldType ref) {\n             super(ref);\n+            this.normalizer = ref.normalizer;\n         }\n \n         public WildcardFieldType clone() {\n             WildcardFieldType result = new WildcardFieldType(this);\n             return result;\n         }\n         \n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (super.equals(o) == false) {\n+                return false;\n+            }\n+            WildcardFieldType other = (WildcardFieldType) o;\n+            return Objects.equals(normalizer, other.normalizer);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 31 * super.hashCode() + Objects.hash(normalizer);\n+        }       \n+        \n+        private NamedAnalyzer normalizer() {\n+            return normalizer;\n+        }\n+\n+        public void setNormalizer(NamedAnalyzer normalizer) {\n+            checkIfFrozen();\n+            this.normalizer = normalizer;\n+        }                \n                 ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3172c32cb993713af9aec45046fde365a3a3fa"}, "originalPosition": 118}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4264, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}