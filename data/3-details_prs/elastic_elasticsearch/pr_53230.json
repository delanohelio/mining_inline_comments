{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODkxODIy", "number": 53230, "title": "Enrich documents with inference results at Fetch", "bodyText": "Why here\nSearch hits can be modified at fetch with new fields added. Fetch sub phases run the on the data node so additional features used by the model can be extracted from Lucene.\nConfiguration\nThere isn't a direct way of configuring FetchSubPhases so I have commandeered SearchExtSpec for the purpose. The ext spec is accessible via the SearchContext passed to the fetch sub phase. Parsed here SearchExtSpecs come under the \"ext\" field forcing this rather clunky nested config upon us:\n    \"query\": { },\n    \"ext\": {\n        \"ml_inference\" : {\n            \"model_id\" : \"an_inference_model\",\n            \"target_field\" : \"ml_results_field\",\n            \"field_mappings\": {\"doc_field_name\": \"name_expected_by_model\"},\n            \"inference_config\": {\n                \"classification\": {\n                      \"num_top_classes\": 1\n                }\n            }\n        }\n    }\n\nThe usual config options apply.\nModifying the Search Hit\nThe goal is to append a field to each search hit with the inference result. I see 2 options for doing so:\n\nModify the document source\nAdd a DocumentField. The new field will appear under the fields section of the search hit as if it had been asked for in the search request via docvalue_fields\n\nI've opted for the 2nd choice as modifying the source seems a little underhand. Again this is awkward putting the result where we would expect doc value fields, depending on the outcome of #49028 the future may offer another way to add fields to the search hit.\n\"hits\" : [\n {\n   \"_index\" : \"store\",\n   \"_id\" : \"NIxgsHABziobK4pvOW_2\",\n   \"_score\" : 0.52354836,\n   \"_source\" : {\n        ...\n   },\n   \"fields\" : {           <-- Usually doc value fields\n     \"ml_results_field\" : [\n       {\n         \"top_classes\" : [\n           {\n             \"class_name\" : \"hot dog\",\n             \"class_probability\" : 0.99,\n             \"class_score\" : 1.0\n           }\n         ],\n         \"predicted_value\" : \"hot dog\"\n       }\n     ]\n   }\n },\n\nThe Problem\nThe InferencePhase class has access to the ModelLoadingService which neatly deals with the model caching problem but there is still a blocking call to load the model (which may or not be cached) the first time InferencePhase.hitsExecute(SearchContext, SearchHit[]) is called.\nWish List\n\nA way to configure the fetch phase without nesting it inside the \"ext\" field\n\nWhy Here (Reprise)\nExecuting locally on the data node has the advantage of being close to any shard level features we want extract and use in inference. But it now occurs to me that those features could be extracted in a fetch sub phase and returned with the hit. Inference would then run on the coordinating node and the blocking call to load the model could be dropped.\nThis PR is raised against the feature branch feature/search-inference", "createdAt": "2020-03-06T15:50:44Z", "url": "https://github.com/elastic/elasticsearch/pull/53230", "merged": true, "mergeCommit": {"oid": "54fb29fbc3fdc720ac5506cd88cec4db90069ca7"}, "closed": true, "closedAt": "2020-03-11T10:15:32Z", "author": {"login": "davidkyle"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcL8XISgBqjMxMTAyNTM1Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMXzheAFqTM3MjI2MjEyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c29d66b692fde7fb3d9bb9ed459c3181f55e336", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c29d66b692fde7fb3d9bb9ed459c3181f55e336", "committedDate": "2020-03-06T13:33:19Z", "message": "add disclaimer"}, "afterCommit": {"oid": "333ba97db0bdb6819a70e966d3d6014fbae654e7", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/333ba97db0bdb6819a70e966d3d6014fbae654e7", "committedDate": "2020-03-09T11:38:31Z", "message": "add disclaimer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "989c21577dd90c1dae47beff96337e6ef7b3a3c9", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/989c21577dd90c1dae47beff96337e6ef7b3a3c9", "committedDate": "2020-03-09T19:11:20Z", "message": "Blacklist tests that fail security checks"}, "afterCommit": {"oid": "0d3aa044392420cdb0c9f751aa4db3c94f915658", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/0d3aa044392420cdb0c9f751aa4db3c94f915658", "committedDate": "2020-03-10T11:04:59Z", "message": "Blacklist tests that fail security checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cdea63e53040fa73c33a8ace4b71f11070a99d4", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/1cdea63e53040fa73c33a8ace4b71f11070a99d4", "committedDate": "2020-03-10T12:37:47Z", "message": "Sketch out how to pass a service to a FetchSubPhase."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5e61c434101885fbbe3e8b592131a600d8f2af5", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5e61c434101885fbbe3e8b592131a600d8f2af5", "committedDate": "2020-03-10T12:37:47Z", "message": "Make sure to lazily access ModelLoadingService."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6b27255905b69d9b6a9a19aff00071928a05ad2", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/f6b27255905b69d9b6a9a19aff00071928a05ad2", "committedDate": "2020-03-10T12:37:47Z", "message": "Use search ext"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de90bae18010f7449454448214c03b9c0995e414", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/de90bae18010f7449454448214c03b9c0995e414", "committedDate": "2020-03-10T12:37:48Z", "message": "Inference at fetch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "818ac7d69b8c76cfd39f4ed5c83a38539ca3ec7f", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/818ac7d69b8c76cfd39f4ed5c83a38539ca3ec7f", "committedDate": "2020-03-10T12:37:48Z", "message": " Add target field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66f6b051aa67fd371b00d27cb4de89c7c355ce0e", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/66f6b051aa67fd371b00d27cb4de89c7c355ce0e", "committedDate": "2020-03-10T12:37:48Z", "message": "add disclaimer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/3088b85f5e19cde7d62913288ec9774f578819b8", "committedDate": "2020-03-10T12:37:48Z", "message": "Blacklist tests that fail security checks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d3aa044392420cdb0c9f751aa4db3c94f915658", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/0d3aa044392420cdb0c9f751aa4db3c94f915658", "committedDate": "2020-03-10T11:04:59Z", "message": "Blacklist tests that fail security checks"}, "afterCommit": {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/3088b85f5e19cde7d62913288ec9774f578819b8", "committedDate": "2020-03-10T12:37:48Z", "message": "Blacklist tests that fail security checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMTIwNDI1", "url": "https://github.com/elastic/elasticsearch/pull/53230#pullrequestreview-372120425", "createdAt": "2020-03-10T16:30:06Z", "commit": {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjozMDowNlrOF0W_MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjozMzoxNlrOF0XHzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0Njg5Ng==", "bodyText": "I wonder if we should implement ToXContentObject instead of having a bespoke method that creates a map.", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390446896", "createdAt": "2020-03-10T16:30:06Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/results/InferenceResults.java", "diffHunk": "@@ -8,8 +8,11 @@\n import org.elasticsearch.common.io.stream.NamedWriteable;\n import org.elasticsearch.ingest.IngestDocument;\n \n+import java.util.Map;\n+\n public interface InferenceResults extends NamedWriteable {\n \n     void writeResult(IngestDocument document, String parentResultField);\n \n+    Map<String, Object> writeResultToMap(String parentResultField);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ0OTEwMQ==", "bodyText": "I think this is backwards.\nWe should have the synchronous method call the asynchronous method. This is the prevelant pattern everywhere else. Also, it is possible to make something asynchronous -> synchronous, not really the other way around.", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390449101", "createdAt": "2020-03-10T16:33:16Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -53,23 +57,18 @@ public String getResultsType() {\n                 return RegressionInferenceResults.NAME;\n             default:\n                 throw ExceptionsHelper.badRequestException(\"Model [{}] has unsupported target type [{}]\",\n-                    modelId,\n-                    trainedModelDefinition.getTrainedModel().targetType());\n+                        modelId,\n+                        trainedModelDefinition.getTrainedModel().targetType());\n         }\n     }\n \n     @Override\n-    public void infer(Map<String, Object> fields, InferenceConfig config, ActionListener<InferenceResults> listener) {\n-        try {\n-            if (fieldNames.stream().allMatch(f -> MapHelper.dig(f, fields) == null)) {\n-                listener.onResponse(new WarningInferenceResults(Messages.getMessage(INFERENCE_WARNING_ALL_FIELDS_MISSING, modelId)));\n-                return;\n-            }\n-\n-            listener.onResponse(trainedModelDefinition.infer(fields, config));\n-        } catch (Exception e) {\n-            listener.onFailure(e);\n+    public InferenceResults infer(Map<String, Object> fields, InferenceConfig config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3088b85f5e19cde7d62913288ec9774f578819b8"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a102b9f3a4902c1f8459b813dbd8eb09eb04091", "author": {"user": {"login": "davidkyle", "name": "David Kyle"}}, "url": "https://github.com/elastic/elasticsearch/commit/6a102b9f3a4902c1f8459b813dbd8eb09eb04091", "committedDate": "2020-03-10T18:37:44Z", "message": "remove default sync method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMjYyMTIw", "url": "https://github.com/elastic/elasticsearch/pull/53230#pullrequestreview-372262120", "createdAt": "2020-03-10T19:35:10Z", "commit": {"oid": "6a102b9f3a4902c1f8459b813dbd8eb09eb04091"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxOTozNToxMFrOF0eDfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxOTozNToxMFrOF0eDfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU2MjY4Nw==", "bodyText": "agreed :D. We may want this call to fail if the model is not deployed in the provided model service. Especially since there is no way to load it just in time :/", "url": "https://github.com/elastic/elasticsearch/pull/53230#discussion_r390562687", "createdAt": "2020-03-10T19:35:10Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/search/InferencePhase.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.inference.search;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.document.DocumentField;\n+import org.elasticsearch.search.SearchExtBuilder;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig;\n+import org.elasticsearch.xpack.core.ml.utils.MapHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+/**\n+ * A very rough sketch of a fetch sub phase that performs inference on each search hit,\n+ * then augments the hit with the result.\n+ */\n+public class InferencePhase implements FetchSubPhase {\n+\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+\n+    public InferencePhase(SetOnce<ModelLoadingService> modelLoadingService) {\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    @Override\n+    public void hitsExecute(SearchContext searchContext, SearchHit[] hits) {\n+        SearchExtBuilder inferenceBuilder = searchContext.getSearchExt(InferenceSearchExtBuilder.NAME);\n+        if (inferenceBuilder == null) {\n+            return;\n+        }\n+\n+        InferenceSearchExtBuilder infBuilder = (InferenceSearchExtBuilder)inferenceBuilder;\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+                ActionListener.wrap(model::set, e -> { throw new RuntimeException();}), latch);\n+\n+        modelLoadingService.get().getModel(infBuilder.getModelId(), listener);\n+        try {\n+            // Eeek blocking on a latch we can't be doing that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a102b9f3a4902c1f8459b813dbd8eb09eb04091"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1842, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}