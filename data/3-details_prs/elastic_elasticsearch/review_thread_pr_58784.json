{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMjkwMTUy", "number": 58784, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjowMjoyNFrOEKX4rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozODoxM1rOEOQxIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzEyNTU3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjowMjoyNFrOGrX4QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjowMjoyNFrOGrX4QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzMzE4NA==", "bodyText": "It's only loosely to this change, but I think we're long overdue on javadocs for these methods. I struggle to remember what they're supposed to do, and they're just getting more complex.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448133184", "createdAt": "2020-07-01T06:02:24Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -46,14 +47,29 @@\n \n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, Predicate<IndexAbstraction>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n \n     private final Group[] groups;\n \n     public IndicesPermission(Group... groups) {\n         this.groups = groups;\n     }\n \n+    public static Predicate<String> indexMatcher(Collection<String> ordinaryIndices, Collection<String> restrictedIndices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzEzODcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjowOTowNlrOGrYAPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjowOTowNlrOGrYAPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNTIzMQ==", "bodyText": "It's a minor thing, but I have a mild dislike of that repeated isRestricted logic.\nWe could do something like:\n    final Predicate<String> namePredicate;\n    if (ordinaryIndices.isEmpty()) {\n        namePredicate = indexMatcher(restrictedIndices);\n    } else {\n        namePredicate = indexMatcher(ordinaryIndices)\n                .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n        if (restrictedIndices.isEmpty() == false) {\n            namePredicate = indexMatcher(restrictedIndices).or(namePredicate);\n        }\n    }", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448135231", "createdAt": "2020-07-01T06:09:06Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -46,14 +47,29 @@\n \n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, Predicate<IndexAbstraction>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n \n     private final Group[] groups;\n \n     public IndicesPermission(Group... groups) {\n         this.groups = groups;\n     }\n \n+    public static Predicate<String> indexMatcher(Collection<String> ordinaryIndices, Collection<String> restrictedIndices) {\n+        final Predicate<String> namePredicate;\n+        if (restrictedIndices.isEmpty()) {\n+            namePredicate = indexMatcher(ordinaryIndices)\n+                    .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n+        } else if (ordinaryIndices.isEmpty()) {\n+            namePredicate = indexMatcher(restrictedIndices);\n+        } else {\n+            namePredicate = indexMatcher(restrictedIndices)\n+                    .or(indexMatcher(ordinaryIndices)\n+                            .and(index -> false == RestrictedIndicesNames.isRestricted(index)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzE0MTg3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxMDozM1rOGrYCNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDowMzo0MlrOGtlVfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNTczNA==", "bodyText": "I think we'll need AutoPutMapping too.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448135734", "createdAt": "2020-07-01T06:10:33Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ1MDgxMw==", "bodyText": "Yes, as we've discussed on another channel, create_doc, create, index lose all mapping update privileges, and write only retains the auto put mapping privilege. For bwc reasons, put mapping and auto put mapping are still allowed on indices and aliases, but not on data streams.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r450450813", "createdAt": "2020-07-06T20:03:42Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNTczNA=="}, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzE0ODQxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/IndexPrivilege.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxMzo0NFrOGrYGWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxMzo0NFrOGrYGWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNjc5NQ==", "bodyText": "My plan here was not to allow AutoPutMapping either, and force it to be a separate privilege (but that could be a followup).", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448136795", "createdAt": "2020-07-01T06:13:44Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/IndexPrivilege.java", "diffHunk": "@@ -49,14 +49,13 @@\n     private static final Automaton READ_CROSS_CLUSTER_AUTOMATON = patterns(\"internal:transport/proxy/indices:data/read/*\",\n             ClusterSearchShardsAction.NAME);\n     private static final Automaton CREATE_AUTOMATON = patterns(\"indices:data/write/index*\", \"indices:data/write/bulk*\",\n-            PutMappingAction.NAME, AutoPutMappingAction.NAME);\n+            AutoPutMappingAction.NAME);\n     private static final Automaton CREATE_DOC_AUTOMATON = patterns(\"indices:data/write/index\", \"indices:data/write/index[*\",\n-        \"indices:data/write/index:op_type/create\", \"indices:data/write/bulk*\", PutMappingAction.NAME, AutoPutMappingAction.NAME);\n+        \"indices:data/write/index:op_type/create\", \"indices:data/write/bulk*\", AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzE1NzUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxNzo0M1rOGrYL5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNzozMTozNVrOGuyUjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzODIxNA==", "bodyText": "We'll also need to think about how to write a deprecation warning if this BWC path gets used, but it's complex because we only want to do that if there isn't another Group that grants explicit mapping update access.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448138214", "createdAt": "2020-07-01T06:17:43Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||\n+                (group.privilege().name().containsAll(IndexPrivilege.CREATE_DOC.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.CREATE.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.INDEX.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.WRITE.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMjkzNQ==", "bodyText": "Do we need add version check here? Or is it because this BWC must exist for v8.0 and we cannot check v9.0 yet? If so, can we add TODO so it's easier to identify?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r450612935", "createdAt": "2020-07-07T05:05:59Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||\n+                (group.privilege().name().containsAll(IndexPrivilege.CREATE_DOC.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.CREATE.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.INDEX.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.WRITE.name()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzODIxNA=="}, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMjE0MA==", "bodyText": "The bwc logic proved tricky and I ended up restructuring this whole logic.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r451712140", "createdAt": "2020-07-08T17:31:35Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||\n+                (group.privilege().name().containsAll(IndexPrivilege.CREATE_DOC.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.CREATE.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.INDEX.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.WRITE.name()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzODIxNA=="}, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTM5NTQ2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1Njo1OVrOGtvFwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1Njo1OVrOGtvFwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDYyNg==", "bodyText": "Can we please retain the previous comments on this block of code?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r450610626", "createdAt": "2020-07-07T04:56:59Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -213,12 +230,13 @@ public Automaton allowedActionsMatcher(String index) {\n             }\n \n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n+                boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                                indexAbstraction.getParentDataStream() != null &&\n+                                group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwOTQwMjEyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTowMDo0M1rOGtvJuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTowMDo0M1rOGtvJuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMTY0Mw==", "bodyText": "Nit: I'd simply the name to be just authorizeMappingUpdateBwc.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r450611643", "createdAt": "2020-07-07T05:00:43Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -281,6 +299,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNDg4NjMxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/store/ReservedRolesStoreTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MDo0M1rOGukAUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MDo0M1rOGukAUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NzU4NQ==", "bodyText": "Uninteresting changes.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r451477585", "createdAt": "2020-07-08T11:40:43Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/store/ReservedRolesStoreTests.java", "diffHunk": "@@ -189,6 +189,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.not;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09a20b67ff3d811d729c7f315d745d48c78b25a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzUwMDQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMDo1Nzo1MFrOGwYjPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMDo1Nzo1MFrOGwYjPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM4NzA3MA==", "bodyText": "Nit: I am aware this is a carry-over from existing code, but could we please change the type from ConcurrentMap to just Map, i.e. Map<String, Predicate<IndexAbstraction>>?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453387070", "createdAt": "2020-07-13T00:57:50Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -44,16 +47,38 @@\n  */\n public final class IndicesPermission {\n \n+    private static final DeprecationLogger deprecationLogger = DeprecationLogger.getLogger(IndicesPermission.class);\n+\n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private static final Set<String> privilegeNameSetBwcAllowMappingUpdate = Set.of(\"create\", \"create_doc\", \"index\", \"write\");\n+\n+    private final ConcurrentMap<String, Predicate<IndexAbstraction>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzY2MTE2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzowMDoyNFrOGwZ9Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzowMDoyNFrOGwZ9Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxMDA3NA==", "bodyText": "I'd prefer to write these boolean expressions in a more boolean way, i.e.:\ngranted = granted || actionCheck;\nbwcGrantMappingUpdate = bwcGrantMappingUpdate || bwcMappingActionCheck;\nA minor benefit is that they short-circuit.\nAlso might wanna consider pulling it up into the above if check since the values do not change unless actionCheck or bwcMappingActionCheck is true.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453410074", "createdAt": "2020-07-13T03:00:24Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzcxNjExOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzozOToxOVrOGwacnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzozOToxOVrOGwacnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxODE0MA==", "bodyText": "Nit: This check is done three times times in different places. I'd personally prefer to extract it into a method.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453418140", "createdAt": "2020-07-13T03:39:19Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzcyMjgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzo0NDoxMlrOGwagjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzo0NDoxMlrOGwagjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxOTE0OA==", "bodyText": "Similarly, this check is done three times. I'd prefer it to be a method, e.g. grantBwcMappingUpdate(group)", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453419148", "createdAt": "2020-07-13T03:44:12Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n             for (final Group group : groups) {\n                 if (group.actionMatcher.test(action)) {\n                     if (group.allowRestrictedIndices) {\n                         restrictedIndices.addAll(Arrays.asList(group.indices()));\n                     } else {\n                         ordinaryIndices.addAll(Arrays.asList(group.indices()));\n                     }\n+                } else if (isMappingUpdateAction &&\n+                        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzcyNDY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzo0NTowN1rOGwahgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo1ODo1N1rOGxQfmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxOTM5NQ==", "bodyText": "I wonder whether it would be better to display a single deprecation log per indexOrAlias, e.g. ... is granted by [privA, privB] ....\nAlso this if block can be placed inside the previous if (actionCheck || bwcMappingActionCheck) so its own if check can become just if (false == actionCheck).", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453419395", "createdAt": "2020-07-13T03:45:07Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;\n+                    if (false == actionCheck && bwcMappingActionCheck) {\n+                        for (String privilegeName : group.privilege.name()) {\n+                            if (privilegeNameSetBwcAllowMappingUpdate.contains(privilegeName)) {\n+                                bwcDeprecationLogActions.add(() -> {\n+                                    deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                            privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                            indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                            \" but the privilege has been tightened to not allow it in the next major release\");\n+                                });\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5OTQwNQ==", "bodyText": "I wonder whether it would be better to display a single deprecation log per indexOrAlias, e.g. ... is granted by [privA, privB] ....\n\nI dunno. I've chosen the current variant because it is easier to code.\nThe deprecationLogger.deprecate method has built-in logic to deduplicate frequent log entries with the same key.\nIf a log message contains a list of privileges, instead of a single one, the deduplication logic would have to be smarter to compare that \"all (or some of) the privileges (given the index) on this deprecation log entry have appeared in (some) previous entries\". It sounds too complicated to implement.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r454299405", "createdAt": "2020-07-14T11:50:18Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;\n+                    if (false == actionCheck && bwcMappingActionCheck) {\n+                        for (String privilegeName : group.privilege.name()) {\n+                            if (privilegeNameSetBwcAllowMappingUpdate.contains(privilegeName)) {\n+                                bwcDeprecationLogActions.add(() -> {\n+                                    deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                            privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                            indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                            \" but the privilege has been tightened to not allow it in the next major release\");\n+                                });\n+                            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxOTM5NQ=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMwMzY0Mg==", "bodyText": "Also this if block can be placed inside the previous if (actionCheck || bwcMappingActionCheck) so its own if check can become just if (false == actionCheck).\n\nI can make the move, I don't know of any heuristic that could help me choose between the two.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r454303642", "createdAt": "2020-07-14T11:58:57Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;\n+                    if (false == actionCheck && bwcMappingActionCheck) {\n+                        for (String privilegeName : group.privilege.name()) {\n+                            if (privilegeNameSetBwcAllowMappingUpdate.contains(privilegeName)) {\n+                                bwcDeprecationLogActions.add(() -> {\n+                                    deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                            privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                            indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                            \" but the privilege has been tightened to not allow it in the next major release\");\n+                                });\n+                            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxOTM5NQ=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzcyOTE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzo0ODoxOFrOGwakLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTo1MjoxNlrOGwu1tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMDA3Nw==", "bodyText": "I think this check can be added as a default method to IndexAbstraction itself.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453420077", "createdAt": "2020-07-13T03:48:18Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n             for (final Group group : groups) {\n                 if (group.actionMatcher.test(action)) {\n                     if (group.allowRestrictedIndices) {\n                         restrictedIndices.addAll(Arrays.asList(group.indices()));\n                     } else {\n                         ordinaryIndices.addAll(Arrays.asList(group.indices()));\n                     }\n+                } else if (isMappingUpdateAction &&\n+                        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {\n+                    // special BWC case for certain privileges: allow put mapping on indices and aliases (but not on data streams), even if\n+                    // the privilege definition does not currently allow it\n+                    if (group.allowRestrictedIndices) {\n+                        grantMappingUpdatesOnRestrictedIndices.addAll(Arrays.asList(group.indices()));\n+                    } else {\n+                        grantMappingUpdatesOnIndices.addAll(Arrays.asList(group.indices()));\n+                    }\n                 }\n             }\n-            final Predicate<String> predicate;\n-            if (restrictedIndices.isEmpty()) {\n-                predicate = indexMatcher(ordinaryIndices)\n-                    .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n-            } else if (ordinaryIndices.isEmpty()) {\n-                predicate = indexMatcher(restrictedIndices);\n-            } else {\n-                predicate = indexMatcher(restrictedIndices)\n-                    .or(indexMatcher(ordinaryIndices)\n-                         .and(index -> false == RestrictedIndicesNames.isRestricted(index)));\n-            }\n-            return predicate;\n+            final Predicate<String> namePredicate = indexMatcher(ordinaryIndices, restrictedIndices);\n+            final Predicate<String> bwcSpecialCaseNamePredicate = indexMatcher(grantMappingUpdatesOnIndices,\n+                    grantMappingUpdatesOnRestrictedIndices);\n+            return indexAbstraction -> {\n+                return namePredicate.test(indexAbstraction.getName()) ||\n+                        (indexAbstraction.getType() != IndexAbstraction.Type.DATA_STREAM &&\n+                                (indexAbstraction.getParentDataStream() == null) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczOTg4MQ==", "bodyText": "indexAbstraction.getParentDataStream() == null tells if it is a concrete index that is not a backing index or an alias.\nindexAbstraction.getType() != IndexAbstraction.Type.DATA_STREAM  tells if it is NOT a data stream.\nYou're suggesting that the IndexAbstraction have a check for whether it is a data stream or a backing index for a data stream, right?\nI'm not convinced that it brings value, more often than not I prefer chaining simple tests rather than invoking a specialised test method with a long name.\nI would resist adding such a test method at the moment, unless you feel strongly about it.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453739881", "createdAt": "2020-07-13T15:36:18Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n             for (final Group group : groups) {\n                 if (group.actionMatcher.test(action)) {\n                     if (group.allowRestrictedIndices) {\n                         restrictedIndices.addAll(Arrays.asList(group.indices()));\n                     } else {\n                         ordinaryIndices.addAll(Arrays.asList(group.indices()));\n                     }\n+                } else if (isMappingUpdateAction &&\n+                        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {\n+                    // special BWC case for certain privileges: allow put mapping on indices and aliases (but not on data streams), even if\n+                    // the privilege definition does not currently allow it\n+                    if (group.allowRestrictedIndices) {\n+                        grantMappingUpdatesOnRestrictedIndices.addAll(Arrays.asList(group.indices()));\n+                    } else {\n+                        grantMappingUpdatesOnIndices.addAll(Arrays.asList(group.indices()));\n+                    }\n                 }\n             }\n-            final Predicate<String> predicate;\n-            if (restrictedIndices.isEmpty()) {\n-                predicate = indexMatcher(ordinaryIndices)\n-                    .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n-            } else if (ordinaryIndices.isEmpty()) {\n-                predicate = indexMatcher(restrictedIndices);\n-            } else {\n-                predicate = indexMatcher(restrictedIndices)\n-                    .or(indexMatcher(ordinaryIndices)\n-                         .and(index -> false == RestrictedIndicesNames.isRestricted(index)));\n-            }\n-            return predicate;\n+            final Predicate<String> namePredicate = indexMatcher(ordinaryIndices, restrictedIndices);\n+            final Predicate<String> bwcSpecialCaseNamePredicate = indexMatcher(grantMappingUpdatesOnIndices,\n+                    grantMappingUpdatesOnRestrictedIndices);\n+            return indexAbstraction -> {\n+                return namePredicate.test(indexAbstraction.getName()) ||\n+                        (indexAbstraction.getType() != IndexAbstraction.Type.DATA_STREAM &&\n+                                (indexAbstraction.getParentDataStream() == null) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMDA3Nw=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1MjI0NA==", "bodyText": "I'd personally prefer to have readable method name, e.g. IndexAbstraction#notAssociatedWithDataStream(), over chaining logical expressions. Java method names are often long and this one does not seem to be much over it. It helps me to read higher level logic without need to figure out the details.\nI would feel strong if the expressions are repeated a few more times. In this case, it is not repeated elsewhere, so I am fine if you prefer to keep it here.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453752244", "createdAt": "2020-07-13T15:52:16Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n             for (final Group group : groups) {\n                 if (group.actionMatcher.test(action)) {\n                     if (group.allowRestrictedIndices) {\n                         restrictedIndices.addAll(Arrays.asList(group.indices()));\n                     } else {\n                         ordinaryIndices.addAll(Arrays.asList(group.indices()));\n                     }\n+                } else if (isMappingUpdateAction &&\n+                        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {\n+                    // special BWC case for certain privileges: allow put mapping on indices and aliases (but not on data streams), even if\n+                    // the privilege definition does not currently allow it\n+                    if (group.allowRestrictedIndices) {\n+                        grantMappingUpdatesOnRestrictedIndices.addAll(Arrays.asList(group.indices()));\n+                    } else {\n+                        grantMappingUpdatesOnIndices.addAll(Arrays.asList(group.indices()));\n+                    }\n                 }\n             }\n-            final Predicate<String> predicate;\n-            if (restrictedIndices.isEmpty()) {\n-                predicate = indexMatcher(ordinaryIndices)\n-                    .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n-            } else if (ordinaryIndices.isEmpty()) {\n-                predicate = indexMatcher(restrictedIndices);\n-            } else {\n-                predicate = indexMatcher(restrictedIndices)\n-                    .or(indexMatcher(ordinaryIndices)\n-                         .and(index -> false == RestrictedIndicesNames.isRestricted(index)));\n-            }\n-            return predicate;\n+            final Predicate<String> namePredicate = indexMatcher(ordinaryIndices, restrictedIndices);\n+            final Predicate<String> bwcSpecialCaseNamePredicate = indexMatcher(grantMappingUpdatesOnIndices,\n+                    grantMappingUpdatesOnRestrictedIndices);\n+            return indexAbstraction -> {\n+                return namePredicate.test(indexAbstraction.getName()) ||\n+                        (indexAbstraction.getType() != IndexAbstraction.Type.DATA_STREAM &&\n+                                (indexAbstraction.getParentDataStream() == null) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMDA3Nw=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzczODc4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMzo1NToyN1rOGwapxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoxMTozOFrOGxQ4Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA==", "bodyText": "I think this can be optimised as\nboolean bwcMappingActionCheck = actionCheck ? false : isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453421508", "createdAt": "2020-07-13T03:55:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMDUwNg==", "bodyText": "I don't like this minor optimisation because it makes it harder to reason about the meaning of the check.\nThere is some overlapping between the actionCheck and the bwcMappingActionCheck flags (they can both be true) because it is easier to express them.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453600506", "createdAt": "2020-07-13T12:03:36Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNjM5Mw==", "bodyText": "I do agree this by itself makes the code harder to read. Since I made a few comments around this code block, I think what I am really suggesting is to re-arrange in a broader context, e.g.:\nif (group.checkAction(action)) {\n    granted = true;\n    propagateDlsAndFlsPermissionsOvertheConcreteIndices(...);\n} else if (isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {\n    bwcGrantMappingUpdate = true;\n    propagateDlsAndFlsPermissionsOvertheConcreteIndices(...);\n    populateDeprecationLogs(...);\n}", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453616393", "createdAt": "2020-07-13T12:34:34Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTUzMg==", "bodyText": "I understand now, but I don't see an improvement. bwcGrantMappingUpdate is updated to true in the if branch, but I slightly prefer it when its value is the expression of the if branch itself; I find it easier to follow like this.\nAlso, you need a similar flag for the if (group.checkAction(action)) if branch, because deprecation logs must only be present if the action is exclusively granted by the deprecation behaviour.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453755532", "createdAt": "2020-07-13T15:57:02Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2MzE4NA==", "bodyText": "I don't quite follow.\nOnce the logic is inside the else if branch, we can already be sure the action is granted by bwc and can go ahead and prepare the deprecation logs within the branch (i.e. populateDeprecationLogs(...)). With this approach, we can get rid of two variables actionCheck and bwcMappingActionCheck. We still need granted and bwcGrantMappingUpdate, but only one of them needs to be updated for each loop.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453763184", "createdAt": "2020-07-13T16:08:54Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMwOTk3OQ==", "bodyText": "Sorry, you're right, I got lost.\nI'm tempted to not change the code as you're suggesting, because the goal to get rid of actionCheck and bwcMappingActionCheck is not worthwhile IMO. To me these look like different approaches with no substantial differences.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r454309979", "createdAt": "2020-07-14T12:11:38Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzc0OTcxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNDowMzoxOFrOGwawBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowMzoyNFrOGwqB0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMzExMQ==", "bodyText": "Would it be possible to push this logic into Group#checkIndex, i.e. make it take a IndexAbstraction so that the logic is internalised?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453423111", "createdAt": "2020-07-13T04:03:18Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5NDM0Mg==", "bodyText": "Unfortunately no because indexOrAlias is a name that might not exist, but which has to be authz or not, whilst indexAbstraction is non-null only when the name exists.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453594342", "createdAt": "2020-07-13T11:50:59Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMzExMQ=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwODY2MA==", "bodyText": "OK, I thought the resolved indices would remove non-existing indices, but apparently I missed something. But when indexOrAlias does not exist, do we need have a null check for indexAbstraction before calling indexAbstraction.getParentDataStream()?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453608660", "createdAt": "2020-07-13T12:19:58Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMzExMQ=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MzQyNQ==", "bodyText": "If indexAbstraction is null, then isBackingIndex is always false (lines 246-247)", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453673425", "createdAt": "2020-07-13T14:03:24Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMzExMQ=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTM3MTI5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo1NjozMFrOGwpuMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo1NjozMFrOGwpuMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2ODQwMg==", "bodyText": "Nit, should be CAPS.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<String> privilegeNameSetBwcAllowMappingUpdate = Set.of(\"create\", \"create_doc\", \"index\", \"write\");\n          \n          \n            \n                private static final Set<String> BWC_PRIVILEGE_NAMES_ALLOW_MAPPING_UPDATE = Set.of(\"create\", \"create_doc\", \"index\", \"write\");", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453668402", "createdAt": "2020-07-13T13:56:30Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -44,16 +47,38 @@\n  */\n public final class IndicesPermission {\n \n+    private static final DeprecationLogger deprecationLogger = DeprecationLogger.getLogger(IndicesPermission.class);\n+\n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private static final Set<String> privilegeNameSetBwcAllowMappingUpdate = Set.of(\"create\", \"create_doc\", \"index\", \"write\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTM3OTQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo1ODoyMFrOGwpzXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjowNDoyNlrOGwvVcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2OTcyNg==", "bodyText": "Can we remove the duplication of detemining isMappingUpdateAction (here and 144)?\nExtract a method, or defined a Set<String> of action names?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453669726", "createdAt": "2020-07-13T13:58:20Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2MDM2OA==", "bodyText": "Yep, I've added a one-line function isMappingUpdateAction.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453760368", "createdAt": "2020-07-13T16:04:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2OTcyNg=="}, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTQxOTQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowNzoxOFrOGwqLoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowNzoxOFrOGwqLoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTkzNg==", "bodyText": "I'm not a fan of this wording - I'll propose an alternative during my day.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453675936", "createdAt": "2020-07-13T14:07:18Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;\n+                    if (false == actionCheck && bwcMappingActionCheck) {\n+                        for (String privilegeName : group.privilege.name()) {\n+                            if (privilegeNameSetBwcAllowMappingUpdate.contains(privilegeName)) {\n+                                bwcDeprecationLogActions.add(() -> {\n+                                    deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                            privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                            indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                            \" but the privilege has been tightened to not allow it in the next major release\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzkwMjQyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozODoxM1rOGxUDug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDowNjo1OVrOGxVTzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MjA0Mg==", "bodyText": "How about\n\nthe index privilege [] allowed the update mapping action [] on index [], this privilege will not permit mapping updates in the next major release - users who require access to update mappings must be granted explicit privileges\n\nIf you don't like it we can merge as-is, & come back and reword it later.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r454362042", "createdAt": "2020-07-14T13:38:13Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +227,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = isMappingUpdateAction(action);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    granted = granted || actionCheck;\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            containsPrivilegeThatGrantsMappingUpdatesForBwc(group);\n+                    bwcGrantMappingUpdate = bwcGrantMappingUpdate || bwcMappingActionCheck;\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                        if (false == actionCheck) {\n+                            for (String privilegeName : group.privilege.name()) {\n+                                if (PRIVILEGE_NAME_SET_BWC_ALLOW_MAPPING_UPDATE.contains(privilegeName)) {\n+                                    bwcDeprecationLogActions.add(() -> {\n+                                        deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                                privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                                indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                                \" but the privilege has been tightened to not allow it in the next major release\");\n+                                    });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d3f64d581ab0f23823a621a7f6bb71c2e991f39"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4MjU0Mg==", "bodyText": "This is clearer, I used idioms such as \"tightening privileges\".", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r454382542", "createdAt": "2020-07-14T14:06:59Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +227,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = isMappingUpdateAction(action);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    granted = granted || actionCheck;\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            containsPrivilegeThatGrantsMappingUpdatesForBwc(group);\n+                    bwcGrantMappingUpdate = bwcGrantMappingUpdate || bwcMappingActionCheck;\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                        if (false == actionCheck) {\n+                            for (String privilegeName : group.privilege.name()) {\n+                                if (PRIVILEGE_NAME_SET_BWC_ALLOW_MAPPING_UPDATE.contains(privilegeName)) {\n+                                    bwcDeprecationLogActions.add(() -> {\n+                                        deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                                privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                                indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                                \" but the privilege has been tightened to not allow it in the next major release\");\n+                                    });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MjA0Mg=="}, "originalCommit": {"oid": "3d3f64d581ab0f23823a621a7f6bb71c2e991f39"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2167, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}