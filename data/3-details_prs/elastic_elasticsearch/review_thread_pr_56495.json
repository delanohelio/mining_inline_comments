{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NzU2OTU1", "number": 56495, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjowMjo1NFrOD7TcEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoyOToxMlrOD70GNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTExMDU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjowMjo1NFrOGTi6IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxODozMzoyOFrOGToZ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0ODA2NQ==", "bodyText": "This should be an optimization rule not analysis (since the literal might not be folded).\nIt also seems incomplete - what if there are multiple non-literals? Is there any validation happening (verifier rule) in the chain?", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r423148065", "createdAt": "2020-05-11T16:02:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -120,4 +124,24 @@ protected LogicalPlan rule(LogicalPlan plan) {\n             });\n         }\n     }\n-}\n\\ No newline at end of file\n+\n+    private class MatchLiteralsOnTheRight extends AnalyzerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan plan) {\n+            return plan.transformExpressionsUp(e -> {\n+                if (e instanceof Match) {\n+                    Match m = (Match) e;\n+                    int size = m.children().size();\n+                    if ((m.children().get(size - 1) instanceof Literal) == false) {\n+                        List<Expression> newChildren = new ArrayList<>(m.children().size());\n+                        newChildren.add(m.children().get(size - 1));\n+                        newChildren.addAll(m.children().subList(0, size - 1));\n+                        return m.replaceChildren(newChildren);\n+                    }\n+                }\n+                return e;\n+            });\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4866b486587f39aff1cee72131ba6c334d28ba2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NjI0MA==", "bodyText": "I didn't like that either to take place in the analysis, but this way the Verifier will call the resolveType() on the Match which will indeed check that the patterns are constants (foldable).\nIf we apply the rule in the Optimizer that's after the verifier so it will \"blow up\".  Any suggestion?", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r423156240", "createdAt": "2020-05-11T16:15:32Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -120,4 +124,24 @@ protected LogicalPlan rule(LogicalPlan plan) {\n             });\n         }\n     }\n-}\n\\ No newline at end of file\n+\n+    private class MatchLiteralsOnTheRight extends AnalyzerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan plan) {\n+            return plan.transformExpressionsUp(e -> {\n+                if (e instanceof Match) {\n+                    Match m = (Match) e;\n+                    int size = m.children().size();\n+                    if ((m.children().get(size - 1) instanceof Literal) == false) {\n+                        List<Expression> newChildren = new ArrayList<>(m.children().size());\n+                        newChildren.add(m.children().get(size - 1));\n+                        newChildren.addAll(m.children().subList(0, size - 1));\n+                        return m.replaceChildren(newChildren);\n+                    }\n+                }\n+                return e;\n+            });\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0ODA2NQ=="}, "originalCommit": {"oid": "b4866b486587f39aff1cee72131ba6c334d28ba2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzODExOA==", "bodyText": "It sounds to me like the resolveType method needs improving;\nthis rule moves the last items to the front of the list so instead of doing that outside Match, the class itself should have the proper behavior in place.", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r423238118", "createdAt": "2020-05-11T18:33:28Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -120,4 +124,24 @@ protected LogicalPlan rule(LogicalPlan plan) {\n             });\n         }\n     }\n-}\n\\ No newline at end of file\n+\n+    private class MatchLiteralsOnTheRight extends AnalyzerRule<LogicalPlan> {\n+\n+        @Override\n+        protected LogicalPlan rule(LogicalPlan plan) {\n+            return plan.transformExpressionsUp(e -> {\n+                if (e instanceof Match) {\n+                    Match m = (Match) e;\n+                    int size = m.children().size();\n+                    if ((m.children().get(size - 1) instanceof Literal) == false) {\n+                        List<Expression> newChildren = new ArrayList<>(m.children().size());\n+                        newChildren.add(m.children().get(size - 1));\n+                        newChildren.addAll(m.children().subList(0, size - 1));\n+                        return m.replaceChildren(newChildren);\n+                    }\n+                }\n+                return e;\n+            });\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0ODA2NQ=="}, "originalCommit": {"oid": "b4866b486587f39aff1cee72131ba6c334d28ba2"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTE2MjY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Match.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNDo1NDozMlrOGUKsqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDozMTo1MVrOGUX1rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5OTk3OQ==", "bodyText": "I would emphasize the two \"versions\" of match function, rather than mentioning that one argument needs to be a field.\nSomething more aligned with the (to be updated) documentation.\nFor example \"either first or last argument of match must be a non-constant\" (or around the same idea).", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r423799979", "createdAt": "2020-05-12T14:54:32Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Match.java", "diffHunk": "@@ -65,29 +72,39 @@ protected TypeResolution resolveType() {\n             return new TypeResolution(\"Unresolved children\");\n         }\n \n-        TypeResolution resolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        int index = 1;\n-        for (Expression regex : patterns) {\n+        TypeResolution resolution;\n+        int index = 0;\n+        List<Integer> nonFoldables = new ArrayList<>(2);\n+        for (Expression e : children()) {\n             // Currently we have limited enum for ordinal numbers\n             // So just using default here for error messaging\n-            resolution = isStringAndExact(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            ParamOrdinal paramOrd = ParamOrdinal.fromIndex(index);\n+            resolution = isStringAndExact(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n                 return resolution;\n             }\n-\n-            resolution = isFoldable(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            resolution = isFoldable(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n-                break;\n+                nonFoldables.add(index);\n             }\n-\n             index++;\n         }\n \n-        return resolution;\n+        if (nonFoldables.size() == 2) {\n+            StringBuilder sb = new StringBuilder(format(null, \"only one argument of [{}] must be non-constant but multiple found: \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzOTIyNA==", "bodyText": "But now we allow the field to be anywhere, should we change and be stricter and allow only first and last?", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r423839224", "createdAt": "2020-05-12T15:45:18Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Match.java", "diffHunk": "@@ -65,29 +72,39 @@ protected TypeResolution resolveType() {\n             return new TypeResolution(\"Unresolved children\");\n         }\n \n-        TypeResolution resolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        int index = 1;\n-        for (Expression regex : patterns) {\n+        TypeResolution resolution;\n+        int index = 0;\n+        List<Integer> nonFoldables = new ArrayList<>(2);\n+        for (Expression e : children()) {\n             // Currently we have limited enum for ordinal numbers\n             // So just using default here for error messaging\n-            resolution = isStringAndExact(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            ParamOrdinal paramOrd = ParamOrdinal.fromIndex(index);\n+            resolution = isStringAndExact(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n                 return resolution;\n             }\n-\n-            resolution = isFoldable(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            resolution = isFoldable(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n-                break;\n+                nonFoldables.add(index);\n             }\n-\n             index++;\n         }\n \n-        return resolution;\n+        if (nonFoldables.size() == 2) {\n+            StringBuilder sb = new StringBuilder(format(null, \"only one argument of [{}] must be non-constant but multiple found: \",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5OTk3OQ=="}, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxMDQwOA==", "bodyText": "Based on the docs my understand is the field (source) would have to be first and the rest would be patterns.\nThere's no mention of them being literals but the code does seem to indicate that.\n@aleksmaus @rw-access can you please advise?", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r424010408", "createdAt": "2020-05-12T20:22:39Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Match.java", "diffHunk": "@@ -65,29 +72,39 @@ protected TypeResolution resolveType() {\n             return new TypeResolution(\"Unresolved children\");\n         }\n \n-        TypeResolution resolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        int index = 1;\n-        for (Expression regex : patterns) {\n+        TypeResolution resolution;\n+        int index = 0;\n+        List<Integer> nonFoldables = new ArrayList<>(2);\n+        for (Expression e : children()) {\n             // Currently we have limited enum for ordinal numbers\n             // So just using default here for error messaging\n-            resolution = isStringAndExact(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            ParamOrdinal paramOrd = ParamOrdinal.fromIndex(index);\n+            resolution = isStringAndExact(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n                 return resolution;\n             }\n-\n-            resolution = isFoldable(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            resolution = isFoldable(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n-                break;\n+                nonFoldables.add(index);\n             }\n-\n             index++;\n         }\n \n-        return resolution;\n+        if (nonFoldables.size() == 2) {\n+            StringBuilder sb = new StringBuilder(format(null, \"only one argument of [{}] must be non-constant but multiple found: \",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5OTk3OQ=="}, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxMjY1Mw==", "bodyText": "Yes, the rest must be literal strings. I believe we currently accept expressions that fold to strings as well.\nI can update the documentation in a few places to reflect that. The rationale is that building regular expressions on the fly generally lead to poor performance or malformed expressions. For some of the existing EQL implementations, we need to know at compile time, so that the state machine can be built only once.", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r424012653", "createdAt": "2020-05-12T20:27:04Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Match.java", "diffHunk": "@@ -65,29 +72,39 @@ protected TypeResolution resolveType() {\n             return new TypeResolution(\"Unresolved children\");\n         }\n \n-        TypeResolution resolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        int index = 1;\n-        for (Expression regex : patterns) {\n+        TypeResolution resolution;\n+        int index = 0;\n+        List<Integer> nonFoldables = new ArrayList<>(2);\n+        for (Expression e : children()) {\n             // Currently we have limited enum for ordinal numbers\n             // So just using default here for error messaging\n-            resolution = isStringAndExact(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            ParamOrdinal paramOrd = ParamOrdinal.fromIndex(index);\n+            resolution = isStringAndExact(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n                 return resolution;\n             }\n-\n-            resolution = isFoldable(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            resolution = isFoldable(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n-                break;\n+                nonFoldables.add(index);\n             }\n-\n             index++;\n         }\n \n-        return resolution;\n+        if (nonFoldables.size() == 2) {\n+            StringBuilder sb = new StringBuilder(format(null, \"only one argument of [{}] must be non-constant but multiple found: \",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5OTk3OQ=="}, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNTI3Ng==", "bodyText": "The same restrictions apply to match, cidrMatch and wildcard.\nAt one point in the past, the function signature used to look like this: match(<regex>, <expr>), but that's been abandoned and now it's a variadic function of the form match(<expr>, <regex1>, <regex2>, ...). There may have been some tests that were of the old form that didn't get changed because they were being supported for backwards compatibility.  But I think it's okay to drop the ambiguous representation and stick with match(<expr>, <regex1>, <regex2>, ...)", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r424015276", "createdAt": "2020-05-12T20:31:51Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Match.java", "diffHunk": "@@ -65,29 +72,39 @@ protected TypeResolution resolveType() {\n             return new TypeResolution(\"Unresolved children\");\n         }\n \n-        TypeResolution resolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        int index = 1;\n-        for (Expression regex : patterns) {\n+        TypeResolution resolution;\n+        int index = 0;\n+        List<Integer> nonFoldables = new ArrayList<>(2);\n+        for (Expression e : children()) {\n             // Currently we have limited enum for ordinal numbers\n             // So just using default here for error messaging\n-            resolution = isStringAndExact(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            ParamOrdinal paramOrd = ParamOrdinal.fromIndex(index);\n+            resolution = isStringAndExact(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n                 return resolution;\n             }\n-\n-            resolution = isFoldable(regex, sourceText(), ParamOrdinal.fromIndex(index));\n+            resolution = isFoldable(e, sourceText(), paramOrd);\n             if (resolution.unresolved()) {\n-                break;\n+                nonFoldables.add(index);\n             }\n-\n             index++;\n         }\n \n-        return resolution;\n+        if (nonFoldables.size() == 2) {\n+            StringBuilder sb = new StringBuilder(format(null, \"only one argument of [{}] must be non-constant but multiple found: \",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5OTk3OQ=="}, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDQ1MjAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoyNjoyMFrOGUXqCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoyNjoyMFrOGUXqCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxMjI5Ng==", "bodyText": "Why isn't this done inside the main Match constructor or even better inside makeSubstitute?", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r424012296", "createdAt": "2020-05-12T20:26:20Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -122,4 +126,31 @@ protected LogicalPlan rule(Filter filter) {\n             });\n         }\n     }\n+\n+    private static class MatchLiteralsOnTheRight extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                if (e instanceof Match) {\n+                    Match m = (Match) e;\n+                    if (m.children().get(0).foldable()) {\n+                        int size = m.children().size();\n+                        List<Expression> newChildren = new ArrayList<>(size);\n+                        Expression field = null;\n+                        for (Expression c : m.children()) {\n+                            if (c.foldable() == false) {\n+                                field = c;\n+                            } else {\n+                                newChildren.add(c);\n+                            }\n+                        }\n+                        newChildren.add(0, field);\n+                        return m.replaceChildren(newChildren);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDQ2MTM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoyOToxMlrOGUXv8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoyOToxMlrOGUXv8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxMzgwOA==", "bodyText": "I don't exactly know the issue that motivated some of these changes, and am not sure why loosening up the signature of match is a good thing.\nFor this example, I'm confused how it's supposed to be evaluated. Which argument is the source string and which are the patterns to be matched against?", "url": "https://github.com/elastic/elasticsearch/pull/56495#discussion_r424013808", "createdAt": "2020-05-12T20:29:12Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -82,6 +82,24 @@ query = '''\n process where match(command_line, '.*?net[1]?  localgroup.*?', '.*? myappserver.py .*?')\n '''\n \n+[[queries]]\n+expected_event_ids  = [50, 97, 98]\n+query = '''\n+process where match('.*?net[1]?  localgroup.*?', command_line,'.*? myappserver.py .*?')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5d529346bf9d5ce2801746880610832fbc1ec2"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 520, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}