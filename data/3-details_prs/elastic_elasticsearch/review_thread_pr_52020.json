{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMTQzNjI4", "number": 52020, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo0NDoyOVrODd9x6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNjoxM1rODe3gdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzQ3NDk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/geo/TriangleTreeReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo0NDoyOVrOFm3fKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNDo1MlrOFoPX-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI5OTMwNg==", "bodyText": "We need to do a similar change for Tile2D#contains and Tile2D#relateLine", "url": "https://github.com/elastic/elasticsearch/pull/52020#discussion_r376299306", "createdAt": "2020-02-07T09:44:29Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/common/geo/TriangleTreeReader.java", "diffHunk": "@@ -311,22 +314,23 @@ private boolean intersectsLine(int aX, int aY, int bX, int bY) {\n          * Checks if the rectangle intersects the provided triangle\n          **/\n         private GeoRelation relateTriangle(int aX, int aY, boolean ab, int bX, int bY, boolean bc, int cX, int cY, boolean ca) {\n-            // 1. query contains any triangle points\n-            if (contains(aX, aY) || contains(bX, bY) || contains(cX, cY)) {\n-                return GeoRelation.QUERY_CROSSES;\n-            }\n-\n             // compute bounding box of triangle\n             int tMinX = StrictMath.min(StrictMath.min(aX, bX), cX);\n             int tMaxX = StrictMath.max(StrictMath.max(aX, bX), cX);\n             int tMinY = StrictMath.min(StrictMath.min(aY, bY), cY);\n             int tMaxY = StrictMath.max(StrictMath.max(aY, bY), cY);\n \n-            // 2. check bounding boxes are disjoint\n-            if (tMaxX < minX || tMinX > maxX || tMinY > maxY || tMaxY < minY) {\n+\n+            // 1. check bounding boxes are disjoint, where north and east boundaries are not considered as crossing\n+            if (tMaxX <= minX || tMinX > maxX || tMinY > maxY || tMaxY <= minY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff54653ef36ad69a27c8cfa85443b8bee86be8c"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczOTI1OA==", "bodyText": "I have deferred some of these changes as it isn't clear as to which behavior is preferred as previous expected tests are failing", "url": "https://github.com/elastic/elasticsearch/pull/52020#discussion_r377739258", "createdAt": "2020-02-11T16:14:52Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/common/geo/TriangleTreeReader.java", "diffHunk": "@@ -311,22 +314,23 @@ private boolean intersectsLine(int aX, int aY, int bX, int bY) {\n          * Checks if the rectangle intersects the provided triangle\n          **/\n         private GeoRelation relateTriangle(int aX, int aY, boolean ab, int bX, int bY, boolean bc, int cX, int cY, boolean ca) {\n-            // 1. query contains any triangle points\n-            if (contains(aX, aY) || contains(bX, bY) || contains(cX, cY)) {\n-                return GeoRelation.QUERY_CROSSES;\n-            }\n-\n             // compute bounding box of triangle\n             int tMinX = StrictMath.min(StrictMath.min(aX, bX), cX);\n             int tMaxX = StrictMath.max(StrictMath.max(aX, bX), cX);\n             int tMinY = StrictMath.min(StrictMath.min(aY, bY), cY);\n             int tMaxY = StrictMath.max(StrictMath.max(aY, bY), cY);\n \n-            // 2. check bounding boxes are disjoint\n-            if (tMaxX < minX || tMinX > maxX || tMinY > maxY || tMaxY < minY) {\n+\n+            // 1. check bounding boxes are disjoint, where north and east boundaries are not considered as crossing\n+            if (tMaxX <= minX || tMinX > maxX || tMinY > maxY || tMaxY <= minY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI5OTMwNg=="}, "originalCommit": {"oid": "fff54653ef36ad69a27c8cfa85443b8bee86be8c"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzQ3NjI3OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridTiler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo0NDo1OFrOFm3f9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwOTo0NDo1OFrOFm3f9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI5OTUxMQ==", "bodyText": "+1", "url": "https://github.com/elastic/elasticsearch/pull/52020#discussion_r376299511", "createdAt": "2020-02-07T09:44:58Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridTiler.java", "diffHunk": "@@ -200,19 +226,13 @@ protected int setValuesByBruteForceScan(GeoShapeCellValues values, MultiGeoValue\n         }\n \n         protected int setValuesByRasterization(int xTile, int yTile, int zTile, GeoShapeCellValues values,\n-                                               int valuesIndex, int targetPrecision, MultiGeoValues.GeoValue geoValue,\n-                                               MultiGeoValues.BoundingBox shapeBounds) {\n+                                               int valuesIndex, int targetPrecision, MultiGeoValues.GeoValue geoValue) {\n             zTile++;\n             for (int i = 0; i < 2; i++) {\n                 for (int j = 0; j < 2; j++) {\n                     int nextX = 2 * xTile + i;\n                     int nextY = 2 * yTile + j;\n                     Rectangle rectangle = GeoTileUtils.toBoundingBox(nextX, nextY, zTile);\n-                    // TODO: this looks hacky, maybe the relate method should handle it?\n-                    if (shapeBounds.minX() == rectangle.getMaxX() ||\n-                        shapeBounds.maxY() == rectangle.getMinY()) {\n-                        continue;\n-                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff54653ef36ad69a27c8cfa85443b8bee86be8c"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjkzMzAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridTiler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNjoxM1rOFoPbTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoyOTowM1rOFoP8PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MDEwOA==", "bodyText": "I believe this can be improved, maybe there can be a way to wrap the shape such that all the latitudes above the map can be normalized down to the edge tile", "url": "https://github.com/elastic/elasticsearch/pull/52020#discussion_r377740108", "createdAt": "2020-02-11T16:16:13Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridTiler.java", "diffHunk": "@@ -156,10 +157,37 @@ public long encode(double x, double y, int precision) {\n             return GeoTileUtils.longEncode(x, y, precision);\n         }\n \n+        /**\n+         * Sets the values of the long[] underlying {@link GeoShapeCellValues}.\n+         *\n+         * If the shape resides between <code>GeoTileUtils.LATITUDE_MASK</code> and 90 degree latitudes, then\n+         * the shape is not accounted for since geo-tiles are only defined within those bounds.\n+         *\n+         * @param values     the bucket values\n+         * @param geoValue   the input shape\n+         * @param precision  the tile zoom-level\n+         *\n+         * @return the number of tiles set by the shape\n+         */\n         @Override\n         public int setValues(GeoShapeCellValues values, MultiGeoValues.GeoValue geoValue, int precision) {\n             MultiGeoValues.BoundingBox bounds = geoValue.boundingBox();\n             assert bounds.minX() <= bounds.maxX();\n+\n+            if (precision == 0) {\n+                values.resizeCell(1);\n+                values.add(0, GeoTileUtils.longEncodeTiles(0, 0, 0));\n+                return 1;\n+            }\n+\n+            // geo tiles are not defined at the extreme latitudes due to them\n+            // tiling the world as a square.\n+            if ((bounds.top > GeoTileUtils.LATITUDE_MASK && bounds.bottom > GeoTileUtils.LATITUDE_MASK)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad89be5871c824b228111bd21df43aa638f3ec06"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MzkzMw==", "bodyText": "Not sure what is the right answer, but if the shape is out of the grid bounds, I think returning an empty intersection is the correct answer.", "url": "https://github.com/elastic/elasticsearch/pull/52020#discussion_r377743933", "createdAt": "2020-02-11T16:22:03Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridTiler.java", "diffHunk": "@@ -156,10 +157,37 @@ public long encode(double x, double y, int precision) {\n             return GeoTileUtils.longEncode(x, y, precision);\n         }\n \n+        /**\n+         * Sets the values of the long[] underlying {@link GeoShapeCellValues}.\n+         *\n+         * If the shape resides between <code>GeoTileUtils.LATITUDE_MASK</code> and 90 degree latitudes, then\n+         * the shape is not accounted for since geo-tiles are only defined within those bounds.\n+         *\n+         * @param values     the bucket values\n+         * @param geoValue   the input shape\n+         * @param precision  the tile zoom-level\n+         *\n+         * @return the number of tiles set by the shape\n+         */\n         @Override\n         public int setValues(GeoShapeCellValues values, MultiGeoValues.GeoValue geoValue, int precision) {\n             MultiGeoValues.BoundingBox bounds = geoValue.boundingBox();\n             assert bounds.minX() <= bounds.maxX();\n+\n+            if (precision == 0) {\n+                values.resizeCell(1);\n+                values.add(0, GeoTileUtils.longEncodeTiles(0, 0, 0));\n+                return 1;\n+            }\n+\n+            // geo tiles are not defined at the extreme latitudes due to them\n+            // tiling the world as a square.\n+            if ((bounds.top > GeoTileUtils.LATITUDE_MASK && bounds.bottom > GeoTileUtils.LATITUDE_MASK)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MDEwOA=="}, "originalCommit": {"oid": "ad89be5871c824b228111bd21df43aa638f3ec06"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0ODU0MQ==", "bodyText": "makes sense", "url": "https://github.com/elastic/elasticsearch/pull/52020#discussion_r377748541", "createdAt": "2020-02-11T16:29:03Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridTiler.java", "diffHunk": "@@ -156,10 +157,37 @@ public long encode(double x, double y, int precision) {\n             return GeoTileUtils.longEncode(x, y, precision);\n         }\n \n+        /**\n+         * Sets the values of the long[] underlying {@link GeoShapeCellValues}.\n+         *\n+         * If the shape resides between <code>GeoTileUtils.LATITUDE_MASK</code> and 90 degree latitudes, then\n+         * the shape is not accounted for since geo-tiles are only defined within those bounds.\n+         *\n+         * @param values     the bucket values\n+         * @param geoValue   the input shape\n+         * @param precision  the tile zoom-level\n+         *\n+         * @return the number of tiles set by the shape\n+         */\n         @Override\n         public int setValues(GeoShapeCellValues values, MultiGeoValues.GeoValue geoValue, int precision) {\n             MultiGeoValues.BoundingBox bounds = geoValue.boundingBox();\n             assert bounds.minX() <= bounds.maxX();\n+\n+            if (precision == 0) {\n+                values.resizeCell(1);\n+                values.add(0, GeoTileUtils.longEncodeTiles(0, 0, 0));\n+                return 1;\n+            }\n+\n+            // geo tiles are not defined at the extreme latitudes due to them\n+            // tiling the world as a square.\n+            if ((bounds.top > GeoTileUtils.LATITUDE_MASK && bounds.bottom > GeoTileUtils.LATITUDE_MASK)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MDEwOA=="}, "originalCommit": {"oid": "ad89be5871c824b228111bd21df43aa638f3ec06"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}