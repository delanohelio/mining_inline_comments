{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNzQ4MDUy", "number": 51852, "title": "Shortcut query phase using the results of other shards", "bodyText": "This commit, built on top of #51708, allows to modify shard search requests based on informations collected on other shards. It is intended to speed up sorted queries on time-based indices. For queries that are only interested in the top documents.\nThis change will rewrite the shard queries to match none if the bottom sort value computed in prior shards is better than all values in the shard.\nFor queries that mix top documents and aggregations this change will reset the size of the top documents to 0 instead of rewriting to match none.\nThis means that we don't need to keep a search context open for this shard since we know in advance that it doesn't contain any competitive hit.\nCloses #49601", "createdAt": "2020-02-04T10:07:33Z", "url": "https://github.com/elastic/elasticsearch/pull/51852", "merged": true, "mergeCommit": {"oid": "ff94792e41689ecd075c7eae7b73529d1b548346"}, "closed": true, "closedAt": "2020-03-17T09:54:45Z", "author": {"login": "jimczi"}, "timelineItems": {"totalCount": 62, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_hwn0AH2gAyMzcwNzQ4MDUyOjI4ZmEyM2I4Y2I2OWRjMmU3OGQ2YWFmNDkxZDA4ZDQ3YjExNjRlNDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOelHjgH2gAyMzcwNzQ4MDUyOmU0ZThiMDIyNGI3MGYxNDIzZjE1NmIzMDgxZGU1ZDU0OTFiNGI0M2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "28fa23b8cb69dc2e78d6aaf491d08d47b1164e43", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/28fa23b8cb69dc2e78d6aaf491d08d47b1164e43", "committedDate": "2020-01-30T21:52:08Z", "message": "Always rewrite search shard request outside of the search thread pool\n\nThis change ensures that the rewrite of the shard request is executed in the network thread or in the refresh listener\nwhen waiting for an active shard. This allows queries that rewrite to match_no_docs to bypass the search thread pool\nentirely even if the can_match phase was skipped (pre_filter_shard_size > number of shards). Coordinating nodes\ndon't have the ability to create empty responses so this change also ensures that at least one shard creates a full empty\nresponse while the other can return null ones. This is needed since creating true empty responses on shards require to create\nconcrete aggregators which would be too costly to build on a network thread. We should move this functionality to aggregation\nbuilders in a follow up but that would be a much bigger change.\nThis change is also important for #49601 since we want to add the ability to use the result of other shards to rewrite the request\nof subsequent ones. For instance if the first M shards have their top N computed, the top worst document in the global queue can be pass\nto subsequent shards that can then rewrite to match_no_docs if they can guarantee that they don't have any document better than the provided\none."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "534b5525ed54f1e4efbe6267bb154b9be578a6f7", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/534b5525ed54f1e4efbe6267bb154b9be578a6f7", "committedDate": "2020-01-30T22:03:28Z", "message": "add serialization test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02f352fe574de396eef1c89f98de74314a35133", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/c02f352fe574de396eef1c89f98de74314a35133", "committedDate": "2020-01-30T22:40:32Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "010ec08d4c01c55b49a5584e6ee2b57d5b67a180", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/010ec08d4c01c55b49a5584e6ee2b57d5b67a180", "committedDate": "2020-01-30T22:41:02Z", "message": "Merge branch 'master' into rewrite_shard_request_no_rejection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5684ecfc7c42588d167d0eec759f9f6f6a1ceb9", "committedDate": "2020-01-30T23:35:04Z", "message": "fix bwc issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0acf244b16fc4a7e9bbfeb64160b71d1ae1a7535", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/0acf244b16fc4a7e9bbfeb64160b71d1ae1a7535", "committedDate": "2020-02-03T10:17:08Z", "message": "address review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6016fa43c844868940c1cf4f5b8572ab69093d52", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/6016fa43c844868940c1cf4f5b8572ab69093d52", "committedDate": "2020-02-03T10:49:40Z", "message": "adapt test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0581270a25c6a11182a5eae9ec2cdeec39e2a07", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/a0581270a25c6a11182a5eae9ec2cdeec39e2a07", "committedDate": "2020-02-03T10:52:09Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8534ed25df43ced97d8ff983caaaec115f6d0ea6", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/8534ed25df43ced97d8ff983caaaec115f6d0ea6", "committedDate": "2020-02-03T14:24:37Z", "message": "fix topNSize when size is reset to 0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27cdf19dfe2c98cd9939cb15f1cab7b34a6e5254", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/27cdf19dfe2c98cd9939cb15f1cab7b34a6e5254", "committedDate": "2020-02-03T19:44:59Z", "message": "add more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a313d1d002930b1f3cc93c925ec7c4607997870e", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/a313d1d002930b1f3cc93c925ec7c4607997870e", "committedDate": "2020-02-03T19:45:23Z", "message": "Merge branch 'master' into rewrite_shard_request_no_rejection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "662972cf2de9b2ad36077b886c4930c8d2a08468", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/662972cf2de9b2ad36077b886c4930c8d2a08468", "committedDate": "2020-02-03T20:36:16Z", "message": "more review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76e90a231f3d4ac4475425e0326792f845b2b4ac", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/76e90a231f3d4ac4475425e0326792f845b2b4ac", "committedDate": "2020-02-03T20:38:39Z", "message": "initial commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eb98fbd56e69aa90abc1aae0022adae493700d4", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/7eb98fbd56e69aa90abc1aae0022adae493700d4", "committedDate": "2020-02-03T20:38:42Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac0451ca0a9f124e6567128a24450025050725a2", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac0451ca0a9f124e6567128a24450025050725a2", "committedDate": "2020-02-03T22:25:00Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0ae6587a970699e73ece42db6a4f2c378b8b1b6", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/d0ae6587a970699e73ece42db6a4f2c378b8b1b6", "committedDate": "2020-02-04T08:14:52Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6747e6f0a895509ac1677a2d10be21b13fa96ad", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/c6747e6f0a895509ac1677a2d10be21b13fa96ad", "committedDate": "2020-02-04T08:17:26Z", "message": "Merge branch 'rewrite_shard_request_no_rejection' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30b3bcb19c8f23baf30b3b5db2da261612f8fe78", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/30b3bcb19c8f23baf30b3b5db2da261612f8fe78", "committedDate": "2020-02-04T09:40:31Z", "message": "iter2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "961c2cd4aa0547272e1e50fda213de90e5f81754", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/961c2cd4aa0547272e1e50fda213de90e5f81754", "committedDate": "2020-02-04T10:39:34Z", "message": "remove unrelated change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d04a16d605b25c47739ededb18366a802764d45a", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/d04a16d605b25c47739ededb18366a802764d45a", "committedDate": "2020-02-06T08:27:31Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af204212f937a19f9b92df50034a59e76fdaa06a", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/af204212f937a19f9b92df50034a59e76fdaa06a", "committedDate": "2020-02-06T08:40:23Z", "message": "fix last merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "291f7427ea7d4d96b0c36857366a15956934a9aa", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/291f7427ea7d4d96b0c36857366a15956934a9aa", "committedDate": "2020-02-06T11:07:13Z", "message": "fix rest test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/71876e4253d3bac8f2acab736aaa74ba35edf310", "committedDate": "2020-02-06T11:57:00Z", "message": "another fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MDM2Nzgw", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-356036780", "createdAt": "2020-02-10T15:38:16Z", "commit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNTozODoxNlrOFnqvwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODo0MTowNVrOFnxLpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEzOTEzNg==", "bodyText": "Not relevant to this PR, but In future, do we want to rewrite  also requests without sort ( e.g. a keyword search) that can be shortcut?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377139136", "createdAt": "2020-02-10T15:38:16Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE0MTk5Nw==", "bodyText": "we can use this.topDocsSize  that we have already pre-calculated.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377141997", "createdAt": "2020-02-10T15:42:21Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {\n+                SearchSourceBuilder newSource = source.shallowCopy();\n+                newSource.trackTotalHits(false);\n+                if (topDocs.scoreDocs.length >= topDocsSize) {\n+                    FieldDoc bottomDoc = (FieldDoc) topDocs.scoreDocs[topDocs.scoreDocs.length-1];\n+                    request.setRawBottomSortValues(bottomDoc.fields);\n+                }\n+                request.source(newSource);\n+            }\n+        }\n+        return request;\n+    }\n+\n+    private Supplier<TopDocs> getBufferTopDocsSupplier(SearchRequest request,\n+                                                       SearchPhaseResults<SearchPhaseResult> searchPhaseResults) {\n+        if (searchPhaseResults instanceof SearchPhaseController.QueryPhaseResultConsumer == false) {\n+            return () -> null;\n+        }\n+        int size = getTopDocsSize(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw==", "bodyText": "I wondering about the case where there was not a reduction, and topDocsBuffer[0] contains a result of any of the first X shards (X is currently 512 by default).   In this case the bottom doc of this shard may not be the best competitive doc.  If we have several topDocs available, should we inspect all of them to find the most competitive doc?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377226997", "createdAt": "2020-02-10T18:05:49Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -683,6 +683,15 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             processedShards[querySearchResult.getShardIndex()] = querySearchResult.getSearchShardTarget();\n         }\n \n+        public TopDocs getBufferTopDocs() {\n+            if (hasTopDocs) {\n+                synchronized (this) {\n+                    return topDocsBuffer[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA==", "bodyText": "should we instead sum all values from totalHits.value from all topDocs in QueryPhaseResultConsumer#topDocsBuffer?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377242774", "createdAt": "2020-02-10T18:37:31Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA==", "bodyText": "I am wondering if instead TRACK_TOTAL_HITS_DISABLED we can instead have a condition describing that we have already collected enough total hits?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377244580", "createdAt": "2020-02-10T18:41:05Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -343,6 +367,25 @@ public String getDescription() {\n         public Rewriteable rewrite(QueryRewriteContext ctx) throws IOException {\n             SearchSourceBuilder newSource = request.source() == null ? null : Rewriteable.rewrite(request.source(), ctx);\n             AliasFilter newAliasFilter = Rewriteable.rewrite(request.getAliasFilter(), ctx);\n+\n+            QueryShardContext shardContext = ctx.convertToShardContext();\n+            FieldSortBuilder primarySort = FieldSortBuilder.getPrimaryFieldSortOrNull(newSource);\n+            // checks if the bottom sort values are guaranteed to be more competitive than all the documents\n+            // contained in the shard\n+            if (shardContext != null\n+                    && primarySort != null\n+                    && primarySort.isBottomSortWithinShard(shardContext, request.getRawBottomSortValues()) == false) {\n+                newSource = newSource.shallowCopy();\n+                if (newSource.trackTotalHitsUpTo() == TRACK_TOTAL_HITS_DISABLED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTg5MjM2", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-356189236", "createdAt": "2020-02-10T19:08:42Z", "commit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTowODo0M1rOFnyE-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTowODo0M1rOFnyE-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng==", "bodyText": "I am wondering if we send MatchNoneQueryBuilder() request to a shard, or size =0 for a request containing query part, can we say that we skipped this shard?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377259256", "createdAt": "2020-02-10T19:08:43Z", "author": {"login": "mayya-sharipova"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search/140_pre_filter_search_shards.yml", "diffHunk": "@@ -180,5 +178,47 @@ setup:\n   - match: { _shards.successful: 3 }\n   - match: { _shards.skipped : 0 }\n   - match: { _shards.failed: 0 }\n-  - match: { hits.total: 0 }\n+  - match: { hits.total.value: 0 }\n   - length: { aggregations.idx_terms.buckets: 0 }\n+\n+  # check field sort is correct when skipping query phase\n+  - do:\n+      search:\n+        # ensure that one shard can return empty response\n+        max_concurrent_shard_requests: 1\n+        pre_filter_shard_size: 1\n+        body:\n+          \"size\": 1\n+          \"track_total_hits\": 1\n+          \"sort\": [{ \"created_at\": \"desc\"}]\n+\n+  - match: { _shards.total: 3 }\n+  - match: { _shards.successful: 3 }\n+  - match: { _shards.skipped: 0 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8aa0e2f42e46d7e9fb9ceeea98ffc9302709c49", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8aa0e2f42e46d7e9fb9ceeea98ffc9302709c49", "committedDate": "2020-02-24T11:12:59Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db4b44f855942177e4052c26ad46e2c486907f92", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/db4b44f855942177e4052c26ad46e2c486907f92", "committedDate": "2020-02-24T11:19:45Z", "message": "address review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd927bd48fe359c2d80c43abf778260f768740f4", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/bd927bd48fe359c2d80c43abf778260f768740f4", "committedDate": "2020-02-24T11:54:07Z", "message": "adapt serialization version before backport"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf8ebde8430f12d9698f72e8d3ca54e61070993a", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/bf8ebde8430f12d9698f72e8d3ca54e61070993a", "committedDate": "2020-02-28T14:57:47Z", "message": "address review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/30173b6b6adea46e899b29099f8cc15136739abe", "committedDate": "2020-02-28T14:58:23Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTA3MzI1", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-366507325", "createdAt": "2020-02-28T16:04:00Z", "commit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjowNDowMFrOFv6JLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjowNDowMFrOFv6JLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4MDAxNQ==", "bodyText": "should it be fieldComparator.compareValues(bestBottom, cand.fields[0]).... ?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385780015", "createdAt": "2020-02-28T16:04:00Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;\n+        FieldDoc bestBottom = null;\n+        SortField primarySort = topDocsList.get(0).fields[0];\n+        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n+        int reverseMul = primarySort.getReverse() ? -1 : 1;\n+        // we don't want to perform a costly merge to find the best bottom field doc so\n+        // we just check pick the best bottom document among the available buffer. This\n+        // means that we don't have the true-best bottom but this avoids running a partial\n+        // merge too often.\n+        for (TopFieldDocs topDocs : topDocsList) {\n+            totalHits += topDocs.totalHits.value;\n+            if (topDocs.scoreDocs.length == topDocsSize) {\n+                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n+                if (bestBottom == null ||\n+                        fieldComparator.compareValues(cand.fields[0], cand.fields[0]) * reverseMul > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e198658bf44e2245e159d2735c96c1c13cd4bc6", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/2e198658bf44e2245e159d2735c96c1c13cd4bc6", "committedDate": "2020-02-28T16:12:59Z", "message": "fix comparator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTE0MjUw", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-366514250", "createdAt": "2020-02-28T16:13:40Z", "commit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjoxMzo0MVrOFv6dhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjoxMzo0MVrOFv6dhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NTIyMQ==", "bodyText": "It is not clear for me why a default value for totalHits  is -1?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385785221", "createdAt": "2020-02-28T16:13:41Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eae737035abbf59b39194d364d68cb7a33d9fae", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/8eae737035abbf59b39194d364d68cb7a33d9fae", "committedDate": "2020-02-28T16:15:24Z", "message": "fix topdocs size"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTgzNjc1", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-366583675", "createdAt": "2020-02-28T18:03:43Z", "commit": {"oid": "8eae737035abbf59b39194d364d68cb7a33d9fae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODowMzo0NFrOFv96Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODowMzo0NFrOFv96Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0MTY5MA==", "bodyText": "Is there a reason why we pass have pass an array of bottom sort values, but we use only 1st element? Should we pass only the 1st element  \u2013 Object[] rawBottomSortValue?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385841690", "createdAt": "2020-02-28T18:03:44Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether all values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortWithinShard(QueryShardContext context, Object[] rawBottomSortValues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8eae737035abbf59b39194d364d68cb7a33d9fae"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea5727ecd17230c45c7600a4a369b41b8d5f2567", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/ea5727ecd17230c45c7600a4a369b41b8d5f2567", "committedDate": "2020-03-02T11:30:20Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f", "committedDate": "2020-03-03T12:22:33Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee2591fc62b10f0b353a606bbfc7e3c19b21d624", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/ee2591fc62b10f0b353a606bbfc7e3c19b21d624", "committedDate": "2020-03-03T12:22:56Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ec6a6caee3981475f0b8b3bf9da3815d19b2c86", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/4ec6a6caee3981475f0b8b3bf9da3815d19b2c86", "committedDate": "2020-03-03T16:47:43Z", "message": "fix final merge when some shard responses have their size artifically rewrote to 0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09bfb098a2e21f2e435f6318929e04bda9808eaf", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/09bfb098a2e21f2e435f6318929e04bda9808eaf", "committedDate": "2020-03-03T17:07:08Z", "message": "check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e268c6bf5ba52c844871f1f488a3dcf4a1d74e3", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/5e268c6bf5ba52c844871f1f488a3dcf4a1d74e3", "committedDate": "2020-03-03T19:44:57Z", "message": "return topfielddocs if the shard search request rewrites the size to 0"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODI2MjAx", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-368826201", "createdAt": "2020-03-04T14:32:56Z", "commit": {"oid": "f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozMjo1NlrOFxvkDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozMjo1NlrOFxvkDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwMzgyMg==", "bodyText": "Previously using fieldComparator.compareValues looks to be faster than using TopFieldDocs.merge (as TopFieldDocs.merge doing a lot of stuff that we don't really need),  especially considering that mergeTopDocs is a synchronized function, and we want to be quite fast.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r387703822", "createdAt": "2020-03-04T14:32:56Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -85,71 +88,59 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        mergeTopDocs(result.queryResult());\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n \n-    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n-        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n-        if (resultConsumer == null) {\n-            return request;\n+    private synchronized void mergeTopDocs(QuerySearchResult result) {\n+        if (result.isNull()\n+                || hasPrimaryFieldSort == false\n+                || result.topDocs().topDocs instanceof TopFieldDocs == false) {\n+            return;\n         }\n-        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n-            .filter(obj -> obj instanceof TopFieldDocs)\n-            .map(obj -> (TopFieldDocs) obj)\n-            .collect(Collectors.toList());\n-        if (topDocsList.isEmpty()) {\n-            return request;\n+        // merge the current best bottom field doc with the new query result\n+        TopFieldDocs topDocs = (TopFieldDocs) result.topDocs().topDocs;\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, result.getShardIndex()) };\n+            bottomDocs[0].shardIndex = result.getShardIndex();\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n         }\n-        SearchSourceBuilder source = request.source();\n-        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n-        long totalHits = 0;\n-        FieldDoc bestBottom = null;\n-        SortField primarySort = topDocsList.get(0).fields[0];\n-        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n-        int reverseMul = primarySort.getReverse() ? -1 : 1;\n-        // we don't want to perform a costly merge to find the best bottom field doc so\n-        // we just check pick the best bottom document among the available buffer. This\n-        // means that we don't have the true-best bottom but this avoids running a partial\n-        // merge too often.\n-        for (TopFieldDocs topDocs : topDocsList) {\n-            totalHits += topDocs.totalHits.value;\n-            if (topDocs.scoreDocs.length == topDocsSize) {\n-                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n-                if (bestBottom == null ||\n-                        fieldComparator.compareValues(cand.fields[0], bestBottom.fields[0]) * reverseMul < 0) {\n-                    bestBottom = cand;\n-                }\n-            }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{bottomTopDocs, toMerge}, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/2307e73ce5c4500609a22c9bbba6162a9028407b", "committedDate": "2020-03-06T09:37:18Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjQ4Njkz", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-370248693", "createdAt": "2020-03-06T11:13:22Z", "commit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMzoyMlrOFy1Sxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMTozMDo1NVrOFy1uhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjI3OA==", "bodyText": "I don't think we should ignore errors here, what if this left bottomTopDocs in an inconsistent state?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388846278", "createdAt": "2020-03-06T11:13:22Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NzIzMQ==", "bodyText": "is this assertion right? I'm not seeing where we make sure to only call this method on sorted requests.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388847231", "createdAt": "2020-03-06T11:15:50Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);\n+        }\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    // merge the current best bottom field doc with the new query result\n+    private synchronized void mergeTopDocs(TopFieldDocs topDocs, int shardIndex) {\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, shardIndex) };\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n+        }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{ bottomTopDocs, toMerge }, false);\n+        }\n+    }\n+\n+    ShardSearchRequest rewriteShardSearchRequest(ShardSearchRequest request) {\n+        final TopFieldDocs current = bottomTopDocs;\n+        if (current == null) {\n+            return request;\n+        }\n+\n+        // disable tracking total hits if we already reached the required estimation.\n+        if (trackTotalHitsUpTo != SearchContext.TRACK_TOTAL_HITS_ACCURATE\n+                && current.totalHits.value >= trackTotalHitsUpTo\n+                && current.totalHits.relation == GREATER_THAN_OR_EQUAL_TO) {\n+            assert request.source() != null : \"source should contain a primary sort field\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0Nzg0OA==", "bodyText": "maybe rename to currentBottomTopDocs to make the below logic easier to read?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388847848", "createdAt": "2020-03-06T11:17:24Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);\n+        }\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    // merge the current best bottom field doc with the new query result\n+    private synchronized void mergeTopDocs(TopFieldDocs topDocs, int shardIndex) {\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, shardIndex) };\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n+        }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{ bottomTopDocs, toMerge }, false);\n+        }\n+    }\n+\n+    ShardSearchRequest rewriteShardSearchRequest(ShardSearchRequest request) {\n+        final TopFieldDocs current = bottomTopDocs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1Mjg3Ng==", "bodyText": "rawBottomSortValues stores the implementation-specific values while isFieldWithinQuery expects high-level representations of the values. For instance, I believe that this implementation as-is is incorrect for date_nanos, which would return a number of nanos since Epoch in rawBottomSortValues and then parse a number of millis in isFieldWithinQuery. So we should call DocValueFormat#format on the min/max values before passing them to isFieldWithinQuery.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388852876", "createdAt": "2020-03-06T11:29:30Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzExMw==", "bodyText": "I don't like silently ignoring exceptions here, can we narrow down the exception type or remove the catch block entirely? I worry that this might hide bugs.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388853113", "createdAt": "2020-03-06T11:30:09Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);\n+            return relation == MappedFieldType.Relation.DISJOINT;\n+        } catch (Exception exc) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzM4MQ==", "bodyText": "why do we need both?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388853381", "createdAt": "2020-03-06T11:30:55Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/lucene/Lucene.java", "diffHunk": "@@ -111,6 +111,7 @@\n     public static final NamedAnalyzer KEYWORD_ANALYZER = new NamedAnalyzer(\"_keyword\", AnalyzerScope.GLOBAL, new KeywordAnalyzer());\n \n     public static final ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];\n+    public static final ScoreDoc[] EMPTY_FIELD_DOCS = new ScoreDoc[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae1b2789bbc509e17c4b99b32d1a2bbb59eac6f0", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae1b2789bbc509e17c4b99b32d1a2bbb59eac6f0", "committedDate": "2020-03-09T15:50:03Z", "message": "Replace raw sort values with formatted ones to handle date and date_nanos correctly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfd2c7253c2996c08d250b550800370dc9971348", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/bfd2c7253c2996c08d250b550800370dc9971348", "committedDate": "2020-03-09T19:27:09Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6489ffeefff1e0ceb43be2e2a16384b1a96567ed", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/6489ffeefff1e0ceb43be2e2a16384b1a96567ed", "committedDate": "2020-03-09T19:43:08Z", "message": "fix unset of track total hits in distributed search"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73aa68159154be7d8da13f34e15d8a4c51c9ec60", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/73aa68159154be7d8da13f34e15d8a4c51c9ec60", "committedDate": "2020-03-10T00:07:34Z", "message": "fix compilation test after merging with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2504e6afb995ebaa428f3d3ebf60b6096b5b241", "committedDate": "2020-03-10T07:49:50Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNzQ0NDI2", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-371744426", "createdAt": "2020-03-10T08:12:04Z", "commit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoxMjowNVrOF0EuXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoyODoyMVrOF0FKGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.formattedSortValues[i] = sortValue;\n          \n          \n            \n                            assert sortValue == null : \"Sort values must be a BytesRef, Long or Double, but got \" + sortValue.getClass() + \": \" + sortValue;\n          \n          \n            \n                            this.formattedSortValues[i] = sortValue;", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390147679", "createdAt": "2020-03-10T08:12:05Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/SearchSortValuesAndFormats.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.lucene.Lucene;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class SearchSortValuesAndFormats implements Writeable {\n+    private final Object[] rawSortValues;\n+    private final Object[] formattedSortValues;\n+    private final DocValueFormat[] sortValueFormats;\n+\n+    public SearchSortValuesAndFormats(Object[] rawSortValues, DocValueFormat[] sortValueFormats) {\n+        assert rawSortValues.length == sortValueFormats.length;\n+        this.rawSortValues = rawSortValues;\n+        this.sortValueFormats = sortValueFormats;\n+        this.formattedSortValues = Arrays.copyOf(rawSortValues, rawSortValues.length);\n+        for (int i = 0; i < rawSortValues.length; ++i) {\n+            Object sortValue = rawSortValues[i];\n+            if (sortValue instanceof BytesRef) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((BytesRef) sortValue);\n+            } else if (sortValue instanceof Long) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((long) sortValue);\n+            } else if (sortValue instanceof Double) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((double) sortValue);\n+            } else {\n+                this.formattedSortValues[i] = sortValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1NDc3OA==", "bodyText": "is my understanding correct that we need this for the case when a shard is mapped as a date_nanos field while other fields are mapped as date fields?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390154778", "createdAt": "2020-03-10T08:28:21Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +353,49 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>bottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, SearchSortValuesAndFormats bottomSortValues) throws IOException {\n+        if (bottomSortValues == null || bottomSortValues.getRawSortValues().length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        DocValueFormat docValueFormat = bottomSortValues.getSortValueFormats()[0];\n+        final DateMathParser dateMathParser;\n+        if (docValueFormat instanceof DocValueFormat.DateTime) {\n+            if (fieldType instanceof DateFieldType && ((DateFieldType) fieldType).resolution() == NANOSECONDS) {\n+                // no matter what\n+                docValueFormat = DocValueFormat.withNanosecondResolution(docValueFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36bec996a78aa340dc7686cbdd0f8af3d57c4263", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/36bec996a78aa340dc7686cbdd0f8af3d57c4263", "committedDate": "2020-03-10T09:48:12Z", "message": "fix partial comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74b8bea6e39f2be287e361e0ae6c87f3b5980395", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/74b8bea6e39f2be287e361e0ae6c87f3b5980395", "committedDate": "2020-03-11T12:07:31Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a5422282569cd68acbf04268939247e765513d3", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a5422282569cd68acbf04268939247e765513d3", "committedDate": "2020-03-11T14:00:18Z", "message": "iter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyODkxNjEy", "url": "https://github.com/elastic/elasticsearch/pull/51852#pullrequestreview-372891612", "createdAt": "2020-03-11T15:51:51Z", "commit": {"oid": "7a5422282569cd68acbf04268939247e765513d3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abda5305ee9602bb9a4c3b9c733c57b41b2fb268", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/abda5305ee9602bb9a4c3b9c733c57b41b2fb268", "committedDate": "2020-03-13T11:22:48Z", "message": "Add stricter assertions\n\nCo-Authored-By: Adrien Grand <jpountz@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06cbc1981b63cca2b8ab23001f0e14523fd21c51", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/06cbc1981b63cca2b8ab23001f0e14523fd21c51", "committedDate": "2020-03-13T11:37:45Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74c5d993d0298abc9f214ebb275045a4cd3f461f", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/74c5d993d0298abc9f214ebb275045a4cd3f461f", "committedDate": "2020-03-13T11:38:12Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e526147b9a4ff2456d8e0cb24b5e6e06a72accd0", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/e526147b9a4ff2456d8e0cb24b5e6e06a72accd0", "committedDate": "2020-03-13T13:51:05Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14542f00db2cca904381678a3a26a20ee77e229b", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/14542f00db2cca904381678a3a26a20ee77e229b", "committedDate": "2020-03-16T08:26:14Z", "message": "sort values can be integers and floats (_doc and _score)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ad41c26ecd936a74229795cc9edbff17f6057ab", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/8ad41c26ecd936a74229795cc9edbff17f6057ab", "committedDate": "2020-03-16T11:07:29Z", "message": "fix test to handle accepted raw sort format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "270533c93ed2d9265208acceb37abc96ffe398d0", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/270533c93ed2d9265208acceb37abc96ffe398d0", "committedDate": "2020-03-17T08:16:50Z", "message": "Merge branch 'master' into distributed_time_sort"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4e8b0224b70f1423f156b3081de5d5491b4b43a", "author": {"user": {"login": "jimczi", "name": "Jim Ferenczi"}}, "url": "https://github.com/elastic/elasticsearch/commit/e4e8b0224b70f1423f156b3081de5d5491b4b43a", "committedDate": "2020-03-17T08:38:43Z", "message": "fix compil after master merge"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2997, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}