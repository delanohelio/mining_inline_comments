{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwMzU2Mjcx", "number": 51815, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoxMzo0NFrODdPhog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo1MToyMFrODdQI8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTg5NjY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoxMzo0NFrOFlu3aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTowMToyM1rOFlzyyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTQ4MA==", "bodyText": "Suggest renaming this to SearchableSnapshotShardStats to clarify that these stats are per-shard.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375109480", "createdAt": "2020-02-05T08:13:44Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDIxNg==", "bodyText": "Sure, I pushed 1167ff7", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190216", "createdAt": "2020-02-05T11:01:23Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTQ4MA=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTg5OTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoxNTowNlrOFlu5Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjoxNToyOFrOFl97yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ==", "bodyText": "Should we use writeVLong? I think all these numbers will be nonnegative (we can assert that).", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375109955", "createdAt": "2020-02-05T08:15:06Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {\n+\n+    private final List<CacheIndexInputStats> inputStats;\n+    private final ShardRouting shardRouting;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+\n+    public SearchableSnapshotStats(ShardRouting shardRouting, SnapshotId snapshotId, IndexId indexId, List<CacheIndexInputStats> stats) {\n+        this.shardRouting = Objects.requireNonNull(shardRouting);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.inputStats = unmodifiableList(Objects.requireNonNull(stats));\n+    }\n+\n+    public SearchableSnapshotStats(StreamInput in) throws IOException {\n+        this.shardRouting = new ShardRouting(in);\n+        this.snapshotId = new SnapshotId(in);\n+        this.indexId = new IndexId(in);\n+        this.inputStats = in.readList(CacheIndexInputStats::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        shardRouting.writeTo(out);\n+        snapshotId.writeTo(out);\n+        indexId.writeTo(out);\n+        out.writeList(inputStats);\n+    }\n+\n+    public ShardRouting getShardRouting() {\n+        return shardRouting;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public List<CacheIndexInputStats> getStats() {\n+        return inputStats;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        {\n+            builder.field(\"snapshot_uuid\", getSnapshotId().getUUID());\n+            builder.field(\"index_uuid\", getIndexId().getId());\n+            builder.startObject(\"shard\");\n+            {\n+                builder.field(\"state\", shardRouting.state());\n+                builder.field(\"primary\", shardRouting.primary());\n+                builder.field(\"node\", shardRouting.currentNodeId());\n+                if (shardRouting.relocatingNodeId() != null) {\n+                    builder.field(\"relocating_node\", shardRouting.relocatingNodeId());\n+                }\n+            }\n+            builder.endObject();\n+            builder.startArray(\"files\");\n+            {\n+                List<CacheIndexInputStats> stats = inputStats.stream()\n+                    .sorted(Comparator.comparing(CacheIndexInputStats::getFileName)).collect(toList());\n+                for (CacheIndexInputStats stat : stats) {\n+                    stat.toXContent(builder, params);\n+                }\n+            }\n+            builder.endArray();\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        SearchableSnapshotStats that = (SearchableSnapshotStats) other;\n+        return Objects.equals(shardRouting, that.shardRouting)\n+            && Objects.equals(snapshotId, that.snapshotId)\n+            && Objects.equals(indexId, that.indexId)\n+            && Objects.equals(inputStats, that.inputStats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(shardRouting, snapshotId, indexId, inputStats);\n+    }\n+\n+\n+    public static class CacheIndexInputStats implements Writeable, ToXContentObject {\n+\n+        private final String fileName;\n+        private final long fileLength;\n+\n+        private final long openCount;\n+        private final long innerCount;\n+        private final long closeCount;\n+\n+        private final Counter forwardSmallSeeks;\n+        private final Counter backwardSmallSeeks;\n+        private final Counter forwardLargeSeeks;\n+        private final Counter backwardLargeSeeks;\n+        private final Counter contiguousReads;\n+        private final Counter nonContiguousReads;\n+        private final Counter cachedBytesRead;\n+        private final Counter cachedBytesWritten;\n+        private final Counter directBytesRead;\n+\n+        public CacheIndexInputStats(String fileName, long fileLength, long openCount, long innerCount, long closeCount,\n+                                    Counter forwardSmallSeeks, Counter backwardSmallSeeks,\n+                                    Counter forwardLargeSeeks, Counter backwardLargeSeeks,\n+                                    Counter contiguousReads, Counter nonContiguousReads,\n+                                    Counter cachedBytesRead, Counter cachedBytesWritten,\n+                                    Counter directBytesRead) {\n+            this.fileName = fileName;\n+            this.fileLength = fileLength;\n+            this.openCount = openCount;\n+            this.innerCount = innerCount;\n+            this.closeCount = closeCount;\n+            this.forwardSmallSeeks = forwardSmallSeeks;\n+            this.backwardSmallSeeks = backwardSmallSeeks;\n+            this.forwardLargeSeeks = forwardLargeSeeks;\n+            this.backwardLargeSeeks = backwardLargeSeeks;\n+            this.contiguousReads = contiguousReads;\n+            this.nonContiguousReads = nonContiguousReads;\n+            this.cachedBytesRead = cachedBytesRead;\n+            this.cachedBytesWritten = cachedBytesWritten;\n+            this.directBytesRead = directBytesRead;\n+        }\n+\n+        CacheIndexInputStats(final StreamInput in) throws IOException {\n+            this.fileName = in.readString();\n+            this.fileLength = in.readVLong();\n+            this.openCount = in.readVLong();\n+            this.innerCount = in.readVLong();\n+            this.closeCount = in.readVLong();\n+            this.forwardSmallSeeks = new Counter(in);\n+            this.backwardSmallSeeks = new Counter(in);\n+            this.forwardLargeSeeks = new Counter(in);\n+            this.backwardLargeSeeks = new Counter(in);\n+            this.contiguousReads = new Counter(in);\n+            this.nonContiguousReads = new Counter(in);\n+            this.cachedBytesRead = new Counter(in);\n+            this.cachedBytesWritten = new Counter(in);\n+            this.directBytesRead = new Counter(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(fileName);\n+            out.writeVLong(fileLength);\n+            out.writeVLong(openCount);\n+            out.writeVLong(innerCount);\n+            out.writeVLong(closeCount);\n+\n+            forwardSmallSeeks.writeTo(out);\n+            backwardSmallSeeks.writeTo(out);\n+            forwardLargeSeeks.writeTo(out);\n+            backwardLargeSeeks.writeTo(out);\n+            contiguousReads.writeTo(out);\n+            nonContiguousReads.writeTo(out);\n+            cachedBytesRead.writeTo(out);\n+            cachedBytesWritten.writeTo(out);\n+            directBytesRead.writeTo(out);\n+        }\n+\n+        public String getFileName() {\n+            return fileName;\n+        }\n+\n+        public long getFileLength() {\n+            return fileLength;\n+        }\n+\n+        public long getOpenCount() {\n+            return openCount;\n+        }\n+\n+        public long getInnerCount() {\n+            return innerCount;\n+        }\n+\n+        public long getCloseCount() {\n+            return closeCount;\n+        }\n+\n+        public Counter getForwardSmallSeeks() {\n+            return forwardSmallSeeks;\n+        }\n+\n+        public Counter getBackwardSmallSeeks() {\n+            return backwardSmallSeeks;\n+        }\n+\n+        public Counter getForwardLargeSeeks() {\n+            return forwardLargeSeeks;\n+        }\n+\n+        public Counter getBackwardLargeSeeks() {\n+            return backwardLargeSeeks;\n+        }\n+\n+        public Counter getContiguousReads() {\n+            return contiguousReads;\n+        }\n+\n+        public Counter getNonContiguousReads() {\n+            return nonContiguousReads;\n+        }\n+\n+        public Counter getCachedBytesRead() {\n+            return cachedBytesRead;\n+        }\n+\n+        public Counter getCachedBytesWritten() {\n+            return cachedBytesWritten;\n+        }\n+\n+        public Counter getDirectBytesRead() {\n+            return directBytesRead;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            {\n+                builder.field(\"name\", getFileName());\n+                builder.field(\"length\", getFileLength());\n+                builder.field(\"open_count\", getOpenCount());\n+                builder.field(\"inner_count\", getInnerCount());\n+                builder.field(\"close_count\", getCloseCount());\n+                builder.field(\"contiguous_bytes_read\", getContiguousReads());\n+                builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n+                builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"cached_bytes_written\", getCachedBytesWritten());\n+                builder.field(\"direct_bytes_read\", getDirectBytesRead());\n+                {\n+                    builder.startObject(\"forward_seeks\");\n+                    builder.field(\"small\", getForwardSmallSeeks());\n+                    builder.field(\"large\", getForwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"backward_seeks\");\n+                    builder.field(\"small\", getBackwardSmallSeeks());\n+                    builder.field(\"large\", getBackwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+            }\n+            return builder.endObject();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (other == null || getClass() != other.getClass()) {\n+                return false;\n+            }\n+            CacheIndexInputStats stats = (CacheIndexInputStats) other;\n+            return fileLength == stats.fileLength\n+                && openCount == stats.openCount\n+                && innerCount == stats.innerCount\n+                && closeCount == stats.closeCount\n+                && Objects.equals(fileName, stats.fileName)\n+                && Objects.equals(forwardSmallSeeks, stats.forwardSmallSeeks)\n+                && Objects.equals(backwardSmallSeeks, stats.backwardSmallSeeks)\n+                && Objects.equals(forwardLargeSeeks, stats.forwardLargeSeeks)\n+                && Objects.equals(backwardLargeSeeks, stats.backwardLargeSeeks)\n+                && Objects.equals(contiguousReads, stats.contiguousReads)\n+                && Objects.equals(nonContiguousReads, stats.nonContiguousReads)\n+                && Objects.equals(cachedBytesRead, stats.cachedBytesRead)\n+                && Objects.equals(cachedBytesWritten, stats.cachedBytesWritten)\n+                && Objects.equals(directBytesRead, stats.directBytesRead);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(fileName, fileLength, openCount, innerCount, closeCount,\n+                forwardSmallSeeks, backwardSmallSeeks,\n+                forwardLargeSeeks, backwardLargeSeeks,\n+                contiguousReads, nonContiguousReads,\n+                cachedBytesRead, cachedBytesWritten,\n+                directBytesRead);\n+        }\n+    }\n+\n+    public static class Counter implements Writeable, ToXContentObject {\n+\n+        private final long count;\n+        private final long total;\n+        private final long min;\n+        private final long max;\n+\n+        public Counter(final long count, final long total, final long min, final long max) {\n+            this.count = count;\n+            this.total = total;\n+            this.min = min;\n+            this.max = max;\n+        }\n+\n+        Counter(final StreamInput in) throws IOException {\n+            this.count = in.readZLong();\n+            this.total = in.readZLong();\n+            this.min = in.readZLong();\n+            this.max = in.readZLong();\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            out.writeZLong(count);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDI0Nw==", "bodyText": "They can be negative for backward seeks counters, which kind of makes sense. I also think we should handle negative longs here because Counter might have different purpose and count different things.\nAnyway I pushed b1d7973 to use negative longs in SearchableSnapshotShardStats serializing tests and also to add some randomization for the seeking threshold in IndexInputStatsTests.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190247", "createdAt": "2020-02-05T11:01:27Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {\n+\n+    private final List<CacheIndexInputStats> inputStats;\n+    private final ShardRouting shardRouting;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+\n+    public SearchableSnapshotStats(ShardRouting shardRouting, SnapshotId snapshotId, IndexId indexId, List<CacheIndexInputStats> stats) {\n+        this.shardRouting = Objects.requireNonNull(shardRouting);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.inputStats = unmodifiableList(Objects.requireNonNull(stats));\n+    }\n+\n+    public SearchableSnapshotStats(StreamInput in) throws IOException {\n+        this.shardRouting = new ShardRouting(in);\n+        this.snapshotId = new SnapshotId(in);\n+        this.indexId = new IndexId(in);\n+        this.inputStats = in.readList(CacheIndexInputStats::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        shardRouting.writeTo(out);\n+        snapshotId.writeTo(out);\n+        indexId.writeTo(out);\n+        out.writeList(inputStats);\n+    }\n+\n+    public ShardRouting getShardRouting() {\n+        return shardRouting;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public List<CacheIndexInputStats> getStats() {\n+        return inputStats;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        {\n+            builder.field(\"snapshot_uuid\", getSnapshotId().getUUID());\n+            builder.field(\"index_uuid\", getIndexId().getId());\n+            builder.startObject(\"shard\");\n+            {\n+                builder.field(\"state\", shardRouting.state());\n+                builder.field(\"primary\", shardRouting.primary());\n+                builder.field(\"node\", shardRouting.currentNodeId());\n+                if (shardRouting.relocatingNodeId() != null) {\n+                    builder.field(\"relocating_node\", shardRouting.relocatingNodeId());\n+                }\n+            }\n+            builder.endObject();\n+            builder.startArray(\"files\");\n+            {\n+                List<CacheIndexInputStats> stats = inputStats.stream()\n+                    .sorted(Comparator.comparing(CacheIndexInputStats::getFileName)).collect(toList());\n+                for (CacheIndexInputStats stat : stats) {\n+                    stat.toXContent(builder, params);\n+                }\n+            }\n+            builder.endArray();\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        SearchableSnapshotStats that = (SearchableSnapshotStats) other;\n+        return Objects.equals(shardRouting, that.shardRouting)\n+            && Objects.equals(snapshotId, that.snapshotId)\n+            && Objects.equals(indexId, that.indexId)\n+            && Objects.equals(inputStats, that.inputStats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(shardRouting, snapshotId, indexId, inputStats);\n+    }\n+\n+\n+    public static class CacheIndexInputStats implements Writeable, ToXContentObject {\n+\n+        private final String fileName;\n+        private final long fileLength;\n+\n+        private final long openCount;\n+        private final long innerCount;\n+        private final long closeCount;\n+\n+        private final Counter forwardSmallSeeks;\n+        private final Counter backwardSmallSeeks;\n+        private final Counter forwardLargeSeeks;\n+        private final Counter backwardLargeSeeks;\n+        private final Counter contiguousReads;\n+        private final Counter nonContiguousReads;\n+        private final Counter cachedBytesRead;\n+        private final Counter cachedBytesWritten;\n+        private final Counter directBytesRead;\n+\n+        public CacheIndexInputStats(String fileName, long fileLength, long openCount, long innerCount, long closeCount,\n+                                    Counter forwardSmallSeeks, Counter backwardSmallSeeks,\n+                                    Counter forwardLargeSeeks, Counter backwardLargeSeeks,\n+                                    Counter contiguousReads, Counter nonContiguousReads,\n+                                    Counter cachedBytesRead, Counter cachedBytesWritten,\n+                                    Counter directBytesRead) {\n+            this.fileName = fileName;\n+            this.fileLength = fileLength;\n+            this.openCount = openCount;\n+            this.innerCount = innerCount;\n+            this.closeCount = closeCount;\n+            this.forwardSmallSeeks = forwardSmallSeeks;\n+            this.backwardSmallSeeks = backwardSmallSeeks;\n+            this.forwardLargeSeeks = forwardLargeSeeks;\n+            this.backwardLargeSeeks = backwardLargeSeeks;\n+            this.contiguousReads = contiguousReads;\n+            this.nonContiguousReads = nonContiguousReads;\n+            this.cachedBytesRead = cachedBytesRead;\n+            this.cachedBytesWritten = cachedBytesWritten;\n+            this.directBytesRead = directBytesRead;\n+        }\n+\n+        CacheIndexInputStats(final StreamInput in) throws IOException {\n+            this.fileName = in.readString();\n+            this.fileLength = in.readVLong();\n+            this.openCount = in.readVLong();\n+            this.innerCount = in.readVLong();\n+            this.closeCount = in.readVLong();\n+            this.forwardSmallSeeks = new Counter(in);\n+            this.backwardSmallSeeks = new Counter(in);\n+            this.forwardLargeSeeks = new Counter(in);\n+            this.backwardLargeSeeks = new Counter(in);\n+            this.contiguousReads = new Counter(in);\n+            this.nonContiguousReads = new Counter(in);\n+            this.cachedBytesRead = new Counter(in);\n+            this.cachedBytesWritten = new Counter(in);\n+            this.directBytesRead = new Counter(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(fileName);\n+            out.writeVLong(fileLength);\n+            out.writeVLong(openCount);\n+            out.writeVLong(innerCount);\n+            out.writeVLong(closeCount);\n+\n+            forwardSmallSeeks.writeTo(out);\n+            backwardSmallSeeks.writeTo(out);\n+            forwardLargeSeeks.writeTo(out);\n+            backwardLargeSeeks.writeTo(out);\n+            contiguousReads.writeTo(out);\n+            nonContiguousReads.writeTo(out);\n+            cachedBytesRead.writeTo(out);\n+            cachedBytesWritten.writeTo(out);\n+            directBytesRead.writeTo(out);\n+        }\n+\n+        public String getFileName() {\n+            return fileName;\n+        }\n+\n+        public long getFileLength() {\n+            return fileLength;\n+        }\n+\n+        public long getOpenCount() {\n+            return openCount;\n+        }\n+\n+        public long getInnerCount() {\n+            return innerCount;\n+        }\n+\n+        public long getCloseCount() {\n+            return closeCount;\n+        }\n+\n+        public Counter getForwardSmallSeeks() {\n+            return forwardSmallSeeks;\n+        }\n+\n+        public Counter getBackwardSmallSeeks() {\n+            return backwardSmallSeeks;\n+        }\n+\n+        public Counter getForwardLargeSeeks() {\n+            return forwardLargeSeeks;\n+        }\n+\n+        public Counter getBackwardLargeSeeks() {\n+            return backwardLargeSeeks;\n+        }\n+\n+        public Counter getContiguousReads() {\n+            return contiguousReads;\n+        }\n+\n+        public Counter getNonContiguousReads() {\n+            return nonContiguousReads;\n+        }\n+\n+        public Counter getCachedBytesRead() {\n+            return cachedBytesRead;\n+        }\n+\n+        public Counter getCachedBytesWritten() {\n+            return cachedBytesWritten;\n+        }\n+\n+        public Counter getDirectBytesRead() {\n+            return directBytesRead;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            {\n+                builder.field(\"name\", getFileName());\n+                builder.field(\"length\", getFileLength());\n+                builder.field(\"open_count\", getOpenCount());\n+                builder.field(\"inner_count\", getInnerCount());\n+                builder.field(\"close_count\", getCloseCount());\n+                builder.field(\"contiguous_bytes_read\", getContiguousReads());\n+                builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n+                builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"cached_bytes_written\", getCachedBytesWritten());\n+                builder.field(\"direct_bytes_read\", getDirectBytesRead());\n+                {\n+                    builder.startObject(\"forward_seeks\");\n+                    builder.field(\"small\", getForwardSmallSeeks());\n+                    builder.field(\"large\", getForwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"backward_seeks\");\n+                    builder.field(\"small\", getBackwardSmallSeeks());\n+                    builder.field(\"large\", getBackwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+            }\n+            return builder.endObject();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (other == null || getClass() != other.getClass()) {\n+                return false;\n+            }\n+            CacheIndexInputStats stats = (CacheIndexInputStats) other;\n+            return fileLength == stats.fileLength\n+                && openCount == stats.openCount\n+                && innerCount == stats.innerCount\n+                && closeCount == stats.closeCount\n+                && Objects.equals(fileName, stats.fileName)\n+                && Objects.equals(forwardSmallSeeks, stats.forwardSmallSeeks)\n+                && Objects.equals(backwardSmallSeeks, stats.backwardSmallSeeks)\n+                && Objects.equals(forwardLargeSeeks, stats.forwardLargeSeeks)\n+                && Objects.equals(backwardLargeSeeks, stats.backwardLargeSeeks)\n+                && Objects.equals(contiguousReads, stats.contiguousReads)\n+                && Objects.equals(nonContiguousReads, stats.nonContiguousReads)\n+                && Objects.equals(cachedBytesRead, stats.cachedBytesRead)\n+                && Objects.equals(cachedBytesWritten, stats.cachedBytesWritten)\n+                && Objects.equals(directBytesRead, stats.directBytesRead);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(fileName, fileLength, openCount, innerCount, closeCount,\n+                forwardSmallSeeks, backwardSmallSeeks,\n+                forwardLargeSeeks, backwardLargeSeeks,\n+                contiguousReads, nonContiguousReads,\n+                cachedBytesRead, cachedBytesWritten,\n+                directBytesRead);\n+        }\n+    }\n+\n+    public static class Counter implements Writeable, ToXContentObject {\n+\n+        private final long count;\n+        private final long total;\n+        private final long min;\n+        private final long max;\n+\n+        public Counter(final long count, final long total, final long min, final long max) {\n+            this.count = count;\n+            this.total = total;\n+            this.min = min;\n+            this.max = max;\n+        }\n+\n+        Counter(final StreamInput in) throws IOException {\n+            this.count = in.readZLong();\n+            this.total = in.readZLong();\n+            this.min = in.readZLong();\n+            this.max = in.readZLong();\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            out.writeZLong(count);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1NjM2Mw==", "bodyText": "Ah of course. \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375356363", "createdAt": "2020-02-05T16:15:28Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {\n+\n+    private final List<CacheIndexInputStats> inputStats;\n+    private final ShardRouting shardRouting;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+\n+    public SearchableSnapshotStats(ShardRouting shardRouting, SnapshotId snapshotId, IndexId indexId, List<CacheIndexInputStats> stats) {\n+        this.shardRouting = Objects.requireNonNull(shardRouting);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.inputStats = unmodifiableList(Objects.requireNonNull(stats));\n+    }\n+\n+    public SearchableSnapshotStats(StreamInput in) throws IOException {\n+        this.shardRouting = new ShardRouting(in);\n+        this.snapshotId = new SnapshotId(in);\n+        this.indexId = new IndexId(in);\n+        this.inputStats = in.readList(CacheIndexInputStats::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        shardRouting.writeTo(out);\n+        snapshotId.writeTo(out);\n+        indexId.writeTo(out);\n+        out.writeList(inputStats);\n+    }\n+\n+    public ShardRouting getShardRouting() {\n+        return shardRouting;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public List<CacheIndexInputStats> getStats() {\n+        return inputStats;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        {\n+            builder.field(\"snapshot_uuid\", getSnapshotId().getUUID());\n+            builder.field(\"index_uuid\", getIndexId().getId());\n+            builder.startObject(\"shard\");\n+            {\n+                builder.field(\"state\", shardRouting.state());\n+                builder.field(\"primary\", shardRouting.primary());\n+                builder.field(\"node\", shardRouting.currentNodeId());\n+                if (shardRouting.relocatingNodeId() != null) {\n+                    builder.field(\"relocating_node\", shardRouting.relocatingNodeId());\n+                }\n+            }\n+            builder.endObject();\n+            builder.startArray(\"files\");\n+            {\n+                List<CacheIndexInputStats> stats = inputStats.stream()\n+                    .sorted(Comparator.comparing(CacheIndexInputStats::getFileName)).collect(toList());\n+                for (CacheIndexInputStats stat : stats) {\n+                    stat.toXContent(builder, params);\n+                }\n+            }\n+            builder.endArray();\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        SearchableSnapshotStats that = (SearchableSnapshotStats) other;\n+        return Objects.equals(shardRouting, that.shardRouting)\n+            && Objects.equals(snapshotId, that.snapshotId)\n+            && Objects.equals(indexId, that.indexId)\n+            && Objects.equals(inputStats, that.inputStats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(shardRouting, snapshotId, indexId, inputStats);\n+    }\n+\n+\n+    public static class CacheIndexInputStats implements Writeable, ToXContentObject {\n+\n+        private final String fileName;\n+        private final long fileLength;\n+\n+        private final long openCount;\n+        private final long innerCount;\n+        private final long closeCount;\n+\n+        private final Counter forwardSmallSeeks;\n+        private final Counter backwardSmallSeeks;\n+        private final Counter forwardLargeSeeks;\n+        private final Counter backwardLargeSeeks;\n+        private final Counter contiguousReads;\n+        private final Counter nonContiguousReads;\n+        private final Counter cachedBytesRead;\n+        private final Counter cachedBytesWritten;\n+        private final Counter directBytesRead;\n+\n+        public CacheIndexInputStats(String fileName, long fileLength, long openCount, long innerCount, long closeCount,\n+                                    Counter forwardSmallSeeks, Counter backwardSmallSeeks,\n+                                    Counter forwardLargeSeeks, Counter backwardLargeSeeks,\n+                                    Counter contiguousReads, Counter nonContiguousReads,\n+                                    Counter cachedBytesRead, Counter cachedBytesWritten,\n+                                    Counter directBytesRead) {\n+            this.fileName = fileName;\n+            this.fileLength = fileLength;\n+            this.openCount = openCount;\n+            this.innerCount = innerCount;\n+            this.closeCount = closeCount;\n+            this.forwardSmallSeeks = forwardSmallSeeks;\n+            this.backwardSmallSeeks = backwardSmallSeeks;\n+            this.forwardLargeSeeks = forwardLargeSeeks;\n+            this.backwardLargeSeeks = backwardLargeSeeks;\n+            this.contiguousReads = contiguousReads;\n+            this.nonContiguousReads = nonContiguousReads;\n+            this.cachedBytesRead = cachedBytesRead;\n+            this.cachedBytesWritten = cachedBytesWritten;\n+            this.directBytesRead = directBytesRead;\n+        }\n+\n+        CacheIndexInputStats(final StreamInput in) throws IOException {\n+            this.fileName = in.readString();\n+            this.fileLength = in.readVLong();\n+            this.openCount = in.readVLong();\n+            this.innerCount = in.readVLong();\n+            this.closeCount = in.readVLong();\n+            this.forwardSmallSeeks = new Counter(in);\n+            this.backwardSmallSeeks = new Counter(in);\n+            this.forwardLargeSeeks = new Counter(in);\n+            this.backwardLargeSeeks = new Counter(in);\n+            this.contiguousReads = new Counter(in);\n+            this.nonContiguousReads = new Counter(in);\n+            this.cachedBytesRead = new Counter(in);\n+            this.cachedBytesWritten = new Counter(in);\n+            this.directBytesRead = new Counter(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(fileName);\n+            out.writeVLong(fileLength);\n+            out.writeVLong(openCount);\n+            out.writeVLong(innerCount);\n+            out.writeVLong(closeCount);\n+\n+            forwardSmallSeeks.writeTo(out);\n+            backwardSmallSeeks.writeTo(out);\n+            forwardLargeSeeks.writeTo(out);\n+            backwardLargeSeeks.writeTo(out);\n+            contiguousReads.writeTo(out);\n+            nonContiguousReads.writeTo(out);\n+            cachedBytesRead.writeTo(out);\n+            cachedBytesWritten.writeTo(out);\n+            directBytesRead.writeTo(out);\n+        }\n+\n+        public String getFileName() {\n+            return fileName;\n+        }\n+\n+        public long getFileLength() {\n+            return fileLength;\n+        }\n+\n+        public long getOpenCount() {\n+            return openCount;\n+        }\n+\n+        public long getInnerCount() {\n+            return innerCount;\n+        }\n+\n+        public long getCloseCount() {\n+            return closeCount;\n+        }\n+\n+        public Counter getForwardSmallSeeks() {\n+            return forwardSmallSeeks;\n+        }\n+\n+        public Counter getBackwardSmallSeeks() {\n+            return backwardSmallSeeks;\n+        }\n+\n+        public Counter getForwardLargeSeeks() {\n+            return forwardLargeSeeks;\n+        }\n+\n+        public Counter getBackwardLargeSeeks() {\n+            return backwardLargeSeeks;\n+        }\n+\n+        public Counter getContiguousReads() {\n+            return contiguousReads;\n+        }\n+\n+        public Counter getNonContiguousReads() {\n+            return nonContiguousReads;\n+        }\n+\n+        public Counter getCachedBytesRead() {\n+            return cachedBytesRead;\n+        }\n+\n+        public Counter getCachedBytesWritten() {\n+            return cachedBytesWritten;\n+        }\n+\n+        public Counter getDirectBytesRead() {\n+            return directBytesRead;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            {\n+                builder.field(\"name\", getFileName());\n+                builder.field(\"length\", getFileLength());\n+                builder.field(\"open_count\", getOpenCount());\n+                builder.field(\"inner_count\", getInnerCount());\n+                builder.field(\"close_count\", getCloseCount());\n+                builder.field(\"contiguous_bytes_read\", getContiguousReads());\n+                builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n+                builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"cached_bytes_written\", getCachedBytesWritten());\n+                builder.field(\"direct_bytes_read\", getDirectBytesRead());\n+                {\n+                    builder.startObject(\"forward_seeks\");\n+                    builder.field(\"small\", getForwardSmallSeeks());\n+                    builder.field(\"large\", getForwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"backward_seeks\");\n+                    builder.field(\"small\", getBackwardSmallSeeks());\n+                    builder.field(\"large\", getBackwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+            }\n+            return builder.endObject();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (other == null || getClass() != other.getClass()) {\n+                return false;\n+            }\n+            CacheIndexInputStats stats = (CacheIndexInputStats) other;\n+            return fileLength == stats.fileLength\n+                && openCount == stats.openCount\n+                && innerCount == stats.innerCount\n+                && closeCount == stats.closeCount\n+                && Objects.equals(fileName, stats.fileName)\n+                && Objects.equals(forwardSmallSeeks, stats.forwardSmallSeeks)\n+                && Objects.equals(backwardSmallSeeks, stats.backwardSmallSeeks)\n+                && Objects.equals(forwardLargeSeeks, stats.forwardLargeSeeks)\n+                && Objects.equals(backwardLargeSeeks, stats.backwardLargeSeeks)\n+                && Objects.equals(contiguousReads, stats.contiguousReads)\n+                && Objects.equals(nonContiguousReads, stats.nonContiguousReads)\n+                && Objects.equals(cachedBytesRead, stats.cachedBytesRead)\n+                && Objects.equals(cachedBytesWritten, stats.cachedBytesWritten)\n+                && Objects.equals(directBytesRead, stats.directBytesRead);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(fileName, fileLength, openCount, innerCount, closeCount,\n+                forwardSmallSeeks, backwardSmallSeeks,\n+                forwardLargeSeeks, backwardLargeSeeks,\n+                contiguousReads, nonContiguousReads,\n+                cachedBytesRead, cachedBytesWritten,\n+                directBytesRead);\n+        }\n+    }\n+\n+    public static class Counter implements Writeable, ToXContentObject {\n+\n+        private final long count;\n+        private final long total;\n+        private final long min;\n+        private final long max;\n+\n+        public Counter(final long count, final long total, final long min, final long max) {\n+            this.count = count;\n+            this.total = total;\n+            this.min = min;\n+            this.max = max;\n+        }\n+\n+        Counter(final StreamInput in) throws IOException {\n+            this.count = in.readZLong();\n+            this.total = in.readZLong();\n+            this.min = in.readZLong();\n+            this.max = in.readZLong();\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            out.writeZLong(count);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTkwNjY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoxNzozMlrOFlu9VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTowMTozMVrOFlzzEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMDk5Nw==", "bodyText": "typo \ud83d\ude01\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    index: \"unkown\"\n          \n          \n            \n                    index: \"unknown\"", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375110997", "createdAt": "2020-02-05T08:17:32Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDI4OA==", "bodyText": ":) a4f92bd", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190288", "createdAt": "2020-02-05T11:01:31Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMDk5Nw=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTkxNjA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoyMToxMVrOFlvDJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjoxNjowNlrOFl99ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMjQ4NQ==", "bodyText": "Does this need us to have refreshed and flushed before taking the snapshot? Or is that handled by the framework?", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375112485", "createdAt": "2020-02-05T08:21:11Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDM1OQ==", "bodyText": "Shards are flushed right before being snapshotted so I don't think this is necessary.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190359", "createdAt": "2020-02-05T11:01:37Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMjQ4NQ=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1Njc3Mg==", "bodyText": "So they are. Don't mind me...", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375356772", "createdAt": "2020-02-05T16:16:06Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMjQ4NQ=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTkyMTk1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoyMzoyOFrOFlvGsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTowMTo0MVrOFlzzew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM5NA==", "bodyText": "I expect this index has replicas; they won't be assigned if the test cluster only has a single data node, but I think this would fail if there were more nodes involved (we don't specify a single node cluster anywhere AFAIK). We should set the number of replicas to make sure this works even in larger clusters.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375113394", "createdAt": "2020-02-05T08:23:28Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }\n+\n+  - do:\n+      nodes.info: {}\n+  - set:\n+      nodes._arbitrary_key_: node_id\n+\n+  - do:\n+      searchable_snapshots.stats:\n+        index: \"ind*\"\n+\n+  - length:  { indices: 1 }\n+  - length:  { indices.index.shards: 1 }\n+  - length:  { indices.index.shards.0: 1 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDM5NQ==", "bodyText": "Good catch - I set the number of replicas to 0 and also renamed the index index to docs to avoid confusion (f2ea47f).", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190395", "createdAt": "2020-02-05T11:01:41Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }\n+\n+  - do:\n+      nodes.info: {}\n+  - set:\n+      nodes._arbitrary_key_: node_id\n+\n+  - do:\n+      searchable_snapshots.stats:\n+        index: \"ind*\"\n+\n+  - length:  { indices: 1 }\n+  - length:  { indices.index.shards: 1 }\n+  - length:  { indices.index.shards.0: 1 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM5NA=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTkyODcxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoyNjoxNVrOFlvKxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTowMTo0NVrOFlzzkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDQzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return stats;\n          \n          \n            \n                    return Collections.unmodifiableMap(stats);", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375114439", "createdAt": "2020-02-05T08:26:15Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -64,6 +64,22 @@ private CacheKey createCacheKey(String fileName) {\n         return new CacheKey(snapshotId, indexId, shardId, fileName);\n     }\n \n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return stats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDQxNw==", "bodyText": "Good catch too - thanks! I pushed dda6ab7", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190417", "createdAt": "2020-02-05T11:01:45Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -64,6 +64,22 @@ private CacheKey createCacheKey(String fileName) {\n         return new CacheKey(snapshotId, indexId, shardId, fileName);\n     }\n \n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return stats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDQzOQ=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTkzNDE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/resources/rest-api-spec/api/searchable_snapshots.stats.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoyODoxM1rOFlvN3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTowMTo0OVrOFlzzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNTIzMA==", "bodyText": "We should at least mark this line as //NORELEASE too, but really I think we should be bolder and say that by the time this is merged we expect this API not to be experimental any more, so there's no need for this.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375115230", "createdAt": "2020-02-05T08:28:13Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/resources/rest-api-spec/api/searchable_snapshots.stats.json", "diffHunk": "@@ -0,0 +1,30 @@\n+{\n+  \"searchable_snapshots.stats\": {\n+    \"documentation\": {\n+      \"url\": \"https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots-get-stats.html //NORELEASE\"\n+    },\n+    \"stability\": \"experimental\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDQ0MA==", "bodyText": "I agree. Sadly we can't mark this line as //NORELEASE too as the stability is checked against a specified set of values. We can't also comment this JSON file.\nI think that experimental reflects the current state of this API for now. I hooked on the //NORELEASE and add more documentation about the stability of the API (see fde0a86).", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190440", "createdAt": "2020-02-05T11:01:49Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/resources/rest-api-spec/api/searchable_snapshots.stats.json", "diffHunk": "@@ -0,0 +1,30 @@\n+{\n+  \"searchable_snapshots.stats\": {\n+    \"documentation\": {\n+      \"url\": \"https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots-get-stats.html //NORELEASE\"\n+    },\n+    \"stability\": \"experimental\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNTIzMA=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTk5NzMxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo1MToyMFrOFlv0BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDowNToxN1rOFmVfPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw==", "bodyText": "Ideally, we would throw an exception if the user specified an index (or pattern) which didn't match any searchable snapshots, but this would naturally fall to the IndexNameExpressionResolver which doesn't seem to have a suitable extension point for this kind of logic.\nHowever, what do you think about handling at least the case of a user specifying a single index with a typo, matching nothing, with an INFE? I.e. if request.indices() is not empty or [\"*\"] or [\"_all\"] but searchableSnapshotIndices is empty, then that's a bad request.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375124997", "createdAt": "2020-02-05T08:51:20Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MDQ4Mg==", "bodyText": "That sounds like a good idea. I implemented it a bit differently though in c9468d1, by checking if one or more concrete indices were resolved (taking security into account) but none of them had a searchable store type (searchableSnapshotIndices is empty) which throws a resource not found exception. I've updated the REST API test for this.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375190482", "createdAt": "2020-02-05T11:01:53Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MjA0MA==", "bodyText": "Hmm, this means that GET _searchable_snapshots/stats returns 200 OK in an empty cluster but 404 Not Found if there are any indices at all but none of them are searchable snapshots. I think that'll be surprising. Maybe it'd be best always to throw a RNFE if searchableSnapshotIndices is empty.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375362040", "createdAt": "2020-02-05T16:24:23Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5OTYxMA==", "bodyText": "I'm not fully sure how it should behave, also because Security also has its specific behavior so I went with your suggestion in d1049a3 which has the advantage to be consistent.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375699610", "createdAt": "2020-02-06T08:38:39Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc0MTAwMg==", "bodyText": "Looks good. Test failures are not obviously related, maybe we need to merge something?", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375741002", "createdAt": "2020-02-06T10:02:44Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc0MjI3MA==", "bodyText": "Yes, need to merge master but I'm waiting for bwc to be reenabled before.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375742270", "createdAt": "2020-02-06T10:05:17Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw=="}, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 44, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}