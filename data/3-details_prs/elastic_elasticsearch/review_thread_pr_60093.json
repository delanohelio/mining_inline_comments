{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MzYwNzY4", "number": 60093, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToxNToxNVrOES_uKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToxNjo0OVrOES_wDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzUzODMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTasksExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToxNToxNVrOG4fKYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMjo1NjozMFrOG4mu3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDAwMw==", "bodyText": "Assigning to a node that is a data node but before version 7.3.0 could still fail (if the node doesn't have the remote cluster client role). I wonder if we should implement this as a last resort? So try to select the least loaded node that is a data node and is a remote cluster client. If that doesn't turn up any nodes, try to assign to a node that is a data node and is before the version that we formalized the remote cluster client role. Note that that is a different version than when we made roles pluggable.", "url": "https://github.com/elastic/elasticsearch/pull/60093#discussion_r461884003", "createdAt": "2020-07-28T21:15:15Z", "author": {"login": "jasontedor"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTasksExecutor.java", "diffHunk": "@@ -124,14 +123,14 @@ public void validate(ShardFollowTask params, ClusterState clusterState) {\n \n     @Override\n     public Assignment getAssignment(final ShardFollowTask params, final ClusterState clusterState) {\n-        final DiscoveryNode node = selectLeastLoadedNode(\n+        final DiscoveryNode selectedNode = selectLeastLoadedNode(\n             clusterState,\n-            ((Predicate<DiscoveryNode>) DiscoveryNode::isDataNode).and(DiscoveryNode::isRemoteClusterClient)\n+            node -> node.isDataNode() && (node.isRemoteClusterClient() || node.getVersion().before(DiscoveryNode.PLUGGABLE_ROLES_VERSION))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2069e529e5b4021c9aaaaba5812a3b057b426827"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODAyOQ==", "bodyText": "I implemented this in fda3927, but I backed it out because I thought it could lead to hotspots on upgraded nodes. I am okay with either option. I pushed 7eeaa14 to restore this behavior.", "url": "https://github.com/elastic/elasticsearch/pull/60093#discussion_r462008029", "createdAt": "2020-07-29T02:56:30Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTasksExecutor.java", "diffHunk": "@@ -124,14 +123,14 @@ public void validate(ShardFollowTask params, ClusterState clusterState) {\n \n     @Override\n     public Assignment getAssignment(final ShardFollowTask params, final ClusterState clusterState) {\n-        final DiscoveryNode node = selectLeastLoadedNode(\n+        final DiscoveryNode selectedNode = selectLeastLoadedNode(\n             clusterState,\n-            ((Predicate<DiscoveryNode>) DiscoveryNode::isDataNode).and(DiscoveryNode::isRemoteClusterClient)\n+            node -> node.isDataNode() && (node.isRemoteClusterClient() || node.getVersion().before(DiscoveryNode.PLUGGABLE_ROLES_VERSION))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDAwMw=="}, "originalCommit": {"oid": "2069e529e5b4021c9aaaaba5812a3b057b426827"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzU0MzE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/allocation/CcrPrimaryFollowerAllocationDecider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMToxNjo0OVrOG4fNSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMjo1Njo0N1rOG4mvPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDc0Ng==", "bodyText": "I wonder if this should be the version that we introduced the remote cluster client role in as opposed to the version that we made node roles pluggable.", "url": "https://github.com/elastic/elasticsearch/pull/60093#discussion_r461884746", "createdAt": "2020-07-28T21:16:49Z", "author": {"login": "jasontedor"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/allocation/CcrPrimaryFollowerAllocationDecider.java", "diffHunk": "@@ -57,11 +58,14 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n             return allocation.decision(Decision.YES, NAME,\n                 \"shard is a primary follower but was bootstrapped already; hence is not under the purview of this decider\");\n         }\n-        if (node.node().isRemoteClusterClient() == false) {\n-            return allocation.decision(Decision.NO, NAME, \"shard is a primary follower and being bootstrapped, but node does not have the \"\n-                + DiscoveryNodeRole.REMOTE_CLUSTER_CLIENT_ROLE.roleName() + \" role\");\n+        if (node.node().isRemoteClusterClient()) {\n+            return allocation.decision(Decision.YES, NAME,\n+                \"shard is a primary follower and node has the \" + DiscoveryNodeRole.REMOTE_CLUSTER_CLIENT_ROLE.roleName() + \" role\");\n+        }\n+        if (node.node().getVersion().before(DiscoveryNode.PLUGGABLE_ROLES_VERSION)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2069e529e5b4021c9aaaaba5812a3b057b426827"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODEyNA==", "bodyText": "Good catch, fixed in 3a33f0a", "url": "https://github.com/elastic/elasticsearch/pull/60093#discussion_r462008124", "createdAt": "2020-07-29T02:56:47Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/allocation/CcrPrimaryFollowerAllocationDecider.java", "diffHunk": "@@ -57,11 +58,14 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n             return allocation.decision(Decision.YES, NAME,\n                 \"shard is a primary follower but was bootstrapped already; hence is not under the purview of this decider\");\n         }\n-        if (node.node().isRemoteClusterClient() == false) {\n-            return allocation.decision(Decision.NO, NAME, \"shard is a primary follower and being bootstrapped, but node does not have the \"\n-                + DiscoveryNodeRole.REMOTE_CLUSTER_CLIENT_ROLE.roleName() + \" role\");\n+        if (node.node().isRemoteClusterClient()) {\n+            return allocation.decision(Decision.YES, NAME,\n+                \"shard is a primary follower and node has the \" + DiscoveryNodeRole.REMOTE_CLUSTER_CLIENT_ROLE.roleName() + \" role\");\n+        }\n+        if (node.node().getVersion().before(DiscoveryNode.PLUGGABLE_ROLES_VERSION)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDc0Ng=="}, "originalCommit": {"oid": "2069e529e5b4021c9aaaaba5812a3b057b426827"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2128, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}