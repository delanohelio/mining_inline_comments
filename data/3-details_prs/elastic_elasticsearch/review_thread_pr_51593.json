{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4NDE4MDg0", "number": 51593, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo1MzoyNVrODbevQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwODoxMjozMFrODbe_nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTQxNzYxOnYy", "diffSide": "LEFT", "path": "test/fixtures/gcs-fixture/src/main/java/fixture/gcs/GoogleCloudStorageHttpHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo1MzoyNVrOFi_Q5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo1MzoyNVrOFi_Q5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMjQyMw==", "bodyText": "Using the BAOS here was pretty brutal for multi MB requests :) Much nicer now with the 16kb chunks Streams.readFully(wrappedRequest) produces", "url": "https://github.com/elastic/elasticsearch/pull/51593#discussion_r372232423", "createdAt": "2020-01-29T07:53:25Z", "author": {"login": "original-brownbear"}, "path": "test/fixtures/gcs-fixture/src/main/java/fixture/gcs/GoogleCloudStorageHttpHandler.java", "diffHunk": "@@ -212,35 +213,21 @@ public void handle(final HttpExchange exchange) throws IOException {\n                     exchange.sendResponseHeaders(RestStatus.NOT_FOUND.getStatus(), -1);\n                     return;\n                 }\n-                byte[] blob = BytesReference.toBytes(blobs.get(blobName));\n+                BytesReference blob = blobs.get(blobName);\n                 final String range = exchange.getRequestHeaders().getFirst(\"Content-Range\");\n                 final Integer limit = getContentRangeLimit(range);\n                 final int start = getContentRangeStart(range);\n                 final int end = getContentRangeEnd(range);\n \n-                final ByteArrayOutputStream out = new ByteArrayOutputStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a586dfdf53f37c7a7c330f6caaa1f2a493643be4"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTQyMTM5OnYy", "diffSide": "RIGHT", "path": "test/fixtures/gcs-fixture/src/main/java/fixture/gcs/GoogleCloudStorageHttpHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo1NDo1N1rOFi_TBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNzo1NDo1N1rOFi_TBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMjk2Nw==", "bodyText": "Even though slice wastes some memory here for the wrapping around the actual blob content for smaller blobs, it's a huge efficiency gain to stick with 16kb chunks from the BytesReference compared to allocating a potentially MB sized array.", "url": "https://github.com/elastic/elasticsearch/pull/51593#discussion_r372232967", "createdAt": "2020-01-29T07:54:57Z", "author": {"login": "original-brownbear"}, "path": "test/fixtures/gcs-fixture/src/main/java/fixture/gcs/GoogleCloudStorageHttpHandler.java", "diffHunk": "@@ -308,10 +295,7 @@ private String httpServerUrl(final HttpExchange exchange) {\n             } else {\n                 // removes the trailing end \"\\r\\n--__END_OF_PART__--\\r\\n\" which is 23 bytes long\n                 int len = fullRequestBody.length() - startPos - 23;\n-                final InputStream stream = fullRequestBody.slice(startPos, len).streamInput();\n-                final byte[] buffer = new byte[len];\n-                Streams.readFully(stream, buffer);\n-                content = Tuple.tuple(name, new BytesArray(buffer));\n+                content = Tuple.tuple(name, fullRequestBody.slice(startPos, len));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a586dfdf53f37c7a7c330f6caaa1f2a493643be4"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTQ1OTUxOnYy", "diffSide": "RIGHT", "path": "test/fixtures/gcs-fixture/src/main/java/fixture/gcs/GoogleCloudStorageHttpHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwODoxMjozMFrOFi_qCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwODoxMjozMFrOFi_qCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzODg1Ng==", "bodyText": "I didn't know about this one \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/51593#discussion_r372238856", "createdAt": "2020-01-29T08:12:30Z", "author": {"login": "tlrx"}, "path": "test/fixtures/gcs-fixture/src/main/java/fixture/gcs/GoogleCloudStorageHttpHandler.java", "diffHunk": "@@ -212,35 +213,21 @@ public void handle(final HttpExchange exchange) throws IOException {\n                     exchange.sendResponseHeaders(RestStatus.NOT_FOUND.getStatus(), -1);\n                     return;\n                 }\n-                byte[] blob = BytesReference.toBytes(blobs.get(blobName));\n+                BytesReference blob = blobs.get(blobName);\n                 final String range = exchange.getRequestHeaders().getFirst(\"Content-Range\");\n                 final Integer limit = getContentRangeLimit(range);\n                 final int start = getContentRangeStart(range);\n                 final int end = getContentRangeEnd(range);\n \n-                final ByteArrayOutputStream out = new ByteArrayOutputStream() {\n-                    @Override\n-                    public byte[] toByteArray() {\n-                        return buf;\n-                    }\n-                };\n-                long bytesRead = Streams.copy(wrappedRequest, out, new byte[128]);\n-                int length = Math.max(end + 1, limit != null ? limit : 0);\n-                if ((int) bytesRead > length) {\n-                    throw new AssertionError(\"Requesting more bytes than available for blob\");\n-                }\n-                if (length > blob.length) {\n-                    blob = ArrayUtil.growExact(blob, length);\n-                }\n-                System.arraycopy(out.toByteArray(), 0, blob, start, Math.toIntExact(bytesRead));\n-                blobs.put(blobName, new BytesArray(blob));\n+                blob = new CompositeBytesReference(blob, Streams.readFully(wrappedRequest));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a586dfdf53f37c7a7c330f6caaa1f2a493643be4"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 90, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}