{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NTg3OTcw", "number": 55633, "title": "Retry failed replication due to transient errors", "bodyText": "Currently a failed replication action will fail an entire replica. This\nincludes when replication fails due to potentially short lived transient\nissues such as network distruptions or circuit breaking errors.\nThis commit implements retries using the retryable action.", "createdAt": "2020-04-22T22:53:20Z", "url": "https://github.com/elastic/elasticsearch/pull/55633", "merged": true, "mergeCommit": {"oid": "b2b32d7cf85cd135b7a1f6c2a538d21f73dbf037"}, "closed": true, "closedAt": "2020-04-30T16:13:30Z", "author": {"login": "tbrooks8"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRj4mvAH2gAyNDA3NTg3OTcwOjE4NWYwYTBlMmJmODViN2UyN2YwZjM3MDdmYzczYTM4NmIzYjg0NmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccurnVAH2gAyNDA3NTg3OTcwOmM3N2I4NzNmZmI0MTdmMDI1N2Y1ZGQ4MGRjZTk2OWViNzBlMDMyOWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "185f0a0e2bf85b7e27f0f3707fc73a386b3b846f", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/185f0a0e2bf85b7e27f0f3707fc73a386b3b846f", "committedDate": "2020-03-26T22:31:18Z", "message": "Retry failed replication due to transient errors\n\nCurrently a failed replication action will fail an entire replica. This\nincludes when replication fails due to potentially short lived transient\nissues such as network distruptions or circuit breaking errors.\n\nThis commit adds the concept of a retryable action. A retryable action\nwill be retryed in face of certain errors. The action will be retried\nafter an exponentially increasing backoff period. After defined time,\nthe action will timeout."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59dda7a918a5bbbf9dfd7b42b66e573bd6cec1c2", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/59dda7a918a5bbbf9dfd7b42b66e573bd6cec1c2", "committedDate": "2020-03-26T22:42:33Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eab09d49bab5a6d226621ae9f8eafa524d6db6b5", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/eab09d49bab5a6d226621ae9f8eafa524d6db6b5", "committedDate": "2020-03-30T20:44:05Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aa25e0919424261bc5a5a2a89093dd8caf75319", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/7aa25e0919424261bc5a5a2a89093dd8caf75319", "committedDate": "2020-03-30T22:39:42Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20fc73d04664bba02d21fea5478e39086aefae9a", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/20fc73d04664bba02d21fea5478e39086aefae9a", "committedDate": "2020-04-03T21:58:07Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "448f35b4b748e20055e7b7b2f70a15fb646c7fcc", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/448f35b4b748e20055e7b7b2f70a15fb646c7fcc", "committedDate": "2020-04-04T00:17:53Z", "message": "Change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2a918f84c03130a0aeb5881cedc673bbbe647d", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/3e2a918f84c03130a0aeb5881cedc673bbbe647d", "committedDate": "2020-04-22T18:44:43Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00bd1570871b84e85390356e13af7808b7ea4b31", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/00bd1570871b84e85390356e13af7808b7ea4b31", "committedDate": "2020-04-22T22:26:48Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f775f95e296713e52be63567ae229ff73b0bf974", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/f775f95e296713e52be63567ae229ff73b0bf974", "committedDate": "2020-04-22T22:50:52Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/83f11aeb6ada46da2a3d102fb341e216201ba45b", "committedDate": "2020-04-22T23:04:24Z", "message": "Changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTkxMjQ4", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-398991248", "createdAt": "2020-04-23T11:04:41Z", "commit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMTowNDo0MlrOGKjnQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozMjowNVrOGKm2Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjQzMg==", "bodyText": "Similar to GlobalCheckpointListeners, I would prefer for PendingReplicationActions to live outside ReplicationTracker (namely in IndexShard). We can then also close it whenever the shard closes, which is another event where we want to ensure that all pending replication actions are completed.\nInstead, we could have a ReplicationGroupChangedListener here, which just invokes a Consumer<ReplicationGroup> here.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413722432", "createdAt": "2020-04-23T11:04:42Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -223,6 +224,8 @@\n      */\n     private final double fileBasedRecoveryThreshold;\n \n+    private final PendingReplicationActions pendingReplication;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNzcwMw==", "bodyText": "should we just use the RetryableAction as key?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413727703", "createdAt": "2020-04-23T11:13:34Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {\n+\n+    private final Map<String, Map<Object, RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+\n+    public void addPendingAction(String nodeId, Object actionKey, RetryableAction<?> replicationAction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyODc3OA==", "bodyText": "In case where this is null, shouldn't we cancel the RetryableAction right away?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413728778", "createdAt": "2020-04-23T11:15:32Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {\n+\n+    private final Map<String, Map<Object, RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+\n+    public void addPendingAction(String nodeId, Object actionKey, RetryableAction<?> replicationAction) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(nodeId);\n+        if (ongoingActionsOnNode != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNDM3NA==", "bodyText": "I'm concerned that we're still running this under the mutex of ReplicationTracker, which is supposed to be only held for a very short time. I wonder if we should fork off to a different thread, or if we should try to move this out of the mutex", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413734374", "createdAt": "2020-04-23T11:25:08Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {\n+\n+    private final Map<String, Map<Object, RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+\n+    public void addPendingAction(String nodeId, Object actionKey, RetryableAction<?> replicationAction) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(nodeId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.put(actionKey, replicationAction);\n+            if (onGoingReplicationActions.containsKey(nodeId) == false) {\n+                replicationAction.cancel(new ElasticsearchException(\"TODO\"));\n+            }\n+        }\n+    }\n+\n+    public void removeReplicationAction(String nodeId, Object actionKey) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(nodeId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(actionKey);\n+        }\n+    }\n+\n+    public synchronized void nodeJoinedReplicationGroup(String nodeId) {\n+        onGoingReplicationActions.put(nodeId, ConcurrentCollections.newConcurrentMap());\n+    }\n+\n+    public synchronized void nodeLeftReplicationGroup(String nodeId) {\n+        Map<Object, RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.remove(nodeId);\n+        for (RetryableAction<?> replicationAction : ongoingActionsOnNode.values()) {\n+            replicationAction.cancel(new ElasticsearchException(\"TODO\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczODc4NQ==", "bodyText": "should we call this before run? That would allow things to be cancelled right away if the node had already dropped...", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413738785", "createdAt": "2020-04-23T11:32:47Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -184,42 +192,65 @@ private void performOnReplica(final ShardRouting shard, final ReplicaRequest rep\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n+        final Object actionKey = new Object();\n \n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        PendingReplicationActions pendingReplicationActions = primary.getPendingReplicationActions();\n+        final ActionListener<ReplicaResponse> replicationListener = new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReplicaResponse response) {\n+                pendingReplicationActions.removeReplicationAction(shard.currentNodeId(), actionKey);\n+                successfulShards.incrementAndGet();\n+                try {\n+                    updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n+                } finally {\n+                    decPendingAndFinishIfNeeded();\n                 }\n+            }\n \n-                @Override\n-                public void onFailure(Exception replicaException) {\n-                    logger.trace(() -> new ParameterizedMessage(\n-                        \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n-                        shard.shardId(), opType, shard, replicaRequest), replicaException);\n-                    // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n-                    if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n-                        RestStatus restStatus = ExceptionsHelper.status(replicaException);\n-                        shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n-                            shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n-                    }\n-                    String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n-                    replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n-                        ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            @Override\n+            public void onFailure(Exception replicaException) {\n+                pendingReplicationActions.removeReplicationAction(shard.currentNodeId(), actionKey);\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n+                    shard.shardId(), opType, shard, replicaRequest), replicaException);\n+                // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n+                if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n+                    RestStatus restStatus = ExceptionsHelper.status(replicaException);\n+                    shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n+                        shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n                 }\n+                String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n+                replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n+                    ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            }\n \n-                @Override\n-                public String toString() {\n-                    return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n-                }\n-            });\n+            @Override\n+            public String toString() {\n+                return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+            }\n+        };\n+\n+        final RetryableAction<ReplicaResponse> replicationAction = new RetryableAction<>(logger, threadPool, TimeValue.timeValueMillis(50),\n+            replicaRequest.timeout(), replicationListener) {\n+\n+            @Override\n+            public void tryAction(ActionListener<ReplicaResponse> listener) {\n+                replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, listener);\n+            }\n+\n+            @Override\n+            public boolean shouldRetry(Exception e) {\n+                final Throwable cause = ExceptionsHelper.unwrapCause(e);\n+                return cause instanceof CircuitBreakingException ||\n+                    cause instanceof EsRejectedExecutionException ||\n+                    cause instanceof ConnectTransportException;\n+            }\n+        };\n+\n+        replicationAction.run();\n+        pendingReplicationActions.addPendingAction(shard.currentNodeId(), actionKey, replicationAction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczOTE0Nw==", "bodyText": "undo?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413739147", "createdAt": "2020-04-23T11:33:23Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -862,8 +865,7 @@ private static long inSyncCheckpointStates(\n     /**\n      * Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or\n      * {@link SequenceNumbers#UNASSIGNED_SEQ_NO}.\n-     *\n-     * @param shardId               the shard ID\n+     *  @param shardId               the shard ID", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NDAxNQ==", "bodyText": "I think that I would prefer for this to be set before we call the methods on pendingReplication, just to be sure that an exception there does not mess up the state in this class.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413764015", "createdAt": "2020-04-23T12:14:47Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +919,47 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    /**\n+     * Returns the pending replication actions for the shard.\n+     *\n+     * @return the pending replication actions\n+     */\n+    public PendingReplicationActions getPendingReplicationActions() {\n+        assert primaryMode;\n+        return pendingReplication;\n+    }\n+\n+    private void updateReplicationGroupAndNotify(boolean replicasMightHaveChanged) {\n+        ReplicationGroup newReplicationGroup = calculateReplicationGroup();\n+        ReplicationGroup oldReplicationGroup = this.replicationGroup;\n+        if (replicasMightHaveChanged) {\n+            Set<String> oldReplicaNodeIds;\n+            if (oldReplicationGroup == null) {\n+                oldReplicaNodeIds = Collections.emptySet();\n+            } else {\n+                oldReplicaNodeIds = oldReplicationGroup.getReplicationTargets().stream()\n+                    .map(ShardRouting::currentNodeId)\n+                    .collect(Collectors.toSet());\n+            }\n+            for (ShardRouting replica : newReplicationGroup.getReplicationTargets()) {\n+                if (oldReplicaNodeIds.contains(replica.currentNodeId()) == false) {\n+                    pendingReplication.nodeJoinedReplicationGroup(replica.currentNodeId());\n+                }\n+            }\n+        }\n+        this.replicationGroup = newReplicationGroup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NTgyNg==", "bodyText": "maybe calculate the node sets for both old and new, and then just use Sets.difference to determine what changed? With the approach here, you're notifying the absence of a given node multiple times.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413765826", "createdAt": "2020-04-23T12:17:41Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +919,47 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    /**\n+     * Returns the pending replication actions for the shard.\n+     *\n+     * @return the pending replication actions\n+     */\n+    public PendingReplicationActions getPendingReplicationActions() {\n+        assert primaryMode;\n+        return pendingReplication;\n+    }\n+\n+    private void updateReplicationGroupAndNotify(boolean replicasMightHaveChanged) {\n+        ReplicationGroup newReplicationGroup = calculateReplicationGroup();\n+        ReplicationGroup oldReplicationGroup = this.replicationGroup;\n+        if (replicasMightHaveChanged) {\n+            Set<String> oldReplicaNodeIds;\n+            if (oldReplicationGroup == null) {\n+                oldReplicaNodeIds = Collections.emptySet();\n+            } else {\n+                oldReplicaNodeIds = oldReplicationGroup.getReplicationTargets().stream()\n+                    .map(ShardRouting::currentNodeId)\n+                    .collect(Collectors.toSet());\n+            }\n+            for (ShardRouting replica : newReplicationGroup.getReplicationTargets()) {\n+                if (oldReplicaNodeIds.contains(replica.currentNodeId()) == false) {\n+                    pendingReplication.nodeJoinedReplicationGroup(replica.currentNodeId());\n+                }\n+            }\n+        }\n+        this.replicationGroup = newReplicationGroup;\n+        if (oldReplicationGroup != null && replicasMightHaveChanged) {\n+            Set<String> newReplicaNodeIds = newReplicationGroup.getReplicationTargets().stream()\n+                .map(ShardRouting::currentNodeId)\n+                .collect(Collectors.toSet());\n+            for (ShardRouting replica : oldReplicationGroup.getReplicationTargets()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2OTY0Mg==", "bodyText": "I think this optimization (replicasMightHaveChanged) is unnecessary (and easy to get wrong). The methods that call updateReplicationGroupAndNotify are rarely called, so let's omit this.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413769642", "createdAt": "2020-04-23T12:23:30Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +919,47 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    /**\n+     * Returns the pending replication actions for the shard.\n+     *\n+     * @return the pending replication actions\n+     */\n+    public PendingReplicationActions getPendingReplicationActions() {\n+        assert primaryMode;\n+        return pendingReplication;\n+    }\n+\n+    private void updateReplicationGroupAndNotify(boolean replicasMightHaveChanged) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3NTM4Mg==", "bodyText": "I we only register an action when we're actively scheduling something for retry, we might not need this class at all, and just have a simple list of listeners that wait for replication group changes, each of which checks whether the set of nodes changed? We could potentially even store the set of nodes of replication targets in ReplicationGroup. This means that a simple hashset lookup would suffice on notificaion of ReplicattionGroup changes to determine if the requests is still to be kept scheduled retrying.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r413775382", "createdAt": "2020-04-23T12:32:05Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+\n+import java.util.Map;\n+\n+public class PendingReplicationActions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f11aeb6ada46da2a3d102fb341e216201ba45b"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e33efc29676e13134e26cfefbaeaf944889f2f62", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/e33efc29676e13134e26cfefbaeaf944889f2f62", "committedDate": "2020-04-23T21:10:23Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "099d784cfa5b4d090d8d3c649707bc7109bfa508", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/099d784cfa5b4d090d8d3c649707bc7109bfa508", "committedDate": "2020-04-23T22:13:06Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94fdb6eea40867b8ae6f4b9156d3dc8a877ae00d", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/94fdb6eea40867b8ae6f4b9156d3dc8a877ae00d", "committedDate": "2020-04-23T22:18:17Z", "message": "Change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eec964be7a38db6da5c6360632a0d7794299eea", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/6eec964be7a38db6da5c6360632a0d7794299eea", "committedDate": "2020-04-23T22:22:43Z", "message": "Put if absent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bbbd21901b1d3c2d38e56853603bb5dd244e4bb", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/0bbbd21901b1d3c2d38e56853603bb5dd244e4bb", "committedDate": "2020-04-23T23:26:09Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4a23dfff6905814cd18ba209532cba634ec868e", "committedDate": "2020-04-23T23:40:59Z", "message": "Whitespace"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5ODg2ODg3", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-399886887", "createdAt": "2020-04-24T12:07:33Z", "commit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjowNzozM1rOGLUk5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzoyNToyMlrOGLXkRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNDY0Nw==", "bodyText": "onReplicationGroupUpdated?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414524647", "createdAt": "2020-04-24T12:07:33Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -223,6 +224,8 @@\n      */\n     private final double fileBasedRecoveryThreshold;\n \n+    private final Consumer<ReplicationGroup> onReplicationGroup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNjY5OQ==", "bodyText": "Given that this is happening under the mutex anyway (add assert Thread.holdsLock(this); to the beginning of this method), I would prefer for the field to be set before the listener is called.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414526699", "createdAt": "2020-04-24T12:10:49Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java", "diffHunk": "@@ -916,6 +936,12 @@ public ReplicationGroup getReplicationGroup() {\n         return replicationGroup;\n     }\n \n+    private void updateReplicationGroupAndNotify() {\n+        ReplicationGroup newReplicationGroup = calculateReplicationGroup();\n+        onReplicationGroup.accept(newReplicationGroup);\n+        replicationGroup = newReplicationGroup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNzkzNw==", "bodyText": "replicationTargets also contain the primary. Perhaps call this replicationTargetNodeIds instead and update method name  / javadoc below.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414527937", "createdAt": "2020-04-24T12:12:54Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ReplicationGroup.java", "diffHunk": "@@ -36,6 +37,7 @@\n     private final Set<String> trackedAllocationIds;\n \n     private final Set<String> unavailableInSyncShards; // derived from the other fields\n+    private final Set<String> replicaNodeIds; // derived from the other fields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMzc0Nw==", "bodyText": "this can be moved now further down below where it's actually used, or perhaps even better, pass it in to the performOnReplica method.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414533747", "createdAt": "2020-04-24T12:22:38Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -184,42 +192,82 @@ private void performOnReplica(final ShardRouting shard, final ReplicaRequest rep\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n-\n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        PendingReplicationActions pendingReplicationActions = primary.getPendingReplicationActions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1MTU3Nw==", "bodyText": "If we implement this check here, then the breaker/rejected/connect exception will be bubbled up as the cause for failure of the replica, which could be confusing (The failure is rather that the replica has been removed from the replication group).", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414551577", "createdAt": "2020-04-24T12:51:46Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -184,42 +192,82 @@ private void performOnReplica(final ShardRouting shard, final ReplicaRequest rep\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n-\n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        PendingReplicationActions pendingReplicationActions = primary.getPendingReplicationActions();\n+        final ActionListener<ReplicaResponse> replicationListener = new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReplicaResponse response) {\n+                successfulShards.incrementAndGet();\n+                try {\n+                    updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n+                } finally {\n+                    decPendingAndFinishIfNeeded();\n                 }\n+            }\n \n-                @Override\n-                public void onFailure(Exception replicaException) {\n-                    logger.trace(() -> new ParameterizedMessage(\n-                        \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n-                        shard.shardId(), opType, shard, replicaRequest), replicaException);\n-                    // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n-                    if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n-                        RestStatus restStatus = ExceptionsHelper.status(replicaException);\n-                        shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n-                            shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n-                    }\n-                    String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n-                    replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n-                        ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            @Override\n+            public void onFailure(Exception replicaException) {\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n+                    shard.shardId(), opType, shard, replicaRequest), replicaException);\n+                // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n+                if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n+                    RestStatus restStatus = ExceptionsHelper.status(replicaException);\n+                    shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n+                        shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n                 }\n+                String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n+                replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n+                    ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+            }\n+        };\n \n-                @Override\n-                public String toString() {\n-                    return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+        final RetryableAction<ReplicaResponse> replicationAction = new RetryableAction<>(logger, threadPool, TimeValue.timeValueMillis(50),\n+            replicaRequest.timeout(), replicationListener) {\n+\n+            private boolean addedToPending = false;\n+\n+            @Override\n+            public void tryAction(ActionListener<ReplicaResponse> listener) {\n+                replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, listener);\n+            }\n+\n+            @Override\n+            public void onSchedulingRetry() {\n+                super.onSchedulingRetry();\n+                if (addedToPending == false) {\n+                    pendingReplicationActions.addPendingAction(shard.currentNodeId(), this);\n+                    addedToPending = true;\n                 }\n-            });\n+            }\n+\n+            @Override\n+            public void onFinished() {\n+                super.onFinished();\n+                pendingReplicationActions.removeReplicationAction(shard.currentNodeId(), this);\n+            }\n+\n+            @Override\n+            public boolean shouldRetry(Exception e) {\n+                // If the node has left the replication group, do not retry\n+                if (primary.getReplicationGroup().getReplicaNodeIds().contains(shard.currentNodeId()) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU3MzYzNw==", "bodyText": "Thinking a bit more about this, we don't need this at all. We can just use trackedAllocationIds in this class instead, and key the information in PendingReplicationActions by allocation id (which represents the shard that is being replicated to).", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r414573637", "createdAt": "2020-04-24T13:25:22Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ReplicationGroup.java", "diffHunk": "@@ -36,6 +37,7 @@\n     private final Set<String> trackedAllocationIds;\n \n     private final Set<String> unavailableInSyncShards; // derived from the other fields\n+    private final Set<String> replicaNodeIds; // derived from the other fields", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUyNzkzNw=="}, "originalCommit": {"oid": "a4a23dfff6905814cd18ba209532cba634ec868e"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5dac25efe21782f957d83cd3d3c68a51539a565", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/e5dac25efe21782f957d83cd3d3c68a51539a565", "committedDate": "2020-04-24T18:13:01Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ca3da2303558994104e8501086761693b46bd2b", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/0ca3da2303558994104e8501086761693b46bd2b", "committedDate": "2020-04-24T20:59:10Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ccfa0c3735e9fed539c9dc102d8e6a6a657d87d", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/2ccfa0c3735e9fed539c9dc102d8e6a6a657d87d", "committedDate": "2020-04-24T22:06:53Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/bccf4029a6dbfb19d655a575eb0bd07d14271fdc", "committedDate": "2020-04-24T22:20:18Z", "message": "Changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTQxMjk2", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-400941296", "createdAt": "2020-04-27T13:17:39Z", "commit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoxNzo0MFrOGMiquw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoyNjo0MVrOGMjF2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNDA5MQ==", "bodyText": "Perhaps we can use IndexShardClosedException here which tells us that a shard has gone away.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415804091", "createdAt": "2020-04-27T13:17:40Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNjgwMw==", "bodyText": "onGoingReplicationActions.keySet() is only eventually consistent (i.e. can race against addPendingAction).", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415806803", "createdAt": "2020-04-27T13:21:12Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new UnavailableShardsException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        Set<String> trackedAllocationIds = replicationGroup.getTrackedAllocationIds();\n+\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMDQyNg==", "bodyText": "This is only eventually consistent (and can race any of the other methods). It's not strictly a problem for the use case where we're using this, but I wonder if we should add a recheck method in this class that we call whenever we reschedule that makes sure that pendingReplicationActions has not been closed, or if we should properly serialize all access to the top-level keyset, e.g. using a read-write-lock.", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415810426", "createdAt": "2020-04-27T13:25:59Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new UnavailableShardsException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        Set<String> trackedAllocationIds = replicationGroup.getTrackedAllocationIds();\n+\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new UnavailableShardsException(shardId, \"Replica left ReplicationGroup\"))));\n+    }\n+\n+\n+    @Override\n+    public void close() {\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>(onGoingReplicationActions.values());\n+        onGoingReplicationActions.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMTAzNQ==", "bodyText": "let's introduce a new setting for this", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r415811035", "createdAt": "2020-04-27T13:26:41Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java", "diffHunk": "@@ -174,52 +184,78 @@ private void performOnReplicas(final ReplicaRequest replicaRequest, final long g\n \n         for (final ShardRouting shard : replicationGroup.getReplicationTargets()) {\n             if (shard.isSameAllocation(primaryRouting) == false) {\n-                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes);\n+                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, pendingReplicationActions);\n             }\n         }\n     }\n \n     private void performOnReplica(final ShardRouting shard, final ReplicaRequest replicaRequest,\n-                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes) {\n+                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes,\n+                                  final PendingReplicationActions pendingReplicationActions) {\n         if (logger.isTraceEnabled()) {\n             logger.trace(\"[{}] sending op [{}] to replica {} for request [{}]\", shard.shardId(), opType, shard, replicaRequest);\n         }\n-\n         totalShards.incrementAndGet();\n         pendingActions.incrementAndGet();\n-        replicasProxy.performOn(shard, replicaRequest, primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,\n-            new ActionListener<>() {\n-                @Override\n-                public void onResponse(ReplicaResponse response) {\n-                    successfulShards.incrementAndGet();\n-                    try {\n-                        updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n-                    } finally {\n-                        decPendingAndFinishIfNeeded();\n-                    }\n+        final ActionListener<ReplicaResponse> replicationListener = new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReplicaResponse response) {\n+                successfulShards.incrementAndGet();\n+                try {\n+                    updateCheckPoints(shard, response::localCheckpoint, response::globalCheckpoint);\n+                } finally {\n+                    decPendingAndFinishIfNeeded();\n                 }\n+            }\n \n-                @Override\n-                public void onFailure(Exception replicaException) {\n-                    logger.trace(() -> new ParameterizedMessage(\n-                        \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n-                        shard.shardId(), opType, shard, replicaRequest), replicaException);\n-                    // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n-                    if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n-                        RestStatus restStatus = ExceptionsHelper.status(replicaException);\n-                        shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n-                            shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n-                    }\n-                    String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n-                    replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n-                        ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            @Override\n+            public void onFailure(Exception replicaException) {\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}] failure while performing [{}] on replica {}, request [{}]\",\n+                    shard.shardId(), opType, shard, replicaRequest), replicaException);\n+                // Only report \"critical\" exceptions - TODO: Reach out to the master node to get the latest shard state then report.\n+                if (TransportActions.isShardNotAvailableException(replicaException) == false) {\n+                    RestStatus restStatus = ExceptionsHelper.status(replicaException);\n+                    shardReplicaFailures.add(new ReplicationResponse.ShardInfo.Failure(\n+                        shard.shardId(), shard.currentNodeId(), replicaException, restStatus, false));\n                 }\n+                String message = String.format(Locale.ROOT, \"failed to perform %s on replica %s\", opType, shard);\n+                replicasProxy.failShardIfNeeded(shard, primaryTerm, message, replicaException,\n+                    ActionListener.wrap(r -> decPendingAndFinishIfNeeded(), ReplicationOperation.this::onNoLongerPrimary));\n+            }\n \n-                @Override\n-                public String toString() {\n-                    return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n-                }\n-            });\n+            @Override\n+            public String toString() {\n+                return \"[\" + replicaRequest + \"][\" + shard + \"]\";\n+            }\n+        };\n+\n+        final String allocationId = shard.allocationId().getId();\n+        final RetryableAction<ReplicaResponse> replicationAction = new RetryableAction<>(logger, threadPool, TimeValue.timeValueMillis(50),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a1b105099441560f2a5672e4438dee8fa32519c", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/5a1b105099441560f2a5672e4438dee8fa32519c", "committedDate": "2020-04-27T16:25:44Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef2378212ee513eddede7201b80e60cc44cdbf8", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/0ef2378212ee513eddede7201b80e60cc44cdbf8", "committedDate": "2020-04-27T23:02:15Z", "message": "Chnages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06982e9caecbef7f0c063dca7328cac2acf9891f", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/06982e9caecbef7f0c063dca7328cac2acf9891f", "committedDate": "2020-04-28T01:50:35Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "159c138024f854a6c2ae7278a8aea32bf51b08da", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/159c138024f854a6c2ae7278a8aea32bf51b08da", "committedDate": "2020-04-28T02:20:08Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/7568718fe1dd671e4d8cc4c07e7c86f1464ccd93", "committedDate": "2020-04-28T04:32:52Z", "message": "Changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNzA5MjMw", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-401709230", "createdAt": "2020-04-28T10:37:06Z", "commit": {"oid": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMDozNzowN1rOGNNvVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMDo1Mjo0NlrOGNOR5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUwOTc4Mw==", "bodyText": "Let's call onFinished before the finalListener (in all cases here).", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416509783", "createdAt": "2020-04-28T10:37:07Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/RetryableAction.java", "diffHunk": "@@ -128,6 +132,7 @@ private RetryingListener(long delayMillisBound, ArrayDeque<Exception> caughtExce\n         public void onResponse(Response response) {\n             if (isDone.compareAndSet(false, true)) {\n                 finalListener.onResponse(response);\n+                onFinished();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxNzUwOQ==", "bodyText": "ok, I missed the synchronized keywords", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416517509", "createdAt": "2020-04-28T10:50:54Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.UnavailableShardsException;\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new UnavailableShardsException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new UnavailableShardsException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        Set<String> trackedAllocationIds = replicationGroup.getTrackedAllocationIds();\n+\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new UnavailableShardsException(shardId, \"Replica left ReplicationGroup\"))));\n+    }\n+\n+\n+    @Override\n+    public void close() {\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>(onGoingReplicationActions.values());\n+        onGoingReplicationActions.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMDQyNg=="}, "originalCommit": {"oid": "bccf4029a6dbfb19d655a575eb0bd07d14271fdc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxODYyOQ==", "bodyText": "can you add the message here that the primary shard closed (in contrast to the replica closing)?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r416518629", "createdAt": "2020-04-28T10:52:46Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void accept(ReplicationGroup replicationGroup) {\n+        acceptNewTrackedAllocationIds(replicationGroup.getTrackedAllocationIds());\n+    }\n+\n+    // Visible for testing\n+    synchronized void acceptNewTrackedAllocationIds(Set<String> trackedAllocationIds) {\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new IndexShardClosedException(shardId, \"Replica left ReplicationGroup\"))));\n+    }\n+\n+\n+    @Override\n+    public synchronized void close() {\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>(onGoingReplicationActions.values());\n+        onGoingReplicationActions.clear();\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()\n+            .flatMap(Collection::stream)\n+            .forEach(action -> action.cancel(new IndexShardClosedException(shardId))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7568718fe1dd671e4d8cc4c07e7c86f1464ccd93"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "decb9eee834c19a93355fc2a57bfbe9175f6f4b0", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/decb9eee834c19a93355fc2a57bfbe9175f6f4b0", "committedDate": "2020-04-28T20:34:00Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6efa3ffc1825840a70b2962249feb2daf99dde1b", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/6efa3ffc1825840a70b2962249feb2daf99dde1b", "committedDate": "2020-04-28T20:38:31Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83e57d1ae6059868b61ad0fc5fd4852c68d6d0c9", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/83e57d1ae6059868b61ad0fc5fd4852c68d6d0c9", "committedDate": "2020-04-28T21:33:56Z", "message": "Mute to ensure all tests are run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f33e2e17433707a843ce1f7d441e0f5b871465e", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/7f33e2e17433707a843ce1f7d441e0f5b871465e", "committedDate": "2020-04-29T15:19:21Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44b607aa4db1f704d774369275c5337cc28ba2ba", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/44b607aa4db1f704d774369275c5337cc28ba2ba", "committedDate": "2020-04-29T15:38:07Z", "message": "Add"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9ca9d1b5452a2687fd3d5781a40953d178d5754", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/f9ca9d1b5452a2687fd3d5781a40953d178d5754", "committedDate": "2020-04-29T15:40:54Z", "message": "double check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5876f52425f063313237786b4e53b3ebd57837a", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/d5876f52425f063313237786b4e53b3ebd57837a", "committedDate": "2020-04-29T16:12:46Z", "message": "Merge remote-tracking branch 'upstream/master' into retry_replication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f75aea491c1c3d1e3dd939563a0138118e82395", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/2f75aea491c1c3d1e3dd939563a0138118e82395", "committedDate": "2020-04-29T16:16:24Z", "message": "npe"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODM1ODU4", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-402835858", "createdAt": "2020-04-29T16:27:17Z", "commit": {"oid": "44b607aa4db1f704d774369275c5337cc28ba2ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNzoxOFrOGOHAFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNzoxOFrOGOHAFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0Nzk1OQ==", "bodyText": "Test failure, should probably be using the random instance here", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417447959", "createdAt": "2020-04-29T16:27:18Z", "author": {"login": "ywelsch"}, "path": "test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java", "diffHunk": "@@ -505,6 +508,11 @@ private static Settings getRandomNodeSettings(long seed) {\n             builder.put(ScriptService.SCRIPT_CACHE_EXPIRE_SETTING.getConcreteSettingForNamespace(ctx).getKey(),\n                         timeValueMillis(RandomNumbers.randomIntBetween(random, 750, 10000000)).getStringRep());\n         }\n+        if (random.nextBoolean()) {\n+            builder.put(TransportReplicationAction.REPLICATION_RETRY_TIMEOUT.getKey(), timeValueSeconds(randomInt(60)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b607aa4db1f704d774369275c5337cc28ba2ba"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/11d35e42a37be128ccee94bc7641d2288a6d42e1", "committedDate": "2020-04-29T16:43:00Z", "message": "Use correct random"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyOTY2NjE5", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-402966619", "createdAt": "2020-04-29T19:19:52Z", "commit": {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDkxODEz", "url": "https://github.com/elastic/elasticsearch/pull/55633#pullrequestreview-403091813", "createdAt": "2020-04-29T22:44:15Z", "commit": {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo0NDoxNVrOGOTr0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo0NTowMFrOGOTs9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NTc2MA==", "bodyText": "Maybe share this logic with close?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417655760", "createdAt": "2020-04-29T22:44:15Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+    private volatile long replicationGroupVersion = -1;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public void accept(ReplicationGroup replicationGroup) {\n+        if (replicationGroup.getVersion() - replicationGroupVersion > 0) {\n+            synchronized (this) {\n+                if (replicationGroup.getVersion() - replicationGroupVersion > 0) {\n+                    acceptNewTrackedAllocationIds(replicationGroup.getTrackedAllocationIds());\n+                    replicationGroupVersion = replicationGroup.getVersion();\n+                }\n+            }\n+        }\n+    }\n+\n+    // Visible for testing\n+    synchronized void acceptNewTrackedAllocationIds(Set<String> trackedAllocationIds) {\n+        for (String targetAllocationId : trackedAllocationIds) {\n+            onGoingReplicationActions.putIfAbsent(targetAllocationId, ConcurrentCollections.newConcurrentSet());\n+        }\n+        ArrayList<Set<RetryableAction<?>>> toCancel = new ArrayList<>();\n+        for (String allocationId : onGoingReplicationActions.keySet()) {\n+            if (trackedAllocationIds.contains(allocationId) == false) {\n+                toCancel.add(onGoingReplicationActions.remove(allocationId));\n+            }\n+        }\n+\n+        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> toCancel.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NTkyNQ==", "bodyText": "maybe just replicationGroup.getVersion() > replicationGroupVersion?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417655925", "createdAt": "2020-04-29T22:44:39Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+    private volatile long replicationGroupVersion = -1;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public void accept(ReplicationGroup replicationGroup) {\n+        if (replicationGroup.getVersion() - replicationGroupVersion > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NjA1Mw==", "bodyText": "maybe just replicationGroup.getVersion() > replicationGroupVersion ?", "url": "https://github.com/elastic/elasticsearch/pull/55633#discussion_r417656053", "createdAt": "2020-04-29T22:45:00Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/support/replication/PendingReplicationActions.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.support.replication;\n+\n+import org.elasticsearch.action.support.RetryableAction;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.index.shard.IndexShardClosedException;\n+import org.elasticsearch.index.shard.ReplicationGroup;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class PendingReplicationActions implements Consumer<ReplicationGroup>, Releasable {\n+\n+    private final Map<String, Set<RetryableAction<?>>> onGoingReplicationActions = ConcurrentCollections.newConcurrentMap();\n+    private final ShardId shardId;\n+    private final ThreadPool threadPool;\n+    private volatile long replicationGroupVersion = -1;\n+\n+    public PendingReplicationActions(ShardId shardId, ThreadPool threadPool) {\n+        this.shardId = shardId;\n+        this.threadPool = threadPool;\n+    }\n+\n+    public void addPendingAction(String allocationId, RetryableAction<?> replicationAction) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.add(replicationAction);\n+            if (onGoingReplicationActions.containsKey(allocationId) == false) {\n+                replicationAction.cancel(new IndexShardClosedException(shardId,\n+                    \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+            }\n+        } else {\n+            replicationAction.cancel(new IndexShardClosedException(shardId,\n+                \"Replica unavailable - replica could have left ReplicationGroup or IndexShard might have closed\"));\n+        }\n+    }\n+\n+    public void removeReplicationAction(String allocationId, RetryableAction<?> action) {\n+        Set<RetryableAction<?>> ongoingActionsOnNode = onGoingReplicationActions.get(allocationId);\n+        if (ongoingActionsOnNode != null) {\n+            ongoingActionsOnNode.remove(action);\n+        }\n+    }\n+\n+    @Override\n+    public void accept(ReplicationGroup replicationGroup) {\n+        if (replicationGroup.getVersion() - replicationGroupVersion > 0) {\n+            synchronized (this) {\n+                if (replicationGroup.getVersion() - replicationGroupVersion > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11d35e42a37be128ccee94bc7641d2288a6d42e1"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c77b873ffb417f0257f5dd80dce969eb70e0329c", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/c77b873ffb417f0257f5dd80dce969eb70e0329c", "committedDate": "2020-04-30T15:19:14Z", "message": "Chnage"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 504, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}