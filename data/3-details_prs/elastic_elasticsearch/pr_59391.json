{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MTUyMjM1", "number": 59391, "title": "Make ScriptFieldMapper a parameterized mapper", "bodyText": "This PR is opened against the runtime fields feature branch.\nRelates to #59332", "createdAt": "2020-07-13T10:05:14Z", "url": "https://github.com/elastic/elasticsearch/pull/59391", "merged": true, "mergeCommit": {"oid": "4eb18b28f0677dcd4a47415d9a05007baecf6129"}, "closed": true, "closedAt": "2020-07-14T14:57:32Z", "author": {"login": "javanna"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0egv8AH2gAyNDQ4MTUyMjM1OmMyZWMwYTJjZGVjNGIzNjY0NjRlNmIyYzFhZmQ3NmM0ZGM2M2UzODM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc03PMTgFqTQ0ODE4MzMxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383", "committedDate": "2020-07-13T10:03:04Z", "message": "Make ScriptFieldMapper a parameterized mapper"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MTE5MjM5", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-447119239", "createdAt": "2020-07-13T10:15:45Z", "commit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoxNTo0NVrOGwiPIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDozMDoxMVrOGwitkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0NTc2MQ==", "bodyText": "You should be able to use Parameter.metaParam() here", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453545761", "createdAt": "2020-07-13T10:15:45Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0Njk0Ng==", "bodyText": "Is there no way of getting it via the ParserContext?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453546946", "createdAt": "2020-07-13T10:17:52Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n             }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n+            if (script.getValue() == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n             }\n \n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = scriptService.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Object scriptObject) {\n+            if (scriptObject instanceof Map) {\n+                Map<String, ?> scriptMap = (Map<String, ?>) scriptObject;\n+                Object sourceObject = scriptMap.remove(\"source\");\n+                if (sourceObject == null) {\n+                    throw new IllegalArgumentException(\"script source must be specified for script field [\" + name + \"]\");\n+                }\n+                Object langObject = scriptMap.remove(\"lang\");\n+                if (langObject != null && langObject.toString().equals(PainlessScriptEngine.NAME) == false) {\n+                    throw new IllegalArgumentException(\"script lang [\" + langObject.toString() + \"] not supported for script field [\"\n+                        + name + \"]\");\n+                }\n+                Map<String, Object> params;\n+                Object paramsObject = scriptMap.remove(\"params\");\n+                if (paramsObject != null) {\n+                    if (paramsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse params for script field [\" + name + \"]\");\n+                    }\n+                    params = (Map<String, Object>) paramsObject;\n+                } else {\n+                    params = Collections.emptyMap();\n+                }\n+                Map<String, String> options;\n+                Object optionsObject = scriptMap.remove(\"options\");\n+                if (optionsObject != null) {\n+                    if (optionsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse options for script field [\" + name + \"]\");\n+                    }\n+                    options = (Map<String, String>) optionsObject;\n+                } else {\n+                    options = Collections.emptyMap();\n+                }\n+                if (scriptMap.size() > 0) {\n+                    throw new IllegalArgumentException(\"unsupported parameters specified for script field [\" + name + \"]: \"\n+                        + scriptMap.keySet());\n+                }\n+                return new Script(ScriptType.INLINE, PainlessScriptEngine.NAME, sourceObject.toString(), options, params);\n+            } else if (scriptObject instanceof String) {\n+                return new Script((String) scriptObject);\n+            } else {\n+                throw new IllegalArgumentException(\"unable to parse script for script field [\" + name + \"]\");\n+\n+            }\n         }\n     }\n \n     public static class TypeParser implements Mapper.TypeParser {\n \n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        // TODO this is quite ugly and it's static which makes it even worse\n+        private static final SetOnce<ScriptService> SCRIPT_SERVICE = new SetOnce<>();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0NzkxMQ==", "bodyText": "Once #59291 is merged then you can set validators directly on the parameter", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453547911", "createdAt": "2020-07-13T10:19:42Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzU1Mw==", "bodyText": "It looks as though we'd have to wire ScriptService into MapperService, but I think that's a reasonable thing to do", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453553553", "createdAt": "2020-07-13T10:30:11Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n             }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n+            if (script.getValue() == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n             }\n \n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = scriptService.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo.build(), this);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Object scriptObject) {\n+            if (scriptObject instanceof Map) {\n+                Map<String, ?> scriptMap = (Map<String, ?>) scriptObject;\n+                Object sourceObject = scriptMap.remove(\"source\");\n+                if (sourceObject == null) {\n+                    throw new IllegalArgumentException(\"script source must be specified for script field [\" + name + \"]\");\n+                }\n+                Object langObject = scriptMap.remove(\"lang\");\n+                if (langObject != null && langObject.toString().equals(PainlessScriptEngine.NAME) == false) {\n+                    throw new IllegalArgumentException(\"script lang [\" + langObject.toString() + \"] not supported for script field [\"\n+                        + name + \"]\");\n+                }\n+                Map<String, Object> params;\n+                Object paramsObject = scriptMap.remove(\"params\");\n+                if (paramsObject != null) {\n+                    if (paramsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse params for script field [\" + name + \"]\");\n+                    }\n+                    params = (Map<String, Object>) paramsObject;\n+                } else {\n+                    params = Collections.emptyMap();\n+                }\n+                Map<String, String> options;\n+                Object optionsObject = scriptMap.remove(\"options\");\n+                if (optionsObject != null) {\n+                    if (optionsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse options for script field [\" + name + \"]\");\n+                    }\n+                    options = (Map<String, String>) optionsObject;\n+                } else {\n+                    options = Collections.emptyMap();\n+                }\n+                if (scriptMap.size() > 0) {\n+                    throw new IllegalArgumentException(\"unsupported parameters specified for script field [\" + name + \"]: \"\n+                        + scriptMap.keySet());\n+                }\n+                return new Script(ScriptType.INLINE, PainlessScriptEngine.NAME, sourceObject.toString(), options, params);\n+            } else if (scriptObject instanceof String) {\n+                return new Script((String) scriptObject);\n+            } else {\n+                throw new IllegalArgumentException(\"unable to parse script for script field [\" + name + \"]\");\n+\n+            }\n         }\n     }\n \n     public static class TypeParser implements Mapper.TypeParser {\n \n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        // TODO this is quite ugly and it's static which makes it even worse\n+        private static final SetOnce<ScriptService> SCRIPT_SERVICE = new SetOnce<>();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU0Njk0Ng=="}, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 199}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c913bbfcb1938f72b0ba66e908a1fb873b667cc9", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/c913bbfcb1938f72b0ba66e908a1fb873b667cc9", "committedDate": "2020-07-13T12:10:13Z", "message": "Merge branch 'feature/runtime_fields' into enhancement/script_mapper_parameterized"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjAwNDk2", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-447200496", "createdAt": "2020-07-13T12:23:57Z", "commit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyMzo1N1rOGwmM0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyMzo1N1rOGwmM0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDcwNg==", "bodyText": "@romseygeek this is for you, does it make sense?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453610706", "createdAt": "2020-07-13T12:23:57Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,59 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {\n+        return (ScriptFieldMapper) in;\n+    }\n+\n+    protected ScriptFieldMapper(\n+        String simpleName,\n+        MappedFieldType mappedFieldType,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        Builder builder\n+    ) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n+        // TODO is it ok that the object being built needs to read from the object that is building it? Shouldn't Builder#build return\n+        // a complete object? Maybe all the parameters need to be passed through instead of the whole builder?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjAwNzg2", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-447200786", "createdAt": "2020-07-13T12:24:22Z", "commit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyNDoyM1rOGwmNsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyNDoyM1rOGwmNsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDkyOQ==", "bodyText": "@romseygeek do you have thoughts on this?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453610929", "createdAt": "2020-07-13T12:24:23Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjAxNDQy", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-447201442", "createdAt": "2020-07-13T12:25:20Z", "commit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyNToyMFrOGwmPvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjoyNToyMFrOGwmPvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTQ1NA==", "bodyText": "@romseygeek and this one too. I think I would prefer making the changes upstream instead of adapting parameterized field mapper in the feature branch. Thoughts?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453611454", "createdAt": "2020-07-13T12:25:20Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\"script\", true, null,\n+            Builder::parseScript, mapper -> toType(mapper).script);\n         private final ScriptService scriptService;\n \n-        private String runtimeType;\n-        private Script script;\n-\n         protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n+            super(name);\n             this.scriptService = scriptService;\n         }\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n-        }\n-\n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n+            if (runtimeType.getValue() == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n             }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n+            if (script.getValue() == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n             }\n \n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = scriptService.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/4458b7133d63d2417652f9e5fa90244e16dfdb07", "committedDate": "2020-07-13T13:17:44Z", "message": "iter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjYxODA0", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-447261804", "createdAt": "2020-07-13T13:42:20Z", "commit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo0MjoyMFrOGwpGxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo0MjoyMFrOGwpGxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1ODMxMA==", "bodyText": "@nik9000 help!", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453658310", "createdAt": "2020-07-13T13:42:20Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapperTests.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+\n+import java.util.Collection;\n+\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class ScriptFieldMapperTests extends ESSingleNodeTestCase {\n+\n+    private static final String[] SUPPORTED_RUNTIME_TYPES = new String[] { \"keyword\" };\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return pluginList(InternalSettingsPlugin.class, RuntimeFields.class, PainlessPlugin.class);\n+    }\n+\n+    public void testRuntimeTypeIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"script\", \"value('test')\")\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: runtime_type must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    public void testScriptIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"runtime_type\", randomFrom(SUPPORTED_RUNTIME_TYPES))\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: script must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    @AwaitsFix(bugUrl = \"Nik: help! :)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjYxNDMx", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-447261431", "createdAt": "2020-07-13T13:41:56Z", "commit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo0MTo1NlrOGwpFkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToyOTo1NVrOGwtzvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1ODAwMg==", "bodyText": "We have this sort of problem now with any thing that can change. I guess scripts make this worse because they are \"more mutable\" than other stuff.", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453658002", "createdAt": "2020-07-13T13:41:56Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +73,118 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n+\n+        private final Parameter<Map<String, String>> meta = new Parameter<>(\n+            \"meta\",\n+            true,\n+            Collections.emptyMap(),\n+            TypeParsers::parseMeta,\n+            m -> m.fieldType().meta()\n+        );\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        );\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMDkyOQ=="}, "originalCommit": {"oid": "c2ec0a2cdec4b366464e6b2c1afd76c4dc63e383"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2MDAxNQ==", "bodyText": "I swear I've seen this before somewhere else...", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453660015", "createdAt": "2020-07-13T13:44:44Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +74,122 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n-        private final ScriptService scriptService;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private String runtimeType;\n-        private Script script;\n-\n-        protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n-            this.scriptService = scriptService;\n-        }\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        ).setValidator(runtimeType -> {\n+            if (runtimeType == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\n+            \"script\",\n+            true,\n+            null,\n+            Builder::parseScript,\n+            mapper -> toType(mapper).script\n+        ).setValidator(script -> {\n+            if (script == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n+        protected Builder(String name, Supplier<QueryShardContext> queryShardContextSupplier) {\n+            super(name);\n+            this.queryShardContextSupplier = queryShardContextSupplier;\n         }\n \n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n-            }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n-            }\n-\n+            QueryShardContext queryShardContext = queryShardContextSupplier.get();\n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = queryShardContext.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(\n+                name,\n+                mappedFieldType,\n+                multiFieldsBuilder.build(this, context),\n+                copyTo.build(),\n+                runtimeType.getValue(),\n+                script.getValue(),\n+                queryShardContextSupplier\n+            );\n         }\n-    }\n \n-    public static class TypeParser implements Mapper.TypeParser {\n-\n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Mapper.TypeParser.ParserContext parserContext, Object scriptObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNzA3Mw==", "bodyText": "I think queryShardContextSupplier exists for the percolator and it is a bit sneaky. It'll do but I'd feel more comfortable if we had the ScriptService directly.", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453727073", "createdAt": "2020-07-13T15:18:20Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -56,81 +74,122 @@ protected String contentType() {\n         return CONTENT_TYPE;\n     }\n \n-    public static class Builder extends FieldMapper.Builder<Builder> {\n-\n-        private final ScriptService scriptService;\n+    public static class Builder extends ParametrizedFieldMapper.Builder {\n \n-        private String runtimeType;\n-        private Script script;\n-\n-        protected Builder(String name, ScriptService scriptService) {\n-            super(name, FIELD_TYPE);\n-            this.scriptService = scriptService;\n-        }\n+        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n+        private final Parameter<String> runtimeType = Parameter.stringParam(\n+            \"runtime_type\",\n+            true,\n+            mapper -> toType(mapper).runtimeType,\n+            null\n+        ).setValidator(runtimeType -> {\n+            if (runtimeType == null) {\n+                throw new IllegalArgumentException(\"runtime_type must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        // TODO script and runtime_type can be updated: what happens to the currently running queries when they get updated?\n+        // do all the shards get a consistent view?\n+        private final Parameter<Script> script = new Parameter<>(\n+            \"script\",\n+            true,\n+            null,\n+            Builder::parseScript,\n+            mapper -> toType(mapper).script\n+        ).setValidator(script -> {\n+            if (script == null) {\n+                throw new IllegalArgumentException(\"script must be specified for script field [\" + name + \"]\");\n+            }\n+        });\n+        private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-        public void runtimeType(String runtimeType) {\n-            this.runtimeType = runtimeType;\n+        protected Builder(String name, Supplier<QueryShardContext> queryShardContextSupplier) {\n+            super(name);\n+            this.queryShardContextSupplier = queryShardContextSupplier;\n         }\n \n-        public void script(Script script) {\n-            this.script = script;\n+        @Override\n+        protected List<Parameter<?>> getParameters() {\n+            return List.of(meta, runtimeType, script);\n         }\n \n         @Override\n         public ScriptFieldMapper build(BuilderContext context) {\n-            if (runtimeType == null) {\n-                throw new IllegalArgumentException(\"runtime_type must be specified\");\n-            }\n-            if (script == null) {\n-                throw new IllegalArgumentException(\"script must be specified\");\n-            }\n-\n+            QueryShardContext queryShardContext = queryShardContextSupplier.get();\n             MappedFieldType mappedFieldType;\n-            if (runtimeType.equals(\"keyword\")) {\n-                StringScriptFieldScript.Factory factory = scriptService.compile(script, StringScriptFieldScript.CONTEXT);\n-                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script, factory, meta);\n+            if (runtimeType.getValue().equals(\"keyword\")) {\n+                StringScriptFieldScript.Factory factory = queryShardContext.compile(script.getValue(), StringScriptFieldScript.CONTEXT);\n+                mappedFieldType = new RuntimeKeywordMappedFieldType(buildFullName(context), script.getValue(), factory, meta.getValue());\n             } else {\n                 throw new IllegalArgumentException(\"runtime_type [\" + runtimeType + \"] not supported\");\n             }\n-            // TODO copy to and multi_fields... not sure what needs to be done.\n-            return new ScriptFieldMapper(name, mappedFieldType, multiFieldsBuilder.build(this, context), copyTo);\n+            // TODO copy to and multi_fields should not be supported, parametrized field mapper needs to be adapted\n+            return new ScriptFieldMapper(\n+                name,\n+                mappedFieldType,\n+                multiFieldsBuilder.build(this, context),\n+                copyTo.build(),\n+                runtimeType.getValue(),\n+                script.getValue(),\n+                queryShardContextSupplier\n+            );\n         }\n-    }\n \n-    public static class TypeParser implements Mapper.TypeParser {\n-\n-        private final SetOnce<ScriptService> scriptService = new SetOnce<>();\n+        @SuppressWarnings(\"unchecked\")\n+        static Script parseScript(String name, Mapper.TypeParser.ParserContext parserContext, Object scriptObject) {\n+            if (scriptObject instanceof Map) {\n+                Map<String, ?> scriptMap = (Map<String, ?>) scriptObject;\n+                Object sourceObject = scriptMap.remove(\"source\");\n+                if (sourceObject == null) {\n+                    throw new IllegalArgumentException(\"script source must be specified for script field [\" + name + \"]\");\n+                }\n+                Object langObject = scriptMap.remove(\"lang\");\n+                if (langObject != null && langObject.toString().equals(PainlessScriptEngine.NAME) == false) {\n+                    throw new IllegalArgumentException(\n+                        \"script lang [\" + langObject.toString() + \"] not supported for script field [\" + name + \"]\"\n+                    );\n+                }\n+                Map<String, Object> params;\n+                Object paramsObject = scriptMap.remove(\"params\");\n+                if (paramsObject != null) {\n+                    if (paramsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse params for script field [\" + name + \"]\");\n+                    }\n+                    params = (Map<String, Object>) paramsObject;\n+                } else {\n+                    params = Collections.emptyMap();\n+                }\n+                Map<String, String> options;\n+                Object optionsObject = scriptMap.remove(\"options\");\n+                if (optionsObject != null) {\n+                    if (optionsObject instanceof Map == false) {\n+                        throw new IllegalArgumentException(\"unable to parse options for script field [\" + name + \"]\");\n+                    }\n+                    options = (Map<String, String>) optionsObject;\n+                } else {\n+                    options = Collections.emptyMap();\n+                }\n+                if (scriptMap.size() > 0) {\n+                    throw new IllegalArgumentException(\n+                        \"unsupported parameters specified for script field [\" + name + \"]: \" + scriptMap.keySet()\n+                    );\n+                }\n+                return new Script(ScriptType.INLINE, PainlessScriptEngine.NAME, sourceObject.toString(), options, params);\n+            } else if (scriptObject instanceof String) {\n+                return new Script((String) scriptObject);\n+            } else {\n+                throw new IllegalArgumentException(\"unable to parse script for script field [\" + name + \"]\");\n \n-        public void setScriptService(ScriptService scriptService) {\n-            this.scriptService.set(scriptService);\n+            }\n         }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n \n         @Override\n         public ScriptFieldMapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n             throws MapperParsingException {\n-            Builder builder = new Builder(name, scriptService.get());\n-            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n-                Map.Entry<String, Object> entry = iterator.next();\n-                String propName = entry.getKey();\n-                Object propNode = entry.getValue();\n-                if (propName.equals(\"runtime_type\")) {\n-                    if (propNode == null) {\n-                        throw new MapperParsingException(\"Property [runtime_type] cannot be null.\");\n-                    }\n-                    builder.runtimeType(XContentMapValues.nodeStringValue(propNode, name + \".runtime_type\"));\n-                    iterator.remove();\n-                } else if (propName.equals(\"script\")) {\n-                    if (propNode == null) {\n-                        throw new MapperParsingException(\"Property [script] cannot be null.\");\n-                    }\n-                    // TODO this should become an object and support the usual script syntax, including lang and params\n-                    builder.script(new Script(XContentMapValues.nodeStringValue(propNode, name + \".script\")));\n-                    iterator.remove();\n-                }\n-            }\n-            // TODO these get passed in sometimes and we don't need them\n-            node.remove(\"doc_values\");\n-            node.remove(\"index\");\n+            ScriptFieldMapper.Builder builder = new ScriptFieldMapper.Builder(name, parserContext.queryShardContextSupplier());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMDg4OQ==", "bodyText": "I worry about keeping the queryShardContextSupplier around because it is sneaky. Could getMergeBuilder get the parse context or something like that?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453730889", "createdAt": "2020-07-13T15:23:26Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,60 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n-import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n-import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.Supplier;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n+    private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {\n+        return (ScriptFieldMapper) in;\n+    }\n+\n+    protected ScriptFieldMapper(\n+        String simpleName,\n+        MappedFieldType mappedFieldType,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        String runtimeType,\n+        Script script,\n+        Supplier<QueryShardContext> queryShardContextSupplier\n+    ) {\n+        super(simpleName, mappedFieldType, multiFields, copyTo);\n+        this.runtimeType = runtimeType;\n+        this.script = script;\n+        this.queryShardContextSupplier = queryShardContextSupplier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMTIyNw==", "bodyText": "Could you move this next to the Builder?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453731227", "createdAt": "2020-07-13T15:23:53Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,60 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n-import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n-import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.Supplier;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n+    private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMTMyMA==", "bodyText": "Or even in the builder?", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453731320", "createdAt": "2020-07-13T15:24:03Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapper.java", "diffHunk": "@@ -6,42 +6,60 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n-import org.apache.lucene.document.FieldType;\n-import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.Mapper;\n import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParametrizedFieldMapper;\n import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.painless.PainlessScriptEngine;\n import org.elasticsearch.script.Script;\n-import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.Supplier;\n \n-public final class ScriptFieldMapper extends FieldMapper {\n+public final class ScriptFieldMapper extends ParametrizedFieldMapper {\n \n     public static final String CONTENT_TYPE = \"script\";\n \n-    private static final FieldType FIELD_TYPE = new FieldType();\n+    private final String runtimeType;\n+    private final Script script;\n+    private final Supplier<QueryShardContext> queryShardContextSupplier;\n \n-    ScriptFieldMapper(String simpleName, MappedFieldType mappedFieldType, MultiFields multiFields, CopyTo copyTo) {\n-        super(simpleName, FIELD_TYPE, mappedFieldType, multiFields, copyTo);\n+    private static ScriptFieldMapper toType(FieldMapper in) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMTIyNw=="}, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTM1OA==", "bodyText": "Is the idea to test that we can properly parse a simple version of the mapper? I don't really get the name of the method. I will try and hack on it locally and let you know what I find.", "url": "https://github.com/elastic/elasticsearch/pull/59391#discussion_r453735358", "createdAt": "2020-07-13T15:29:55Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptFieldMapperTests.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.mapper;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.painless.PainlessPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n+\n+import java.util.Collection;\n+\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class ScriptFieldMapperTests extends ESSingleNodeTestCase {\n+\n+    private static final String[] SUPPORTED_RUNTIME_TYPES = new String[] { \"keyword\" };\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return pluginList(InternalSettingsPlugin.class, RuntimeFields.class, PainlessPlugin.class);\n+    }\n+\n+    public void testRuntimeTypeIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"script\", \"value('test')\")\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: runtime_type must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    public void testScriptIsRequired() throws Exception {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder()\n+            .startObject()\n+            .startObject(\"_doc\")\n+            .startObject(\"properties\")\n+            .startObject(\"my_field\")\n+            .field(\"type\", \"script\")\n+            .field(\"runtime_type\", randomFrom(SUPPORTED_RUNTIME_TYPES))\n+            .endObject()\n+            .endObject()\n+            .endObject()\n+            .endObject();\n+\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createIndex(\"test\", Settings.EMPTY, mapping));\n+        assertEquals(\"Failed to parse mapping: script must be specified for script field [my_field]\", exception.getMessage());\n+    }\n+\n+    @AwaitsFix(bugUrl = \"Nik: help! :)\")\n+    public void testDefaultMapping() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4458b7133d63d2417652f9e5fa90244e16dfdb07"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99f18133932d0202acd9874b338a32c782e47011", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/99f18133932d0202acd9874b338a32c782e47011", "committedDate": "2020-07-14T07:47:33Z", "message": "Merge branch 'feature/runtime_fields' into enhancement/script_mapper_parameterized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "993ba667c240c1cd9fc6ce9d2000d2981b933995", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/993ba667c240c1cd9fc6ce9d2000d2981b933995", "committedDate": "2020-07-14T08:13:29Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7265381b9dfa5c6948276d4f1ce86eae1ef9276b", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/7265381b9dfa5c6948276d4f1ce86eae1ef9276b", "committedDate": "2020-07-14T12:50:02Z", "message": "Merge branch 'feature/runtime_fields' into enhancement/script_mapper_parameterized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b7846d386565c901374f4aef3a2637965628022", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b7846d386565c901374f4aef3a2637965628022", "committedDate": "2020-07-14T13:02:21Z", "message": "share parsing code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67cc50dadaf4f062ee85809111afd7e332db6598", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/67cc50dadaf4f062ee85809111afd7e332db6598", "committedDate": "2020-07-14T13:47:50Z", "message": "make test work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b69696a352692ae5eedf770a47db33b6c2aa363", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/0b69696a352692ae5eedf770a47db33b6c2aa363", "committedDate": "2020-07-14T13:58:16Z", "message": "iter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MTgzMzE1", "url": "https://github.com/elastic/elasticsearch/pull/59391#pullrequestreview-448183315", "createdAt": "2020-07-14T14:51:31Z", "commit": {"oid": "0b69696a352692ae5eedf770a47db33b6c2aa363"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4520, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}