{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MjY0Mzk1", "number": 52432, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoyNDo1MVrODgyPkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo1NDoyOFrODg7JrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzA0MjA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoyNDo1MVrOFrLfNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTozMToyOFrOFuCrgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTMwMw==", "bodyText": "I'm assuming this is intentional and will be uncommented out later?", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r380821303", "createdAt": "2020-02-18T17:24:51Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "diffHunk": "@@ -19,6 +26,60 @@ PhysicalPlan fold(PhysicalPlan plan) {\n \n     @Override\n     protected Iterable<RuleExecutor<PhysicalPlan>.Batch> batches() {\n+        Batch fold = new Batch(\"Fold queries\",\n+                new FoldFilter()\n+        );\n+        Batch finish = new Batch(\"Finish query\", Limiter.ONCE,\n+                new PlanOutputToQueryRef()\n+        );\n+        \n+        //return Arrays.asList(fold, finish);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyMjcyMQ==", "bodyText": "Yes.", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r383822721", "createdAt": "2020-02-25T11:31:28Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "diffHunk": "@@ -19,6 +26,60 @@ PhysicalPlan fold(PhysicalPlan plan) {\n \n     @Override\n     protected Iterable<RuleExecutor<PhysicalPlan>.Batch> batches() {\n+        Batch fold = new Batch(\"Fold queries\",\n+                new FoldFilter()\n+        );\n+        Batch finish = new Batch(\"Finish query\", Limiter.ONCE,\n+                new PlanOutputToQueryRef()\n+        );\n+        \n+        //return Arrays.asList(fold, finish);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTMwMw=="}, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODQ3MjQxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjozNDo1N1rOFrZTTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjozNDo1N1rOFrZTTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NzYyOA==", "bodyText": "nit: empty line, ocd kicks in :-)", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381047628", "createdAt": "2020-02-19T02:34:57Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/planner/QueryFolder.java", "diffHunk": "@@ -19,6 +26,60 @@ PhysicalPlan fold(PhysicalPlan plan) {\n \n     @Override\n     protected Iterable<RuleExecutor<PhysicalPlan>.Batch> batches() {\n+        Batch fold = new Batch(\"Fold queries\",\n+                new FoldFilter()\n+        );\n+        Batch finish = new Batch(\"Finish query\", Limiter.ONCE,\n+                new PlanOutputToQueryRef()\n+        );\n+        \n+        //return Arrays.asList(fold, finish);\n         return emptyList();\n     }\n-}\n+    \n+    private static class FoldFilter extends FoldingRule<FilterExec> {\n+        @Override\n+        protected PhysicalPlan rule(FilterExec plan) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODQ5NTQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo1MDoxNlrOFrZhWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo1MDoxNlrOFrZhWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MTIyNA==", "bodyText": "assuming fullFieldName is going to be used when topHitFieldRef impl is complete", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381051224", "createdAt": "2020-02-19T02:50:16Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODQ5ODM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo1MjoyMFrOFrZjOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNzo1NFrOFuHu9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MTcwNA==", "bodyText": "do we care about the rest of members of QueryContainer for hashCode and equals?", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381051704", "createdAt": "2020-02-19T02:52:20Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());\n+            rootField = rootField.parent();\n+        }\n+\n+        throw new UnsupportedOperationException(\"Extraction pending\");\n+    }\n+\n+    public QueryContainer addColumn(FieldExtraction ref, String id) {\n+        return new QueryContainer(query, combine(fields, new Tuple<>(ref, id)), attributes, trackHits, includeFrozen);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(query);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        QueryContainer other = (QueryContainer) obj;\n+        return Objects.equals(query, other.query);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNTUyNw==", "bodyText": "Fixed", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r383905527", "createdAt": "2020-02-25T14:17:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());\n+            rootField = rootField.parent();\n+        }\n+\n+        throw new UnsupportedOperationException(\"Extraction pending\");\n+    }\n+\n+    public QueryContainer addColumn(FieldExtraction ref, String id) {\n+        return new QueryContainer(query, combine(fields, new Tuple<>(ref, id)), attributes, trackHits, includeFrozen);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(query);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        QueryContainer other = (QueryContainer) obj;\n+        return Objects.equals(query, other.query);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MTcwNA=="}, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODUwMTU3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo1NDoyOFrOFrZlPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMjo1NDoyOFrOFrZlPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA1MjIyMw==", "bodyText": "maybe something derived from RuntimeException? or is it fine for a draft for now?", "url": "https://github.com/elastic/elasticsearch/pull/52432#discussion_r381052223", "createdAt": "2020-02-19T02:54:28Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/querydsl/container/QueryContainer.java", "diffHunk": "@@ -5,9 +5,164 @@\n  */\n package org.elasticsearch.xpack.eql.querydsl.container;\n \n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.eql.execution.search.SourceGenerator;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.execution.search.FieldExtraction;\n+import org.elasticsearch.xpack.ql.expression.Attribute;\n+import org.elasticsearch.xpack.ql.expression.AttributeMap;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.FieldAttribute;\n+import org.elasticsearch.xpack.ql.querydsl.query.Query;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.emptyList;\n+import static org.elasticsearch.xpack.ql.util.CollectionUtils.combine;\n+\n public class QueryContainer {\n \n+    private final Query query;\n+    // attributes found in the tree\n+    private final AttributeMap<Expression> attributes;\n+    // list of fields available in the output\n+    private final List<Tuple<FieldExtraction, String>> fields;\n+\n+    private final boolean trackHits;\n+    private final boolean includeFrozen;\n+\n+    public QueryContainer() {\n+        this(null, emptyList(), AttributeMap.emptyAttributeMap(), false, false);\n+    }\n+\n+    private QueryContainer(Query query, List<Tuple<FieldExtraction, String>> fields, AttributeMap<Expression> attributes, boolean trackHits,\n+                           boolean includeFrozen) {\n+        this.query = query;\n+        this.fields = fields;\n+        this.attributes = attributes;\n+        this.trackHits = trackHits;\n+        this.includeFrozen = includeFrozen;\n+    }\n+\n     public QueryContainer withFrozen() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+    public Query query() {\n+        return query;\n+    }\n+\n+    public List<Tuple<FieldExtraction, String>> fields() {\n+        return fields;\n+    }\n+\n+    public boolean shouldTrackHits() {\n+        return trackHits;\n+    }\n+\n+    public QueryContainer with(Query q) {\n+        return new QueryContainer(q, fields, attributes, trackHits, includeFrozen);\n+    }\n+\n+    public QueryContainer addColumn(Attribute attr) {\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+        Tuple<QueryContainer, FieldExtraction> tuple = asFieldExtraction(attr);\n+        return tuple.v1().addColumn(tuple.v2(), Expressions.id(expression));\n+    }\n+\n+    private Tuple<QueryContainer, FieldExtraction> asFieldExtraction(Attribute attr) {\n+        // resolve it Expression\n+        Expression expression = attributes.getOrDefault(attr, attr);\n+\n+        if (expression instanceof FieldAttribute) {\n+            FieldAttribute fa = (FieldAttribute) expression;\n+            if (fa.isNested()) {\n+                throw new UnsupportedOperationException(\"Nested not yet supported\");\n+            }\n+            return new Tuple<>(this, topHitFieldRef(fa));\n+        }\n+\n+        throw new QlIllegalArgumentException(\"Unknown output attribute {}\", attr);\n+    }\n+\n+    //\n+    // reference methods\n+    //\n+    private FieldExtraction topHitFieldRef(FieldAttribute fieldAttr) {\n+        FieldAttribute actualField = fieldAttr;\n+        FieldAttribute rootField = fieldAttr;\n+        StringBuilder fullFieldName = new StringBuilder(fieldAttr.field().getName());\n+        \n+        // Only if the field is not an alias (in which case it will be taken out from docvalue_fields if it's isAggregatable()),\n+        // go up the tree of parents until a non-object (and non-nested) type of field is found and use that specific parent\n+        // as the field to extract data from, from _source. We do it like this because sub-fields are not in the _source, only\n+        // the root field to which those sub-fields belong to, are. Instead of \"text_field.keyword_subfield\" for _source extraction,\n+        // we use \"text_field\", because there is no source for \"keyword_subfield\".\n+        /*\n+         *    \"text_field\": {\n+         *       \"type\": \"text\",\n+         *       \"fields\": {\n+         *         \"keyword_subfield\": {\n+         *           \"type\": \"keyword\"\n+         *         }\n+         *       }\n+         *     }\n+         */\n+        if (fieldAttr.field().isAlias() == false) {\n+            while (actualField.parent() != null\n+                    && actualField.parent().field().getDataType() != DataTypes.OBJECT\n+                    && actualField.parent().field().getDataType() != DataTypes.NESTED\n+                    && actualField.field().getDataType().hasDocValues() == false) {\n+                actualField = actualField.parent();\n+            }\n+        }\n+        while (rootField.parent() != null) {\n+            fullFieldName.insert(0, \".\").insert(0, rootField.parent().field().getName());\n+            rootField = rootField.parent();\n+        }\n+\n+        throw new UnsupportedOperationException(\"Extraction pending\");\n+    }\n+\n+    public QueryContainer addColumn(FieldExtraction ref, String id) {\n+        return new QueryContainer(query, combine(fields, new Tuple<>(ref, id)), attributes, trackHits, includeFrozen);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(query);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        QueryContainer other = (QueryContainer) obj;\n+        return Objects.equals(query, other.query);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n+            builder.humanReadable(true).prettyPrint();\n+            SourceGenerator.sourceBuilder(this, null, null).toXContent(builder, ToXContent.EMPTY_PARAMS);\n+            return Strings.toString(builder);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"error rendering\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e994203ba9aa346f11413e773caaa252a71ffbb"}, "originalPosition": 162}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3934, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}