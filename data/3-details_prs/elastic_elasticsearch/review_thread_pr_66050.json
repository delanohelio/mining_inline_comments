{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NjA5Mjc2", "number": 66050, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToxMzowNVrOFCjOdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToxMzowNVrOFCjOdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjE4NjEyOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/doc/java/org/elasticsearch/painless/ContextGeneratorCommon.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToxMzowNVrOIBx2Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToxMzowNVrOIBx2Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjE2Ng==", "bodyText": "TODO remove TODO", "url": "https://github.com/elastic/elasticsearch/pull/66050#discussion_r538736166", "createdAt": "2020-12-08T19:13:05Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/doc/java/org/elasticsearch/painless/ContextGeneratorCommon.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless;\n+\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.painless.action.PainlessContextClassBindingInfo;\n+import org.elasticsearch.painless.action.PainlessContextClassInfo;\n+import org.elasticsearch.painless.action.PainlessContextInfo;\n+import org.elasticsearch.painless.action.PainlessContextInstanceBindingInfo;\n+import org.elasticsearch.painless.action.PainlessContextMethodInfo;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+public class ContextGeneratorCommon {\n+    @SuppressForbidden(reason = \"retrieving data from an internal API not exposed as part of the REST client\")\n+    public static List<PainlessContextInfo> getContextInfos() throws IOException {\n+        URLConnection getContextNames = new URL(\n+            \"http://\" + System.getProperty(\"cluster.uri\") + \"/_scripts/painless/_context\").openConnection();\n+        XContentParser parser = JsonXContent.jsonXContent.createParser(null, null, getContextNames.getInputStream());\n+        parser.nextToken();\n+        parser.nextToken();\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> contextNames = (List<String>)(Object)parser.list();\n+        parser.close();\n+        ((HttpURLConnection)getContextNames).disconnect();\n+\n+        List<PainlessContextInfo> contextInfos = new ArrayList<>();\n+\n+        for (String contextName : contextNames) {\n+            URLConnection getContextInfo = new URL(\n+                \"http://\" + System.getProperty(\"cluster.uri\") + \"/_scripts/painless/_context?context=\" + contextName).openConnection();\n+            parser = JsonXContent.jsonXContent.createParser(null, null, getContextInfo.getInputStream());\n+            contextInfos.add(PainlessContextInfo.fromXContent(parser));\n+            ((HttpURLConnection)getContextInfo).disconnect();\n+        }\n+\n+        contextInfos.sort(Comparator.comparing(PainlessContextInfo::getName));\n+\n+        return contextInfos;\n+    }\n+\n+    public static String getType(Map<String, String> javaNamesToDisplayNames, String javaType) {\n+        int arrayDimensions = 0;\n+\n+        while (javaType.charAt(arrayDimensions) == '[') {\n+            ++arrayDimensions;\n+        }\n+\n+        if (arrayDimensions > 0) {\n+            if (javaType.charAt(javaType.length() - 1) == ';') {\n+                javaType = javaType.substring(arrayDimensions + 1, javaType.length() - 1);\n+            } else {\n+                javaType = javaType.substring(arrayDimensions);\n+            }\n+        }\n+\n+        if (\"Z\".equals(javaType) || \"boolean\".equals(javaType)) {\n+            javaType = \"boolean\";\n+        } else if (\"V\".equals(javaType) || \"void\".equals(javaType)) {\n+            javaType = \"void\";\n+        } else if (\"B\".equals(javaType) || \"byte\".equals(javaType)) {\n+            javaType = \"byte\";\n+        } else if (\"S\".equals(javaType) || \"short\".equals(javaType)) {\n+            javaType = \"short\";\n+        } else if (\"C\".equals(javaType) || \"char\".equals(javaType)) {\n+            javaType = \"char\";\n+        } else if (\"I\".equals(javaType) || \"int\".equals(javaType)) {\n+            javaType = \"int\";\n+        } else if (\"J\".equals(javaType) || \"long\".equals(javaType)) {\n+            javaType = \"long\";\n+        } else if (\"F\".equals(javaType) || \"float\".equals(javaType)) {\n+            javaType = \"float\";\n+        } else if (\"D\".equals(javaType) || \"double\".equals(javaType)) {\n+            javaType = \"double\";\n+        } else if (\"org.elasticsearch.painless.lookup.def\".equals(javaType)) {\n+            javaType = \"def\";\n+        } else {\n+            javaType = javaNamesToDisplayNames.get(javaType);\n+        }\n+\n+        while (arrayDimensions-- > 0) {\n+            javaType += \"[]\";\n+        }\n+\n+        return javaType;\n+    }\n+\n+    private static Map<String, String> getDisplayNames(Collection<PainlessContextInfo> contextInfos) {\n+        Map<String, String> javaNamesToDisplayNames = new HashMap<>();\n+\n+        for (PainlessContextInfo contextInfo : contextInfos) {\n+            for (PainlessContextClassInfo classInfo : contextInfo.getClasses()) {\n+                String className = classInfo.getName();\n+                if (javaNamesToDisplayNames.containsKey(className) == false) {\n+                    if (classInfo.isImported()) {\n+                        javaNamesToDisplayNames.put(className,\n+                            className.substring(className.lastIndexOf('.') + 1).replace('$', '.'));\n+                    } else {\n+                        javaNamesToDisplayNames.put(className, className.replace('$', '.'));\n+                    }\n+                }\n+            }\n+        }\n+        return javaNamesToDisplayNames;\n+    }\n+\n+    public static List<PainlessContextClassInfo> sortClassInfos(Collection<PainlessContextClassInfo> unsortedClassInfos) {\n+\n+        List<PainlessContextClassInfo> classInfos = new ArrayList<>(unsortedClassInfos);\n+        classInfos.removeIf(v ->\n+            \"void\".equals(v.getName())  || \"boolean\".equals(v.getName()) || \"byte\".equals(v.getName())   ||\n+                \"short\".equals(v.getName()) || \"char\".equals(v.getName())    || \"int\".equals(v.getName())    ||\n+                \"long\".equals(v.getName())  || \"float\".equals(v.getName())   || \"double\".equals(v.getName()) ||\n+                \"org.elasticsearch.painless.lookup.def\".equals(v.getName())  ||\n+                isInternalClass(v.getName())\n+        );\n+\n+        classInfos.sort((c1, c2) -> {\n+            String n1 = c1.getName();\n+            String n2 = c2.getName();\n+            boolean i1 = c1.isImported();\n+            boolean i2 = c2.isImported();\n+\n+            String p1 = n1.substring(0, n1.lastIndexOf('.'));\n+            String p2 = n2.substring(0, n2.lastIndexOf('.'));\n+\n+            int compare = p1.compareTo(p2);\n+\n+            if (compare == 0) {\n+                if (i1 && i2) {\n+                    compare = n1.substring(n1.lastIndexOf('.') + 1).compareTo(n2.substring(n2.lastIndexOf('.') + 1));\n+                } else if (i1 == false && i2 == false) {\n+                    compare = n1.compareTo(n2);\n+                } else {\n+                    compare = Boolean.compare(i1, i2) * -1;\n+                }\n+            }\n+\n+            return compare;\n+        });\n+\n+        // TODO(stu): unmodifiable list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "240dde7586164dc3bb4f9d56b5d5ded7bec839cb"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4692, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}