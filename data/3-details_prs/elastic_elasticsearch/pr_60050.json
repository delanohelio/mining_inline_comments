{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MTY4ODk0", "number": 60050, "title": "Introduce 64-bit unsigned long field type", "bodyText": "This field type supports\n\nindexing of integer values from [0, 18446744073709551615]\nprecise queries (term, range)\nprecise sorting and terms aggs.\nother aggs are based on double values.\n\nSort values, term aggs keys, script values, doc values fields,\nsource fields return long (for values <=2^63-1)\nand BigInteger (for values > 2^63-1).\nCloses #32434", "createdAt": "2020-07-22T14:50:41Z", "url": "https://github.com/elastic/elasticsearch/pull/60050", "merged": true, "mergeCommit": {"oid": "ff55296f7ad39d7fbfa919f8f8233c58bd6d8620"}, "closed": true, "closedAt": "2020-09-23T16:06:22Z", "author": {"login": "mayya-sharipova"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3cRbtAFqTQ1MzQxMzAxNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLuEbGAH2gAyNDU1MTY4ODk0OmNjYTZiMzBlMWQ0NzI5NTQ5N2ZjMWEzNGQyY2E5NDg4MWE2MjMxN2Q=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNDEzMDE1", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-453413015", "createdAt": "2020-07-22T15:08:18Z", "commit": {"oid": "f691a7bbdff713600d8425dd5305f07e7b4810ef"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f691a7bbdff713600d8425dd5305f07e7b4810ef", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/f691a7bbdff713600d8425dd5305f07e7b4810ef", "committedDate": "2020-07-22T14:41:06Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}, "afterCommit": {"oid": "8861d6d9645311bbd2388c90dafa4ecb48fbceeb", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/8861d6d9645311bbd2388c90dafa4ecb48fbceeb", "committedDate": "2020-07-22T19:28:26Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8861d6d9645311bbd2388c90dafa4ecb48fbceeb", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/8861d6d9645311bbd2388c90dafa4ecb48fbceeb", "committedDate": "2020-07-22T19:28:26Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}, "afterCommit": {"oid": "c276ffdcb301251979c8ee467464802019ce1683", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/c276ffdcb301251979c8ee467464802019ce1683", "committedDate": "2020-07-22T20:08:38Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/dffd748747fabf2be412e878db904db907caa6e1", "committedDate": "2020-07-22T20:54:17Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c276ffdcb301251979c8ee467464802019ce1683", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/c276ffdcb301251979c8ee467464802019ce1683", "committedDate": "2020-07-22T20:08:38Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}, "afterCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/dffd748747fabf2be412e878db904db907caa6e1", "committedDate": "2020-07-22T20:54:17Z", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MDEwMTk0", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-454010194", "createdAt": "2020-07-23T10:32:48Z", "commit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMjo0OFrOG2E6lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0ODo1OFrOG2FYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NjgyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Accepts `true` (default) and `false`. Not applicable for unsigned_long.\n          \n          \n            \n                Accepts `true` (default) and `false`. Not applicable for `unsigned_long`.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459356823", "createdAt": "2020-07-23T10:32:48Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/numeric.asciidoc", "diffHunk": "@@ -115,7 +116,7 @@ The following parameters are accepted by numeric types:\n <<coerce,`coerce`>>::\n \n     Try to convert strings to numbers and truncate fractions for integers.\n-    Accepts `true` (default) and `false`.\n+    Accepts `true` (default) and `false`. Not applicable for unsigned_long.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NzAwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At index-time, an indexed value is converted to the singed long range:\n          \n          \n            \n            At index-time, an indexed value is converted to the signed long range:", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459357003", "createdAt": "2020-07-23T10:33:17Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).\n+\n+At index-time, an indexed value is converted to the singed long range:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NzE2Mw==", "bodyText": "I'm unsure whether this implementation detail is worth sharing.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459357163", "createdAt": "2020-07-23T10:33:33Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).\n+\n+At index-time, an indexed value is converted to the singed long range:\n+[- 9223372036854775808, 9223372036854775807] by subtracting +2^63^+ from it\n+and stored as a singed long taking 8 bytes.\n+At query-time, the same conversion is done on query terms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NzcwNA==", "bodyText": "In Elasticsearch range queries with the from/to notation, the \"to\" bound is exclusive, while I think it's inclusive in your example here. Maybe be explicit by saying \"to XYZ included\" ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459357704", "createdAt": "2020-07-23T10:34:41Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1ODQxMA==", "bodyText": "Clarify what happens in that case?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459358410", "createdAt": "2020-07-23T10:36:16Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).\n+\n+At index-time, an indexed value is converted to the singed long range:\n+[- 9223372036854775808, 9223372036854775807] by subtracting +2^63^+ from it\n+and stored as a singed long taking 8 bytes.\n+At query-time, the same conversion is done on query terms.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range queries can contain ranges with decimal parts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1OTE1Nw==", "bodyText": "do we really need to have support for unsigned longs at such a low level, or could we implement parsing of unsigned longs in the field mapper directly?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459359157", "createdAt": "2020-07-23T10:37:48Z", "author": {"login": "jpountz"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java", "diffHunk": "@@ -166,6 +167,26 @@ public long doLongValue() throws IOException {\n         return parser.getLongValue();\n     }\n \n+    @Override\n+    protected long doUnsignedLongValue() throws IOException {\n+        JsonParser.NumberType numberType = parser.getNumberType();\n+        if ((numberType == JsonParser.NumberType.INT) || (numberType == JsonParser.NumberType.LONG)) {\n+            long longValue = parser.getLongValue();\n+            if (longValue < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + longValue + \"] is out of range for unsigned long.\");\n+            }\n+            return longValue;\n+        } else if (numberType == JsonParser.NumberType.BIG_INTEGER) {\n+            BigInteger bigIntegerValue = parser.getBigIntegerValue();\n+            if (bigIntegerValue.compareTo(BIGINTEGER_MAX_UNSIGNED_LONG_VALUE) > 0 || bigIntegerValue.compareTo(BigInteger.ZERO) < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + bigIntegerValue + \"] is out of range for unsigned long\");\n+            }\n+            return bigIntegerValue.longValue();\n+        } else { // for all other value types including numbers with decimal parts\n+            throw new IllegalArgumentException(\"For input string: [\" + parser.getValueAsString() + \"].\");\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NDM3OQ==", "bodyText": "without context I'd guess that this is doing a cast, maybe make the method name more explicit, e.g. unsignedToSortableSignedLong", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459364379", "createdAt": "2020-07-23T10:48:58Z", "author": {"login": "jpountz"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {\n+\n+        public UnsignedLongFieldType(String name, boolean indexed, boolean hasDocValues, Map<String, String> meta) {\n+            super(name, indexed, hasDocValues, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+        }\n+\n+        public UnsignedLongFieldType(String name) {\n+            this(name, true, true, Collections.emptyMap());\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            failIfNotIndexed();\n+            Long longValue = parseTerm(value);\n+            if (longValue == null) {\n+                return new MatchNoDocsQuery();\n+            }\n+            Query query = LongPoint.newExactQuery(name(), convertToSignedLong(longValue));\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public Query termsQuery(List<?> values, QueryShardContext context) {\n+            failIfNotIndexed();\n+            long[] lvalues = new long[values.size()];\n+            int upTo = 0;\n+            for (int i = 0; i < values.size(); i++) {\n+                Object value = values.get(i);\n+                Long longValue = parseTerm(value);\n+                if (longValue != null) {\n+                    lvalues[upTo++] = convertToSignedLong(longValue);\n+                }\n+            }\n+            if (upTo == 0) {\n+                return new MatchNoDocsQuery();\n+            }\n+            if (upTo != lvalues.length) {\n+                lvalues = Arrays.copyOf(lvalues, upTo);\n+            }\n+            Query query = LongPoint.newSetQuery(name(), lvalues);\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n+            failIfNotIndexed();\n+            long l = Long.MIN_VALUE;\n+            long u = Long.MAX_VALUE;\n+            if (lowerTerm != null) {\n+                Long lt = parseLowerRangeTerm(lowerTerm, includeLower);\n+                if (lt == null) return new MatchNoDocsQuery();\n+                l = convertToSignedLong(lt);\n+            }\n+            if (upperTerm != null) {\n+                Long ut = parseUpperRangeTerm(upperTerm, includeUpper);\n+                if (ut == null) return new MatchNoDocsQuery();\n+                u = convertToSignedLong(ut);\n+            }\n+            if (l > u) return new MatchNoDocsQuery();\n+\n+            Query query = LongPoint.newRangeQuery(name(), l, u);\n+            if (hasDocValues()) {\n+                Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(name(), l, u);\n+                query = new IndexOrDocValuesQuery(query, dvQuery);\n+                if (context.indexSortedOnField(name())) {\n+                    query = new IndexSortSortedNumericDocValuesRangeQuery(name(), l, u, query);\n+                }\n+            }\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return (cache, breakerService, mapperService) -> {\n+                final IndexNumericFieldData signedLongValues = new SortedNumericIndexFieldData.Builder(\n+                    name(),\n+                    IndexNumericFieldData.NumericType.LONG\n+                ).build(cache, breakerService, mapperService);\n+                return new UnsignedLongIndexFieldData(signedLongValues);\n+            };\n+        }\n+\n+        @Override\n+        public Object valueForDisplay(Object value) {\n+            if (value == null) {\n+                return null;\n+            }\n+            return convertToOriginal(((Number) value).longValue());\n+        }\n+\n+        @Override\n+        public DocValueFormat docValueFormat(String format, ZoneId timeZone) {\n+            if (timeZone != null) {\n+                throw new IllegalArgumentException(\n+                    \"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support custom time zones\"\n+                );\n+            }\n+            if (format == null) {\n+                return DocValueFormat.RAW;\n+            } else {\n+                return new DocValueFormat.Decimal(format);\n+            }\n+        }\n+\n+        @Override\n+        public Function<byte[], Number> pointReaderIfPossible() {\n+            if (isSearchable()) {\n+                return (value) -> LongPoint.decodeDimension(value, 0);\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Parses value to unsigned long for Term Query\n+         * @param value to to parse\n+         * @return parsed value, if a value represents an unsigned long in the range [0, 18446744073709551615]\n+         *         null, if a value represents some other number\n+         *         throws an exception if a value is wrongly formatted number\n+         */\n+        protected static Long parseTerm(Object value) {\n+            if (value instanceof Number) {\n+                if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                    long lv = ((Number) value).longValue();\n+                    if (lv >= 0) {\n+                        return lv;\n+                    }\n+                } else if (value instanceof BigInteger) {\n+                    BigInteger bigIntegerValue = (BigInteger) value;\n+                    if (bigIntegerValue.compareTo(BigInteger.ZERO) >= 0 && bigIntegerValue.compareTo(BIGINTEGER_2_64_MINUS_ONE) <= 0) {\n+                        return bigIntegerValue.longValue();\n+                    }\n+                }\n+            } else {\n+                String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+                try {\n+                    return Long.parseUnsignedLong(stringValue);\n+                } catch (NumberFormatException e) {\n+                    // try again in case a number was negative or contained decimal\n+                    Double.parseDouble(stringValue); // throws an exception if it is an improper number\n+                }\n+            }\n+            return null; // any other number: decimal or beyond the range of unsigned long\n+        }\n+\n+        /**\n+         * Parses a lower term for a range query\n+         * @param value to parse\n+         * @param include whether a value should be included\n+         * @return parsed value to long considering include parameter\n+         *      0, if value is less than 0\n+         *      a value truncated to long, if value is in range [0, 18446744073709551615]\n+         *      null, if value is higher than the maximum allowed value for unsigned long\n+         *      throws an exception is value represents wrongly formatted number\n+         */\n+        protected static Long parseLowerRangeTerm(Object value, boolean include) {\n+            if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                long longValue = ((Number) value).longValue();\n+                if (longValue < 0) return 0L; // limit lowerTerm to min value for unsigned long: 0\n+                if (include == false) { // start from the next value\n+                    // for unsigned long, the next value for Long.MAX_VALUE is -9223372036854775808L\n+                    longValue = longValue == Long.MAX_VALUE ? Long.MIN_VALUE : ++longValue;\n+                }\n+                return longValue;\n+            }\n+            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+            final BigDecimal bigDecimalValue = new BigDecimal(stringValue);  // throws an exception if it is an improper number\n+            if (bigDecimalValue.compareTo(BigDecimal.ZERO) <= 0) {\n+                return 0L; // for values <=0, set lowerTerm to 0\n+            }\n+            int c = bigDecimalValue.compareTo(BIGDECIMAL_2_64_MINUS_ONE);\n+            if (c > 0 || (c == 0 && include == false)) {\n+                return null; // lowerTerm is beyond maximum value\n+            }\n+            long longValue = bigDecimalValue.longValue();\n+            boolean hasDecimal = (bigDecimalValue.scale() > 0 && bigDecimalValue.stripTrailingZeros().scale() > 0);\n+            if (include == false || hasDecimal) {\n+                ++longValue;\n+            }\n+            return longValue;\n+        }\n+\n+        /**\n+         * Parses an upper term for a range query\n+         * @param value to parse\n+         * @param include whether a value should be included\n+         * @return parsed value to long considering include parameter\n+         *      null, if value is less that 0, as value is lower than the minimum allowed value for unsigned long\n+         *      a value truncated to long if value is in range [0, 18446744073709551615]\n+         *      -1 (unsigned long of 18446744073709551615) for values greater than 18446744073709551615\n+         *      throws an exception is value represents wrongly formatted number\n+         */\n+        protected static Long parseUpperRangeTerm(Object value, boolean include) {\n+            if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                long longValue = ((Number) value).longValue();\n+                if ((longValue < 0) || (longValue == 0 && include == false)) return null; // upperTerm is below minimum\n+                longValue = include ? longValue : --longValue;\n+                return longValue;\n+            }\n+            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+            final BigDecimal bigDecimalValue = new BigDecimal(stringValue);  // throws an exception if it is an improper number\n+            int c = bigDecimalValue.compareTo(BigDecimal.ZERO);\n+            if (c < 0 || (c == 0 && include == false)) {\n+                return null; // upperTerm is below minimum\n+            }\n+            if (bigDecimalValue.compareTo(BIGDECIMAL_2_64_MINUS_ONE) > 0) {\n+                return -1L; // limit upperTerm to max value for unsigned long: 18446744073709551615\n+            }\n+            long longValue = bigDecimalValue.longValue();\n+            boolean hasDecimal = (bigDecimalValue.scale() > 0 && bigDecimalValue.stripTrailingZeros().scale() > 0);\n+            if (include == false && hasDecimal == false) {\n+                --longValue;\n+            }\n+            return longValue;\n+        }\n+    }\n+\n+    private Explicit<Boolean> ignoreMalformed;\n+    private final String nullValue;\n+    private final Long nullValueNumeric;\n+\n+    private UnsignedLongFieldMapper(\n+        String simpleName,\n+        FieldType fieldType,\n+        UnsignedLongFieldType mappedFieldType,\n+        Explicit<Boolean> ignoreMalformed,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        String nullValue\n+    ) {\n+        super(simpleName, fieldType, mappedFieldType, multiFields, copyTo);\n+        this.nullValue = nullValue;\n+        this.nullValueNumeric = nullValue == null ? null : convertToSignedLong(parseUnsignedLong(nullValue));\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    public UnsignedLongFieldType fieldType() {\n+        return (UnsignedLongFieldType) super.fieldType();\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected UnsignedLongFieldMapper clone() {\n+        return (UnsignedLongFieldMapper) super.clone();\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+        XContentParser parser = context.parser();\n+        Long numericValue;\n+        if (context.externalValueSet()) {\n+            numericValue = parseUnsignedLong(context.externalValue());\n+        } else if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {\n+            numericValue = null;\n+        } else if (parser.currentToken() == XContentParser.Token.VALUE_STRING && parser.textLength() == 0) {\n+            numericValue = null;\n+        } else {\n+            try {\n+                numericValue = parser.unsignedLongValue();\n+            } catch (InputCoercionException | IllegalArgumentException | JsonParseException e) {\n+                if (ignoreMalformed.value() && parser.currentToken().isValue()) {\n+                    context.addIgnoredField(mappedFieldType.name());\n+                    return;\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        }\n+        if (numericValue == null) {\n+            numericValue = nullValueNumeric;\n+            if (numericValue == null) return;\n+        } else {\n+            numericValue = convertToSignedLong(numericValue);\n+        }\n+\n+        boolean docValued = fieldType().hasDocValues();\n+        boolean indexed = fieldType().isSearchable();\n+        boolean stored = fieldType.stored();\n+\n+        List<Field> fields = NumberFieldMapper.NumberType.LONG.createFields(fieldType().name(), numericValue, indexed, docValued, stored);\n+        context.doc().addAll(fields);\n+        if (docValued == false && (indexed || stored)) {\n+            createFieldNamesField(context);\n+        }\n+    }\n+\n+    @Override\n+    protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        UnsignedLongFieldMapper mergeWith = (UnsignedLongFieldMapper) other;\n+        if (mergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = mergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+\n+        if (includeDefaults || ignoreMalformed.explicit()) {\n+            builder.field(\"ignore_malformed\", ignoreMalformed.value());\n+        }\n+        if (nullValue != null) {\n+            builder.field(\"null_value\", nullValue);\n+        }\n+    }\n+\n+    /**\n+     * Parse object to unsigned long\n+     * @param value must represent an unsigned long in rage [0;18446744073709551615] or an exception will be thrown\n+     */\n+    private static long parseUnsignedLong(Object value) {\n+        if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+            long lv = ((Number) value).longValue();\n+            if (lv < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + lv + \"] is out of range for unsigned long.\");\n+            }\n+            return lv;\n+        }\n+        String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+        try {\n+            return Long.parseUnsignedLong(stringValue);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"For input string: \\\"\" + stringValue + \"\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Convert an unsigned long to the singed long by subtract 2^63 from it\n+     * @param value \u2013 unsigned long value in the range [0; 2^64-1], values greater than 2^63-1 are negative\n+     * @return signed long value in the range [-2^63; 2^63-1]\n+     */\n+    private static long convertToSignedLong(long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 502}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "678b8838912665e46c60759d49face4360b15ec3", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/678b8838912665e46c60759d49face4360b15ec3", "committedDate": "2020-08-14T22:18:59Z", "message": "WIP"}, "afterCommit": {"oid": "3b1411be89318d0f858a8d4d634724ec9be91139", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b1411be89318d0f858a8d4d634724ec9be91139", "committedDate": "2020-08-18T18:54:07Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eb2d4acd6597e07f51e9fe695bd5d195eae14d6", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/7eb2d4acd6597e07f51e9fe695bd5d195eae14d6", "committedDate": "2020-08-18T21:10:26Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612b7daa7d3fe7943636396467988ca9c79bd2f7", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/612b7daa7d3fe7943636396467988ca9c79bd2f7", "committedDate": "2020-08-18T21:11:08Z", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ada3422c7f73a22c714974c1542a4e84b3ecadee", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/ada3422c7f73a22c714974c1542a4e84b3ecadee", "committedDate": "2020-08-18T22:18:47Z", "message": "Modifications after master merge"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3b1411be89318d0f858a8d4d634724ec9be91139", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b1411be89318d0f858a8d4d634724ec9be91139", "committedDate": "2020-08-18T18:54:07Z", "message": "Address feedback"}, "afterCommit": {"oid": "ada3422c7f73a22c714974c1542a4e84b3ecadee", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/ada3422c7f73a22c714974c1542a4e84b3ecadee", "committedDate": "2020-08-18T22:18:47Z", "message": "Modifications after master merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7551cd6933e74c7e295286d7838a202146b337c6", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/7551cd6933e74c7e295286d7838a202146b337c6", "committedDate": "2020-08-19T10:21:42Z", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/e903940c82c2e9e494465f5a1e8633b1bd834d53", "committedDate": "2020-08-19T20:29:29Z", "message": "Rename methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDQxODUx", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-483441851", "createdAt": "2020-09-07T10:24:47Z", "commit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDoyNDo0N1rOHN53NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0MjoyM1rOHN6Ykg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MTU1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and must be avoided. If there is a need for a such kind of sorting, script based\n          \n          \n            \n            and must be avoided. If there is a need for such kind of sorting, script based", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484341557", "createdAt": "2020-09-07T10:24:47Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjExNQ==", "bodyText": "We handle long => double conversion in the terms aggregation so I wonder if that's true ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484342115", "createdAt": "2020-09-07T10:25:48Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based\n+sorting can be used instead.\n+Aggregations across several numeric types one of which `unsigned_long` are supported,\n+except a terms aggregation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA==", "bodyText": "These variables should be final and static ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484343114", "createdAt": "2020-09-07T10:27:50Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/DocValueFormat.java", "diffHunk": "@@ -48,6 +49,8 @@\n \n /** A formatter for values as returned by the fielddata/doc-values APIs. */\n public interface DocValueFormat extends NamedWriteable {\n+    long MASK_2_63 = 0x8000000000000000L;\n+    BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjQzOA==", "bodyText": "Can you fix the indentation of the blocks ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484346438", "createdAt": "2020-09-07T10:34:49Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "diffHunk": "@@ -826,7 +827,14 @@ public final void writeOptionalInstant(@Nullable Instant instant) throws IOExcep\n                             o.writeByte((byte) 25);\n                         }\n                         o.writeCollection((Set<?>) v, StreamOutput::writeGenericValue);\n-                    }\n+                    }),\n+            entry(\n+                // TODO: improve serialization of BigInteger\n+                BigInteger.class,\n+                (o, v) -> {\n+                    o.writeByte((byte) 26);\n+                    o.writeString(v.toString());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA==", "bodyText": "We'd need to provide the doc value format but that could be done in the ScriptDocValues.Long directly ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484350098", "createdAt": "2020-09-07T10:42:23Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjYzMzU5", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-484263359", "createdAt": "2020-09-08T15:35:13Z", "commit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTozODozMFrOHOjFKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTo1ODoyNVrOHOj5bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNjg3NQ==", "bodyText": "What would you think of including this in the top-level numeric types page instead of creating a separate page ? It seems nice to combine all numeric field types so it's easy to find and compare them. We just did this for the keyword type family.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485016875", "createdAt": "2020-09-08T15:38:30Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -9,7 +9,7 @@ document:\n === Core data types\n \n string::         <<text,`text`>>, <<keyword,`keyword`>> and <<wildcard,`wildcard`>>\n-<<number>>::     `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`\n+<<number>>::     `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`, <<unsigned-long,`unsigned_long`>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA==", "bodyText": "I didn't review this logic in detail, but I was curious if we considered having this extend NumberFieldType ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485030254", "createdAt": "2020-09-08T15:58:25Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e057c08334d30f489903b452ff7d81142541866", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/9e057c08334d30f489903b452ff7d81142541866", "committedDate": "2020-09-08T20:00:04Z", "message": "Address Jim's feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab54a23fee318cc4827c2e8446949fc01035d3ad", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab54a23fee318cc4827c2e8446949fc01035d3ad", "committedDate": "2020-09-08T20:28:04Z", "message": "Include unsigned_long docs into numeric type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4de3bd06e560d791ac7a561076f6ec195f7b9bb5", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/4de3bd06e560d791ac7a561076f6ec195f7b9bb5", "committedDate": "2020-09-08T20:36:49Z", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/2b567c961f4dc9331ef7eef25c4c9c8b271a67c8", "committedDate": "2020-09-09T20:05:57Z", "message": "Convert UnsignedLongFieldMapper to parametrized\n\n- Convert UnsignedLongFieldMapper to a parametrized form\n- Small adjustments in UnsignedLongScriptDocValues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NzEyNTI4", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-485712528", "createdAt": "2020-09-10T08:41:52Z", "commit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0MTo1M1rOHPpVUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0NDowN1rOHPpa5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2Nzg5MA==", "bodyText": "That's a bit scary to add as a warning ;). I would change {es} with something like rest clients need to handle big integer values in json to support this field type correctly or something along those lines ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486167890", "createdAt": "2020-09-10T08:41:53Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,115 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2ODU5Mw==", "bodyText": "I'd say produce a Number that represents a long or a BigInteger...", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486168593", "createdAt": "2020-09-10T08:42:58Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,115 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2OTMxOA==", "bodyText": "++, thanks", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486169318", "createdAt": "2020-09-10T08:44:07Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based\n+sorting can be used instead.\n+Aggregations across several numeric types one of which `unsigned_long` are supported,\n+except a terms aggregation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjExNQ=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NzE1Mjcx", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-485715271", "createdAt": "2020-09-10T08:45:13Z", "commit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/07470b5006ed3aac8a635a2953424f635ccd46c0", "committedDate": "2020-09-10T13:55:18Z", "message": "Small edits in documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTk2NjU5", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-487996659", "createdAt": "2020-09-14T17:32:52Z", "commit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzozMjo1M1rOHRfoaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzo0MjowMlrOHRf7jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjA4OA==", "bodyText": "Small comment, we could say 'Searches with mixed numeric types' to be more precise (since this section mentions aggs too).", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r488106088", "createdAt": "2020-09-14T17:32:53Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+return a number representing a `long` or `BigInteger`.\n+The same values: `long` or `BigInteger` are used for `terms` aggregations.\n+\n+==== Queries with mixed numeric types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjI0NA==", "bodyText": "Really small comment, I think we usually capitalize REST and JSON.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r488106244", "createdAt": "2020-09-14T17:33:10Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODExMDk4OA==", "bodyText": "I think it'd be clearer to call out the Java type here: \"return a Number representing a Long or BigInteger\".", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r488110988", "createdAt": "2020-09-14T17:42:02Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17912bc0549aaa275099513383517517c02dc7f9", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/17912bc0549aaa275099513383517517c02dc7f9", "committedDate": "2020-09-16T14:25:35Z", "message": "Address Julie's comment on documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2eef4c4ca9997dddface371cfad3b1671fd438b", "committedDate": "2020-09-16T19:45:27Z", "message": "Add check that unsigned_long field type can't be sorted with other types"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c16b1e1ef43d3161a85d436ee2e47691f68a36f3", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/c16b1e1ef43d3161a85d436ee2e47691f68a36f3", "committedDate": "2020-09-16T19:36:09Z", "message": "Add check that unsigned_long field type can't be sorted with other types"}, "afterCommit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2eef4c4ca9997dddface371cfad3b1671fd438b", "committedDate": "2020-09-16T19:45:27Z", "message": "Add check that unsigned_long field type can't be sorted with other types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b315a0fa32ba32ccab8cc6dec9337811ad242569", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/b315a0fa32ba32ccab8cc6dec9337811ad242569", "committedDate": "2020-09-16T20:24:39Z", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7652e6671ce385c670231cc15292500311a8a785", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/7652e6671ce385c670231cc15292500311a8a785", "committedDate": "2020-09-16T20:48:49Z", "message": "Fix build and test failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTk1MTEx", "url": "https://github.com/elastic/elasticsearch/pull/60050#pullrequestreview-489995111", "createdAt": "2020-09-16T20:27:24Z", "commit": {"oid": "17912bc0549aaa275099513383517517c02dc7f9"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNzoyNFrOHTDBIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTo1NzowN1rOHTFo9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczNDQzMw==", "bodyText": "I was actually thinking about the heading \"Queries with mixed numeric types\" !", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489734433", "createdAt": "2020-09-16T20:27:24Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+return a number representing a `long` or `BigInteger`.\n+The same values: `long` or `BigInteger` are used for `terms` aggregations.\n+\n+==== Queries with mixed numeric types", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjA4OA=="}, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ==", "bodyText": "Checking my understanding -- are all shards guaranteed to have the same number of sort formats (even if some sort fields are unmapped)?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489754889", "createdAt": "2020-09-16T21:07:44Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n+     */\n+    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+        boolean[] ulFormats = null;\n+        boolean firstResult = true;\n+        for (SearchPhaseResult entry : queryResults) {\n+            DocValueFormat[] formats = entry.queryResult().sortValueFormats();\n+            if (formats == null) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3NzM5Nw==", "bodyText": "This TODO makes sense. It's unfortunate that we need to do a special check here, but it feels worth it to me to avoid silently returning incorrect results.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489777397", "createdAt": "2020-09-16T21:57:07Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7652e6671ce385c670231cc15292500311a8a785"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0508e700e0c57b42086e8baeae57a4fecaa32653", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/0508e700e0c57b42086e8baeae57a4fecaa32653", "committedDate": "2020-09-23T14:32:12Z", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24cbe55162a29463c22de9815187b7e48fc65844", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/24cbe55162a29463c22de9815187b7e48fc65844", "committedDate": "2020-09-23T14:37:23Z", "message": "Rename the method for validating consistency of merge formats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cca6b30e1d47295497fc1a34d2ca94881a62317d", "author": {"user": {"login": "mayya-sharipova", "name": "Mayya Sharipova"}}, "url": "https://github.com/elastic/elasticsearch/commit/cca6b30e1d47295497fc1a34d2ca94881a62317d", "committedDate": "2020-09-23T15:10:52Z", "message": "Change unsigned_long mapper based on recent master changes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4836, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}