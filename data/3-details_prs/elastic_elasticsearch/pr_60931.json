{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1Njc2ODYz", "number": 60931, "title": "Run core's integration tests with runtime fields", "bodyText": "Adds the x-pack/plugin/runtime-fields/qa/rest project to run core's\nintegration tests against an index with runtime_scipt fields. This\nworks by modifying the test configuration on load to replace supported\nfield types with runtime_script.\nRelates to #59332", "createdAt": "2020-08-10T19:05:54Z", "url": "https://github.com/elastic/elasticsearch/pull/60931", "merged": true, "mergeCommit": {"oid": "eeb4afbf672dbb1d8060eb93b205c4c2338888ca"}, "closed": true, "closedAt": "2020-08-11T16:17:49Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9nBgGAH2gAyNDY1Njc2ODYzOjQ0YWE2ZTdkMTQxZjAxNGUyNDk0NDU1YjRjZmJkOTEwNzAzZDkwZjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc95P1mgH2gAyNDY1Njc2ODYzOmFjNWUyZTFjNTI4NjBiNGI0YWQ3Y2YyZjg4NmFmYjc2NTgxN2EzMTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "44aa6e7d141f014e2494455b4cfbd910703d90f6", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/44aa6e7d141f014e2494455b4cfbd910703d90f6", "committedDate": "2020-08-10T19:03:24Z", "message": "Run core's integration tests with runtime fields\n\nAdds the `x-pack/plugin/runtime-fields/qa/rest` project to run core's\nintegration tests against an index with `runtime_scipt` fields. This\nworks by modifying the test configuration on load to replace supported\nfield types with `runtime_script`.\n\nRelates to #59332"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/fb8402f6ca5839d6118f10f3df224803ee3f8389", "committedDate": "2020-08-10T19:04:41Z", "message": "Newline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDk4NjMy", "url": "https://github.com/elastic/elasticsearch/pull/60931#pullrequestreview-464498632", "createdAt": "2020-08-10T19:07:55Z", "commit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTowNzo1NVrOG-bpNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTowNzo1NVrOG-bpNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExNzgxNA==", "bodyText": "I wrote this one so I figured I could fix it while I was here. Runtime fields don't have global ordinals so rather than skip the entire test for them I split it into two tests, one that runtime fields can run (below) and this one which runtime fields will skip.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468117814", "createdAt": "2020-08-10T19:07:55Z", "author": {"login": "nik9000"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search.aggregation/20_terms.yml", "diffHunk": "@@ -724,7 +724,7 @@ setup:\n         body: { \"size\" : 0, \"aggs\" : { \"no_field_terms\" : { \"terms\" : { \"size\": 1 } } } }\n \n ---\n-\"string profiler\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTMzOTc2", "url": "https://github.com/elastic/elasticsearch/pull/60931#pullrequestreview-464533976", "createdAt": "2020-08-10T19:55:05Z", "commit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTo1NTowNVrOG-dWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTo1NTowNVrOG-dWXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA==", "bodyText": "This is quite the list of exclusions. Seems a bit brittle. One issue I anticipate is future newly added tests also being incompatible with this approach for one reason or another.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468145758", "createdAt": "2020-08-10T19:55:05Z", "author": {"login": "mark-vieira"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTUxMzcw", "url": "https://github.com/elastic/elasticsearch/pull/60931#pullrequestreview-464551370", "createdAt": "2020-08-10T20:11:17Z", "commit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDoxMToxN1rOG-d1jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDoxMToxN1rOG-d1jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1Mzc0Mg==", "bodyText": "We should replace all of this with the elasticsearch.yaml-rest-test plugin. Additionally the test suite should move from src/test to src/yamlRestTest to comply with new conventions.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468153742", "createdAt": "2020-08-10T20:11:17Z", "author": {"login": "mark-vieira"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/b392332ced3a2f896b962453b45600c397ef7602", "committedDate": "2020-08-10T20:18:06Z", "message": "New way"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTc0ODcy", "url": "https://github.com/elastic/elasticsearch/pull/60931#pullrequestreview-464574872", "createdAt": "2020-08-10T20:45:17Z", "commit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDo0NToxN1rOG-fKgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMToyMDoxMFrOG-gMjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3NTQ4OA==", "bodyText": "I like the idea of a skip property -- that way the 'skip reason' is discoverable and right next to the test itself.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468175488", "createdAt": "2020-08-10T20:45:17Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTEyMw==", "bodyText": "Is there ever a time when the rest of the Object array is relevant (beyond the first element)? Maybe we could replace orig[0] and still return orig, or simply assert orig.length == 1 ?", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468179123", "createdAt": "2020-08-10T20:52:37Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mjg2OA==", "bodyText": "I find the formatting hard to follow, does it work to just do return settings.containsKey(\"sort.field\"); ? Also maybe we could use the phrase 'index sort' to clarify what this setting refers to.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468182868", "createdAt": "2020-08-10T20:59:59Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng==", "bodyText": "This seems like the best approach for now but feels a bit fragile -- we're essentially duplicating the source parsing logic, which can be pretty nuanced. For example, for boolean fields, the value \"\" is interpreted as false. We also don't cover cases where the value is malformed or missing from _source.\nTo make this more robust, I guess we could switch to 'source-only fields' when those are available?  That way we could reuse the logic from fields retrieval for parsing values from source. Or we could consider adding a way to access nicely-formatted source fields from painless?", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468192396", "createdAt": "2020-08-10T21:20:10Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return\n+        /*\n+         * You can't sort on a runtime_keyword and it is hard to figure out\n+         * if the sort was a runtime_keyword so lets just skip this test.\n+         */\n+        settings.containsKey(\"sort.field\");\n+    }\n+\n+    private static String painlessToLoadFromSource(String name, String type) {\n+        String emit = PAINLESS_TO_EMIT.get(type);\n+        if (emit == null) {\n+            return null;\n+        }\n+        StringBuilder b = new StringBuilder();\n+        b.append(\"def v = source['\").append(name).append(\"'];\\n\");\n+        b.append(\"if (v instanceof Iterable) {\\n\");\n+        b.append(\"  for (def vv : ((Iterable) v)) {\\n\");\n+        b.append(\"    if (vv != null) {\\n\");\n+        b.append(\"      def value = vv;\\n\");\n+        b.append(\"      \").append(emit).append(\"\\n\");\n+        b.append(\"    }\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"} else {\\n\");\n+        b.append(\"  if (v != null) {\\n\");\n+        b.append(\"    def value = v;\\n\");\n+        b.append(\"    \").append(emit).append(\"\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"}\\n\");\n+        return b.toString();\n+    }\n+\n+    private static final Map<String, String> PAINLESS_TO_EMIT = Map.ofEntries(\n+        // TODO implement dates against the parser\n+        Map.entry(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac330ec82f95b716987d6ca7488fec962af380f9", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac330ec82f95b716987d6ca7488fec962af380f9", "committedDate": "2020-08-11T13:43:20Z", "message": "Just search"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/5eccfcdbc357f72044d8724bdd7e73c9904b8b0c", "committedDate": "2020-08-11T14:06:03Z", "message": "Merge branch 'feature/runtime_fields' into runtime_fields_tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjA2OTE4", "url": "https://github.com/elastic/elasticsearch/pull/60931#pullrequestreview-465206918", "createdAt": "2020-08-11T15:56:39Z", "commit": {"oid": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1NjozOVrOG--hCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1OTozNlrOG--oiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTE2Mg==", "bodyText": "Small comment, we could say 'index sort' for clarity?", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468689162", "createdAt": "2020-08-11T15:56:39Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            assert orig.length == 1;\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && ((Map<?, ?>) settings).containsKey(\"sort.field\")) {\n+                    /*\n+                     * You can't sort on a runtime_keyword and it is hard to figure out", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MTA4MQ==", "bodyText": "That makes sense. I think this is the right way to go for this feature branch, but it'd be good to follow-up on source parsing improvements at a later point.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468691081", "createdAt": "2020-08-11T15:59:36Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return\n+        /*\n+         * You can't sort on a runtime_keyword and it is hard to figure out\n+         * if the sort was a runtime_keyword so lets just skip this test.\n+         */\n+        settings.containsKey(\"sort.field\");\n+    }\n+\n+    private static String painlessToLoadFromSource(String name, String type) {\n+        String emit = PAINLESS_TO_EMIT.get(type);\n+        if (emit == null) {\n+            return null;\n+        }\n+        StringBuilder b = new StringBuilder();\n+        b.append(\"def v = source['\").append(name).append(\"'];\\n\");\n+        b.append(\"if (v instanceof Iterable) {\\n\");\n+        b.append(\"  for (def vv : ((Iterable) v)) {\\n\");\n+        b.append(\"    if (vv != null) {\\n\");\n+        b.append(\"      def value = vv;\\n\");\n+        b.append(\"      \").append(emit).append(\"\\n\");\n+        b.append(\"    }\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"} else {\\n\");\n+        b.append(\"  if (v != null) {\\n\");\n+        b.append(\"    def value = v;\\n\");\n+        b.append(\"    \").append(emit).append(\"\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"}\\n\");\n+        return b.toString();\n+    }\n+\n+    private static final Map<String, String> PAINLESS_TO_EMIT = Map.ofEntries(\n+        // TODO implement dates against the parser\n+        Map.entry(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng=="}, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac5e2e1c52860b4b4ad7cf2f886afb765817a315", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac5e2e1c52860b4b4ad7cf2f886afb765817a315", "committedDate": "2020-08-11T16:17:21Z", "message": "Words"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3360, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}