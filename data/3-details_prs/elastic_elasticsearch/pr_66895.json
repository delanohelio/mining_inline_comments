{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ3MDI2MjM0", "number": 66895, "title": "Lower contention on requests with many aggs", "bodyText": "This lowers the contention on the REQUEST circuit breaker when building\nmany aggregations on many threads by preallocating a chunk of breaker\nup front. This cuts down on the number of times we enter the busy loop\nin ChildMemoryCircuitBreaker.limit. Now we hit it one time when building\naggregations. We still hit the busy loop if we collect many buckets.\nWe let the AggregationBuilder pick size of the \"chunk\" that we\npreallocate but it doesn't have much to go on - not even the field types.\nBut it is available in a convenient spot and the estimates don't have to\nbe particularly accurate.\nThe benchmarks on my 12 core desktop are interesting:\nBenchmark         (breaker)  Mode  Cnt    Score    Error  Units\nsum                    noop  avgt   10    1.672 \u00b1  0.042  us/op\nsum                    real  avgt   10    4.100 \u00b1  0.027  us/op\nsum             preallocate  avgt   10    4.230 \u00b1  0.034  us/op\ntermsSixtySums         noop  avgt   10   92.658 \u00b1  0.939  us/op\ntermsSixtySums         real  avgt   10  278.764 \u00b1 39.751  us/op\ntermsSixtySums  preallocate  avgt   10  120.896 \u00b1 16.097  us/op\ntermsSum               noop  avgt   10    4.573 \u00b1  0.095  us/op\ntermsSum               real  avgt   10    9.932 \u00b1  0.211  us/op\ntermsSum        preallocate  avgt   10    7.695 \u00b1  0.313  us/op\n\nThey show pretty clearly that not using the circuit breaker at all is\nfaster. But we can't do that because we don't want to bring the node\ndown on bad aggs. When there are many aggs (termsSixtySums) the\npreallocation claws back much of the performance. It even helps\nmarginally when there are two aggs (termsSum). For a single agg (sum)\nwe see a 130 nanosecond hit. Fine.\nBut these values are all pretty small. At best we're seeing a 160\nmicrosecond savings. Not so on a 160 vCPU machine:\nBenchmark         (breaker)  Mode  Cnt      Score       Error  Units\nsum                    noop  avgt   10     44.956 \u00b1     8.851  us/op\nsum                    real  avgt   10    118.008 \u00b1    19.505  us/op\nsum             preallocate  avgt   10    241.234 \u00b1   305.998  us/op\ntermsSixtySums         noop  avgt   10   1339.802 \u00b1    51.410  us/op\ntermsSixtySums         real  avgt   10  12077.671 \u00b1 12110.993  us/op\ntermsSixtySums  preallocate  avgt   10   3804.515 \u00b1  1458.702  us/op\ntermsSum               noop  avgt   10     59.478 \u00b1     2.261  us/op\ntermsSum               real  avgt   10    293.756 \u00b1   253.854  us/op\ntermsSum        preallocate  avgt   10    197.963 \u00b1    41.578  us/op\n\nAll of these numbers are larger because we're running all the CPUs\nflat out and we're seeing more contention everywhere. Even the \"noop\"\nbreaker sees some contention, but I think it is mostly around memory\nallocation. Anyway, with many many (termsSixtySums) aggs we're looking\nat 8 milliseconds of savings by preallocating. Just by dodging the busy\nloop as much as possible. The error in the measurements there are\nsubstantial. Here are the runs:\nreal:\nIteration   1: 8679.417 \u00b1(99.9%) 273.220 us/op\nIteration   2: 5849.538 \u00b1(99.9%) 179.258 us/op\nIteration   3: 5953.935 \u00b1(99.9%) 152.829 us/op\nIteration   4: 5763.465 \u00b1(99.9%) 150.759 us/op\nIteration   5: 14157.592 \u00b1(99.9%) 395.224 us/op\nIteration   1: 24857.020 \u00b1(99.9%) 1133.847 us/op\nIteration   2: 24730.903 \u00b1(99.9%) 1107.718 us/op\nIteration   3: 18894.383 \u00b1(99.9%) 738.706 us/op\nIteration   4: 5493.965 \u00b1(99.9%) 120.529 us/op\nIteration   5: 6396.493 \u00b1(99.9%) 143.630 us/op\npreallocate:\nIteration   1: 5512.590 \u00b1(99.9%) 110.222 us/op\nIteration   2: 3087.771 \u00b1(99.9%) 120.084 us/op\nIteration   3: 3544.282 \u00b1(99.9%) 110.373 us/op\nIteration   4: 3477.228 \u00b1(99.9%) 107.270 us/op\nIteration   5: 4351.820 \u00b1(99.9%) 82.946 us/op\nIteration   1: 3185.250 \u00b1(99.9%) 154.102 us/op\nIteration   2: 3058.000 \u00b1(99.9%) 143.758 us/op\nIteration   3: 3199.920 \u00b1(99.9%) 61.589 us/op\nIteration   4: 3163.735 \u00b1(99.9%) 71.291 us/op\nIteration   5: 5464.556 \u00b1(99.9%) 59.034 us/op\n\nThat variability from 5.5ms to 25ms is terrible. It makes me not\nparticularly trust the 8ms savings from the report. But still,\nthe preallocating method has much less variability between runs\nand almost all the runs are faster than all of the non-preallocated\nruns. Maybe the savings is more like 2 or 3 milliseconds, but still.\nOr maybe we should think of hte savings as worst vs worst? If so its\n19 milliseconds.\nAnyway, its hard to measure how much this helps. But, certainly some.\nCloses #58647", "createdAt": "2020-12-30T17:25:58Z", "url": "https://github.com/elastic/elasticsearch/pull/66895", "merged": true, "mergeCommit": {"oid": "de8b39e52dc8fa4e85ddc091f38bec2123c5820a"}, "closed": true, "closedAt": "2021-01-04T16:26:43Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkNkcigH2gAyNTQ3MDI2MjM0OjJjODg5MGQxOTYyNDI4MzA2OGIwZjAzOTMyNTY4ZmQwYTc5ZTBjMGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABds3sRHAH2gAyNTQ3MDI2MjM0OjkwMDI2NzQ1YzE2ODYwOGRiZGZmZDI1NDc3NmY1ZjQ5ZDJmODY2ZjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2c8890d19624283068b0f03932568fd0a79e0c0a", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c8890d19624283068b0f03932568fd0a79e0c0a", "committedDate": "2020-12-08T17:27:05Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85dacd4d2c32521704f29f6526a5de06572982c2", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/85dacd4d2c32521704f29f6526a5de06572982c2", "committedDate": "2020-12-08T17:27:05Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26d980950837547668229391291ca901294fb220", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/26d980950837547668229391291ca901294fb220", "committedDate": "2020-12-08T17:27:05Z", "message": "Sixty sums"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9166f271f0f1719ce40626bfc5e95ce71f3cad4b", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/9166f271f0f1719ce40626bfc5e95ce71f3cad4b", "committedDate": "2020-12-08T17:27:05Z", "message": "Doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46a229549b4a00b314c30f3894b1910a738d8d32", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/46a229549b4a00b314c30f3894b1910a738d8d32", "committedDate": "2020-12-08T17:27:05Z", "message": "Test preallocation pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb0ddcc18d1eac0381ec49693966516554ce5069", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/bb0ddcc18d1eac0381ec49693966516554ce5069", "committedDate": "2020-12-29T22:48:56Z", "message": "Merge branch 'master' into agg_construction_contention"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "385607d74629b3b822254449429bef4b7d130c4a", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/385607d74629b3b822254449429bef4b7d130c4a", "committedDate": "2020-12-30T13:37:01Z", "message": "Compile plz"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "795c89a068bd453e717ac67f4d5d15cca48751d2", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/795c89a068bd453e717ac67f4d5d15cca48751d2", "committedDate": "2020-12-30T15:38:55Z", "message": "Working?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff4835345d6ee3ce3e99aa22f599f9f00f974565", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/ff4835345d6ee3ce3e99aa22f599f9f00f974565", "committedDate": "2020-12-30T15:40:08Z", "message": "Drop .new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3f04a44ddfb0cdcb30c60c466b2ad11acbc88af", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/d3f04a44ddfb0cdcb30c60c466b2ad11acbc88af", "committedDate": "2020-12-30T16:13:11Z", "message": "Release properly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c8aeb513bc0b82334ba93405e9728107ea445f8", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c8aeb513bc0b82334ba93405e9728107ea445f8", "committedDate": "2020-12-30T16:21:50Z", "message": "Drop benchmark we don't need"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMTM3MjU4", "url": "https://github.com/elastic/elasticsearch/pull/66895#pullrequestreview-560137258", "createdAt": "2020-12-30T17:27:52Z", "commit": {"oid": "ff4835345d6ee3ce3e99aa22f599f9f00f974565"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNzoyNzo1MlrOIMxzNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxNzoyNzo1MlrOIMxzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI2OTc1MA==", "bodyText": "Making AggregationContext Releasable lets us free the preallocated breaker after freeing all of the aggs without adding complexity to SearchContext.", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550269750", "createdAt": "2020-12-30T17:27:52Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -63,7 +66,7 @@\n  * this is {@code abstract} so that tests can build it without creating the\n  * massing {@link QueryShardContext}.\n  */\n-public abstract class AggregationContext {\n+public abstract class AggregationContext implements Releasable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff4835345d6ee3ce3e99aa22f599f9f00f974565"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24addcf3dd8d8b11f1fc3efa71f0632fc8fd8d0c", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/24addcf3dd8d8b11f1fc3efa71f0632fc8fd8d0c", "committedDate": "2020-12-30T18:57:49Z", "message": "tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7a64a8cbaed18d45f2f55c0a347001aa5292582", "committedDate": "2020-12-30T19:11:07Z", "message": "Test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMTc5OTE0", "url": "https://github.com/elastic/elasticsearch/pull/66895#pullrequestreview-560179914", "createdAt": "2020-12-30T19:46:57Z", "commit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxOTo0Njo1N1rOIM0I_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxOTo0Njo1N1rOIM0I_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwODA5NA==", "bodyText": "this ternary shouldn't be necessary, right?", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550308094", "createdAt": "2020-12-30T19:46:57Z", "author": {"login": "DJRickyB"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -277,12 +277,25 @@ public ProductionAggregationContext(\n             Supplier<Boolean> isCancelled\n         ) {\n             this.context = context;\n-            this.breakerService = new PreallocatedCircuitBreakerService(\n-                context.bigArrays().breakerService(),\n-                CircuitBreaker.REQUEST,\n-                bytesToPreallocate\n-            );\n-            this.bigArrays = context.bigArrays().withBreakerService(breakerService).withCircuitBreaking();\n+            if (bytesToPreallocate == 0) {\n+                /*\n+                 * Its possible if a bit strange for the aggregations to ask\n+                 * to preallocate 0 bytes. Mostly this is for testing other\n+                 * things, but we should honor it and just not preallocate\n+                 * anything. Setting the breakerService reference to null will\n+                 * cause us to skip it when we close this context.\n+                 */\n+                this.breakerService = null;\n+                this.bigArrays = context.bigArrays().withCircuitBreaking();\n+            } else {\n+                this.breakerService = bytesToPreallocate == 0 ? null : new PreallocatedCircuitBreakerService(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bd4bc56c468c56b54c565113151226bf09f88b1", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/0bd4bc56c468c56b54c565113151226bf09f88b1", "committedDate": "2020-12-30T19:51:05Z", "message": "zap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMTgxODYx", "url": "https://github.com/elastic/elasticsearch/pull/66895#pullrequestreview-560181861", "createdAt": "2020-12-30T19:53:52Z", "commit": {"oid": "0bd4bc56c468c56b54c565113151226bf09f88b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMTczMTUz", "url": "https://github.com/elastic/elasticsearch/pull/66895#pullrequestreview-560173153", "createdAt": "2020-12-30T19:23:42Z", "commit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxOToyMzo0MlrOIMzwcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMDowMDo0NFrOIM0WmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwMTgxMA==", "bodyText": "Why do we change this to a null here?", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550301810", "createdAt": "2020-12-30T19:23:42Z", "author": {"login": "not-napoleon"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/action/search/TransportSearchIT.java", "diffHunk": "@@ -567,13 +572,13 @@ public Aggregator subAggregator(String name) {\n         @Override\n         public InternalAggregation[] buildAggregations(long[] owningBucketOrds) throws IOException {\n             return new InternalAggregation[] {\n-                new InternalMax(name(), Double.NaN, DocValueFormat.RAW, Collections.emptyMap())\n+                buildEmptyAggregation()\n             };\n         }\n \n         @Override\n         public InternalAggregation buildEmptyAggregation() {\n-            return new InternalMax(name(), Double.NaN, DocValueFormat.RAW, Collections.emptyMap());\n+            return new InternalMax(name(), Double.NaN, DocValueFormat.RAW, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwMjE0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Use this when you know you'll be allocating many small\n          \n          \n            \n             * Use this when you know you'll be allocating many small bits of memory.\n          \n      \n    \n    \n  \n\nor something like that.  Just a dangling sentence fragment right now.", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550302142", "createdAt": "2020-12-30T19:24:54Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/common/breaker/PreallocatedCircuitBreakerService.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.breaker;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.indices.breaker.AllCircuitBreakerStats;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerStats;\n+\n+/**\n+ * {@link CircuitBreakerService} that preallocates some bytes on construction.\n+ * Use this when you know you'll be allocating many small", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNDg0Mg==", "bodyText": "Isn't this always going to be true, since three lines previous, we checked that newUsed > preallocated?  Nothing involved is volatile, right?", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550304842", "createdAt": "2020-12-30T19:34:46Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/common/breaker/PreallocatedCircuitBreakerService.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.breaker;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.indices.breaker.AllCircuitBreakerStats;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerStats;\n+\n+/**\n+ * {@link CircuitBreakerService} that preallocates some bytes on construction.\n+ * Use this when you know you'll be allocating many small\n+ */\n+public class PreallocatedCircuitBreakerService extends CircuitBreakerService implements Releasable {\n+    private final CircuitBreakerService next;\n+    private final PreallocedCircuitBreaker preallocated;\n+\n+    public PreallocatedCircuitBreakerService(\n+        CircuitBreakerService next,\n+        String breakerToPreallocate,\n+        long bytesToPreallocate,\n+        String label\n+    ) {\n+        if (bytesToPreallocate <= 0) {\n+            throw new IllegalArgumentException(\"can't preallocate negative or zero bytes but got [\" + bytesToPreallocate + \"]\");\n+        }\n+        CircuitBreaker nextBreaker = next.getBreaker(breakerToPreallocate);\n+        nextBreaker.addEstimateBytesAndMaybeBreak(bytesToPreallocate, \"preallocate[\" + label + \"]\");\n+        this.next = next;\n+        this.preallocated = new PreallocedCircuitBreaker(nextBreaker, bytesToPreallocate);\n+    }\n+\n+    @Override\n+    public CircuitBreaker getBreaker(String name) {\n+        if (name.equals(preallocated.getName())) {\n+            return preallocated;\n+        }\n+        return next.getBreaker(name);\n+    }\n+\n+    @Override\n+    public AllCircuitBreakerStats stats() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public CircuitBreakerStats stats(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void close() {\n+        preallocated.close();\n+    }\n+\n+    /**\n+     * The preallocated breaker.\n+     * <p>\n+     * This breaker operates in two states:\n+     * <ol>\n+     * <li>We've used fewer bytes than we've preallocated.\n+     * <li>We've used all of the preallocated bytes.\n+     * </ol>\n+     * <p>\n+     * If we're in the \"used fewer bytes\" state than we've allocated then\n+     * allocating new bytes just adds to\n+     * {@link PreallocedCircuitBreaker#preallocationUsed}, maxing out at\n+     * {@link PreallocedCircuitBreaker#preallocated}. If we max\n+     * out we irreversibly switch to \"used all\" state. In that state any\n+     * additional allocations are passed directly to the underlying breaker.\n+     * <p>\n+     * De-allocating is just allocating a negative number of bytes. De-allocating\n+     * can not transition us from the \"used all\" state back into the\n+     * \"used fewer bytes\" state. It is a one way trip. Once we're in the\n+     * \"used all\" state all de-allocates are done directly on the underlying\n+     * breaker. So well behaved callers will naturally de-allocate everything.\n+     * <p>\n+     * {@link PreallocedCircuitBreaker#close()} is only used to de-allocate\n+     * bytes from the underlying breaker if we're still in the \"used fewer bytes\"\n+     * state. There is nothing to de-allocate if we are in the \"used all\" state. \n+     */\n+    private static class PreallocedCircuitBreaker implements CircuitBreaker, Releasable {\n+        private final CircuitBreaker next;\n+        private final long preallocated;\n+        private long preallocationUsed;\n+        private boolean closed;\n+\n+        PreallocedCircuitBreaker(CircuitBreaker next, long preallocated) {\n+            this.next = next;\n+            this.preallocated = preallocated;\n+        }\n+\n+        @Override\n+        public void circuitBreak(String fieldName, long bytesNeeded) {\n+            next.circuitBreak(fieldName, bytesNeeded);\n+        }\n+\n+        @Override\n+        public double addEstimateBytesAndMaybeBreak(long bytes, String label) throws CircuitBreakingException {\n+            if (closed) {\n+                throw new IllegalStateException(\"already closed\");\n+            }\n+            if (preallocationUsed == preallocated) {\n+                return next.addEstimateBytesAndMaybeBreak(bytes, label);\n+            }\n+            long newUsed = preallocationUsed + bytes;\n+            if (newUsed > preallocated) {\n+                preallocationUsed = preallocated;\n+                long toAllocate = newUsed - preallocated;\n+                if (toAllocate > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMwNjMxOA==", "bodyText": "...That is a terrifying comment.  Maybe let's open an issue to drop the return value from this method?", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550306318", "createdAt": "2020-12-30T19:40:14Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/common/breaker/PreallocatedCircuitBreakerService.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.breaker;\n+\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.indices.breaker.AllCircuitBreakerStats;\n+import org.elasticsearch.indices.breaker.CircuitBreakerService;\n+import org.elasticsearch.indices.breaker.CircuitBreakerStats;\n+\n+/**\n+ * {@link CircuitBreakerService} that preallocates some bytes on construction.\n+ * Use this when you know you'll be allocating many small\n+ */\n+public class PreallocatedCircuitBreakerService extends CircuitBreakerService implements Releasable {\n+    private final CircuitBreakerService next;\n+    private final PreallocedCircuitBreaker preallocated;\n+\n+    public PreallocatedCircuitBreakerService(\n+        CircuitBreakerService next,\n+        String breakerToPreallocate,\n+        long bytesToPreallocate,\n+        String label\n+    ) {\n+        if (bytesToPreallocate <= 0) {\n+            throw new IllegalArgumentException(\"can't preallocate negative or zero bytes but got [\" + bytesToPreallocate + \"]\");\n+        }\n+        CircuitBreaker nextBreaker = next.getBreaker(breakerToPreallocate);\n+        nextBreaker.addEstimateBytesAndMaybeBreak(bytesToPreallocate, \"preallocate[\" + label + \"]\");\n+        this.next = next;\n+        this.preallocated = new PreallocedCircuitBreaker(nextBreaker, bytesToPreallocate);\n+    }\n+\n+    @Override\n+    public CircuitBreaker getBreaker(String name) {\n+        if (name.equals(preallocated.getName())) {\n+            return preallocated;\n+        }\n+        return next.getBreaker(name);\n+    }\n+\n+    @Override\n+    public AllCircuitBreakerStats stats() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public CircuitBreakerStats stats(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void close() {\n+        preallocated.close();\n+    }\n+\n+    /**\n+     * The preallocated breaker.\n+     * <p>\n+     * This breaker operates in two states:\n+     * <ol>\n+     * <li>We've used fewer bytes than we've preallocated.\n+     * <li>We've used all of the preallocated bytes.\n+     * </ol>\n+     * <p>\n+     * If we're in the \"used fewer bytes\" state than we've allocated then\n+     * allocating new bytes just adds to\n+     * {@link PreallocedCircuitBreaker#preallocationUsed}, maxing out at\n+     * {@link PreallocedCircuitBreaker#preallocated}. If we max\n+     * out we irreversibly switch to \"used all\" state. In that state any\n+     * additional allocations are passed directly to the underlying breaker.\n+     * <p>\n+     * De-allocating is just allocating a negative number of bytes. De-allocating\n+     * can not transition us from the \"used all\" state back into the\n+     * \"used fewer bytes\" state. It is a one way trip. Once we're in the\n+     * \"used all\" state all de-allocates are done directly on the underlying\n+     * breaker. So well behaved callers will naturally de-allocate everything.\n+     * <p>\n+     * {@link PreallocedCircuitBreaker#close()} is only used to de-allocate\n+     * bytes from the underlying breaker if we're still in the \"used fewer bytes\"\n+     * state. There is nothing to de-allocate if we are in the \"used all\" state. \n+     */\n+    private static class PreallocedCircuitBreaker implements CircuitBreaker, Releasable {\n+        private final CircuitBreaker next;\n+        private final long preallocated;\n+        private long preallocationUsed;\n+        private boolean closed;\n+\n+        PreallocedCircuitBreaker(CircuitBreaker next, long preallocated) {\n+            this.next = next;\n+            this.preallocated = preallocated;\n+        }\n+\n+        @Override\n+        public void circuitBreak(String fieldName, long bytesNeeded) {\n+            next.circuitBreak(fieldName, bytesNeeded);\n+        }\n+\n+        @Override\n+        public double addEstimateBytesAndMaybeBreak(long bytes, String label) throws CircuitBreakingException {\n+            if (closed) {\n+                throw new IllegalStateException(\"already closed\");\n+            }\n+            if (preallocationUsed == preallocated) {\n+                return next.addEstimateBytesAndMaybeBreak(bytes, label);\n+            }\n+            long newUsed = preallocationUsed + bytes;\n+            if (newUsed > preallocated) {\n+                preallocationUsed = preallocated;\n+                long toAllocate = newUsed - preallocated;\n+                if (toAllocate > 0) {\n+                    return next.addEstimateBytesAndMaybeBreak(toAllocate, label);\n+                }\n+                return 0;\n+            }\n+            // This is the fast case. No volatile reads or writes here, ma!\n+            preallocationUsed = newUsed;\n+            // We return garbage here but callers never use the result for anything interesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7a64a8cbaed18d45f2f55c0a347001aa5292582"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMTU3Nw==", "bodyText": "This is a great comment.  I was literally about to ask why it would ever be 0.", "url": "https://github.com/elastic/elasticsearch/pull/66895#discussion_r550311577", "createdAt": "2020-12-30T20:00:44Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/AggregationContext.java", "diffHunk": "@@ -243,36 +251,55 @@ public final AggregationUsageService getUsageService() {\n      */\n     public static class ProductionAggregationContext extends AggregationContext {\n         private final QueryShardContext context;\n+        private final PreallocatedCircuitBreakerService breakerService;\n         private final BigArrays bigArrays;\n         private final Query topLevelQuery;\n         private final AggregationProfiler profiler;\n         private final MultiBucketConsumer multiBucketConsumer;\n         private final Supplier<SubSearchContext> subSearchContextBuilder;\n-        private final Consumer<Aggregator> addReleasable;\n         private final BitsetFilterCache bitsetFilterCache;\n         private final int randomSeed;\n         private final LongSupplier relativeTimeInMillis;\n         private final Supplier<Boolean> isCancelled;\n \n+        private final List<Aggregator> releaseMe = new ArrayList<>();\n+\n         public ProductionAggregationContext(\n             QueryShardContext context,\n+            long bytesToPreallocate,\n             Query topLevelQuery,\n             @Nullable AggregationProfiler profiler,\n             MultiBucketConsumer multiBucketConsumer,\n             Supplier<SubSearchContext> subSearchContextBuilder,\n-            Consumer<Aggregator> addReleasable,\n             BitsetFilterCache bitsetFilterCache,\n             int randomSeed,\n             LongSupplier relativeTimeInMillis,\n             Supplier<Boolean> isCancelled\n         ) {\n             this.context = context;\n-            this.bigArrays = context.bigArrays().withCircuitBreaking();  // We can break in searches.\n+            if (bytesToPreallocate == 0) {\n+                /*\n+                 * Its possible if a bit strange for the aggregations to ask\n+                 * to preallocate 0 bytes. Mostly this is for testing other\n+                 * things, but we should honor it and just not preallocate\n+                 * anything. Setting the breakerService reference to null will\n+                 * cause us to skip it when we close this context.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bd4bc56c468c56b54c565113151226bf09f88b1"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e01f0e27393cd1f19747c2a695a03eada1e1f69", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/4e01f0e27393cd1f19747c2a695a03eada1e1f69", "committedDate": "2021-01-04T14:07:52Z", "message": "Merge branch 'master' into agg_construction_contention"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d42334873d2c9bee3e0a66a747700eb25b758f8", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/2d42334873d2c9bee3e0a66a747700eb25b758f8", "committedDate": "2021-01-04T14:27:55Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90026745c168608dbdffd254776f5f49d2f866f6", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/90026745c168608dbdffd254776f5f49d2f866f6", "committedDate": "2021-01-04T15:03:02Z", "message": "Moar words!"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4267, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}