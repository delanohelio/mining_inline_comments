{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5ODc5OTkw", "number": 53670, "title": "Remove [removal-of-types] docs page, and point to 7x docs", "bodyText": "Given that types have been removed entirely in 8.0, we don't need a detailed page\nexplaining what they are and why they are going away.  This commit replaces the\npage with a short paragraph saying that types are no longer supported, and a link\nto the [removal-of-types] page in 7x", "createdAt": "2020-03-17T14:43:55Z", "url": "https://github.com/elastic/elasticsearch/pull/53670", "merged": true, "mergeCommit": {"oid": "534a4a9b320fbdecbebf6cf30505915ee55e8e88"}, "closed": true, "closedAt": "2020-03-18T14:13:01Z", "author": {"login": "romseygeek"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOjyAPgH2gAyMzg5ODc5OTkwOjg1YTFlOTMzMjQxNmM5ZTI3ODg3ZTBlMmE0NThkNDhiZGRiMWU5Y2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcO3wsLgH2gAyMzg5ODc5OTkwOjU0YzFlOGUwODQzYzkyZTVhMTI2ZGExNTA0NjZkNDQzMWQ3NDY2OTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "85a1e9332416c9e27887e0e2a458d48bddb1e9ce", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/85a1e9332416c9e27887e0e2a458d48bddb1e9ce", "committedDate": "2020-03-17T14:42:19Z", "message": "Remove [removal-of-types] docs page, and point to 7x docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3adad4fe0bd3a380c3dcd1ebd12eec08cb40da8b", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/3adad4fe0bd3a380c3dcd1ebd12eec08cb40da8b", "committedDate": "2020-03-18T10:40:08Z", "message": "Tidy up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2Nzk1MzI0", "url": "https://github.com/elastic/elasticsearch/pull/53670#pullrequestreview-376795324", "createdAt": "2020-03-18T11:58:15Z", "commit": {"oid": "3adad4fe0bd3a380c3dcd1ebd12eec08cb40da8b"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2ODE2NDYz", "url": "https://github.com/elastic/elasticsearch/pull/53670#pullrequestreview-376816463", "createdAt": "2020-03-18T12:29:40Z", "commit": {"oid": "3adad4fe0bd3a380c3dcd1ebd12eec08cb40da8b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoyOTo0MFrOF4Cwkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMjoyOTo0MFrOF4Cwkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMwOTc3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {ref-7x}/removal-of-types.html[removal of types] documentation for the 7x release\n          \n          \n            \n            {ref-7x}/removal-of-types.html[removal of types] documentation for the 7.x release.", "url": "https://github.com/elastic/elasticsearch/pull/53670#discussion_r394309778", "createdAt": "2020-03-18T12:29:40Z", "author": {"login": "jrodewig"}, "path": "docs/reference/mapping/removal_of_types.asciidoc", "diffHunk": "@@ -1,674 +1,6 @@\n [[removal-of-types]]\n == Removal of mapping types\n \n-IMPORTANT: Indices created in Elasticsearch 7.0.0 or later no longer accept a\n-`_default_` mapping. Indices created in 6.x will continue to function as before\n-in Elasticsearch 6.x. Types are deprecated in APIs in 7.0, with breaking changes\n-to the index creation, put mapping, get mapping, put template, get template and\n-get field mappings APIs.\n-\n-[float]\n-=== What are mapping types?\n-\n-Since the first release of Elasticsearch, each document has been stored in a\n-single index and assigned a single mapping type.  A mapping type was used to\n-represent the type of document or entity being indexed, for instance a\n-`twitter` index might have a `user` type and a `tweet` type.\n-\n-Each mapping type could have its own fields, so the `user` type might have a\n-`full_name` field, a `user_name` field, and an `email` field, while the\n-`tweet` type could have a `content` field, a `tweeted_at` field and, like the\n-`user` type, a `user_name` field.\n-\n-Each document had a `_type` meta-field containing the type name, and searches\n-could be limited to one or more types by specifying the type name(s) in the\n-URL:\n-\n-[source,js]\n-----\n-GET twitter/user,tweet/_search\n-{\n-  \"query\": {\n-    \"match\": {\n-      \"user_name\": \"kimchy\"\n-    }\n-  }\n-}\n-----\n-// NOTCONSOLE\n-\n-The `_type` field was combined with the document's `_id` to generate a `_uid`\n-field, so documents of different types with the same `_id` could exist in a\n-single index.\n-\n-Mapping types were also used to establish a\n-<<parent-join,parent-child relationship>>\n-between documents, so documents of type `question` could be parents to\n-documents of type `answer`.\n-\n-[float]\n-=== Why are mapping types being removed?\n-\n-Initially, we spoke about an ``index'' being similar to a ``database'' in an\n-SQL database, and a ``type'' being equivalent to a\n-``table''.\n-\n-This was a bad analogy that led to incorrect assumptions. In an SQL database,\n-tables are independent of each other.  The columns in one table have no\n-bearing on columns with the same name in another table.  This is not the case\n-for fields in a mapping type.\n-\n-In an Elasticsearch index, fields that have the same name in different mapping\n-types are backed by the same Lucene field internally.  In other words, using\n-the example above, the `user_name` field in the `user` type is stored in\n-exactly the same field as the `user_name` field in the `tweet` type, and both\n-`user_name` fields must have the same mapping (definition) in both types.\n-\n-This can lead to frustration when, for example, you want `deleted` to be a\n-`date` field in one type and a `boolean` field in another type in the same\n-index.\n-\n-On top of that, storing different entities that have few or no fields in\n-common in the same index leads to sparse data and interferes with Lucene's\n-ability to compress documents efficiently.\n-\n-For these reasons, we have decided to remove the concept of mapping types from\n-Elasticsearch.\n-\n-[float]\n-=== Alternatives to mapping types\n-\n-[float]\n-==== Index per document type\n-\n-The first alternative is to have an index per document type.  Instead of\n-storing tweets and users in a single `twitter` index, you could store tweets\n-in the `tweets` index and users in the `user` index. Indices are completely\n-independent of each other and so there will be no conflict of field types\n-between indices.\n-\n-This approach has two benefits:\n-\n-* Data is more likely to be dense and so benefit from compression techniques\n-  used in Lucene.\n-\n-* The term statistics used for scoring in full text search are more likely to\n-  be accurate because all documents in the same index represent a single\n-  entity.\n-\n-Each index can be sized appropriately for the number of documents it will\n-contain: you can use a smaller number of primary shards for `users` and a\n-larger number of primary shards for `tweets`.\n-\n-[float]\n-==== Custom type field\n-\n-Of course, there is a limit to how many primary shards can exist in a cluster\n-so you may not want to waste an entire shard for a collection of only a few\n-thousand documents.  In this case, you can implement your own custom `type`\n-field which will work in a similar way to the old `_type`.\n-\n-Let's take the `user`/`tweet` example above.  Originally, the workflow would\n-have looked something like this:\n-\n-[source,js]\n-----\n-PUT twitter\n-{\n-  \"mappings\": {\n-    \"user\": {\n-      \"properties\": {\n-        \"name\": { \"type\": \"text\" },\n-        \"user_name\": { \"type\": \"keyword\" },\n-        \"email\": { \"type\": \"keyword\" }\n-      }\n-    },\n-    \"tweet\": {\n-      \"properties\": {\n-        \"content\": { \"type\": \"text\" },\n-        \"user_name\": { \"type\": \"keyword\" },\n-        \"tweeted_at\": { \"type\": \"date\" }\n-      }\n-    }\n-  }\n-}\n-\n-PUT twitter/user/kimchy\n-{\n-  \"name\": \"Shay Banon\",\n-  \"user_name\": \"kimchy\",\n-  \"email\": \"shay@kimchy.com\"\n-}\n-\n-PUT twitter/tweet/1\n-{\n-  \"user_name\": \"kimchy\",\n-  \"tweeted_at\": \"2017-10-24T09:00:00Z\",\n-  \"content\": \"Types are going away\"\n-}\n-\n-GET twitter/tweet/_search\n-{\n-  \"query\": {\n-    \"match\": {\n-      \"user_name\": \"kimchy\"\n-    }\n-  }\n-}\n-----\n-// NOTCONSOLE\n-\n-You can achieve the same thing by adding a custom `type` field as follows:\n-\n-[source,js]\n-----\n-PUT twitter\n-{\n-  \"mappings\": {\n-    \"_doc\": {\n-      \"properties\": {\n-        \"type\": { \"type\": \"keyword\" }, <1>\n-        \"name\": { \"type\": \"text\" },\n-        \"user_name\": { \"type\": \"keyword\" },\n-        \"email\": { \"type\": \"keyword\" },\n-        \"content\": { \"type\": \"text\" },\n-        \"tweeted_at\": { \"type\": \"date\" }\n-      }\n-    }\n-  }\n-}\n-\n-PUT twitter/_doc/user-kimchy\n-{\n-  \"type\": \"user\", <1>\n-  \"name\": \"Shay Banon\",\n-  \"user_name\": \"kimchy\",\n-  \"email\": \"shay@kimchy.com\"\n-}\n-\n-PUT twitter/_doc/tweet-1\n-{\n-  \"type\": \"tweet\", <1>\n-  \"user_name\": \"kimchy\",\n-  \"tweeted_at\": \"2017-10-24T09:00:00Z\",\n-  \"content\": \"Types are going away\"\n-}\n-\n-GET twitter/_search\n-{\n-  \"query\": {\n-    \"bool\": {\n-      \"must\": {\n-        \"match\": {\n-          \"user_name\": \"kimchy\"\n-        }\n-      },\n-      \"filter\": {\n-        \"match\": {\n-          \"type\": \"tweet\" <1>\n-        }\n-      }\n-    }\n-  }\n-}\n-----\n-// NOTCONSOLE\n-<1> The explicit `type` field takes the place of the implicit `_type` field.\n-\n-[float]\n-[[parent-child-mapping-types]]\n-==== Parent/Child without mapping types\n-\n-Previously, a parent-child relationship was represented by making one mapping\n-type the parent, and one or more other mapping types the children.  Without\n-types, we can no longer use this syntax.  The parent-child feature will\n-continue to function as before, except that the way of expressing the\n-relationship between documents has been changed to use the new\n-<<parent-join,`join` field>>.\n-\n-\n-[float]\n-=== Schedule for removal of mapping types\n-\n-This is a big change for our users, so we have tried to make it as painless as\n-possible.  The change will roll out as follows:\n-\n-Elasticsearch 5.6.0::\n-\n-* Setting `index.mapping.single_type: true` on an index will enable the\n-  single-type-per-index behaviour which will be enforced in 6.0.\n-\n-* The <<parent-join,`join` field>> replacement for parent-child is available\n-  on indices created in 5.6.\n-\n-Elasticsearch 6.x::\n-\n-* Indices created in 5.x will continue to function in 6.x as they did in 5.x.\n-\n-* Indices created in 6.x only allow a single-type per index.  Any name\n-  can be used for the type, but there can be only one. The preferred type name\n-  is `_doc`, so that index APIs have the same path as they will have in 7.0:\n-  `PUT {index}/_doc/{id}` and `POST {index}/_doc`\n-\n-* The `_type` name can no longer be combined with the `_id` to form the `_uid`\n-  field. The `_uid` field has become an alias for the `_id` field.\n-\n-* New indices no longer support the old-style of parent/child and should\n-  use the <<parent-join,`join` field>> instead.\n-\n-* The `_default_` mapping type is deprecated.\n-\n-* In 6.8, the index creation, index template, and mapping APIs support a query\n-  string parameter (`include_type_name`) which indicates whether requests and\n-  responses should include a type name. It defaults to `true`, and should be set\n-  to an explicit value to prepare to upgrade to 7.0. Not setting `include_type_name`\n-  will result in a deprecation warning. Indices which don't have an explicit type will\n-  use the dummy type name `_doc`.\n-\n-Elasticsearch 7.x::\n-\n-* Specifying types in requests is deprecated. For instance, indexing a\n-  document no longer requires a document `type`.  The new index APIs\n-  are `PUT {index}/_doc/{id}` in case of explicit ids and `POST {index}/_doc`\n-  for auto-generated ids. Note that in 7.0, `_doc` is a permanent part of the\n-  path, and represents the endpoint name rather than the document type.\n-\n-* The `include_type_name` parameter in the index creation, index template,\n-  and mapping APIs will default to `false`. Setting the parameter at all will\n-  result in a deprecation warning.\n-\n-* The `_default_` mapping type is removed.\n-\n-Elasticsearch 8.x::\n-\n-* Specifying types in requests is no longer supported.\n-\n-* The `include_type_name` parameter is removed.\n-\n-[float]\n-=== Migrating multi-type indices to single-type\n-\n-The <<docs-reindex,Reindex API>> can be used to convert multi-type indices to\n-single-type indices. The following examples can be used in Elasticsearch 5.6\n-or Elasticsearch 6.x.  In 6.x, there is no need to specify\n-`index.mapping.single_type` as that is the default.\n-\n-[float]\n-==== Index per document type\n-\n-This first example splits our `twitter` index into a `tweets` index and a\n-`users` index:\n-\n-[source,js]\n-----\n-PUT users\n-{\n-  \"settings\": {\n-    \"index.mapping.single_type\": true\n-  },\n-  \"mappings\": {\n-    \"_doc\": {\n-      \"properties\": {\n-        \"name\": {\n-          \"type\": \"text\"\n-        },\n-        \"user_name\": {\n-          \"type\": \"keyword\"\n-        },\n-        \"email\": {\n-          \"type\": \"keyword\"\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-PUT tweets\n-{\n-  \"settings\": {\n-    \"index.mapping.single_type\": true\n-  },\n-  \"mappings\": {\n-    \"_doc\": {\n-      \"properties\": {\n-        \"content\": {\n-          \"type\": \"text\"\n-        },\n-        \"user_name\": {\n-          \"type\": \"keyword\"\n-        },\n-        \"tweeted_at\": {\n-          \"type\": \"date\"\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-POST _reindex\n-{\n-  \"source\": {\n-    \"index\": \"twitter\",\n-    \"type\": \"user\"\n-  },\n-  \"dest\": {\n-    \"index\": \"users\",\n-    \"type\": \"_doc\"\n-  }\n-}\n-\n-POST _reindex\n-{\n-  \"source\": {\n-    \"index\": \"twitter\",\n-    \"type\": \"tweet\"\n-  },\n-  \"dest\": {\n-    \"index\": \"tweets\",\n-    \"type\": \"_doc\"\n-  }\n-}\n-----\n-// NOTCONSOLE\n-\n-[float]\n-==== Custom type field\n-\n-This next example adds a custom `type` field and sets it to the value of the\n-original `_type`.  It also adds the type to the `_id` in case there are any\n-documents of different types which have conflicting IDs:\n-\n-[source,js]\n-----\n-PUT new_twitter\n-{\n-  \"mappings\": {\n-    \"_doc\": {\n-      \"properties\": {\n-        \"type\": {\n-          \"type\": \"keyword\"\n-        },\n-        \"name\": {\n-          \"type\": \"text\"\n-        },\n-        \"user_name\": {\n-          \"type\": \"keyword\"\n-        },\n-        \"email\": {\n-          \"type\": \"keyword\"\n-        },\n-        \"content\": {\n-          \"type\": \"text\"\n-        },\n-        \"tweeted_at\": {\n-          \"type\": \"date\"\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\n-POST _reindex\n-{\n-  \"source\": {\n-    \"index\": \"twitter\"\n-  },\n-  \"dest\": {\n-    \"index\": \"new_twitter\"\n-  },\n-  \"script\": {\n-    \"source\": \"\"\"\n-      ctx._source.type = ctx._type;\n-      ctx._id = ctx._type + '-' + ctx._id;\n-      ctx._type = '_doc';\n-    \"\"\"\n-  }\n-}\n-----\n-// NOTCONSOLE\n-\n-[float]\n-=== Typeless APIs in 7.0\n-\n-In Elasticsearch 7.0, each API will support typeless requests,\n-and specifying a type will produce a deprecation warning.\n-\n-NOTE: Typeless APIs work even if the target index contains a custom type.\n-For example, if an index has the custom type name `my_type`, we can add\n-documents to it using typeless `index` calls, and load documents with typeless\n-`get` calls.\n-\n-[float]\n-==== Index APIs\n-\n-Index creation, index template, and mapping APIs support a new `include_type_name`\n-URL parameter that specifies whether mapping definitions in requests and responses\n-should contain the type name. The parameter defaults to `true` in version 6.8 to\n-match the pre-7.0 behavior of using type names in mappings. It defaults to `false`\n-in version 7.0 and will be removed in version 8.0.\n-\n-It should be set explicitly in 6.8 to prepare to upgrade to 7.0. To avoid deprecation\n-warnings in 6.8, the parameter can be set to either `true` or `false`. In 7.0, setting\n-`include_type_name` at all will result in a deprecation warning.\n-\n-See some examples of interactions with Elasticsearch with this option set to `false`:\n-\n-[source,console]\n---------------------------------------------------\n-PUT index\n-{\n-  \"mappings\": {\n-    \"properties\": { <1>\n-      \"foo\": {\n-        \"type\": \"keyword\"\n-      }\n-    }\n-  }\n-}\n---------------------------------------------------\n-\n-<1> Mappings are included directly under the `mappings` key, without a type name.\n-\n-[source,console]\n---------------------------------------------------\n-PUT index/_mappings\n-{\n-  \"properties\": { <1>\n-    \"bar\": {\n-      \"type\": \"text\"\n-    }\n-  }\n-}\n---------------------------------------------------\n-// TEST[continued]\n-\n-<1> Mappings are included directly under the `mappings` key, without a type name.\n-\n-[source,console]\n---------------------------------------------------\n-GET index/_mappings\n---------------------------------------------------\n-// TEST[continued]\n-\n-The above call returns\n-\n-[source,console-result]\n---------------------------------------------------\n-{\n-  \"index\": {\n-    \"mappings\": {\n-      \"properties\": { <1>\n-        \"foo\": {\n-          \"type\": \"keyword\"\n-        },\n-        \"bar\": {\n-          \"type\": \"text\"\n-        }\n-      }\n-    }\n-  }\n-}\n---------------------------------------------------\n-\n-<1> Mappings are included directly under the `mappings` key, without a type name.\n-\n-[float]\n-==== Document APIs\n-\n-In 7.0, index APIs must be called with the `{index}/_doc` path for automatic\n-generation of the `_id` and `{index}/_doc/{id}` with explicit ids.\n-\n-[source,console]\n---------------------------------------------------\n-PUT index/_doc/1\n-{\n-  \"foo\": \"baz\"\n-}\n---------------------------------------------------\n-\n-[source,console-result]\n---------------------------------------------------\n-{\n-  \"_index\": \"index\",\n-  \"_id\": \"1\",\n-  \"_version\": 1,\n-  \"result\": \"created\",\n-  \"_shards\": {\n-    \"total\": 2,\n-    \"successful\": 1,\n-    \"failed\": 0\n-  },\n-  \"_seq_no\": 0,\n-  \"_primary_term\": 1\n-}\n---------------------------------------------------\n-\n-Similarly, the `get` and `delete` APIs use the path `{index}/_doc/{id}`:\n-\n-[source,console]\n---------------------------------------------------\n-GET index/_doc/1\n---------------------------------------------------\n-// TEST[continued]\n-\n-NOTE: In 7.0, `_doc` represents the endpoint name instead of the document type.\n-The `_doc` component is a permanent part of the path for the document `index`,\n-`get`, and `delete` APIs going forward, and will not be removed in 8.0.\n-\n-For API paths that contain both a type and endpoint name like `_update`,\n-in 7.0 the endpoint will immediately follow the index name:\n-\n-[source,console]\n---------------------------------------------------\n-POST index/_update/1\n-{\n-    \"doc\" : {\n-        \"foo\" : \"qux\"\n-    }\n-}\n-\n-GET /index/_source/1\n---------------------------------------------------\n-// TEST[continued]\n-\n-Types should also no longer appear in the body of requests. The following\n-example of bulk indexing omits the type both in the URL, and in the individual\n-bulk commands:\n-\n-[source,console]\n---------------------------------------------------\n-POST _bulk\n-{ \"index\" : { \"_index\" : \"index\", \"_id\" : \"3\" } }\n-{ \"foo\" : \"baz\" }\n-{ \"index\" : { \"_index\" : \"index\", \"_id\" : \"4\" } }\n-{ \"foo\" : \"qux\" }\n---------------------------------------------------\n-\n-[float]\n-==== Search APIs\n-\n-When calling a search API such `_search`, `_msearch`, or `_explain`, types\n-should not be included in the URL. Additionally, the `_type` field should not\n-be used in queries, aggregations, or scripts.\n-\n-[float]\n-==== Index templates\n-\n-It is recommended to make index templates typeless by re-adding them with\n-`include_type_name` set to `false`. Under the hood, typeless templates will use\n-the dummy type `_doc` when creating indices.\n-\n-In case typeless templates are used with typed index creation calls or typed\n-templates are used with typeless index creation calls, the template will still\n-be applied but the index creation call decides whether there should be a type\n-or not. For instance in the below example, `index-1-01` will have a type in\n-spite of the fact that it matches a template that is typeless, and `index-2-01`\n-will be typeless in spite of the fact that it matches a template that defines\n-a type. Both `index-1-01` and `index-2-01` will inherit the `foo` field from\n-the template that they match.\n-\n-[source,console]\n---------------------------------------------------\n-PUT _template/template1\n-{\n-  \"index_patterns\":[ \"index-1-*\" ],\n-  \"mappings\": {\n-    \"properties\": {\n-      \"foo\": {\n-        \"type\": \"keyword\"\n-      }\n-    }\n-  }\n-}\n-\n-PUT index-1-01\n-{\n-  \"mappings\": {\n-    \"properties\": {\n-      \"bar\": {\n-        \"type\": \"long\"\n-      }\n-    }\n-  }\n-}\n-\n-PUT index-2-01\n-{\n-  \"mappings\": {\n-    \"properties\": {\n-      \"bar\": {\n-        \"type\": \"long\"\n-      }\n-    }\n-  }\n-}\n---------------------------------------------------\n-\n-//////////////////////////\n-\n-[source,console]\n---------------------------------------------------\n-DELETE /_template/template1\n---------------------------------------------------\n-// TEST[continued]\n-\n-//////////////////////////\n-\n-In case of implicit index creation, because of documents that get indexed in\n-an index that doesn't exist yet, the template is always honored. This is\n-usually not a problem due to the fact that typeless index calls work on typed\n-indices.\n-\n-[float]\n-==== Mixed-version clusters\n-\n-In a cluster composed of both 6.8 and 7.0 nodes, the parameter\n-`include_type_name` should be specified in index APIs like index\n-creation. This is because the parameter has a different default between\n-6.8 and 7.0, so the same mapping definition will not be valid for both\n-node versions.\n-\n-Typeless document APIs such as `bulk` and `update` are only available as of\n-7.0, and will not work with 6.8 nodes. This also holds true for the typeless\n-versions of queries that perform document lookups, such as `terms`.\n+Elasticsearch 8.0.0 no longer supports mapping types.  For details on how to\n+migrate your clusters away from mapping types, see the\n+{ref-7x}/removal-of-types.html[removal of types] documentation for the 7x release", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3adad4fe0bd3a380c3dcd1ebd12eec08cb40da8b"}, "originalPosition": 677}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2ODE2NzA3", "url": "https://github.com/elastic/elasticsearch/pull/53670#pullrequestreview-376816707", "createdAt": "2020-03-18T12:30:01Z", "commit": {"oid": "3adad4fe0bd3a380c3dcd1ebd12eec08cb40da8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54c1e8e0843c92e5a126da150466d4431d746693", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/54c1e8e0843c92e5a126da150466d4431d746693", "committedDate": "2020-03-18T13:58:59Z", "message": "feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1969, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}