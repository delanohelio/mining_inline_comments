{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMTY0MDY3", "number": 51905, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODozODo0NFrODdP7Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNjoxOTozNVrODeE0Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxOTk2MTk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/engine/NoOpEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODozODo0NFrOFlve4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowMTo1OFrOFnKMOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExOTU4Ng==", "bodyText": "Not sure about why number of uncommitted ops are relevant to trimming?", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r375119586", "createdAt": "2020-02-05T08:38:44Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/NoOpEngine.java", "diffHunk": "@@ -137,31 +138,26 @@ public void trimUnreferencedTranslogFiles() {\n         try (ReleasableLock lock = readLock.acquire()) {\n             ensureOpen();\n             final List<IndexCommit> commits = DirectoryReader.listCommits(store.directory());\n-            if (commits.size() == 1) {\n+            if (commits.size() == 1 &&\n+                translogStats.getUncommittedOperations() == 0 &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6733791b37c5af4ca6ded83e2ebd0ae5576c19"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNTc1Mg==", "bodyText": "Good catch. That is not needed. I removed it in 63c25e2.", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376605752", "createdAt": "2020-02-07T21:01:58Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/index/engine/NoOpEngine.java", "diffHunk": "@@ -137,31 +138,26 @@ public void trimUnreferencedTranslogFiles() {\n         try (ReleasableLock lock = readLock.acquire()) {\n             ensureOpen();\n             final List<IndexCommit> commits = DirectoryReader.listCommits(store.directory());\n-            if (commits.size() == 1) {\n+            if (commits.size() == 1 &&\n+                translogStats.getUncommittedOperations() == 0 &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExOTU4Ng=="}, "originalCommit": {"oid": "fe6733791b37c5af4ca6ded83e2ebd0ae5576c19"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTIzODQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjo0MToxNFrOFmiIgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjo0MToxNFrOFmiIgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk0OTQ0Mg==", "bodyText": "assert localCheckpointOfSafeCommit <= localCheckpointOfLastCommit", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r375949442", "createdAt": "2020-02-06T16:41:14Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java", "diffHunk": "@@ -121,16 +121,12 @@ private void updateRetentionPolicy() throws IOException {\n         assert Thread.holdsLock(this);\n         logger.debug(\"Safe commit [{}], last commit [{}]\", commitDescription(safeCommit), commitDescription(lastCommit));\n         assert safeCommit.isDeleted() == false : \"The safe commit must not be deleted\";\n-        final long minRequiredGen = Long.parseLong(safeCommit.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));\n         assert lastCommit.isDeleted() == false : \"The last commit must not be deleted\";\n-        final long lastGen = Long.parseLong(lastCommit.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));\n-\n-        assert minRequiredGen <= lastGen : \"minRequiredGen must not be greater than lastGen\";\n-        translogDeletionPolicy.setTranslogGenerationOfLastCommit(lastGen);\n-        translogDeletionPolicy.setMinTranslogGenerationForRecovery(minRequiredGen);\n-\n-        softDeletesPolicy.setLocalCheckpointOfSafeCommit(\n-            Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)));\n+        final long localCheckpointOfSafeCommit = Long.parseLong(safeCommit.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));\n+        final long localCheckpointOfLastCommit = Long.parseLong(lastCommit.getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));\n+        softDeletesPolicy.setLocalCheckpointOfSafeCommit(localCheckpointOfSafeCommit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eb0d5399e72449ff10af0417221394048b838cc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTI1Mjg3OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjo0NDo0OVrOFmiRgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNDoyNDo1MlrOFm-nBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk1MTc0NQ==", "bodyText": "this log might still be useful?", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r375951745", "createdAt": "2020-02-06T16:44:49Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -458,23 +458,22 @@ public void skipTranslogRecovery() {\n     }\n \n     private void recoverFromTranslogInternal(TranslogRecoveryRunner translogRecoveryRunner, long recoverUpToSeqNo) throws IOException {\n-        Translog.TranslogGeneration translogGeneration = translog.getGeneration();\n         final int opsRecovered;\n-        final long translogFileGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));\n-        try (Translog.Snapshot snapshot = translog.newSnapshotFromGen(\n-            new Translog.TranslogGeneration(translog.getTranslogUUID(), translogFileGen), recoverUpToSeqNo)) {\n-            opsRecovered = translogRecoveryRunner.run(this, snapshot);\n-        } catch (Exception e) {\n-            throw new EngineException(shardId, \"failed to recover from translog\", e);\n+        final long localCheckpoint = getProcessedLocalCheckpoint();\n+        if (localCheckpoint < recoverUpToSeqNo) {\n+            try (Translog.Snapshot snapshot = translog.newSnapshot(localCheckpoint + 1, recoverUpToSeqNo)) {\n+                opsRecovered = translogRecoveryRunner.run(this, snapshot);\n+            } catch (Exception e) {\n+                throw new EngineException(shardId, \"failed to recover from translog\", e);\n+            }\n+        } else {\n+            opsRecovered = 0;\n         }\n         // flush if we recovered something or if we have references to older translogs\n         // note: if opsRecovered == 0 and we have older translogs it means they are corrupted or 0 length.\n         assert pendingTranslogRecovery.get() : \"translogRecovery is not pending but should be\";\n         pendingTranslogRecovery.set(false); // we are good - now we can commit\n         if (opsRecovered > 0) {\n-            logger.trace(\"flushing post recovery from translog. ops recovered [{}]. committed translog id [{}]. current id [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eb0d5399e72449ff10af0417221394048b838cc"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxNjAwNg==", "bodyText": "restored in 2c0b257", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376416006", "createdAt": "2020-02-07T14:24:52Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -458,23 +458,22 @@ public void skipTranslogRecovery() {\n     }\n \n     private void recoverFromTranslogInternal(TranslogRecoveryRunner translogRecoveryRunner, long recoverUpToSeqNo) throws IOException {\n-        Translog.TranslogGeneration translogGeneration = translog.getGeneration();\n         final int opsRecovered;\n-        final long translogFileGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));\n-        try (Translog.Snapshot snapshot = translog.newSnapshotFromGen(\n-            new Translog.TranslogGeneration(translog.getTranslogUUID(), translogFileGen), recoverUpToSeqNo)) {\n-            opsRecovered = translogRecoveryRunner.run(this, snapshot);\n-        } catch (Exception e) {\n-            throw new EngineException(shardId, \"failed to recover from translog\", e);\n+        final long localCheckpoint = getProcessedLocalCheckpoint();\n+        if (localCheckpoint < recoverUpToSeqNo) {\n+            try (Translog.Snapshot snapshot = translog.newSnapshot(localCheckpoint + 1, recoverUpToSeqNo)) {\n+                opsRecovered = translogRecoveryRunner.run(this, snapshot);\n+            } catch (Exception e) {\n+                throw new EngineException(shardId, \"failed to recover from translog\", e);\n+            }\n+        } else {\n+            opsRecovered = 0;\n         }\n         // flush if we recovered something or if we have references to older translogs\n         // note: if opsRecovered == 0 and we have older translogs it means they are corrupted or 0 length.\n         assert pendingTranslogRecovery.get() : \"translogRecovery is not pending but should be\";\n         pendingTranslogRecovery.set(false); // we are good - now we can commit\n         if (opsRecovered > 0) {\n-            logger.trace(\"flushing post recovery from translog. ops recovered [{}]. committed translog id [{}]. current id [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk1MTc0NQ=="}, "originalCommit": {"oid": "1eb0d5399e72449ff10af0417221394048b838cc"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODU3MDYyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNjowMTo1N1rOFnB7Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTowMjoxNVrOFnKMtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3MDMzOA==", "bodyText": "I wonder why this change is necessary? I find it a bit counter intuitive to update that before sync'ing translog, but I am sure there is a good reason.", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376470338", "createdAt": "2020-02-07T16:01:57Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java", "diffHunk": "@@ -5664,8 +5647,8 @@ public void testRecoverFromLocalTranslog() throws Exception {\n                 for (Engine.Operation op : operations) {\n                     applyOperation(engine, op);\n                     if (randomBoolean()) {\n+                        globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getProcessedLocalCheckpoint()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0b2573dc8ee7aa21c418b0319dad3e276f1c8a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNTg3OQ==", "bodyText": "I've reverted this in 630da78.", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376605879", "createdAt": "2020-02-07T21:02:15Z", "author": {"login": "dnhatn"}, "path": "server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java", "diffHunk": "@@ -5664,8 +5647,8 @@ public void testRecoverFromLocalTranslog() throws Exception {\n                 for (Engine.Operation op : operations) {\n                     applyOperation(engine, op);\n                     if (randomBoolean()) {\n+                        globalCheckpoint.set(randomLongBetween(globalCheckpoint.get(), engine.getProcessedLocalCheckpoint()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3MDMzOA=="}, "originalCommit": {"oid": "2c0b2573dc8ee7aa21c418b0319dad3e276f1c8a"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODU5MzEwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNjowOTowOVrOFnCKAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToyMjo0OFrOFnKrHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3NDExMg==", "bodyText": "I am guessing that the change in the next line is due to only keeping one generation now? In that case, this comment needs updating I think.", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376474112", "createdAt": "2020-02-07T16:09:09Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java", "diffHunk": "@@ -416,7 +416,7 @@ public void testStressMaybeFlushOrRollTranslogGeneration() throws Exception {\n         final Settings settings;\n         if (flush) {\n             // size of the operation plus two generations of overhead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0b2573dc8ee7aa21c418b0319dad3e276f1c8a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMzY2MQ==", "bodyText": "fixed in 8c91dcf.", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376613661", "createdAt": "2020-02-07T21:22:48Z", "author": {"login": "dnhatn"}, "path": "server/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java", "diffHunk": "@@ -416,7 +416,7 @@ public void testStressMaybeFlushOrRollTranslogGeneration() throws Exception {\n         final Settings settings;\n         if (flush) {\n             // size of the operation plus two generations of overhead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3NDExMg=="}, "originalCommit": {"oid": "2c0b2573dc8ee7aa21c418b0319dad3e276f1c8a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODYyODE1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/engine/NoOpEngineTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNjoxOTozNVrOFnCfmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToyMjozNFrOFnKqvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3OTY0Mg==", "bodyText": "Should we check prior to this that we have some operations to trim, except in the case where the last thing done was a flush?", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376479642", "createdAt": "2020-02-07T16:19:35Z", "author": {"login": "henningandersen"}, "path": "server/src/test/java/org/elasticsearch/index/engine/NoOpEngineTests.java", "diffHunk": "@@ -168,49 +166,28 @@ public void testTrimUnreferencedTranslogFiles() throws Exception {\n         tracker.updateFromMaster(1L, Collections.singleton(allocationId.getId()), table);\n         tracker.activatePrimaryMode(SequenceNumbers.NO_OPS_PERFORMED);\n \n-        boolean softDeleteEnabled = engine.config().getIndexSettings().isSoftDeleteEnabled();\n         final int numDocs = scaledRandomIntBetween(10, 3000);\n         for (int i = 0; i < numDocs; i++) {\n             engine.index(indexForDoc(createParsedDoc(Integer.toString(i), null)));\n             tracker.updateLocalCheckpoint(allocationId.getId(), i);\n             if (rarely()) {\n                 engine.flush();\n             }\n+            if (randomBoolean()) {\n+                engine.rollTranslogGeneration();\n+            }\n         }\n+        // prevent translog from trimming so we can test trimUnreferencedFiles in NoOpEngine.\n+        final Translog.Snapshot snapshot = engine.getTranslog().newSnapshot();\n         engine.flush(true, true);\n-\n-        final String translogUuid = engine.getTranslog().getTranslogUUID();\n-        final long minFileGeneration = engine.getTranslog().getMinFileGeneration();\n-        final long currentFileGeneration = engine.getTranslog().currentFileGeneration();\n         engine.close();\n \n         final NoOpEngine noOpEngine = new NoOpEngine(noOpConfig(INDEX_SETTINGS, store, primaryTranslogDir, tracker));\n-        final Path translogPath = noOpEngine.config().getTranslogConfig().getTranslogPath();\n-\n-        final long lastCommitedTranslogGeneration;\n-        try (Engine.IndexCommitRef indexCommitRef = noOpEngine.acquireLastIndexCommit(false)) {\n-            Map<String, String> lastCommittedUserData = indexCommitRef.getIndexCommit().getUserData();\n-            lastCommitedTranslogGeneration = Long.parseLong(lastCommittedUserData.get(Translog.TRANSLOG_GENERATION_KEY));\n-            assertThat(lastCommitedTranslogGeneration, equalTo(currentFileGeneration));\n-        }\n-\n-        assertThat(Translog.readMinTranslogGeneration(translogPath, translogUuid), equalTo(minFileGeneration));\n-        assertThat(noOpEngine.getTranslogStats().estimatedNumberOfOperations(), equalTo(softDeleteEnabled ? 0 : numDocs));\n-        assertThat(noOpEngine.getTranslogStats().getUncommittedOperations(), equalTo(0));\n-\n         noOpEngine.trimUnreferencedTranslogFiles();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0b2573dc8ee7aa21c418b0319dad3e276f1c8a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMzU2NQ==", "bodyText": "++. Added in 02103b7.", "url": "https://github.com/elastic/elasticsearch/pull/51905#discussion_r376613565", "createdAt": "2020-02-07T21:22:34Z", "author": {"login": "dnhatn"}, "path": "server/src/test/java/org/elasticsearch/index/engine/NoOpEngineTests.java", "diffHunk": "@@ -168,49 +166,28 @@ public void testTrimUnreferencedTranslogFiles() throws Exception {\n         tracker.updateFromMaster(1L, Collections.singleton(allocationId.getId()), table);\n         tracker.activatePrimaryMode(SequenceNumbers.NO_OPS_PERFORMED);\n \n-        boolean softDeleteEnabled = engine.config().getIndexSettings().isSoftDeleteEnabled();\n         final int numDocs = scaledRandomIntBetween(10, 3000);\n         for (int i = 0; i < numDocs; i++) {\n             engine.index(indexForDoc(createParsedDoc(Integer.toString(i), null)));\n             tracker.updateLocalCheckpoint(allocationId.getId(), i);\n             if (rarely()) {\n                 engine.flush();\n             }\n+            if (randomBoolean()) {\n+                engine.rollTranslogGeneration();\n+            }\n         }\n+        // prevent translog from trimming so we can test trimUnreferencedFiles in NoOpEngine.\n+        final Translog.Snapshot snapshot = engine.getTranslog().newSnapshot();\n         engine.flush(true, true);\n-\n-        final String translogUuid = engine.getTranslog().getTranslogUUID();\n-        final long minFileGeneration = engine.getTranslog().getMinFileGeneration();\n-        final long currentFileGeneration = engine.getTranslog().currentFileGeneration();\n         engine.close();\n \n         final NoOpEngine noOpEngine = new NoOpEngine(noOpConfig(INDEX_SETTINGS, store, primaryTranslogDir, tracker));\n-        final Path translogPath = noOpEngine.config().getTranslogConfig().getTranslogPath();\n-\n-        final long lastCommitedTranslogGeneration;\n-        try (Engine.IndexCommitRef indexCommitRef = noOpEngine.acquireLastIndexCommit(false)) {\n-            Map<String, String> lastCommittedUserData = indexCommitRef.getIndexCommit().getUserData();\n-            lastCommitedTranslogGeneration = Long.parseLong(lastCommittedUserData.get(Translog.TRANSLOG_GENERATION_KEY));\n-            assertThat(lastCommitedTranslogGeneration, equalTo(currentFileGeneration));\n-        }\n-\n-        assertThat(Translog.readMinTranslogGeneration(translogPath, translogUuid), equalTo(minFileGeneration));\n-        assertThat(noOpEngine.getTranslogStats().estimatedNumberOfOperations(), equalTo(softDeleteEnabled ? 0 : numDocs));\n-        assertThat(noOpEngine.getTranslogStats().getUncommittedOperations(), equalTo(0));\n-\n         noOpEngine.trimUnreferencedTranslogFiles();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3OTY0Mg=="}, "originalCommit": {"oid": "2c0b2573dc8ee7aa21c418b0319dad3e276f1c8a"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4922, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}