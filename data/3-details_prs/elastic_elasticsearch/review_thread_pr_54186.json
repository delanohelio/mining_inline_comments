{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNTk4NTUy", "number": 54186, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0OToyOVrODrOJlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDo0Mzo0NFrODvTEMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NjQ3MTkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/common/src/main/java/org/elasticsearch/test/eql/CommonEqlActionTestCase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0OToyOVrOF7b5xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0OToyOVrOF7b5xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NzQ2MA==", "bodyText": "Needed mapping to IP type, this creating the index with mapping.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397867460", "createdAt": "2020-03-25T13:49:29Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/qa/common/src/main/java/org/elasticsearch/test/eql/CommonEqlActionTestCase.java", "diffHunk": "@@ -55,6 +57,12 @@ private static void setupData(CommonEqlActionTestCase tc) throws Exception {\n             return;\n         }\n \n+        CreateIndexRequest request = new CreateIndexRequest(testIndexName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NjQ3NzU1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo1MDo0MFrOF7b9Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQyMDoyNDozM1rOGA0enw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg==", "bodyText": "The current enum for error messages doesn't work great for variadic type of function. Open to suggestions.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397868342", "createdAt": "2020-03-25T13:50:40Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMDM3OA==", "bodyText": "I added a method here in my wildcard PR:\n\n  \n    \n      elasticsearch/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/Expressions.java\n    \n    \n        Lines 36 to 44\n      in\n      d482c47\n    \n    \n    \n    \n\n        \n          \n           public static ParamOrdinal fromIndex(int index) { \n        \n\n        \n          \n               switch (index) { \n        \n\n        \n          \n                   case 0: return ParamOrdinal.FIRST; \n        \n\n        \n          \n                   case 1: return ParamOrdinal.SECOND; \n        \n\n        \n          \n                   case 2: return ParamOrdinal.THIRD; \n        \n\n        \n          \n                   case 3: return ParamOrdinal.FOURTH; \n        \n\n        \n          \n                   default: return ParamOrdinal.DEFAULT; \n        \n\n        \n          \n               } \n        \n\n        \n          \n           }", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397910378", "createdAt": "2020-03-25T14:44:07Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMTUyNQ==", "bodyText": "Also, should these fields also be isStringAndExact? and an isFoldable check?\nHere's how I approached that\n\n  \n    \n      elasticsearch/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java\n    \n    \n        Lines 80 to 83\n      in\n      d482c47\n    \n    \n    \n    \n\n        \n          \n           lastResolution = isFoldable(p, sourceText(), ParamOrdinal.fromIndex(index)); \n        \n\n        \n          \n           if (lastResolution.unresolved()) { \n        \n\n        \n          \n               break; \n        \n\n        \n          \n           }", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397911525", "createdAt": "2020-03-25T14:45:34Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxNjY2OQ==", "bodyText": "Cool! Will update after your PR merges.\nThe ParamOrdinal falls back to ParamOrdinal.DEFAULT after 4 params anyways. Maybe make enum longer if we still want to use enum there?", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397916669", "createdAt": "2020-03-25T14:51:56Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU2NTU0Ng==", "bodyText": "For how to handle functions that deal with a variable list of parameters, I suggest having a look at org.elasticsearch.xpack.sql.expression.predicate.conditional.Case or org.elasticsearch.xpack.sql.expression.predicate.conditional.Coalesce since these are functions that have a variable list of parameters.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r398565546", "createdAt": "2020-03-26T13:20:47Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMjk5MQ==", "bodyText": "Relying on the same def builder here that was merged with wildcard function for now.\nUpdated to align with wildcard impl usage of ParamOrdinal.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403512991", "createdAt": "2020-04-04T20:24:33Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Njc0ODUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDo0NjozOFrOF7epOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQyMDoyNjo0N1rOGA0fXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjM3Nw==", "bodyText": "I think field.foldable() will be included as part of super?", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397912377", "createdAt": "2020-03-25T14:46:38Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n+        return resolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return super.foldable() && field.foldable() && asFunction().foldable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMzE4MQ==", "bodyText": "Removed super.foldable()", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403513181", "createdAt": "2020-04-04T20:26:47Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n+        return resolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return super.foldable() && field.foldable() && asFunction().foldable();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjM3Nw=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDgzNTA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzowOTo1MFrOF8GD-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQyMDoxNzozNlrOGA0bsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1ODIwMg==", "bodyText": "I prefer listing the functions in alphabetical order.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r398558202", "createdAt": "2020-03-26T13:09:50Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -24,6 +25,7 @@ public EqlFunctionRegistry() {\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n+                def(CIDRMatch.class, CIDRMatch::new, \"cidrmatch\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMjI0MQ==", "bodyText": "Yep. Updated.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403512241", "createdAt": "2020-04-04T20:17:36Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -24,6 +25,7 @@ public EqlFunctionRegistry() {\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n+                def(CIDRMatch.class, CIDRMatch::new, \"cidrmatch\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1ODIwMg=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDg0NTMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzoxMjoyNVrOF8GKbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQyMDoxOTozNFrOGA0cew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1OTg1NQ==", "bodyText": "Personal preference, but I would like to see a useful description of the function. Not even the original EQL documentation is clear imo: https://eql.readthedocs.io/en/latest/query-guide/functions.html", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r398559855", "createdAt": "2020-03-26T13:12:25Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMjQ0Mw==", "bodyText": "Added a couple of more lines with a link to the EQL doc.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403512443", "createdAt": "2020-04-04T20:19:34Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1OTg1NQ=="}, "originalCommit": {"oid": "aff0389bb6da7b0423260f8df577a0b2df728017"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTIyMDMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDo0Mzo0NFrOGBpKEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDo1NToyN1rOGBpiEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NjA4MQ==", "bodyText": "Please update to take into account #54795 - reduces the class and removes a separate optimizer rule.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r404376081", "createdAt": "2020-04-06T20:43:44Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ * Returns true if the source address matches any of the provided CIDR blocks.\n+ * Refer to: https://eql.readthedocs.io/en/latest/query-guide/functions.html#cidrMatch\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n+        int index = 1;\n+\n+        for (Expression addr: addresses) {\n+\n+            resolution = isFoldable(addr, sourceText(), ParamOrdinal.fromIndex(index));\n+            if (resolution.unresolved()) {\n+                break;\n+            }\n+\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.fromIndex(index));\n+            if (resolution.unresolved()) {\n+                break;\n+            }\n+\n+            index++;\n+        }\n+\n+        return resolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return field.foldable() && asFunction().foldable();\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asFunction().fold();\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, CIDRMatch::new, field, addresses);\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+        return new CIDRMatch(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    public ScalarFunction asFunction() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ff57dbcef47a5a8003265b2d69d8b579cfc931"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4MjIyNQ==", "bodyText": "Sure, will do once #54795 is merged.", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r404382225", "createdAt": "2020-04-06T20:55:27Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ * Returns true if the source address matches any of the provided CIDR blocks.\n+ * Refer to: https://eql.readthedocs.io/en/latest/query-guide/functions.html#cidrMatch\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n+        int index = 1;\n+\n+        for (Expression addr: addresses) {\n+\n+            resolution = isFoldable(addr, sourceText(), ParamOrdinal.fromIndex(index));\n+            if (resolution.unresolved()) {\n+                break;\n+            }\n+\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.fromIndex(index));\n+            if (resolution.unresolved()) {\n+                break;\n+            }\n+\n+            index++;\n+        }\n+\n+        return resolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return field.foldable() && asFunction().foldable();\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asFunction().fold();\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, CIDRMatch::new, field, addresses);\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+        return new CIDRMatch(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    public ScalarFunction asFunction() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NjA4MQ=="}, "originalCommit": {"oid": "16ff57dbcef47a5a8003265b2d69d8b579cfc931"}, "originalPosition": 118}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4076, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}