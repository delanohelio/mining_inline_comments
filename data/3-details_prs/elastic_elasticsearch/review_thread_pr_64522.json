{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NjgwMzkz", "number": 64522, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMjo0NjoxMlrOE5OEJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMjo0OTowMlrOE5OFEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDM0NzI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/package-info.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMjo0NjoxMlrOHzjxsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTozMzoxNFrOHzwDCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgyNTU4Nw==", "bodyText": "I think it is from the source to the target?", "url": "https://github.com/elastic/elasticsearch/pull/64522#discussion_r523825587", "createdAt": "2020-11-15T22:46:12Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/package-info.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * <p>This package contains the logic for the recovery functionality.</p>\n+ *\n+ * <h2>Preliminaries</h2>\n+ *\n+ * Recoveries are started on data nodes as a result of data node discovering shard assignments to themselves in the cluster state. The\n+ * master node sets up these shard allocations in the cluster state (see {@link org.elasticsearch.cluster.routing.ShardRouting}).\n+ * If a data node finds shard allocations that require recovery on itself, it will execute the required recoveries by executing the\n+ * logic starting at {@link org.elasticsearch.indices.cluster.IndicesClusterStateService#createOrUpdateShards}. As the data nodes execute\n+ * the steps of the recovery state machine they report back success or failure to do so to the master node via the transport actions in\n+ * {@link org.elasticsearch.cluster.action.shard.ShardStateAction}, which will then update the shard routing in the cluster state\n+ * accordingly to reflect the status of the recovered shards or to handle failures in the recovery process. Recoveries can have various\n+ * kinds of sources that are modeled via the {@link org.elasticsearch.cluster.routing.RecoverySource} that is communicated to the recovery\n+ * target by {@link org.elasticsearch.cluster.routing.ShardRouting#recoverySource()} for each shard routing. These sources and their state\n+ * machines will be described below. The actual recovery process for all of them is started by invoking\n+ * {@link org.elasticsearch.index.shard.IndexShard#startRecovery}.\n+ *\n+ * <h3>Checkpoints</h3>\n+ *\n+ * Aspects of the recovery logic are based on the concepts of local and global checkpoints. Each operation on a shard is tracked by a\n+ * sequence number as well as the primary term during which it was applied to the index. The sequence number up to which operations have\n+ * been fully processed on a shard is that shard's local checkpoint. The sequence number up to which operations on all replicas for a shard\n+ * have been fully processed is referred to as the global checkpoint. Comparing the local checkpoints of shard copies enables determining\n+ * which operations would have to be replayed to a shard copy to bring it in-sync with the primary shard. By retaining operations in the\n+ * {@link org.elasticsearch.indices.recovery.RecoveryState.Translog} or in soft deletes, they are available for this kind of replay that\n+ * moves a shard lower local checkpoint up to a higher local checkpoint. The global checkpoint allows for determining which operations have\n+ * been safely processed on all shards and thus don't have to be retained on the primary node for replay to replicas.\n+ *\n+ * The primary node tracks the global checkpoint for a shard via the {@link org.elasticsearch.index.seqno.ReplicationTracker}. The primary\n+ * term is tracked by the master node and stored in the cluster state and incremented each time the primary node for a shard changes.\n+ *\n+ * <h3>Retention Leases</h3>\n+ *\n+ * The duration for which a shard retains individual operations for replay during recovery is governed by the\n+ * {@link org.elasticsearch.index.seqno.RetentionLease} functionality. More information about this functionality can be found in the\n+ * {@link org.elasticsearch.index.seqno} package and the \"History retention\" section in the docs.\n+ *\n+ * <h2>Recovery Types</h2>\n+ *\n+ * <h3>1. Peer Recovery</h3>\n+ *\n+ * Peer recovery is the process of bringing a shard copy on one node, referred to as the target node below, in-sync with the shard copy on\n+ * another node, referred to as the source node below. It is always the primary node of a shard that serves as the source of the recovery.\n+ * On a high level, recovery happens by a combination of comparing and subsequently synchronizing files and operations from the target to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066a5c64a8a02abbf7f06cd716d7829e5489d0e9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAyNjYzNQ==", "bodyText": "right :) fixed", "url": "https://github.com/elastic/elasticsearch/pull/64522#discussion_r524026635", "createdAt": "2020-11-16T09:33:14Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/package-info.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * <p>This package contains the logic for the recovery functionality.</p>\n+ *\n+ * <h2>Preliminaries</h2>\n+ *\n+ * Recoveries are started on data nodes as a result of data node discovering shard assignments to themselves in the cluster state. The\n+ * master node sets up these shard allocations in the cluster state (see {@link org.elasticsearch.cluster.routing.ShardRouting}).\n+ * If a data node finds shard allocations that require recovery on itself, it will execute the required recoveries by executing the\n+ * logic starting at {@link org.elasticsearch.indices.cluster.IndicesClusterStateService#createOrUpdateShards}. As the data nodes execute\n+ * the steps of the recovery state machine they report back success or failure to do so to the master node via the transport actions in\n+ * {@link org.elasticsearch.cluster.action.shard.ShardStateAction}, which will then update the shard routing in the cluster state\n+ * accordingly to reflect the status of the recovered shards or to handle failures in the recovery process. Recoveries can have various\n+ * kinds of sources that are modeled via the {@link org.elasticsearch.cluster.routing.RecoverySource} that is communicated to the recovery\n+ * target by {@link org.elasticsearch.cluster.routing.ShardRouting#recoverySource()} for each shard routing. These sources and their state\n+ * machines will be described below. The actual recovery process for all of them is started by invoking\n+ * {@link org.elasticsearch.index.shard.IndexShard#startRecovery}.\n+ *\n+ * <h3>Checkpoints</h3>\n+ *\n+ * Aspects of the recovery logic are based on the concepts of local and global checkpoints. Each operation on a shard is tracked by a\n+ * sequence number as well as the primary term during which it was applied to the index. The sequence number up to which operations have\n+ * been fully processed on a shard is that shard's local checkpoint. The sequence number up to which operations on all replicas for a shard\n+ * have been fully processed is referred to as the global checkpoint. Comparing the local checkpoints of shard copies enables determining\n+ * which operations would have to be replayed to a shard copy to bring it in-sync with the primary shard. By retaining operations in the\n+ * {@link org.elasticsearch.indices.recovery.RecoveryState.Translog} or in soft deletes, they are available for this kind of replay that\n+ * moves a shard lower local checkpoint up to a higher local checkpoint. The global checkpoint allows for determining which operations have\n+ * been safely processed on all shards and thus don't have to be retained on the primary node for replay to replicas.\n+ *\n+ * The primary node tracks the global checkpoint for a shard via the {@link org.elasticsearch.index.seqno.ReplicationTracker}. The primary\n+ * term is tracked by the master node and stored in the cluster state and incremented each time the primary node for a shard changes.\n+ *\n+ * <h3>Retention Leases</h3>\n+ *\n+ * The duration for which a shard retains individual operations for replay during recovery is governed by the\n+ * {@link org.elasticsearch.index.seqno.RetentionLease} functionality. More information about this functionality can be found in the\n+ * {@link org.elasticsearch.index.seqno} package and the \"History retention\" section in the docs.\n+ *\n+ * <h2>Recovery Types</h2>\n+ *\n+ * <h3>1. Peer Recovery</h3>\n+ *\n+ * Peer recovery is the process of bringing a shard copy on one node, referred to as the target node below, in-sync with the shard copy on\n+ * another node, referred to as the source node below. It is always the primary node of a shard that serves as the source of the recovery.\n+ * On a high level, recovery happens by a combination of comparing and subsequently synchronizing files and operations from the target to", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgyNTU4Nw=="}, "originalCommit": {"oid": "066a5c64a8a02abbf7f06cd716d7829e5489d0e9"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDM0OTYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/package-info.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMjo0OTowMlrOHzjy2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMjo0OTowMlrOHzjy2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgyNTg4MQ==", "bodyText": "We no longer use translog in peer recoveries since 8.0.", "url": "https://github.com/elastic/elasticsearch/pull/64522#discussion_r523825881", "createdAt": "2020-11-15T22:49:02Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/package-info.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * <p>This package contains the logic for the recovery functionality.</p>\n+ *\n+ * <h2>Preliminaries</h2>\n+ *\n+ * Recoveries are started on data nodes as a result of data node discovering shard assignments to themselves in the cluster state. The\n+ * master node sets up these shard allocations in the cluster state (see {@link org.elasticsearch.cluster.routing.ShardRouting}).\n+ * If a data node finds shard allocations that require recovery on itself, it will execute the required recoveries by executing the\n+ * logic starting at {@link org.elasticsearch.indices.cluster.IndicesClusterStateService#createOrUpdateShards}. As the data nodes execute\n+ * the steps of the recovery state machine they report back success or failure to do so to the master node via the transport actions in\n+ * {@link org.elasticsearch.cluster.action.shard.ShardStateAction}, which will then update the shard routing in the cluster state\n+ * accordingly to reflect the status of the recovered shards or to handle failures in the recovery process. Recoveries can have various\n+ * kinds of sources that are modeled via the {@link org.elasticsearch.cluster.routing.RecoverySource} that is communicated to the recovery\n+ * target by {@link org.elasticsearch.cluster.routing.ShardRouting#recoverySource()} for each shard routing. These sources and their state\n+ * machines will be described below. The actual recovery process for all of them is started by invoking\n+ * {@link org.elasticsearch.index.shard.IndexShard#startRecovery}.\n+ *\n+ * <h3>Checkpoints</h3>\n+ *\n+ * Aspects of the recovery logic are based on the concepts of local and global checkpoints. Each operation on a shard is tracked by a\n+ * sequence number as well as the primary term during which it was applied to the index. The sequence number up to which operations have\n+ * been fully processed on a shard is that shard's local checkpoint. The sequence number up to which operations on all replicas for a shard\n+ * have been fully processed is referred to as the global checkpoint. Comparing the local checkpoints of shard copies enables determining\n+ * which operations would have to be replayed to a shard copy to bring it in-sync with the primary shard. By retaining operations in the\n+ * {@link org.elasticsearch.indices.recovery.RecoveryState.Translog} or in soft deletes, they are available for this kind of replay that\n+ * moves a shard lower local checkpoint up to a higher local checkpoint. The global checkpoint allows for determining which operations have\n+ * been safely processed on all shards and thus don't have to be retained on the primary node for replay to replicas.\n+ *\n+ * The primary node tracks the global checkpoint for a shard via the {@link org.elasticsearch.index.seqno.ReplicationTracker}. The primary\n+ * term is tracked by the master node and stored in the cluster state and incremented each time the primary node for a shard changes.\n+ *\n+ * <h3>Retention Leases</h3>\n+ *\n+ * The duration for which a shard retains individual operations for replay during recovery is governed by the\n+ * {@link org.elasticsearch.index.seqno.RetentionLease} functionality. More information about this functionality can be found in the\n+ * {@link org.elasticsearch.index.seqno} package and the \"History retention\" section in the docs.\n+ *\n+ * <h2>Recovery Types</h2>\n+ *\n+ * <h3>1. Peer Recovery</h3>\n+ *\n+ * Peer recovery is the process of bringing a shard copy on one node, referred to as the target node below, in-sync with the shard copy on\n+ * another node, referred to as the source node below. It is always the primary node of a shard that serves as the source of the recovery.\n+ * On a high level, recovery happens by a combination of comparing and subsequently synchronizing files and operations from the target to\n+ * the source.\n+ * Synchronizing the on-disk file structure on the target with those on the source node is referred to as file-based recovery.\n+ * Synchronizing operations based on comparing checkpoints is commonly referred to as ops-based recovery. As primaries and replicas are\n+ * independent Lucene indices that will execute their Lucene level merges independently the concrete on-disk file structure on a pair of\n+ * primary and replica nodes for a given shard will diverge over time even if both copies of the shard hold the exact same set of documents\n+ * and operations. Peer recovery will therefore try to avoid file-based recovery where possible to reduce the amount of data that has to be\n+ * transferred. It will prefer replaying just those operations missing on the target relative to the source instead as this\n+ * avoids copying files from source to target that could contain data that is for the most part already present on the target.\n+ * Replaying operations is possible as long as the primary node retains the missing operations in its", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066a5c64a8a02abbf7f06cd716d7829e5489d0e9"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4043, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}