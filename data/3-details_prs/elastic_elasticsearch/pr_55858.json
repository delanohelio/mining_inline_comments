{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMTIzMDQ2", "number": 55858, "title": "Add auto create action", "bodyText": "Currently the TransportBulkAction detects whether an index is missing and\nthen decides whether it should be auto created. The coordination of the\nindex creation also happens in the TransportBulkAction on the coordinating node.\nThis change adds a new transport action that the TransportBulkAction delegates to\nif missing indices need to be created. The reasons for this change:\n\nAuto creation of data streams can't occur on the coordinating node.\nBased on the index template (v2) either a regular index or a data stream should be created.\nHowever if the coordinating node is slow in processing cluster state updates then it may be\nunaware of the existence of certain index templates, which then can load to the\nTransportBulkAction creating an index instead of a data stream. Therefor the coordination of\ncreating an index or data stream should occur on the master node. See #55377\nFrom a security perspective it is useful to know whether index creation originates from the\ncreate index api or from auto creating a new index via the bulk or index api. For example\na user would be allowed to auto create an index, but not to use the create index api. The\nauto create action will allow security to distinguish these two different patterns of\nindex creation.\n\nThis change adds the following new transport actions:\n\nAutoCreateAction, the TransportBulkAction redirects to this action and this action will actually create the index (instead of the TransportCreateIndexAction). Later via #55377, can improve the AutoCreateAction to also determine whether an index or data stream should be created.\n\nThe create_index index privilege is also modified, so that if this permission is granted then a user is also allowed to auto create indices. This change does not yet add an auto_create index privilege. A future change can introduce this new index privilege or modify an existing index / write index privilege.", "createdAt": "2020-04-28T13:34:27Z", "url": "https://github.com/elastic/elasticsearch/pull/55858", "merged": true, "mergeCommit": {"oid": "0a4428cb3920e4cb468b73f4283fafa1f2973d7c"}, "closed": true, "closedAt": "2020-05-04T15:06:04Z", "author": {"login": "martijnvg"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccD9vjgH2gAyNDEwMTIzMDQ2OjgwYWY3YjQ0NjI5MGFkZTU1MjI5NDRhZDVlNGZjZmU0MTc0ZmQ4Mzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceAPEQAFqTQwNTAzMjkwOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "80af7b446290ade5522944ad5e4fcfe4174fd839", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/80af7b446290ade5522944ad5e4fcfe4174fd839", "committedDate": "2020-04-28T13:33:07Z", "message": "Add auto create action\n\nCurrently the TransportBulkAction detects whether an index is missing and\nthen decides whether it should be auto created. The coordination of the\nindex creation also happens in the TransportBulkAction on the coordinating node.\n\nThis change adds a new transport action that the TransportBulkAction delegates to\nif missing indices need to be created. The reasons for this change:\n* Auto creation of data streams can't occur on the coordinating node.\n  Based on the index template (v2) either a regular index or a data stream should be created.\n  However if the coordinating node is unaware of certain index templates then the TransportBulkAction\n  could create an index instead of a data stream. Therefor the decision of whether an index or\n  data stream should be created should happen on the master node. See #55377\n* From a security perspective it is useful to know whether index creation originates from the\n  create index api or from auto creating a new index via the bulk or index api. For example\n  a user would be allowed to auto create an index, but not to use the create index api. The\n  auto create action will allow security to distinguish these two different patterns of\n  index creation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48a8d977837a6976a020d72888581ea210e67efe", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/48a8d977837a6976a020d72888581ea210e67efe", "committedDate": "2020-04-28T14:02:55Z", "message": "take into account date math in index names."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b241508ad0fa70e3552efb4556731aa67147875", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/0b241508ad0fa70e3552efb4556731aa67147875", "committedDate": "2020-04-28T15:23:38Z", "message": "Change request class to implement `IndicesRequest` interface, similar to create index request."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fe33c94ea74c1426565c3137117dd1392468674", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/9fe33c94ea74c1426565c3137117dd1392468674", "committedDate": "2020-04-28T18:49:35Z", "message": "Split index creation part of the AutoCreateAction class to AutoCreateIndexAction.\n\nThis is needed, because AutoCreateAction will make the decision whether to auto create an data stream\nor index, and AutoCreateIndexAction really auto creates the index. Future change will add\nAutoCreateDataStream action. If this logic is in a single action then we can't distingues\nwhether a data stream or index is being auto created, which is important because a user may be\nable to auto create a data stream, but not an index or visa versa."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8431d37c553d817275659fe00ea3b62b0d03fadf", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/8431d37c553d817275659fe00ea3b62b0d03fadf", "committedDate": "2020-04-28T19:43:30Z", "message": "fixed checkstyle violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b13dd497de6e7472471961b364302df04093350", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b13dd497de6e7472471961b364302df04093350", "committedDate": "2020-04-28T20:02:18Z", "message": "Merge remote-tracking branch 'es/master' into auto_create_action!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4dcc2bb95e3c59d9736847d097bba25f99e7bc", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/7f4dcc2bb95e3c59d9736847d097bba25f99e7bc", "committedDate": "2020-04-29T09:51:54Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6342f4a75ceaed2d11aafc466557e52b378ab9d0", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/6342f4a75ceaed2d11aafc466557e52b378ab9d0", "committedDate": "2020-04-29T10:12:21Z", "message": "Merge remote-tracking branch 'es/master' into auto_create_action!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "070df7114f8c7ac3687f04cdba03ed15d78b036e", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/070df7114f8c7ac3687f04cdba03ed15d78b036e", "committedDate": "2020-04-29T11:27:36Z", "message": "fixed test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "687d2841e34d1afb57b2c14736f88dd118e49d67", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/687d2841e34d1afb57b2c14736f88dd118e49d67", "committedDate": "2020-04-29T12:22:47Z", "message": "Merge remote-tracking branch 'es/master' into auto_create_action!"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjQ1NDI5", "url": "https://github.com/elastic/elasticsearch/pull/55858#pullrequestreview-403645429", "createdAt": "2020-04-30T15:42:49Z", "commit": {"oid": "687d2841e34d1afb57b2c14736f88dd118e49d67"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo0Mjo0OVrOGOvL-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo1NTozMlrOGOvvIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwNjM2Mg==", "bodyText": "I think it would be nicer to handle the ResourceAlreadyExistsException in the auto-create action.", "url": "https://github.com/elastic/elasticsearch/pull/55858#discussion_r418106362", "createdAt": "2020-04-30T15:42:49Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -235,36 +238,91 @@ protected void doExecute(Task task, BulkRequest bulkRequest, ActionListener<Bulk\n             if (autoCreateIndices.isEmpty()) {\n                 executeBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated);\n             } else {\n-                final AtomicInteger counter = new AtomicInteger(autoCreateIndices.size());\n-                for (String index : autoCreateIndices) {\n-                    createIndex(index, bulkRequest.preferV2Templates(), bulkRequest.timeout(), new ActionListener<>() {\n-                        @Override\n-                        public void onResponse(CreateIndexResponse result) {\n-                            if (counter.decrementAndGet() == 0) {\n-                                threadPool.executor(ThreadPool.Names.WRITE).execute(\n-                                    () -> executeBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated));\n+                if (state.getNodes().getMinNodeVersion().onOrAfter(Version.V_8_0_0)) {\n+                    CheckedConsumer<AutoCreateAction.Response, Exception> handler = response -> {\n+                        Exception suppressed = null;\n+                        for (Map.Entry<String, Exception> entry : response.getFailureByNames().entrySet()) {\n+                            Exception e = entry.getValue();\n+                            if (e == null || ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687d2841e34d1afb57b2c14736f88dd118e49d67"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMTA1OA==", "bodyText": "The map is in the response named \"failureByNames\". I think we should either not add successful indices into it, rename the map or separate the two parts in the response.", "url": "https://github.com/elastic/elasticsearch/pull/55858#discussion_r418111058", "createdAt": "2020-04-30T15:49:33Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/create/AutoCreateAction.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.create;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.CompositeIndicesRequest;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.MasterNodeReadRequest;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Proxy action for auto creating an indexable resource.\n+ * Currently only auto creates indices by redirecting to {@link AutoCreateIndexAction}.\n+ */\n+public final class AutoCreateAction extends ActionType<AutoCreateAction.Response> {\n+\n+    public static final AutoCreateAction INSTANCE = new AutoCreateAction();\n+    public static final String NAME = \"indices:admin/auto_create\";\n+\n+    private AutoCreateAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends MasterNodeReadRequest<Request> implements CompositeIndicesRequest {\n+\n+        private final Set<String> names;\n+        private final String cause;\n+        private final Boolean preferV2Templates;\n+\n+        public Request(Set<String> names, String cause, Boolean preferV2Templates) {\n+            this.names = Objects.requireNonNull(names);\n+            this.cause = Objects.requireNonNull(cause);\n+            this.preferV2Templates = preferV2Templates;\n+            assert names.size() != 0;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readSet(StreamInput::readString);\n+            this.cause = in.readString();\n+            this.preferV2Templates = in.readOptionalBoolean();\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringCollection(names);\n+            out.writeString(cause);\n+            out.writeOptionalBoolean(preferV2Templates);\n+        }\n+\n+        public Set<String> getNames() {\n+            return names;\n+        }\n+\n+        public String getCause() {\n+            return cause;\n+        }\n+\n+        public Boolean getPreferV2Templates() {\n+            return preferV2Templates;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Request request = (Request) o;\n+            return names.equals(request.names) &&\n+                Objects.equals(preferV2Templates, request.preferV2Templates);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(names, preferV2Templates);\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse {\n+\n+        private final Map<String, Exception> failureByNames;\n+\n+        public Response(Map<String, Exception> failureByNames) {\n+            this.failureByNames = failureByNames;\n+        }\n+\n+        public Response(StreamInput in) throws IOException {\n+            super(in);\n+            failureByNames = in.readMap(StreamInput::readString, StreamInput::readException);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeMap(failureByNames, StreamOutput::writeString, StreamOutput::writeException);\n+        }\n+\n+        public Map<String, Exception> getFailureByNames() {\n+            return failureByNames;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response response = (Response) o;\n+            /*\n+             * Exception does not implement equals(...) so we will compute the hash code based on the key set and the\n+             * messages.\n+             */\n+            return Objects.equals(getKeys(failureByNames), getKeys(response.failureByNames)) &&\n+                Objects.equals(getExceptionMessages(failureByNames), getExceptionMessages(response.failureByNames));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            /*\n+             * Exception does not implement hash code so we will compute the hash code based on the key set and the\n+             * messages.\n+             */\n+            return Objects.hash(getKeys(failureByNames), getExceptionMessages(failureByNames));\n+        }\n+\n+        private static List<String> getExceptionMessages(final Map<String, Exception> map) {\n+            return map.values().stream().map(Throwable::getMessage).sorted(String::compareTo).collect(Collectors.toList());\n+        }\n+\n+        private static List<String> getKeys(final Map<String, Exception> map) {\n+            return map.keySet().stream().sorted(String::compareTo).collect(Collectors.toList());\n+        }\n+    }\n+\n+    public static final class TransportAction extends TransportMasterNodeAction<Request, Response> {\n+\n+        private final Client client;\n+\n+        @Inject\n+        public TransportAction(TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                               ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver, Client client) {\n+            super(NAME, transportService, clusterService, threadPool, actionFilters, Request::new, indexNameExpressionResolver);\n+            this.client = client;\n+        }\n+\n+        @Override\n+        protected String executor() {\n+            return ThreadPool.Names.SAME;\n+        }\n+\n+        @Override\n+        protected Response read(StreamInput in) throws IOException {\n+            return new Response(in);\n+        }\n+\n+        @Override\n+        protected void masterOperation(Task task,\n+                                       Request request,\n+                                       ClusterState state,\n+                                       ActionListener<Response> listener) {\n+            autoCreate(request, listener, client);\n+        }\n+\n+        @Override\n+        protected ClusterBlockException checkBlock(Request request, ClusterState state) {\n+            return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, request.names.toArray(new String[0]));\n+        }\n+    }\n+\n+    static void autoCreate(Request request, ActionListener<Response> listener, Client client) {\n+        // For now always redirect to the auto create index action, because only indices get auto created.\n+        final AtomicInteger counter = new AtomicInteger(request.getNames().size());\n+        final Map<String, Exception> results = new HashMap<>();\n+        for (String name : request.getNames()) {\n+            CreateIndexRequest createIndexRequest = new CreateIndexRequest();\n+            createIndexRequest.index(name);\n+            createIndexRequest.cause(request.getCause());\n+            createIndexRequest.masterNodeTimeout(request.masterNodeTimeout());\n+            createIndexRequest.preferV2Templates(request.getPreferV2Templates());\n+            client.execute(AutoCreateIndexAction.INSTANCE, createIndexRequest, ActionListener.wrap(\n+                createIndexResponse -> {\n+                    // Maybe a bit overkill to ensure visibility of results map across threads...\n+                    synchronized (results) {\n+                        results.put(name, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687d2841e34d1afb57b2c14736f88dd118e49d67"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExNTM2MA==", "bodyText": "By delegating to a separate transport action, we risk that the retry on no longer master happens inside that transport action, making any decision we make on cluster state here invalid (or at least potentially stale). I would much prefer to do the cluster state update here.\nThat way we could also create all the indices and streams in one go, reducing the number of cluster states published.\nI think auto-create does not have to be specific to data stream or index. It goes together with the document level privileges which are also agnostic of whether the data ends up in a data stream or an index.", "url": "https://github.com/elastic/elasticsearch/pull/55858#discussion_r418115360", "createdAt": "2020-04-30T15:55:32Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/create/AutoCreateAction.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.create;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.CompositeIndicesRequest;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.MasterNodeReadRequest;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Proxy action for auto creating an indexable resource.\n+ * Currently only auto creates indices by redirecting to {@link AutoCreateIndexAction}.\n+ */\n+public final class AutoCreateAction extends ActionType<AutoCreateAction.Response> {\n+\n+    public static final AutoCreateAction INSTANCE = new AutoCreateAction();\n+    public static final String NAME = \"indices:admin/auto_create\";\n+\n+    private AutoCreateAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends MasterNodeReadRequest<Request> implements CompositeIndicesRequest {\n+\n+        private final Set<String> names;\n+        private final String cause;\n+        private final Boolean preferV2Templates;\n+\n+        public Request(Set<String> names, String cause, Boolean preferV2Templates) {\n+            this.names = Objects.requireNonNull(names);\n+            this.cause = Objects.requireNonNull(cause);\n+            this.preferV2Templates = preferV2Templates;\n+            assert names.size() != 0;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readSet(StreamInput::readString);\n+            this.cause = in.readString();\n+            this.preferV2Templates = in.readOptionalBoolean();\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringCollection(names);\n+            out.writeString(cause);\n+            out.writeOptionalBoolean(preferV2Templates);\n+        }\n+\n+        public Set<String> getNames() {\n+            return names;\n+        }\n+\n+        public String getCause() {\n+            return cause;\n+        }\n+\n+        public Boolean getPreferV2Templates() {\n+            return preferV2Templates;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Request request = (Request) o;\n+            return names.equals(request.names) &&\n+                Objects.equals(preferV2Templates, request.preferV2Templates);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(names, preferV2Templates);\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse {\n+\n+        private final Map<String, Exception> failureByNames;\n+\n+        public Response(Map<String, Exception> failureByNames) {\n+            this.failureByNames = failureByNames;\n+        }\n+\n+        public Response(StreamInput in) throws IOException {\n+            super(in);\n+            failureByNames = in.readMap(StreamInput::readString, StreamInput::readException);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeMap(failureByNames, StreamOutput::writeString, StreamOutput::writeException);\n+        }\n+\n+        public Map<String, Exception> getFailureByNames() {\n+            return failureByNames;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response response = (Response) o;\n+            /*\n+             * Exception does not implement equals(...) so we will compute the hash code based on the key set and the\n+             * messages.\n+             */\n+            return Objects.equals(getKeys(failureByNames), getKeys(response.failureByNames)) &&\n+                Objects.equals(getExceptionMessages(failureByNames), getExceptionMessages(response.failureByNames));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            /*\n+             * Exception does not implement hash code so we will compute the hash code based on the key set and the\n+             * messages.\n+             */\n+            return Objects.hash(getKeys(failureByNames), getExceptionMessages(failureByNames));\n+        }\n+\n+        private static List<String> getExceptionMessages(final Map<String, Exception> map) {\n+            return map.values().stream().map(Throwable::getMessage).sorted(String::compareTo).collect(Collectors.toList());\n+        }\n+\n+        private static List<String> getKeys(final Map<String, Exception> map) {\n+            return map.keySet().stream().sorted(String::compareTo).collect(Collectors.toList());\n+        }\n+    }\n+\n+    public static final class TransportAction extends TransportMasterNodeAction<Request, Response> {\n+\n+        private final Client client;\n+\n+        @Inject\n+        public TransportAction(TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                               ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver, Client client) {\n+            super(NAME, transportService, clusterService, threadPool, actionFilters, Request::new, indexNameExpressionResolver);\n+            this.client = client;\n+        }\n+\n+        @Override\n+        protected String executor() {\n+            return ThreadPool.Names.SAME;\n+        }\n+\n+        @Override\n+        protected Response read(StreamInput in) throws IOException {\n+            return new Response(in);\n+        }\n+\n+        @Override\n+        protected void masterOperation(Task task,\n+                                       Request request,\n+                                       ClusterState state,\n+                                       ActionListener<Response> listener) {\n+            autoCreate(request, listener, client);\n+        }\n+\n+        @Override\n+        protected ClusterBlockException checkBlock(Request request, ClusterState state) {\n+            return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, request.names.toArray(new String[0]));\n+        }\n+    }\n+\n+    static void autoCreate(Request request, ActionListener<Response> listener, Client client) {\n+        // For now always redirect to the auto create index action, because only indices get auto created.\n+        final AtomicInteger counter = new AtomicInteger(request.getNames().size());\n+        final Map<String, Exception> results = new HashMap<>();\n+        for (String name : request.getNames()) {\n+            CreateIndexRequest createIndexRequest = new CreateIndexRequest();\n+            createIndexRequest.index(name);\n+            createIndexRequest.cause(request.getCause());\n+            createIndexRequest.masterNodeTimeout(request.masterNodeTimeout());\n+            createIndexRequest.preferV2Templates(request.getPreferV2Templates());\n+            client.execute(AutoCreateIndexAction.INSTANCE, createIndexRequest, ActionListener.wrap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687d2841e34d1afb57b2c14736f88dd118e49d67"}, "originalPosition": 222}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9705bde126df93945085eb477d862a4a56d553d6", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/9705bde126df93945085eb477d862a4a56d553d6", "committedDate": "2020-05-01T07:11:47Z", "message": "Merge remote-tracking branch 'es/master' into auto_create_action!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7095f79fe245900b3669df7f16f8100f465b2d5d", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/7095f79fe245900b3669df7f16f8100f465b2d5d", "committedDate": "2020-05-03T20:28:48Z", "message": "Simplify auto create index logic:\n* One action for auto creating indices and in the future also auto create data streams\n* The TransportBulkAction just executes the auto create action like the create index action.\n* Avoid the complexity of auto creating indices in a single request / cluster state update.\n  This adds quite some complexity while the benefits are likely only noticeable in edge cases\n  (if many indices get auto created)) Also on the security side, authorization of the auto\n  create indices would become much more complex compared to authorization of auto creating\n  an index one at a time."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "111420f8d8ee20cf0e906b72eb8f957a349165c3", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/111420f8d8ee20cf0e906b72eb8f957a349165c3", "committedDate": "2020-05-03T20:29:17Z", "message": "Merge remote-tracking branch 'es/master' into auto_create_action!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58575da2e3babda8a1292410bdf84c7ba06966b2", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/58575da2e3babda8a1292410bdf84c7ba06966b2", "committedDate": "2020-05-03T20:33:02Z", "message": "removed unused imports and class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa36c850fbfcbcd98eb20cdb3ed903ee06fbcedc", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa36c850fbfcbcd98eb20cdb3ed903ee06fbcedc", "committedDate": "2020-05-04T14:11:51Z", "message": "Added integration test for auto index creation and the auto_create index privilege"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MDMyOTA4", "url": "https://github.com/elastic/elasticsearch/pull/55858#pullrequestreview-405032908", "createdAt": "2020-05-04T14:20:16Z", "commit": {"oid": "fa36c850fbfcbcd98eb20cdb3ed903ee06fbcedc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 470, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}