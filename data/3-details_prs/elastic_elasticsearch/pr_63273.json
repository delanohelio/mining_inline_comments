{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MDEyOTc4", "number": 63273, "title": "Check docs limit before indexing on primary", "bodyText": "Today indexing to a shard with 2147483519 documents will fail that shard. We should check the number of documents and reject the write requests instead.\nCloses #51136", "createdAt": "2020-10-05T17:42:36Z", "url": "https://github.com/elastic/elasticsearch/pull/63273", "merged": true, "mergeCommit": {"oid": "2b5e337e8940d8027b10612a3b5cbd3c39fd84e2"}, "closed": true, "closedAt": "2020-10-13T14:50:34Z", "author": {"login": "dnhatn"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdPnZvpgH2gAyNDk4MDEyOTc4Ojg0NTFlOTYxM2FkOGIzMDJlZWZjOTYxOGYyNWQ0MTFhOTMxNGFmM2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQjkZDgFqTUwNDkyMzE5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8451e9613ad8b302eefc9618f25d411a9314af3e", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/8451e9613ad8b302eefc9618f25d411a9314af3e", "committedDate": "2020-10-05T17:40:31Z", "message": "Check docs limit before indexing on primary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12aaf83f775411b369a0dc504ec04a9d46f868df", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/12aaf83f775411b369a0dc504ec04a9d46f868df", "committedDate": "2020-10-05T18:54:07Z", "message": "unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5e10be04004d2c735f20a5daf342ce44235cf53", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5e10be04004d2c735f20a5daf342ce44235cf53", "committedDate": "2020-10-06T01:41:57Z", "message": "Merge branch 'master' into check-docs-limit-on-primary"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNzA1MDkw", "url": "https://github.com/elastic/elasticsearch/pull/63273#pullrequestreview-502705090", "createdAt": "2020-10-06T08:33:43Z", "commit": {"oid": "f5e10be04004d2c735f20a5daf342ce44235cf53"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwODozMzo0NFrOHc7rHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwODozNTowMVrOHc7uBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ==", "bodyText": "I'm wondering why we use a margin of 1000 docs here. IIUC the index writer will only under-count the total by at most one doc per write thread?\nOTOH if there is more severe under-counting under concurrent load then is 1000 enough?", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500099869", "createdAt": "2020-10-06T08:33:44Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -176,6 +176,16 @@\n     private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();\n     private final AtomicBoolean shouldPeriodicallyFlushAfterBigMerge = new AtomicBoolean(false);\n \n+    /**\n+     * If multiple writes passed {@link InternalEngine#testReserveDocs(Operation, int)} (int)} but haven't adjusted\n+     * {@link IndexWriter#getPendingNumDocs()} yet, then IndexWriter can fail with too many documents. In this case,\n+     * we have to fail the engine because we already generated sequence numbers for write operations; otherwise we\n+     * will have gaps in sequence numbers. To avoid this (best-effort), we use a lower limit when trying to reserve\n+     * documents in InternalEngine.\n+     */\n+    static final int DEFAULT_MAX_DOCS = IndexWriter.MAX_DOCS - 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e10be04004d2c735f20a5daf342ce44235cf53"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMDYxNA==", "bodyText": "Could we run this test (or a similar one) with concurrent indexing too, to demonstrate that we only exceed the limit by a bounded amount?", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500100614", "createdAt": "2020-10-06T08:35:01Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.engine;\n+\n+import org.apache.lucene.index.IndexWriterMaxDocsChanger;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.plugins.EnginePlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class MaxDocsLimitIT extends ESIntegTestCase {\n+\n+    public static class TestEnginePlugin extends Plugin implements EnginePlugin {\n+        public static final int maxDocs = randomIntBetween(1, 20);\n+\n+        @Override\n+        public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n+            return Optional.of(config -> EngineTestCase.createEngine(config, maxDocs));\n+        }\n+    }\n+\n+    @Override\n+    protected boolean addMockInternalEngine() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(TestEnginePlugin.class);\n+        return plugins;\n+    }\n+\n+    public void testMaxDocsLimit() throws Exception {\n+        final int maxDocs = TestEnginePlugin.maxDocs;\n+        IndexWriterMaxDocsChanger.setMaxDocs(maxDocs);\n+        try {\n+            internalCluster().ensureAtLeastNumDataNodes(1);\n+            assertAcked(client().admin().indices().prepareCreate(\"test\")\n+                .setSettings(Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+                    .put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.REQUEST)));\n+            int numDocs = randomIntBetween(maxDocs + 1, maxDocs * 2);\n+            for (int i = 0; i < numDocs; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e10be04004d2c735f20a5daf342ce44235cf53"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efa8145303e98c3a1b9f4886691a5cfbd5c548b4", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/efa8145303e98c3a1b9f4886691a5cfbd5c548b4", "committedDate": "2020-10-07T14:48:57Z", "message": "Keep track reserving docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25ee199696d3beda0fed96025e5df5ffb72063b1", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/25ee199696d3beda0fed96025e5df5ffb72063b1", "committedDate": "2020-10-07T14:51:29Z", "message": "Merge branch 'master' into check-docs-limit-on-primary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1d7ade6034dd18c94afa2d7d1d68aaa910e7f39", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1d7ade6034dd18c94afa2d7d1d68aaa910e7f39", "committedDate": "2020-10-07T15:01:09Z", "message": "wording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/95189c54bf1269c540f16a757d7063821b13fdbe", "committedDate": "2020-10-07T15:05:17Z", "message": "more wording"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDA1MzQ0", "url": "https://github.com/elastic/elasticsearch/pull/63273#pullrequestreview-504005344", "createdAt": "2020-10-07T15:28:53Z", "commit": {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToyODo1M1rOHd5GSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTozMzoxM1rOHd5S5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNjI1MA==", "bodyText": "Can we make this assertion more generally too? IIRC there are some other assertions that check that things have settled down after a test (no in-flight operations, for instance) although I'm not quite sure where they are.", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501106250", "createdAt": "2020-10-07T15:28:53Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.engine;\n+\n+import org.apache.lucene.index.IndexWriterMaxDocsChanger;\n+import org.apache.lucene.store.AlreadyClosedException;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.IndexShardTestCase;\n+import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.plugins.EnginePlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.both;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+\n+public class MaxDocsLimitIT extends ESIntegTestCase {\n+\n+    private static final AtomicInteger maxDocs = new AtomicInteger();\n+\n+    public static class TestEnginePlugin extends Plugin implements EnginePlugin {\n+        @Override\n+        public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n+            return Optional.of(config -> {\n+                assert maxDocs.get() > 0 : \"maxDocs is unset\";\n+                return EngineTestCase.createEngine(config, maxDocs.get());\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected boolean addMockInternalEngine() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(TestEnginePlugin.class);\n+        return plugins;\n+    }\n+\n+    @Before\n+    public void setMaxDocs() {\n+        maxDocs.set(randomIntBetween(10, 100)); // Do not set this too low as we can fail to write the cluster state\n+        IndexWriterMaxDocsChanger.setMaxDocs(maxDocs.get());\n+    }\n+\n+    @After\n+    public void restoreMaxDocs() {\n+        IndexWriterMaxDocsChanger.restoreMaxDocs();\n+    }\n+\n+    public static void assertNoOutstandingReservingDocs() throws Exception {\n+        assertBusy(() -> {\n+            for (IndicesService indicesService : internalCluster().getDataNodeInstances(IndicesService.class)) {\n+                for (IndexService indexService : indicesService) {\n+                    for (IndexShard indexShard : indexService) {\n+                        try {\n+                            assertThat(EngineTestCase.getReservingDocs(IndexShardTestCase.getEngine(indexShard)), equalTo(0L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNzY5Mw==", "bodyText": "Naming nit: reserved feels rather too general a term for me, how would you feel about renaming this something like inFlightDocCount instead?", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501107693", "createdAt": "2020-10-07T15:30:39Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -176,6 +176,18 @@\n     private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();\n     private final AtomicBoolean shouldPeriodicallyFlushAfterBigMerge = new AtomicBoolean(false);\n \n+    /**\n+     * If multiple writes passed {@link InternalEngine#tryReserveDocs(Operation, int)} but they haven't adjusted\n+     * {@link IndexWriter#getPendingNumDocs()} yet, then IndexWriter can fail with too many documents. In this case, we have to fail\n+     * the engine because we already generated sequence numbers for write operations; otherwise we will have gaps in sequence numbers.\n+     * To avoid this, we keep track the number of documents that are being added to IndexWriter, and account it in\n+     * {@link InternalEngine#tryReserveDocs(Operation, int)}. Although we can double count some adding documents in both IW and Engine,\n+     * this shouldn't be an issue because it happens for a short window and we adjust the reservingNumDocs once an indexing is completed.\n+     */\n+    private final AtomicLong reservingNumDocs = new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTE0Nw==", "bodyText": "Since we only ever use this to release the docs, how about renaming this to something like releaseInFlightDocs  and accepting a positive parameter instead?", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501109147", "createdAt": "2020-10-07T15:32:45Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -1275,11 +1308,35 @@ public DeleteResult delete(Delete delete) throws IOException {\n                 e.addSuppressed(inner);\n             }\n             throw e;\n+        } finally {\n+            adjustReservingDocs(-reservedDocs);\n         }\n         maybePruneDeletes();\n         return deleteResult;\n     }\n \n+    private Exception tryReserveDocs(Operation operation, int addingDocs) {\n+        assert operation.origin() == Operation.Origin.PRIMARY : operation;\n+        assert operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO : operation;\n+        final long totalDocs = indexWriter.getPendingNumDocs() + reservingNumDocs.addAndGet(addingDocs);\n+        if (totalDocs > maxDocs) {\n+            adjustReservingDocs(-addingDocs);\n+            return new IllegalArgumentException(\"Number of documents in the index can't exceed [\" + maxDocs + \"]\");\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private void adjustReservingDocs(int numDocs) {\n+        assert numDocs <= 0 : numDocs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTQ3Ng==", "bodyText": "Contrasting with releaseInFlightDocs how about tryAcquireInFlightDocs?", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501109476", "createdAt": "2020-10-07T15:33:13Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -1275,11 +1308,35 @@ public DeleteResult delete(Delete delete) throws IOException {\n                 e.addSuppressed(inner);\n             }\n             throw e;\n+        } finally {\n+            adjustReservingDocs(-reservedDocs);\n         }\n         maybePruneDeletes();\n         return deleteResult;\n     }\n \n+    private Exception tryReserveDocs(Operation operation, int addingDocs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "294fcb478194df3b0ab9f659e42a9946ad5ab519", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/294fcb478194df3b0ab9f659e42a9946ad5ab519", "committedDate": "2020-10-07T16:02:06Z", "message": "Naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "290806d102a5f63ecd2af1476ba0fffb360ffc77", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/290806d102a5f63ecd2af1476ba0fffb360ffc77", "committedDate": "2020-10-07T16:03:21Z", "message": "Assert after test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4f74408057ee81b3fab8cedc2d50a39275da120", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/c4f74408057ee81b3fab8cedc2d50a39275da120", "committedDate": "2020-10-07T16:41:21Z", "message": "line length"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTIzMTkw", "url": "https://github.com/elastic/elasticsearch/pull/63273#pullrequestreview-504923190", "createdAt": "2020-10-08T15:46:27Z", "commit": {"oid": "c4f74408057ee81b3fab8cedc2d50a39275da120"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4425, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}