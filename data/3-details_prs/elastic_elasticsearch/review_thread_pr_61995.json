{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NzE3MzEz", "number": 61995, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDowODoxMlrOEgZZ4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwOTo0MDozN1rOEjgk0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDA2MTEzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDowODoxMlrOHNO98w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjo0Nzo1MFrOHPFo1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzODc3MQ==", "bodyText": "I think this is the most controversial part of this change. Previously we were building the SourceLookup in the fetch phase and letting things that needed doc values at fetch time use the standard search lookup. This starts us down a road to removing that. I think we like this because we don't want things like the explain sub-phase to modify the rest of the fetch phases.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483638771", "createdAt": "2020-09-04T14:08:12Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -299,6 +299,18 @@ public SearchLookup lookup() {\n         return this.lookup;\n     }\n \n+    private SearchLookup fetchLookup = null;\n+\n+    public SearchLookup fetchLookup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyMjg0Nw==", "bodyText": "Could we just create a SearchLookup within FetchPhase? I think we could store it on HitContext instead of storing SourceLookup directly. That would make its scope and lifetime clearer. It also feels weird to me to put this on QueryShardContext, since it's not meant to be used during the query phase.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485122847", "createdAt": "2020-09-08T18:41:57Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -299,6 +299,18 @@ public SearchLookup lookup() {\n         return this.lookup;\n     }\n \n+    private SearchLookup fetchLookup = null;\n+\n+    public SearchLookup fetchLookup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzODc3MQ=="}, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNTczNQ==", "bodyText": "Hmmmmm. Let me dig into this again! I did it this way when I was building things really early and needed something in a much more \"global\" place to do the building.\nI was trying not to modify HitContext so much - maybe it can be something we pass in to the phases when we build them. I'll take another look.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485135735", "createdAt": "2020-09-08T19:05:38Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -299,6 +299,18 @@ public SearchLookup lookup() {\n         return this.lookup;\n     }\n \n+    private SearchLookup fetchLookup = null;\n+\n+    public SearchLookup fetchLookup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzODc3MQ=="}, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxMjUzMw==", "bodyText": "We can create SearchLookup just for the FetchPhase. I'll push a change that does that. Sadly, we still have to delegate to QueryShardContext to create it because it is the thing with all of the right dependencies.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485212533", "createdAt": "2020-09-08T21:42:48Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -299,6 +299,18 @@ public SearchLookup lookup() {\n         return this.lookup;\n     }\n \n+    private SearchLookup fetchLookup = null;\n+\n+    public SearchLookup fetchLookup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzODc3MQ=="}, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2OTc0MA==", "bodyText": "I've pushed the change.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485569740", "createdAt": "2020-09-09T12:26:06Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -299,6 +299,18 @@ public SearchLookup lookup() {\n         return this.lookup;\n     }\n \n+    private SearchLookup fetchLookup = null;\n+\n+    public SearchLookup fetchLookup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzODc3MQ=="}, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MzA2Mg==", "bodyText": "I guess I need to read this discussion because I have been asking questions around this as part of my review :)", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485583062", "createdAt": "2020-09-09T12:47:50Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -299,6 +299,18 @@ public SearchLookup lookup() {\n         return this.lookup;\n     }\n \n+    private SearchLookup fetchLookup = null;\n+\n+    public SearchLookup fetchLookup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzODc3MQ=="}, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDA2Njk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDowOTo0NlrOHNPBdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDowOTo0NlrOHNPBdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzOTY3MA==", "bodyText": "Now that all of the phases get a SearchLookup when they are built we could remove this and rely on them closing over what they need at construction time. That is pretty much what the doc values fetcher does, but not all of them do it. I think it is a bit confusing that some do and some don't, but I don't think now is the right time to make that change.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483639670", "createdAt": "2020-09-04T14:09:46Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "diffHunk": "@@ -252,7 +252,14 @@ private HitContext prepareNonNestedHitContext(SearchContext context,\n         int subDocId = docId - subReaderContext.docBase;\n         if (fieldsVisitor == null) {\n             SearchHit hit = new SearchHit(docId, null, null, null);\n-            return new HitContext(hit, subReaderContext, subDocId, context.searcher(), sharedCache);\n+            return new HitContext(\n+                hit,\n+                subReaderContext,\n+                subDocId,\n+                context.searcher(),\n+                context.getQueryShardContext().fetchLookup().source(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDA3MDA0OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchDocValuesPhase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoxMDo0MVrOHNPDWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoxMDo0MVrOHNPDWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MDE1Mg==", "bodyText": "All of the \"brains\" of this stuff has moved into the LeafFieldData implementations.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483640152", "createdAt": "2020-09-04T14:10:41Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchDocValuesPhase.java", "diffHunk": "@@ -90,149 +84,19 @@ public void process(HitContext hit) throws IOException {\n                         // docValues fields will still be document fields, and put under \"fields\" section of a hit.\n                         hit.hit().setDocumentField(f.field, hitField);\n                     }\n-                    f.setValues(hit.docId(), hitField);\n+                    hitField.getValues().addAll(f.fetcher.fetchValues(hit.sourceLookup()));\n                 }\n             }\n         };\n     }\n \n-    private abstract static class DocValueField {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDA3ODk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeScriptFieldMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoxMzoxNVrOHNPI9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoxMzoxNVrOHNPI9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MTU5MQ==", "bodyText": "Given that everything else is in the LeafFieldData implemenations, this is all we need in runtime fields!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483641591", "createdAt": "2020-09-04T14:13:15Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeScriptFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), () -> lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f46a63c917eb35e704e8c55345b9acd3d6cf30"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDg2NzkxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchDocValuesPhase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNzo0MDo0MFrOHNWuAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDoxOTo0NlrOHPY3iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc2NTc2Mw==", "bodyText": "I don't have a strong opinion, but it feels simpler to to use a LinkedHashMap and remove this class DocValueField.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483765763", "createdAt": "2020-09-04T17:40:40Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchDocValuesPhase.java", "diffHunk": "@@ -90,149 +84,19 @@ public void process(HitContext hit) throws IOException {\n                         // docValues fields will still be document fields, and put under \"fields\" section of a hit.\n                         hit.hit().setDocumentField(f.field, hitField);\n                     }\n-                    f.setValues(hit.docId(), hitField);\n+                    hitField.getValues().addAll(f.fetcher.fetchValues(hit.sourceLookup()));\n                 }\n             }\n         };\n     }\n \n-    private abstract static class DocValueField {\n-\n-        final String field;\n-        final DocValueFormat format;\n+    private class DocValueField {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNjQ1Mg==", "bodyText": "I tried swapping this to a map and it broke tests! I've pushed c63a886 to revert that change and explain why it has to stay with these tuples.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485606452", "createdAt": "2020-09-09T13:22:29Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchDocValuesPhase.java", "diffHunk": "@@ -90,149 +84,19 @@ public void process(HitContext hit) throws IOException {\n                         // docValues fields will still be document fields, and put under \"fields\" section of a hit.\n                         hit.hit().setDocumentField(f.field, hitField);\n                     }\n-                    f.setValues(hit.docId(), hitField);\n+                    hitField.getValues().addAll(f.fetcher.fetchValues(hit.sourceLookup()));\n                 }\n             }\n         };\n     }\n \n-    private abstract static class DocValueField {\n-\n-        final String field;\n-        final DocValueFormat format;\n+    private class DocValueField {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc2NTc2Mw=="}, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5ODEyMw==", "bodyText": "I'm not sure it's actually good we support retrieving the same field twice (!) but it definitely makes sense not to touch this behavior now. Thanks for looking into it.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485898123", "createdAt": "2020-09-09T20:19:46Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchDocValuesPhase.java", "diffHunk": "@@ -90,149 +84,19 @@ public void process(HitContext hit) throws IOException {\n                         // docValues fields will still be document fields, and put under \"fields\" section of a hit.\n                         hit.hit().setDocumentField(f.field, hitField);\n                     }\n-                    f.setValues(hit.docId(), hitField);\n+                    hitField.getValues().addAll(f.fetcher.fetchValues(hit.sourceLookup()));\n                 }\n             }\n         };\n     }\n \n-    private abstract static class DocValueField {\n-\n-        final String field;\n-        final DocValueFormat format;\n+    private class DocValueField {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc2NTc2Mw=="}, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDk3ODYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODoyMTozN1rOHNXxeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxOToyODoxN1rOHNZY5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MzAzNA==", "bodyText": "Am I understanding correctly that we lazily initialize here because the value fetchers are potentially created early, when constructing FieldValueRetriever inside FetchFieldsContext?\nIt feels natural to move the construction of FieldValueRetriever to FetchFieldsPhase#getProcessor, since fetch phases can now maintain state (after @romseygeek's nice refactor) ?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483783034", "createdAt": "2020-09-04T18:21:37Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.lookup.SourceLookup;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final Supplier<IndexFieldData<?>> ifdSource;\n+    /**\n+     * Field data implementation to load the values. Lazily initialized\n+     * because it is expensive.\n+     */\n+    private IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    /**\n+     * Build the fetcher.\n+     * @param format the format to use\n+     * @param ifdSource a supplier that will build the field data when we need it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwOTUwOQ==", "bodyText": "Yeah, I looked into moving the construction but it didn't feel good. I'll give it another look. I'm sure I missed something.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483809509", "createdAt": "2020-09-04T19:28:17Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.lookup.SourceLookup;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final Supplier<IndexFieldData<?>> ifdSource;\n+    /**\n+     * Field data implementation to load the values. Lazily initialized\n+     * because it is expensive.\n+     */\n+    private IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    /**\n+     * Build the fetcher.\n+     * @param format the format to use\n+     * @param ifdSource a supplier that will build the field data when we need it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MzAzNA=="}, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTA3NDAyOnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODo1ODo1M1rOHNYsNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMDo1MzoyOFrOHNbOkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5ODA2OA==", "bodyText": "This is pretty complex, and although MapperTestCase is a unit test, it feels closer to an integration test. Are you primarily trying to add coverage docvalue_fields on dates? It could be natural to just add some cases to SearchFieldsIT.\nIt feels like a bigger change (perhaps for a follow-up?) to figure out how to test docvalue_fields effectively. As we discussed, there's not great test coverage for it, especially not in terms of unit tests.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483798068", "createdAt": "2020-09-04T18:58:53Z", "author": {"login": "jtibshirani"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "diffHunk": "@@ -122,19 +143,78 @@ public final void testMeta() throws IOException {\n         );\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) throws IOException {\n         return fetchSourceValue(mapper, sourceValue, null);\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) throws IOException {\n         String field = mapper.name();\n \n         MapperService mapperService = mock(MapperService.class);\n         when(mapperService.sourcePath(field)).thenReturn(Set.of(field));\n \n-        ValueFetcher fetcher = mapper.valueFetcher(mapperService, format);\n+        ValueFetcher fetcher = mapper.valueFetcher(mapperService, null, format);\n         SourceLookup lookup = new SourceLookup();\n         lookup.setSource(Collections.singletonMap(field, sourceValue));\n         return fetcher.fetchValues(lookup);\n     }\n+\n+    /**\n+     * Use a {@linkplain FieldMapper} to extract values from doc values.\n+     */\n+    protected final List<?> fetchFromDocValues(FieldMapper mapper, DocValueFormat format, Object sourceValue) throws IOException {\n+        MapperService mapperService = mock(MapperService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgxMDc3OA==", "bodyText": "Yeah, I'm try to do an end to end test of doc values saving and loading. I agree it is a super big \"unit\" for a unit test, but its way smaller than spinning up a whole cluster.\nI could have done this for keywords or other fields but it felt like dates were the hardest thing.\nWe have fairly similar tests to this for the other field mappers but they use the json parsing to build the mapper so they get a lot of the infrastructure that we mock for free. Honestly that might be a better way to do it.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483810778", "createdAt": "2020-09-04T19:31:36Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "diffHunk": "@@ -122,19 +143,78 @@ public final void testMeta() throws IOException {\n         );\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) throws IOException {\n         return fetchSourceValue(mapper, sourceValue, null);\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) throws IOException {\n         String field = mapper.name();\n \n         MapperService mapperService = mock(MapperService.class);\n         when(mapperService.sourcePath(field)).thenReturn(Set.of(field));\n \n-        ValueFetcher fetcher = mapper.valueFetcher(mapperService, format);\n+        ValueFetcher fetcher = mapper.valueFetcher(mapperService, null, format);\n         SourceLookup lookup = new SourceLookup();\n         lookup.setSource(Collections.singletonMap(field, sourceValue));\n         return fetcher.fetchValues(lookup);\n     }\n+\n+    /**\n+     * Use a {@linkplain FieldMapper} to extract values from doc values.\n+     */\n+    protected final List<?> fetchFromDocValues(FieldMapper mapper, DocValueFormat format, Object sourceValue) throws IOException {\n+        MapperService mapperService = mock(MapperService.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5ODA2OA=="}, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzOTYzNA==", "bodyText": "I pushed some code to remove some of the mocking and use some of the rest of the infrastructure that we use to test field mappers.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483839634", "createdAt": "2020-09-04T20:53:28Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "diffHunk": "@@ -122,19 +143,78 @@ public final void testMeta() throws IOException {\n         );\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) throws IOException {\n         return fetchSourceValue(mapper, sourceValue, null);\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) throws IOException {\n         String field = mapper.name();\n \n         MapperService mapperService = mock(MapperService.class);\n         when(mapperService.sourcePath(field)).thenReturn(Set.of(field));\n \n-        ValueFetcher fetcher = mapper.valueFetcher(mapperService, format);\n+        ValueFetcher fetcher = mapper.valueFetcher(mapperService, null, format);\n         SourceLookup lookup = new SourceLookup();\n         lookup.setSource(Collections.singletonMap(field, sourceValue));\n         return fetcher.fetchValues(lookup);\n     }\n+\n+    /**\n+     * Use a {@linkplain FieldMapper} to extract values from doc values.\n+     */\n+    protected final List<?> fetchFromDocValues(FieldMapper mapper, DocValueFormat format, Object sourceValue) throws IOException {\n+        MapperService mapperService = mock(MapperService.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5ODA2OA=="}, "originalCommit": {"oid": "ef3b2a4197d3fe649a06cfb9787e9b730ffe93fa"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTI1NDE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMDoxMDo0M1rOHNaWeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMDoxNjo1M1rOHNafEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyNTI3Mg==", "bodyText": "Could we just store and expose fields on this context? It feels confusing to me to store a FieldValueRetriever supplier instead. Then we could take a simple approach where FetchFieldsPhase just constructs the FieldValueRetriever directly.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483825272", "createdAt": "2020-09-04T20:10:43Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "diffHunk": "@@ -36,21 +37,21 @@ public static FetchFieldsContext create(\n     ) {\n         DocumentMapper documentMapper = mapperService.documentMapper();\n         if (documentMapper.sourceMapper().enabled() == false) {\n-            throw new IllegalArgumentException(\"Unable to retrieve the requested [fields] since _source is \" +\n-                \"disabled in the mappings for index [\" + indexName + \"]\");\n+            throw new IllegalArgumentException(\n+                \"Unable to retrieve the requested [fields] since _source is \" + \"disabled in the mappings for index [\" + indexName + \"]\"\n+            );\n         }\n \n-        FieldValueRetriever fieldValueRetriever = FieldValueRetriever.create(mapperService, searchLookup, fields);\n-        return new FetchFieldsContext(fieldValueRetriever);\n+        return new FetchFieldsContext((m, s) -> FieldValueRetriever.create(m, s, fields));\n     }\n \n-    private final FieldValueRetriever fieldValueRetriever;\n+    private final BiFunction<MapperService, SearchLookup, FieldValueRetriever> fieldValueRetriever;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9da0675a98ef5c0001dab82287cd95b8a48b33"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyNzQ3Mg==", "bodyText": "I have no idea why I didn't do that before.....", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483827472", "createdAt": "2020-09-04T20:16:53Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "diffHunk": "@@ -36,21 +37,21 @@ public static FetchFieldsContext create(\n     ) {\n         DocumentMapper documentMapper = mapperService.documentMapper();\n         if (documentMapper.sourceMapper().enabled() == false) {\n-            throw new IllegalArgumentException(\"Unable to retrieve the requested [fields] since _source is \" +\n-                \"disabled in the mappings for index [\" + indexName + \"]\");\n+            throw new IllegalArgumentException(\n+                \"Unable to retrieve the requested [fields] since _source is \" + \"disabled in the mappings for index [\" + indexName + \"]\"\n+            );\n         }\n \n-        FieldValueRetriever fieldValueRetriever = FieldValueRetriever.create(mapperService, searchLookup, fields);\n-        return new FetchFieldsContext(fieldValueRetriever);\n+        return new FetchFieldsContext((m, s) -> FieldValueRetriever.create(m, s, fields));\n     }\n \n-    private final FieldValueRetriever fieldValueRetriever;\n+    private final BiFunction<MapperService, SearchLookup, FieldValueRetriever> fieldValueRetriever;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyNTI3Mg=="}, "originalCommit": {"oid": "af9da0675a98ef5c0001dab82287cd95b8a48b33"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTM2NjcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMTowMTo1NFrOHNbZpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDoyMzozNVrOHPY_Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjQ3MQ==", "bodyText": "Small comment, it feels more natural to do this in FetchFieldsContext rather than this factory method ?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r483842471", "createdAt": "2020-09-04T21:01:54Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "diffHunk": "@@ -18,36 +18,27 @@\n  */\n package org.elasticsearch.search.fetch.subphase;\n \n-import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.util.List;\n \n /**\n  * The context needed to retrieve fields.\n  */\n public class FetchFieldsContext {\n+    private final List<FieldAndFormat> fields;\n \n-    private FieldValueRetriever fieldValueRetriever;\n-\n-    public static FetchFieldsContext create(String indexName,\n-                                            MapperService mapperService,\n-                                            List<FieldAndFormat> fields) {\n-        DocumentMapper documentMapper = mapperService.documentMapper();\n-        if (documentMapper.sourceMapper().enabled() == false) {\n-            throw new IllegalArgumentException(\"Unable to retrieve the requested [fields] since _source is \" +\n-                \"disabled in the mappings for index [\" + indexName + \"]\");\n-        }\n-\n-        FieldValueRetriever fieldValueRetriever = FieldValueRetriever.create(mapperService, fields);\n-        return new FetchFieldsContext(fieldValueRetriever);\n+    public FetchFieldsContext(List<FieldAndFormat> fields) {\n+        this.fields = fields;\n     }\n \n-    private FetchFieldsContext(FieldValueRetriever fieldValueRetriever) {\n-        this.fieldValueRetriever = fieldValueRetriever;\n-    }\n-\n-    public FieldValueRetriever fieldValueRetriever() {\n-        return fieldValueRetriever;\n+    public FieldValueRetriever fieldValueRetriever(String indexName, MapperService mapperService, SearchLookup searchLookup) {\n+        if (mapperService.documentMapper().sourceMapper().enabled() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxNDM2MA==", "bodyText": "I inherited its location from where it was before - I dunno where it feels better. Would you prefer I move it into the factory method?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485214360", "createdAt": "2020-09-08T21:47:02Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "diffHunk": "@@ -18,36 +18,27 @@\n  */\n package org.elasticsearch.search.fetch.subphase;\n \n-import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.util.List;\n \n /**\n  * The context needed to retrieve fields.\n  */\n public class FetchFieldsContext {\n+    private final List<FieldAndFormat> fields;\n \n-    private FieldValueRetriever fieldValueRetriever;\n-\n-    public static FetchFieldsContext create(String indexName,\n-                                            MapperService mapperService,\n-                                            List<FieldAndFormat> fields) {\n-        DocumentMapper documentMapper = mapperService.documentMapper();\n-        if (documentMapper.sourceMapper().enabled() == false) {\n-            throw new IllegalArgumentException(\"Unable to retrieve the requested [fields] since _source is \" +\n-                \"disabled in the mappings for index [\" + indexName + \"]\");\n-        }\n-\n-        FieldValueRetriever fieldValueRetriever = FieldValueRetriever.create(mapperService, fields);\n-        return new FetchFieldsContext(fieldValueRetriever);\n+    public FetchFieldsContext(List<FieldAndFormat> fields) {\n+        this.fields = fields;\n     }\n \n-    private FetchFieldsContext(FieldValueRetriever fieldValueRetriever) {\n-        this.fieldValueRetriever = fieldValueRetriever;\n-    }\n-\n-    public FieldValueRetriever fieldValueRetriever() {\n-        return fieldValueRetriever;\n+    public FieldValueRetriever fieldValueRetriever(String indexName, MapperService mapperService, SearchLookup searchLookup) {\n+        if (mapperService.documentMapper().sourceMapper().enabled() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjQ3MQ=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkwMDEwMg==", "bodyText": "Sure if you don't mind I think it's nicer to create it directly in FetchFieldsContext.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485900102", "createdAt": "2020-09-09T20:23:35Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FetchFieldsContext.java", "diffHunk": "@@ -18,36 +18,27 @@\n  */\n package org.elasticsearch.search.fetch.subphase;\n \n-import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.util.List;\n \n /**\n  * The context needed to retrieve fields.\n  */\n public class FetchFieldsContext {\n+    private final List<FieldAndFormat> fields;\n \n-    private FieldValueRetriever fieldValueRetriever;\n-\n-    public static FetchFieldsContext create(String indexName,\n-                                            MapperService mapperService,\n-                                            List<FieldAndFormat> fields) {\n-        DocumentMapper documentMapper = mapperService.documentMapper();\n-        if (documentMapper.sourceMapper().enabled() == false) {\n-            throw new IllegalArgumentException(\"Unable to retrieve the requested [fields] since _source is \" +\n-                \"disabled in the mappings for index [\" + indexName + \"]\");\n-        }\n-\n-        FieldValueRetriever fieldValueRetriever = FieldValueRetriever.create(mapperService, fields);\n-        return new FetchFieldsContext(fieldValueRetriever);\n+    public FetchFieldsContext(List<FieldAndFormat> fields) {\n+        this.fields = fields;\n     }\n \n-    private FetchFieldsContext(FieldValueRetriever fieldValueRetriever) {\n-        this.fieldValueRetriever = fieldValueRetriever;\n-    }\n-\n-    public FieldValueRetriever fieldValueRetriever() {\n-        return fieldValueRetriever;\n+    public FieldValueRetriever fieldValueRetriever(String indexName, MapperService mapperService, SearchLookup searchLookup) {\n+        if (mapperService.documentMapper().sourceMapper().enabled() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjQ3MQ=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDIyNDgxOnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODoyOTo1NVrOHOpKjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoyNjo0NlrOHPE2UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjU1OA==", "bodyText": "Could we just access the leaf reader directly? This is pretty common when you're just testing a single document:\nLeafReaderContext context = searcher.getIndexReader().leaves().get(0);", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485116558", "createdAt": "2020-09-08T18:29:55Z", "author": {"login": "jtibshirani"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "diffHunk": "@@ -122,19 +137,60 @@ public final void testMeta() throws IOException {\n         );\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) throws IOException {\n         return fetchSourceValue(mapper, sourceValue, null);\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) throws IOException {\n         String field = mapper.name();\n \n         MapperService mapperService = mock(MapperService.class);\n         when(mapperService.sourcePath(field)).thenReturn(Set.of(field));\n \n-        ValueFetcher fetcher = mapper.valueFetcher(mapperService, format);\n+        ValueFetcher fetcher = mapper.valueFetcher(mapperService, null, format);\n         SourceLookup lookup = new SourceLookup();\n         lookup.setSource(Collections.singletonMap(field, sourceValue));\n         return fetcher.fetchValues(lookup);\n     }\n+\n+    /**\n+     * Use a {@linkplain FieldMapper} to extract values from doc values.\n+     */\n+    protected final List<?> fetchFromDocValues(MapperService mapperService, MappedFieldType ft, DocValueFormat format, Object sourceValue)\n+        throws IOException {\n+\n+        BiFunction<MappedFieldType, Supplier<SearchLookup>, IndexFieldData<?>> fieldDataLookup = (mft, lookupSource) -> mft\n+            .fielddataBuilder(\"test\", () -> { throw new UnsupportedOperationException(); })\n+            .build(new IndexFieldDataCache.None(), new NoneCircuitBreakerService(), mapperService);\n+        SetOnce<List<?>> result = new SetOnce<>();\n+        withLuceneIndex(mapperService, iw -> {\n+            iw.addDocument(mapperService.documentMapper().parse(source(b -> b.field(ft.name(), sourceValue))).rootDoc());\n+        }, iw -> {\n+            IndexSearcher indexSearcher = newSearcher(iw);\n+            SearchLookup lookup = new SearchLookup(mapperService, fieldDataLookup);\n+            ValueFetcher valueFetcher = new DocValueFetcher(format, lookup.doc().getForField(ft));\n+            indexSearcher.search(new MatchAllDocsQuery(), new Collector() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxOTA5Ng==", "bodyText": "Sure!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485219096", "createdAt": "2020-09-08T21:58:47Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "diffHunk": "@@ -122,19 +137,60 @@ public final void testMeta() throws IOException {\n         );\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) throws IOException {\n         return fetchSourceValue(mapper, sourceValue, null);\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) throws IOException {\n         String field = mapper.name();\n \n         MapperService mapperService = mock(MapperService.class);\n         when(mapperService.sourcePath(field)).thenReturn(Set.of(field));\n \n-        ValueFetcher fetcher = mapper.valueFetcher(mapperService, format);\n+        ValueFetcher fetcher = mapper.valueFetcher(mapperService, null, format);\n         SourceLookup lookup = new SourceLookup();\n         lookup.setSource(Collections.singletonMap(field, sourceValue));\n         return fetcher.fetchValues(lookup);\n     }\n+\n+    /**\n+     * Use a {@linkplain FieldMapper} to extract values from doc values.\n+     */\n+    protected final List<?> fetchFromDocValues(MapperService mapperService, MappedFieldType ft, DocValueFormat format, Object sourceValue)\n+        throws IOException {\n+\n+        BiFunction<MappedFieldType, Supplier<SearchLookup>, IndexFieldData<?>> fieldDataLookup = (mft, lookupSource) -> mft\n+            .fielddataBuilder(\"test\", () -> { throw new UnsupportedOperationException(); })\n+            .build(new IndexFieldDataCache.None(), new NoneCircuitBreakerService(), mapperService);\n+        SetOnce<List<?>> result = new SetOnce<>();\n+        withLuceneIndex(mapperService, iw -> {\n+            iw.addDocument(mapperService.documentMapper().parse(source(b -> b.field(ft.name(), sourceValue))).rootDoc());\n+        }, iw -> {\n+            IndexSearcher indexSearcher = newSearcher(iw);\n+            SearchLookup lookup = new SearchLookup(mapperService, fieldDataLookup);\n+            ValueFetcher valueFetcher = new DocValueFetcher(format, lookup.doc().getForField(ft));\n+            indexSearcher.search(new MatchAllDocsQuery(), new Collector() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjU1OA=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MDEyOA==", "bodyText": "I pushed a change for this one.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485570128", "createdAt": "2020-09-09T12:26:46Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/MapperTestCase.java", "diffHunk": "@@ -122,19 +137,60 @@ public final void testMeta() throws IOException {\n         );\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue) throws IOException {\n         return fetchSourceValue(mapper, sourceValue, null);\n     }\n \n-    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) {\n+    public static List<?> fetchSourceValue(FieldMapper mapper, Object sourceValue, String format) throws IOException {\n         String field = mapper.name();\n \n         MapperService mapperService = mock(MapperService.class);\n         when(mapperService.sourcePath(field)).thenReturn(Set.of(field));\n \n-        ValueFetcher fetcher = mapper.valueFetcher(mapperService, format);\n+        ValueFetcher fetcher = mapper.valueFetcher(mapperService, null, format);\n         SourceLookup lookup = new SourceLookup();\n         lookup.setSource(Collections.singletonMap(field, sourceValue));\n         return fetcher.fetchValues(lookup);\n     }\n+\n+    /**\n+     * Use a {@linkplain FieldMapper} to extract values from doc values.\n+     */\n+    protected final List<?> fetchFromDocValues(MapperService mapperService, MappedFieldType ft, DocValueFormat format, Object sourceValue)\n+        throws IOException {\n+\n+        BiFunction<MappedFieldType, Supplier<SearchLookup>, IndexFieldData<?>> fieldDataLookup = (mft, lookupSource) -> mft\n+            .fielddataBuilder(\"test\", () -> { throw new UnsupportedOperationException(); })\n+            .build(new IndexFieldDataCache.None(), new NoneCircuitBreakerService(), mapperService);\n+        SetOnce<List<?>> result = new SetOnce<>();\n+        withLuceneIndex(mapperService, iw -> {\n+            iw.addDocument(mapperService.documentMapper().parse(source(b -> b.field(ft.name(), sourceValue))).rootDoc());\n+        }, iw -> {\n+            IndexSearcher indexSearcher = newSearcher(iw);\n+            SearchLookup lookup = new SearchLookup(mapperService, fieldDataLookup);\n+            ValueFetcher valueFetcher = new DocValueFetcher(format, lookup.doc().getForField(ft));\n+            indexSearcher.search(new MatchAllDocsQuery(), new Collector() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjU1OA=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDMwNzA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/ValueFetcher.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODo1Mzo0NFrOHOp8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoyNzoxMVrOHPE3Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTI0OQ==", "bodyText": "I'm not sure about this idea, but it feels natural to only pass the doc ID here:\nList<Object> fetchValues(SourceLookup lookup) throws IOException;\n\nThen SourceValueFetcher could hang onto the SearchLookup and use that to access SourceLookup ?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485129249", "createdAt": "2020-09-08T18:53:44Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ValueFetcher.java", "diffHunk": "@@ -42,5 +44,10 @@\n      * @param lookup a lookup structure over the document's source.\n      * @return a list a standardized field values.\n      */\n-    List<Object> fetchValues(SourceLookup lookup);\n+    List<Object> fetchValues(SourceLookup lookup) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNDk2MQ==", "bodyText": "I was thinking about that too! I didn't want to do it as part if this PR because it'd make it huge, but I think its a good idea.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485134961", "createdAt": "2020-09-08T19:04:05Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ValueFetcher.java", "diffHunk": "@@ -42,5 +44,10 @@\n      * @param lookup a lookup structure over the document's source.\n      * @return a list a standardized field values.\n      */\n-    List<Object> fetchValues(SourceLookup lookup);\n+    List<Object> fetchValues(SourceLookup lookup) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTI0OQ=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMTg3Mw==", "bodyText": "Hmm - this doesn't look like it'll make the PR much bigger. I'll do that.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485221873", "createdAt": "2020-09-08T22:06:01Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ValueFetcher.java", "diffHunk": "@@ -42,5 +44,10 @@\n      * @param lookup a lookup structure over the document's source.\n      * @return a list a standardized field values.\n      */\n-    List<Object> fetchValues(SourceLookup lookup);\n+    List<Object> fetchValues(SourceLookup lookup) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTI0OQ=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MDM3NA==", "bodyText": "I've pushed a refactor for this too.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485570374", "createdAt": "2020-09-09T12:27:11Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/ValueFetcher.java", "diffHunk": "@@ -42,5 +44,10 @@\n      * @param lookup a lookup structure over the document's source.\n      * @return a list a standardized field values.\n      */\n-    List<Object> fetchValues(SourceLookup lookup);\n+    List<Object> fetchValues(SourceLookup lookup) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTI0OQ=="}, "originalCommit": {"oid": "e4944126afac3c8900411baaca58a028c62e1d05"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjQ2MTM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwOTowNjoyNVrOHO9-rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwOTozOToyNVrOHR5ZUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1NzU4MQ==", "bodyText": "if you use Collections.emptyList() don't you save yourself some trouble when backporting? :)", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485457581", "createdAt": "2020-09-09T09:06:25Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    public DocValueFetcher(DocValueFormat format, IndexFieldData<?> ifd) {\n+        this.format = format;\n+        this.ifd = ifd;\n+    }\n+\n+    public void setNextReader(LeafReaderContext context) {\n+        leaf = ifd.load(context).getLeafValueFetcher(format);\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(int docId) throws IOException {\n+        if (false == leaf.advanceExact(docId)) {\n+            return List.of();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MDUzNQ==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485570535", "createdAt": "2020-09-09T12:27:28Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    public DocValueFetcher(DocValueFormat format, IndexFieldData<?> ifd) {\n+        this.format = format;\n+        this.ifd = ifd;\n+    }\n+\n+    public void setNextReader(LeafReaderContext context) {\n+        leaf = ifd.load(context).getLeafValueFetcher(format);\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(int docId) throws IOException {\n+        if (false == leaf.advanceExact(docId)) {\n+            return List.of();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1NzU4MQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUyODIwOQ==", "bodyText": "ping?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r488528209", "createdAt": "2020-09-15T09:39:25Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    public DocValueFetcher(DocValueFormat format, IndexFieldData<?> ifd) {\n+        this.format = format;\n+        this.ifd = ifd;\n+    }\n+\n+    public void setNextReader(LeafReaderContext context) {\n+        leaf = ifd.load(context).getLeafValueFetcher(format);\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(int docId) throws IOException {\n+        if (false == leaf.advanceExact(docId)) {\n+            return List.of();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1NzU4MQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjY3MDk5OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/search/internal/SearchContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwOTo1ODo0M1rOHO__pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoyNzozNVrOHPE4IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MDU5OA==", "bodyText": "removing one method from SearchContext, that is great!!!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485490598", "createdAt": "2020-09-09T09:58:43Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/internal/SearchContext.java", "diffHunk": "@@ -230,8 +229,6 @@ public final void assignRescoreDocIds(RescoreDocIds rescoreDocIds) {\n \n     public abstract BitsetFilterCache bitsetFilterCache();\n \n-    public abstract <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MDU5Mw==", "bodyText": "It made me happy!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485570593", "createdAt": "2020-09-09T12:27:35Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/internal/SearchContext.java", "diffHunk": "@@ -230,8 +229,6 @@ public final void assignRescoreDocIds(RescoreDocIds rescoreDocIds) {\n \n     public abstract BitsetFilterCache bitsetFilterCache();\n \n-    public abstract <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MDU5OA=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjY4NjQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDowMzowMVrOHPAJVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjozMDo0MVrOHPE_GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MzA3Nw==", "bodyText": "why does it need to be clean rather than the one coming from the query shard context?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485493077", "createdAt": "2020-09-09T10:03:01Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "diffHunk": "@@ -337,7 +369,14 @@ private HitContext prepareNestedHitContext(SearchContext context,\n                 getInternalNestedIdentity(context, nestedDocId, subReaderContext, context.mapperService(), nestedObjectMapper);\n \n         SearchHit hit = new SearchHit(nestedTopDocId, rootId, nestedIdentity, docFields, metaFields);\n-        HitContext hitContext = new HitContext(hit, subReaderContext, nestedDocId, context.searcher(), sharedCache);\n+        HitContext hitContext = new HitContext(\n+            hit,\n+            subReaderContext,\n+            nestedDocId,\n+            context.searcher(),\n+            new SourceLookup(),  // Use a clean, fresh SourceLookup for the nested context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MjM3Ng==", "bodyText": "I've not dug too deeply into it, but I thought we'd be trashing the data that we'd already loaded. I'm not 100% sure of that. I'll dig more.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485572376", "createdAt": "2020-09-09T12:30:41Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "diffHunk": "@@ -337,7 +369,14 @@ private HitContext prepareNestedHitContext(SearchContext context,\n                 getInternalNestedIdentity(context, nestedDocId, subReaderContext, context.mapperService(), nestedObjectMapper);\n \n         SearchHit hit = new SearchHit(nestedTopDocId, rootId, nestedIdentity, docFields, metaFields);\n-        HitContext hitContext = new HitContext(hit, subReaderContext, nestedDocId, context.searcher(), sharedCache);\n+        HitContext hitContext = new HitContext(\n+            hit,\n+            subReaderContext,\n+            nestedDocId,\n+            context.searcher(),\n+            new SourceLookup(),  // Use a clean, fresh SourceLookup for the nested context", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MzA3Nw=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjY5OTU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDowNjoxN1rOHPARNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjo1MzoyNVrOHPF3wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NTA5Mw==", "bodyText": "why can't we re-use the search lookup from the query shard context?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485495093", "createdAt": "2020-09-09T10:06:17Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "diffHunk": "@@ -102,9 +103,10 @@ public void execute(SearchContext context) {\n             SearchHit[] hits = new SearchHit[context.docIdsToLoadSize()];\n             Map<String, Object> sharedCache = new HashMap<>();\n \n+            SearchLookup lookup = context.getQueryShardContext().newSearchLookup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MzcyNQ==", "bodyText": "@jtibshirani can talk more about this, but my understanding is that fetch wants a different context so things like explaining a script don't stomp what we're doing. Right now it uses a \"clean\" SourceLookup and I'm mostly just continuing that. SourceLookup is pretty much the only thing was state in the first place.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485573725", "createdAt": "2020-09-09T12:32:53Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "diffHunk": "@@ -102,9 +103,10 @@ public void execute(SearchContext context) {\n             SearchHit[] hits = new SearchHit[context.docIdsToLoadSize()];\n             Map<String, Object> sharedCache = new HashMap<>();\n \n+            SearchLookup lookup = context.getQueryShardContext().newSearchLookup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NTA5Mw=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4Njg4Mg==", "bodyText": "ok it would be nice to chat about this, I think the changes you are making make sense after all, the only thing I don't love is having to expose this newSearchLookup public method which I foresee will be misused in the future, because it's there, handy, and people will wonder \"which one do I need: newSearchLookup or lookup ?\"", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485586882", "createdAt": "2020-09-09T12:53:25Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java", "diffHunk": "@@ -102,9 +103,10 @@ public void execute(SearchContext context) {\n             SearchHit[] hits = new SearchHit[context.docIdsToLoadSize()];\n             Map<String, Object> sharedCache = new HashMap<>();\n \n+            SearchLookup lookup = context.getQueryShardContext().newSearchLookup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NTA5Mw=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjczNjY3OnYy", "diffSide": "LEFT", "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchSubPhase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDoxNjo0M1rOHPAoHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjo1NDozOFrOHPF6xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMDk1OQ==", "bodyText": "Interesting, so we were using a different SourceLookup instance for each hit? what does that mean in practice?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485500959", "createdAt": "2020-09-09T10:16:43Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchSubPhase.java", "diffHunk": "@@ -39,15 +40,22 @@\n         private final IndexSearcher searcher;\n         private final LeafReaderContext readerContext;\n         private final int docId;\n-        private final SourceLookup sourceLookup = new SourceLookup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3Njk4OA==", "bodyText": "I think reusing the SourceLookup here doesn't hurt or help, really. But it brings it closer to how the search phase works which is nice. We end up repositioning the SourceLookup before each fetch. And preloading the source too.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485576988", "createdAt": "2020-09-09T12:38:17Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchSubPhase.java", "diffHunk": "@@ -39,15 +40,22 @@\n         private final IndexSearcher searcher;\n         private final LeafReaderContext readerContext;\n         private final int docId;\n-        private final SourceLookup sourceLookup = new SourceLookup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMDk1OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzY1Mg==", "bodyText": "indeed, so I believe that as long as all the sub fetch phases share the same source lookup for the same hit, we make sure that _source is loaded only once for that hit (as part of fetch, query is a different story)", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485587652", "createdAt": "2020-09-09T12:54:38Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/FetchSubPhase.java", "diffHunk": "@@ -39,15 +40,22 @@\n         private final IndexSearcher searcher;\n         private final LeafReaderContext readerContext;\n         private final int docId;\n-        private final SourceLookup sourceLookup = new SourceLookup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMDk1OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjc0NjkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDoxOTo0NFrOHPAuPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDoxOTo0NFrOHPAuPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjUyNw==", "bodyText": "this looks much better, thank you!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485502527", "createdAt": "2020-09-09T10:19:44Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "diffHunk": "@@ -37,4 +41,26 @@\n      */\n     SortedBinaryDocValues getBytesValues();\n \n+    /**\n+     * Return a value fetcher for this leaf implementation.\n+     */\n+    default DocValueFetcher.Leaf getLeafValueFetcher(DocValueFormat format) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjc0ODkyOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "isResolved": false, "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDoyMDoyMFrOHPAvgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNTo0NDoxNFrOHPNqNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ==", "bodyText": "I wonder if in all places where we carry around the search lookup, we should not rather make it a supplier like we did in fielddataBuilder.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485502849", "createdAt": "2020-09-09T10:20:20Z", "author": {"login": "javanna"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3NzcwOA==", "bodyText": "If we did the Supplier we could automatically forkAndTrackReferences when you call get on it which is kind of neat. I like it!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485577708", "createdAt": "2020-09-09T12:39:23Z", "author": {"login": "nik9000"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4ODczNw==", "bodyText": "@jtibshirani what do you think? I was under the impression that the lookup is not used in many places, and maybe we could / should create it lazily. We do that already in fielddataBuilder, though it is some indirection that may make the code harder to read.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485588737", "createdAt": "2020-09-09T12:56:11Z", "author": {"login": "javanna"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDcwNA==", "bodyText": "Hmm - I don't think we can know from the signature how to fork....", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485590704", "createdAt": "2020-09-09T12:59:15Z", "author": {"login": "nik9000"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MzkwNQ==", "bodyText": "Wait wait wait, we don't need to forkAndTrackReferences because getting doc values does that for us. Ignore that. I think we're actually fine without the Supplier then. Because the only thing it'd let us do is lazily build the SearchLookup but that class isn't that heavy so I don't think it is worth it. And we need the SourceLookup anyway because the fetch phase is pretty centralized around it.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485593905", "createdAt": "2020-09-09T13:04:12Z", "author": {"login": "nik9000"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyMTE4MA==", "bodyText": "ok so what you are saying is that given fetching revolves around source most of the times, and we get source lookup from search lookup, effectively a supplier does not save much. I was trying to figure out what makes this scenario different compared to fielddataBuilder that would justify having a supplier on one side but not on the other.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485621180", "createdAt": "2020-09-09T13:42:34Z", "author": {"login": "javanna"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5NDAyMA==", "bodyText": "I think with field data builder we typically don't even need the lookup at all - only really runtime fields want it.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485694020", "createdAt": "2020-09-09T15:16:13Z", "author": {"login": "nik9000"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5OTEyOQ==", "bodyText": "Possibly dumb question - is it worth putting it into the SearchContext, rather than having it as an extra parameter here?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485699129", "createdAt": "2020-09-09T15:22:57Z", "author": {"login": "romseygeek"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcwODA2OQ==", "bodyText": "It is all but a dumb question to me. In fact when I saw the new argument the first thing I did was checking that it was not already available in search context :)", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485708069", "createdAt": "2020-09-09T15:35:32Z", "author": {"login": "javanna"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxMDM1Ng==", "bodyText": "I don't want to add it to SearchContext because it'd have a huge blast radius. I think it'd be reasonable to make a FetchContext which has both things. But I don't think it is worth it because there are only 2 arguments..", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485710356", "createdAt": "2020-09-09T15:38:41Z", "author": {"login": "nik9000"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxMTc5MQ==", "bodyText": "FetchContext might be an interesting followup, but sure let's leave it for now.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485711791", "createdAt": "2020-09-09T15:40:31Z", "author": {"login": "romseygeek"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxNDQ4Ng==", "bodyText": "I think if we did FetchContext I'd want it to be smaller than the SearchContext. That thing is just too big....", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485714486", "createdAt": "2020-09-09T15:44:14Z", "author": {"login": "nik9000"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/search/fetch/FetchSubPhasePluginIT.java", "diffHunk": "@@ -114,7 +115,7 @@ public void testPlugin() throws Exception {\n         private static final String NAME = \"term_vectors_fetch\";\n \n         @Override\n-        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext) {\n+        public FetchSubPhaseProcessor getProcessor(SearchContext searchContext, SearchLookup lookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjg0OQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzA3MDU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMTo1NzowMVrOHPDyNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjo1ODowNVrOHPGDvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ==", "bodyText": "thinking out loud, would it make any sense to call fieldType().fieldDataBuilder directly instead of calling getForField against the lookup? Any substantial difference between the two?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485552695", "createdAt": "2020-09-09T11:57:01Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MzAwOQ==", "bodyText": "I already commented about this on another method, but I wonder if this SearchLookup argument should rather be a supplier. What are the pros and cons?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485553009", "createdAt": "2020-09-09T11:57:34Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MzY1Mw==", "bodyText": "One more: will the time zone stay null or is it only temporary?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485553653", "createdAt": "2020-09-09T11:58:28Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MDUwMw==", "bodyText": "Replied above about supplier. Its a good idea I think.\nAbout calling the builder directly - I think we need the lookup so runtime fields can have it.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485580503", "createdAt": "2020-09-09T12:43:57Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MDk1MQ==", "bodyText": "And time zone will stay null until the fields parameter supports it. docvalue_fields never has so I don't expect fields will do it any time soon. But is certainly possible!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485580951", "createdAt": "2020-09-09T12:44:38Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4OTQ1NQ==", "bodyText": "About calling the builder directly - I think we need the lookup so runtime fields can have it.\n\nyea we would still need to provide the lookup as a supplier to fielddatabuilder, we would get to the same method, just in a different way, I think", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485589455", "createdAt": "2020-09-09T12:57:18Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4OTk0OQ==", "bodyText": "docvalue_fields never has so I don't expect fields will do it any time soon. But is certainly possible!\n\nCool, I saw later that it was already null in the doc values fetch phase so nothing new, I thought it had to do with limitations of runtime fields but that is not the case", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485589949", "createdAt": "2020-09-09T12:58:05Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/RuntimeFieldMapper.java", "diffHunk": "@@ -75,8 +77,8 @@ protected void parseCreateField(ParseContext context) {\n     }\n \n     @Override\n-    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n-        throw new UnsupportedOperationException();\n+    public ValueFetcher valueFetcher(MapperService mapperService, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(fieldType().docValueFormat(format, null), lookup.doc().getForField(fieldType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MjY5NQ=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzE5MzEwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjozMDoxMlrOHPE-CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowNzowN1rOHPGbcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MjEwNA==", "bodyText": "I was about to ask if we are good considering this the default impl, but I double checked the old logic from FetchDocValuesPhase and it seems to match the index field data class hierarchy, so +1. One concern I have, and I have been wondering for a while, why don't we have a base class for all the Sorted*DocValues given that all of the advanceExact and docValueCount impl are exactly the same? nextValue also is very similar besides its return type.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485572104", "createdAt": "2020-09-09T12:30:12Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "diffHunk": "@@ -37,4 +41,26 @@\n      */\n     SortedBinaryDocValues getBytesValues();\n \n+    /**\n+     * Return a value fetcher for this leaf implementation.\n+     */\n+    default DocValueFetcher.Leaf getLeafValueFetcher(DocValueFormat format) {\n+        SortedBinaryDocValues values = getBytesValues();\n+        return new DocValueFetcher.Leaf() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MzA1OA==", "bodyText": "I think some of the SortedNumericDocValues comes from Lucene and it is sort of \"theirs\". I think LeafFieldData is \"our\" layer on top of it. I'm not 100% sure I'd have designed it all this way, but it is how we're using it now. I think.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485583058", "createdAt": "2020-09-09T12:47:50Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "diffHunk": "@@ -37,4 +41,26 @@\n      */\n     SortedBinaryDocValues getBytesValues();\n \n+    /**\n+     * Return a value fetcher for this leaf implementation.\n+     */\n+    default DocValueFetcher.Leaf getLeafValueFetcher(DocValueFormat format) {\n+        SortedBinaryDocValues values = getBytesValues();\n+        return new DocValueFetcher.Leaf() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MjEwNA=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MzgyNQ==", "bodyText": "right, SortedNumericDocvalues comes from Lucene, while the others (double, binary etc) we added. I guess that we needed only a subset of the methods that lucene has on its impls as they all extend DocValuesIterator.\nIt is probably complicated to change the classes hierarchy then.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485593825", "createdAt": "2020-09-09T13:04:05Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "diffHunk": "@@ -37,4 +41,26 @@\n      */\n     SortedBinaryDocValues getBytesValues();\n \n+    /**\n+     * Return a value fetcher for this leaf implementation.\n+     */\n+    default DocValueFetcher.Leaf getLeafValueFetcher(DocValueFormat format) {\n+        SortedBinaryDocValues values = getBytesValues();\n+        return new DocValueFetcher.Leaf() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MjEwNA=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NjAxOQ==", "bodyText": "We probably could make a shared base class for the ones that are \"ours\" though. I feel like we should leave the interface because we're often adapting from the double one to the long one and back. So really there are, like, two common implementations, one that wraps and one that counts.\nBut I think that is a change for another time.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485596019", "createdAt": "2020-09-09T13:07:07Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/LeafFieldData.java", "diffHunk": "@@ -37,4 +41,26 @@\n      */\n     SortedBinaryDocValues getBytesValues();\n \n+    /**\n+     * Return a value fetcher for this leaf implementation.\n+     */\n+    default DocValueFetcher.Leaf getLeafValueFetcher(DocValueFormat format) {\n+        SortedBinaryDocValues values = getBytesValues();\n+        return new DocValueFetcher.Leaf() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MjEwNA=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzI1Mjg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjo0NToxMFrOHPFh_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzo0MDozNlrOHPH4HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MTMxMA==", "bodyText": "These methods look suspiciously similar (the same?) to those exposed by all of our Sorted*DocValues implementations. I have been thinking about why we need this new interface, given that conceptually, what we are doing when fetching values from doc_values is exactly the same as usual (reading!) plus some reformatting on what nextValue returns.\nI think that we have a chance to make the integration with the existing doc values classes easier to follow. I am under the impression that we need this new interface mostly because all of our SortedDocValues classes don't share a base class, is that the case? Would it be possible / make sense to have LeafFieldData instead return an enhanced version of SortedDocValues that does the formatting, rather than introducing a new interface for that that has the same methods as the existing classes?\nThis may become a bigger change, I haven't thought all of this through, but maybe it makes sense to discuss as we may have a chance to reduce the boilerplate we need to add here.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485581310", "createdAt": "2020-09-09T12:45:10Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    public DocValueFetcher(DocValueFormat format, IndexFieldData<?> ifd) {\n+        this.format = format;\n+        this.ifd = ifd;\n+    }\n+\n+    public void setNextReader(LeafReaderContext context) {\n+        leaf = ifd.load(context).getLeafValueFetcher(format);\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(int docId) throws IOException {\n+        if (false == leaf.advanceExact(docId)) {\n+            return List.of();\n+        }\n+        List<Object> result = new ArrayList<Object>(leaf.docValueCount());\n+        for (int i = 0, count = leaf.docValueCount(); i < count; ++i) {\n+            result.add(leaf.nextValue());\n+        }\n+        return result;\n+    }\n+\n+    public interface Leaf {\n+        /**\n+         * Advance the doc values reader to the provided doc.\n+         * @return false if there are no values for this document, true otherwise\n+         */\n+        boolean advanceExact(int docId) throws IOException;\n+\n+        /**\n+         * A count of the number of values at this document.\n+         */\n+        int docValueCount() throws IOException;\n+\n+        /**\n+         * Load and format the next value.\n+         */\n+        Object nextValue() throws IOException;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4ODU4MQ==", "bodyText": "_Would it be possible / make sense to have LeafFieldData instead return an enhanced version of Sorted_DocValues that does the formatting, rather than introducing a new interface for that that has the same methods as the existing classes?\n\nThat's a great idea! I hadn't thought of it. And now that I look at it maybe it won't work. I think the return of nextValue has to line up - SortedBinaryDocValues returns BytesRef. SortedNumericDoubleValues returns double. SortedNumericDocValues returns long. And It has a bunch of extra methods it inherits from Lucene that don't make sense here. So to reuse those in this context we'd want to make one that returns Object and wrap them. Which is what this ended up being. Sort of on accident.\nI do wonder if it'd be useful to make a common interface that declares advanceExact and docValueCount. I don't know that it'd save a ton of work though.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485588581", "createdAt": "2020-09-09T12:55:58Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    public DocValueFetcher(DocValueFormat format, IndexFieldData<?> ifd) {\n+        this.format = format;\n+        this.ifd = ifd;\n+    }\n+\n+    public void setNextReader(LeafReaderContext context) {\n+        leaf = ifd.load(context).getLeafValueFetcher(format);\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(int docId) throws IOException {\n+        if (false == leaf.advanceExact(docId)) {\n+            return List.of();\n+        }\n+        List<Object> result = new ArrayList<Object>(leaf.docValueCount());\n+        for (int i = 0, count = leaf.docValueCount(); i < count; ++i) {\n+            result.add(leaf.nextValue());\n+        }\n+        return result;\n+    }\n+\n+    public interface Leaf {\n+        /**\n+         * Advance the doc values reader to the provided doc.\n+         * @return false if there are no values for this document, true otherwise\n+         */\n+        boolean advanceExact(int docId) throws IOException;\n+\n+        /**\n+         * A count of the number of values at this document.\n+         */\n+        int docValueCount() throws IOException;\n+\n+        /**\n+         * Load and format the next value.\n+         */\n+        Object nextValue() throws IOException;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MTMxMA=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxOTc0MQ==", "bodyText": "I spent some time looking at alternatives but given that getValues return a different type, we don't want auto-boxing, and DocValueFormat also has specific format methods per type, I don't think this puzzle can be solved better than you already did. Looking at it from that perspective, what you achieved is pretty nice!", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r485619741", "createdAt": "2020-09-09T13:40:36Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocValueFetcher.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Value fetcher that loads from doc values.\n+ */\n+public final class DocValueFetcher implements ValueFetcher {\n+    private final DocValueFormat format;\n+    private final IndexFieldData<?> ifd;\n+    private Leaf leaf;\n+\n+    public DocValueFetcher(DocValueFormat format, IndexFieldData<?> ifd) {\n+        this.format = format;\n+        this.ifd = ifd;\n+    }\n+\n+    public void setNextReader(LeafReaderContext context) {\n+        leaf = ifd.load(context).getLeafValueFetcher(format);\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(int docId) throws IOException {\n+        if (false == leaf.advanceExact(docId)) {\n+            return List.of();\n+        }\n+        List<Object> result = new ArrayList<Object>(leaf.docValueCount());\n+        for (int i = 0, count = leaf.docValueCount(); i < count; ++i) {\n+            result.add(leaf.nextValue());\n+        }\n+        return result;\n+    }\n+\n+    public interface Leaf {\n+        /**\n+         * Advance the doc values reader to the provided doc.\n+         * @return false if there are no values for this document, true otherwise\n+         */\n+        boolean advanceExact(int docId) throws IOException;\n+\n+        /**\n+         * A count of the number of values at this document.\n+         */\n+        int docValueCount() throws IOException;\n+\n+        /**\n+         * Load and format the next value.\n+         */\n+        Object nextValue() throws IOException;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MTMxMA=="}, "originalCommit": {"oid": "4e5bd650efd9972b1496a73849320c1e296a2cb4"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NjY5MzMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwOTo0MDozN1rOHR5cpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo1OToxMVrOHSI5EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUyOTA2Mg==", "bodyText": "shall we open an issue to track finding an alternative for this?", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r488529062", "createdAt": "2020-09-15T09:40:37Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -290,15 +290,33 @@ MappedFieldType failIfFieldMappingNotFound(String name, MappedFieldType fieldMap\n \n     private SearchLookup lookup = null;\n \n+    /**\n+     * Get the lookup to use during the search.\n+     */\n     public SearchLookup lookup() {\n         if (this.lookup == null) {\n             this.lookup = new SearchLookup(\n                 getMapperService(),\n-                (fieldType, searchLookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), searchLookup));\n+                (fieldType, searchLookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), searchLookup)\n+            );\n         }\n         return this.lookup;\n     }\n \n+    /**\n+     * Build a lookup customized for the fetch phase. Use {@link #lookup()}\n+     * in other phases.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3790f5e48dabc86ae045f9d20cecca51a18d2ece"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4MjA5Ng==", "bodyText": "It looks like @romseygeek  is working on this now.", "url": "https://github.com/elastic/elasticsearch/pull/61995#discussion_r488782096", "createdAt": "2020-09-15T15:59:11Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -290,15 +290,33 @@ MappedFieldType failIfFieldMappingNotFound(String name, MappedFieldType fieldMap\n \n     private SearchLookup lookup = null;\n \n+    /**\n+     * Get the lookup to use during the search.\n+     */\n     public SearchLookup lookup() {\n         if (this.lookup == null) {\n             this.lookup = new SearchLookup(\n                 getMapperService(),\n-                (fieldType, searchLookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), searchLookup));\n+                (fieldType, searchLookup) -> indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName(), searchLookup)\n+            );\n         }\n         return this.lookup;\n     }\n \n+    /**\n+     * Build a lookup customized for the fetch phase. Use {@link #lookup()}\n+     * in other phases.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUyOTA2Mg=="}, "originalCommit": {"oid": "3790f5e48dabc86ae045f9d20cecca51a18d2ece"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1759, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}