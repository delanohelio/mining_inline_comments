{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNjIwMDc0", "number": 54020, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozNzowMlrODqkGuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzowNDo1MVrODq4ycw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTU4MzI4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozNzowMlrOF6ZB0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzowMzo0OFrOF6bT3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw==", "bodyText": "java.* packages should be imported - the only reason when a class should be fully qualified if there's a class name clash.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396771793", "createdAt": "2020-03-23T21:37:02Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwOTE4MA==", "bodyText": "thanks. I think this was an oversight on my part using IntelliJ's 'automatically import class' functionality. cleaned this up with the array initialization", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396809180", "createdAt": "2020-03-23T23:03:48Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTU4NTUxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozNzo1MlrOF6ZDSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzowMzoyNVrOF6bTHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA==", "bodyText": "Easier to do Arrays.asList(args..) directly in the constructor", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772168", "createdAt": "2020-03-23T21:37:52Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwODk5MQ==", "bodyText": "I tried to find a way to get src, then all of patterns and couldn't find a good way.\nArrays.asList(src, patterns) didn't seem to work. I'm definitely open to learning a better way", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396808991", "createdAt": "2020-03-23T23:03:25Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTU4OTU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozOTowOVrOF6ZFxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMjo1MDozOFrOF8vuCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(source, getArguments(field, patterns));\n          \n          \n            \n                    super(source, Arrays.asList(field, patterns));\n          \n      \n    \n    \n  \n\nlike the rest of the subclasses.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772806", "createdAt": "2020-03-23T21:39:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwOTM2Ng==", "bodyText": "doesn't seem to work if the first value is a T, and the next is a List<T>", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396809366", "createdAt": "2020-03-23T23:04:21Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0MDcxMg==", "bodyText": "CollectionUtils.combine(patterns, field) or if you want to preserve the order:\nCollectionUtils.combine(singletonList(field), patterns)", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r399240712", "createdAt": "2020-03-27T12:50:38Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY1MTg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowMDo1N1rOF6Zs3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowMDo1N1rOF6Zs3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MjgxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean foldable = field.foldable();\n          \n          \n            \n                    for (Expression p : patterns) {\n          \n          \n            \n                        foldable = foldable && p.foldable();\n          \n          \n            \n                    }\n          \n          \n            \n                    return foldable;\n          \n          \n            \n                    return Expressions.foldable(arguments());", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396782812", "createdAt": "2020-03-23T22:00:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        boolean foldable = field.foldable();\n+        for (Expression p : patterns) {\n+            foldable = foldable && p.foldable();\n+        }\n+        return foldable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY1ODczOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowMzoyNFrOF6ZxNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzoxNDoxNVrOF6biZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Expression asLikes = asLikes();\n          \n          \n            \n                    if (asLikes instanceof Like) {\n          \n          \n            \n                        return ((Like) asLikes).makePipe();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return ((Or) asLikes).makePipe();\n          \n          \n            \n                    }\n          \n          \n            \n                return asLike().makePipe();", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396783925", "createdAt": "2020-03-23T22:03:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjUxMw==", "bodyText": "This doesn't seem to be needed and in fact the implementation should be throw new EqlIllegalArgumentException(\"should not call this method\")", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792513", "createdAt": "2020-03-23T22:22:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMjkwMQ==", "bodyText": "awesome. that was my hope.\nI still need to keep fold() though for the optimizer, right?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396812901", "createdAt": "2020-03-23T23:14:15Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY2MTAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowNDowOVrOF6ZyiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzoyNzoxMlrOF6b8PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ==", "bodyText": "Since it's always a Like or an Or, return a ScalarFunction instead. Also the method should be private.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784265", "createdAt": "2020-03-23T22:04:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxOTUxNg==", "bodyText": "Currently accessing via the Optimizer, which is why it was left public:\nhttps://github.com/elastic/elasticsearch/pull/54020/files#diff-cb6f05d0222f3291ea3df5d33525d6f6R71", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396819516", "createdAt": "2020-03-23T23:27:12Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY2MTgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowNDoyOVrOF6ZzCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowNDoyOVrOF6ZzCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDM5NQ==", "bodyText": "Extra new line.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784395", "createdAt": "2020-03-23T22:04:29Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY4OTQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxNDozNlrOF6aELg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxNDozNlrOF6aELg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4ODc4Mg==", "bodyText": "Please implement the methods in the order of the super class (which is not alphabetical) which roughly is:\nconstructor\nnodeInfo/replaceChildren\ntype resolution\ngetters\ndatatype/nullable\nfoldable/fold\nscripting & co\nequals/hash", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396788782", "createdAt": "2020-03-23T22:14:36Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTcxMDQ5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyMjoyM1rOF6aRug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyMjoyM1rOF6aRug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjI1MA==", "bodyText": "Since the optimizer is replacing this function, this method will never be called but rather Like and Or directly", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792250", "createdAt": "2020-03-23T22:22:23Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTcxNjA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/utils/StringUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyNDoxOFrOF6aVDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyNDoxOFrOF6aVDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MzEwMA==", "bodyText": "Make the class abstract or better yet final + private constructor to prevent instantiation/inheritance.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396793100", "createdAt": "2020-03-23T22:24:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/utils/StringUtils.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.utils;\n+\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.LikePattern;\n+\n+public class StringUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTcyODYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyODo0NlrOF6acmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzoxNToyMFrOF6bjxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA==", "bodyText": "How many arguments does wildcard expect?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795034", "createdAt": "2020-03-23T22:28:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -421,4 +421,26 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     protected interface CastFunctionBuilder<T> {\n         T build(Source source, Expression expression, DataType dataType);\n     }\n+\n+    @SuppressWarnings(\"overloads\")  // These are ambiguous if you aren't using ctor references but we always do\n+    public static <T extends Function> FunctionDefinition def(Class<T> function,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMzI1NQ==", "bodyText": "at least two, but it's unbounded in the maximum number\nhttps://eql.readthedocs.io/en/latest/query-guide/functions.html#wildcard", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396813255", "createdAt": "2020-03-23T23:15:20Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -421,4 +421,26 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     protected interface CastFunctionBuilder<T> {\n         T build(Source source, Expression expression, DataType dataType);\n     }\n+\n+    @SuppressWarnings(\"overloads\")  // These are ambiguous if you aren't using ctor references but we always do\n+    public static <T extends Function> FunctionDefinition def(Class<T> function,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTcyODgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/logical/BinaryLogic.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoyODo1MVrOF6acuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzoxNjozOVrOF6blaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA==", "bodyText": "Why?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795064", "createdAt": "2020-03-23T22:28:51Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/logical/BinaryLogic.java", "diffHunk": "@@ -34,7 +34,7 @@ protected TypeResolution resolveInputType(Expression e, Expressions.ParamOrdinal\n     }\n \n     @Override\n-    protected Pipe makePipe() {\n+    public Pipe makePipe() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMzY3NQ==", "bodyText": "I'll set this back. I was using it within Wildcard.make_pipe, but since that is unreachable, I'll set this back.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396813675", "createdAt": "2020-03-23T23:16:39Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/logical/BinaryLogic.java", "diffHunk": "@@ -34,7 +34,7 @@ protected TypeResolution resolveInputType(Expression e, Expressions.ParamOrdinal\n     }\n \n     @Override\n-    protected Pipe makePipe() {\n+    public Pipe makePipe() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA=="}, "originalCommit": {"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjQ4NDMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNToyMToxMVrOF61bDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDowMzo1M1rOF7BBEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw==", "bodyText": "Isn't wildcard a \"string function\"? If so, it should belong to the FunctionDefinition array that, also, has substring in it. In SQL we were grouping these functions by their type: string, grouping, math, conditional, date etc.", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397237007", "createdAt": "2020-03-24T15:21:11Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -17,14 +18,17 @@\n     public EqlFunctionRegistry() {\n         super(functions());\n     }\n-    \n+\n     private static FunctionDefinition[][] functions() {\n         return new FunctionDefinition[][] {\n         // Scalar functions\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n             },\n+            new FunctionDefinition[] {\n+                def(Wildcard.class, Wildcard::new, \"wildcard\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNjk2Mw==", "bodyText": "oh right, good catch", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397426963", "createdAt": "2020-03-24T20:03:53Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -17,14 +18,17 @@\n     public EqlFunctionRegistry() {\n         super(functions());\n     }\n-    \n+\n     private static FunctionDefinition[][] functions() {\n         return new FunctionDefinition[][] {\n         // Scalar functions\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n             },\n+            new FunctionDefinition[] {\n+                def(Wildcard.class, Wildcard::new, \"wildcard\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw=="}, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjQ5MzkzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNToyMzoxNlrOF61hNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNToyMzoxNlrOF61hNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzODU4MQ==", "bodyText": "childrenResolved() == false", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397238581", "createdAt": "2020-03-24T15:23:16Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjUyNDkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNToyOTozNlrOF611DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDowNDo0MFrOF7BCkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ==", "bodyText": "Shouldn't the field be, also, foldable? (ie return Expressions.foldable(children());)", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397243661", "createdAt": "2020-03-24T15:29:36Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Njc5Ng==", "bodyText": "Since wildcard is converted to a bunch of LIKEs, I'm wondering if foldable() shouldn't fall back to the result of the wildcard -> LIKEs transformation foldable() functionality. Basically the Or.foldable().", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397296796", "createdAt": "2020-03-24T16:36:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNzM0Ng==", "bodyText": "arguments() = field + patterns()\narguments() comes from the super and is identical to children()\nI'll swap to children() since that's more obvious", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397427346", "createdAt": "2020-03-24T20:04:40Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjgyMDMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjozMToyOFrOF641Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjozMToyOFrOF641Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Mjg5MA==", "bodyText": "I don't think isStringAndExact is correct here... \"exact\" refers to a field being of type keyword or having a sub-field of type keyword basically. isString should be enough imo.\nAlso, shouldn't the p.foldable() == false (comparison against variables basically) check be before this one?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397292890", "createdAt": "2020-03-24T16:31:28Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mjg4NDUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo0NToyM1rOF65eUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzoxNToyNlrOF7abIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw==", "bodyText": "Maybe move this method to org.elasticsearch.xpack.ql.util.CollectionUtils and make it more generic?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397303377", "createdAt": "2020-03-24T16:45:23Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asLikes().fold();\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.makePipe() should not be called directly\");\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.asScript() should not be called directly\");\n+    }\n+\n+    public ScalarFunction asLikes() {\n+        ScalarFunction result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static List<Expression> toArguments(Expression src, List<Expression> patterns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzIzMw==", "bodyText": "saw this kind fo construct used in few places\nCollectionUtils.combine(singletonList(src), patterns))", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397843233", "createdAt": "2020-03-25T13:15:26Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asLikes().fold();\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.makePipe() should not be called directly\");\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.asScript() should not be called directly\");\n+    }\n+\n+    public ScalarFunction asLikes() {\n+        ScalarFunction result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static List<Expression> toArguments(Expression src, List<Expression> patterns) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw=="}, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mjg5MzEzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo0Njo1OFrOF65jgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo0Njo1OFrOF65jgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNDcwNQ==", "bodyText": "return e instanceof Wildcard ? ((Wildcard) e).asLikes() : e; as a shorter (hopefully more elegant) variant?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397304705", "createdAt": "2020-03-24T16:46:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -60,6 +62,20 @@ public LogicalPlan optimize(LogicalPlan verified) {\n     }\n \n \n+    private static class ReplaceWildcardFunction extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                if (e instanceof Wildcard) {\n+                    e = ((Wildcard) e).asLikes();\n+                }\n+\n+                return e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mjk3MjAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzowNDo1MVrOF66XFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzowNDo1MVrOF66XFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzkxMQ==", "bodyText": "I think there are other error messages to check with wildcard: the fact that the field needs to be string and exact and, also, that the \"patterns\" should be all strings, no?", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397317911", "createdAt": "2020-03-24T17:04:51Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -22,4 +24,19 @@ public void testPropertyEquationInClauseFilterUnsupported() {\n         String msg = e.getMessage();\n         assertEquals(\"Line 1:52: Comparisons against variables are not (currently) supported; offender [parent_process_name] in [==]\", msg);\n     }\n+\n+    public void testWildcardNotEnoughArguments() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4227, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}