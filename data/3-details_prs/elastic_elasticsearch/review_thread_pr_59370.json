{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NzYzNzA5", "number": 59370, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDoyMVrOENt4yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDo0NFrOENt5uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODE4NzYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/Expressions.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDoyMVrOGwepZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDoyMVrOGwepZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ4Njk0OA==", "bodyText": "Could you please replace this with a Tuple<Attribute, Expression>?\n\nAttributeAlias replaced with Tuple<Attribute, Expression>?", "url": "https://github.com/elastic/elasticsearch/pull/59370#discussion_r453486948", "createdAt": "2020-07-13T08:40:21Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/Expressions.java", "diffHunk": "@@ -164,14 +163,15 @@ public static boolean equalsAsAttribute(Expression left, Expression right) {\n         return true;\n     }\n \n-    public static AttributeMap<Expression> aliases(List<? extends NamedExpression> named) {\n-        Map<Attribute, Expression> aliasMap = new LinkedHashMap<>();\n+    public static List<Tuple<Attribute, Expression>> aliases(List<? extends NamedExpression> named) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06e80643cbaac564e1048437a5d622e950e6f2bb"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODE4ODgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDozMlrOGweqBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDozMlrOGweqBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ4NzEwOA==", "bodyText": "Why removing it from here and adding it only if matches.size() == 1?\n\nAttribute#withLocation() will \"overwrite\" any pre-existing location, which is not desirable if the existing locations need to be kept in order to be reported in an error message.", "url": "https://github.com/elastic/elasticsearch/pull/59370#discussion_r453487108", "createdAt": "2020-07-13T08:40:32Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -192,16 +192,21 @@ private static Attribute resolveAgainstList(UnresolvedAttribute u, Collection<At\n         }\n \n         if (matches.size() == 1) {\n-            return handleSpecialFields(u, matches.get(0), allowCompound);\n+            // only add the location if the match is univocal; b/c otherwise adding the location will overwrite any preexisting one\n+            return handleSpecialFields(u, matches.get(0).withLocation(u.source()), allowCompound);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06e80643cbaac564e1048437a5d622e950e6f2bb"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODE4OTQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDozOVrOGweqWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDozOVrOGweqWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ4NzE5NQ==", "bodyText": "Please remove the comparison implementation from here and use a custom comparator to sort the ambiguous attributes.\n\nImplementations of Comparable removed.", "url": "https://github.com/elastic/elasticsearch/pull/59370#discussion_r453487195", "createdAt": "2020-07-13T08:40:39Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -192,16 +192,21 @@ private static Attribute resolveAgainstList(UnresolvedAttribute u, Collection<At\n         }\n \n         if (matches.size() == 1) {\n-            return handleSpecialFields(u, matches.get(0), allowCompound);\n+            // only add the location if the match is univocal; b/c otherwise adding the location will overwrite any preexisting one\n+            return handleSpecialFields(u, matches.get(0).withLocation(u.source()), allowCompound);\n         }\n \n-        return u.withUnresolvedMessage(\"Reference [\" + u.qualifiedName()\n-                + \"] is ambiguous (to disambiguate use quotes or qualifiers); matches any of \" +\n-                 matches.stream()\n-                 .map(a -> \"\\\"\" + a.qualifier() + \"\\\".\\\"\" + a.name() + \"\\\"\")\n-                 .sorted()\n-                 .collect(toList())\n-                );\n+        List<String> refs = matches.stream()\n+            .sorted((a, b) -> {\n+                int lineDiff = a.sourceLocation().getLineNumber() - b.sourceLocation().getLineNumber();\n+                int colDiff = a.sourceLocation().getColumnNumber() - b.sourceLocation().getColumnNumber();\n+                return lineDiff != 0 ? lineDiff : (colDiff != 0 ? colDiff : a.qualifiedName().compareTo(b.qualifiedName()));\n+            })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06e80643cbaac564e1048437a5d622e950e6f2bb"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODE5MDAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDo0NFrOGweqpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo0MDo0NFrOGweqpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ4NzI3MA==", "bodyText": "Imho, it would be better to use a for loop to increase readability.\n\nThe stream construction seems a bit more compact and readable IMO and inline with other usages (like the current Analyzer#resolveAgainstList()), but I can still change it if desired.", "url": "https://github.com/elastic/elasticsearch/pull/59370#discussion_r453487270", "createdAt": "2020-07-13T08:40:44Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java", "diffHunk": "@@ -327,22 +332,31 @@ else if (plan instanceof Aggregate) {\n                     return new Aggregate(a.source(), a.child(), a.groupings(),\n                             expandProjections(a.aggregates(), a.child()));\n                 }\n-                // if the grouping is unresolved but the aggs are, use the former to resolve the latter\n-                // solves the case of queries declaring an alias in SELECT and referring to it in GROUP BY\n+                // if the grouping is unresolved but the aggs are, use the latter to resolve the former.\n+                // solves the case of queries declaring an alias in SELECT and referring to it in GROUP BY.\n                 // e.g. SELECT x AS a ... GROUP BY a\n                 if (!a.expressionsResolved() && Resolvables.resolved(a.aggregates())) {\n                     List<Expression> groupings = a.groupings();\n                     List<Expression> newGroupings = new ArrayList<>();\n-                    AttributeMap<Expression> resolved = Expressions.aliases(a.aggregates());\n+                    List<Tuple<Attribute, Expression>> resolvedAliases = Expressions.aliases(a.aggregates());\n \n                     boolean changed = false;\n                     for (Expression grouping : groupings) {\n                         if (grouping instanceof UnresolvedAttribute) {\n-                            Attribute maybeResolved = resolveAgainstList((UnresolvedAttribute) grouping, resolved.keySet());\n+                            Attribute maybeResolved = resolveAgainstList((UnresolvedAttribute) grouping,\n+                                resolvedAliases.stream().map(Tuple::v1).collect(toList()));\n                             if (maybeResolved != null) {\n                                 changed = true;\n-                                // use the matched expression (not its attribute)\n-                                grouping = resolved.get(maybeResolved);\n+                                if (maybeResolved.resolved()) {\n+                                    grouping = resolvedAliases.stream()\n+                                        .filter(t -> t.v1().equals(maybeResolved))\n+                                        // use the matched expression (not its attribute)\n+                                        .map(Tuple::v2)\n+                                        .findAny()\n+                                        .get(); // there should always be exactly one match", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06e80643cbaac564e1048437a5d622e950e6f2bb"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1968, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}