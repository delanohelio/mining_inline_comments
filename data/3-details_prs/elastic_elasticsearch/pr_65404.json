{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MTQ0MzE1", "number": 65404, "title": "Extract security wildcard pattern matching", "bodyText": "This commit moves the implementation of wildcard pattern matching into\na standalone utility class (\"StringMatcher\").\nIn general, we rely on lucene Automaton objects to implement pattern\nmatching (wildcards and regexp) within Elasticsearch security - for\nexample in Index name patterns within a role.\nThe IndicesPermission class also has a special optimisation for exact\nstring matches (that is raw index names that contain no wildcards) as\nusing String.equals / Set.contains is more efficient for this common\ncase.\nAll of the above functionality has now been extracted into the\nStringMatcher class, and it is now used in several places where it may\nbe more efficient that the previous use of raw Automaton objects.\nA future change will expand this StringMatcher class with additional\noptimisations for common use cases that are poorly handled within our\nexisting automaton compilation process.\nRelates: #36062", "createdAt": "2020-11-24T03:19:29Z", "url": "https://github.com/elastic/elasticsearch/pull/65404", "merged": true, "mergeCommit": {"oid": "77a59ad5574fb50e97acb38f737a81e5f570b460"}, "closed": true, "closedAt": "2020-12-21T01:48:54Z", "author": {"login": "tvernum"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfgme6gH2gAyNTI2MTQ0MzE1OjI4ODE4MTdhZWRlZThhZTliODQxMTllZjMxMjQ5MjY1YzgzOTQ1YzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnSciygH2gAyNTI2MTQ0MzE1OmVhNjI4OGVkNTA1YTU2MDRjMGQ0MmVlYmJhNjQ0Y2QyYzU2NTQ0ZDI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/2881817aedee8ae9b84119ef31249265c83945c0", "committedDate": "2020-11-24T02:47:53Z", "message": "Extract security wildcard pattern matching\n\nThis commit moves the implementation of wildcard pattern matching into\na standalone utility class (\"StringMatcher\").\n\nIn general, we rely on lucene Automaton objects to implement pattern\nmatching (wildcards and regexp) within Elasticsearch security - for\nexample in Index name patterns within a role.\n\nThe IndicesPermission class also has a special optimisation for exact\nstring matches (that is raw index names that contain no wildcards) as\nusing String.equals / Set.contains is more efficient for this common\ncase.\n\nAll of the above functionality has now been extracted into the\nStringMatcher class, and it is now used in several places where it may\nbe more efficient that the previous use of raw Automaton objects.\n\nA future change will expand this StringMatcher class with additional\noptimisations for common use cases that are poorly handled within our\nexisting automaton compilation process.\n\nRelates: #36062"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDM5NjYy", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-537439662", "createdAt": "2020-11-24T12:24:41Z", "commit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjoyNDo0MVrOH4-eOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjoyNDo0MVrOH4-eOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNTg1MA==", "bodyText": "Should these methods have argument of type StringMatcher instead of Predicate? A raw predicate does not make much sense to have description?\nNits:\n\nIt seems the two and methods can be merged into one if it follows the pattern of the or method.\nIf any of the description is itself a combined one, e.g. a|b|c, when concatenating it again with another description, would it be helpful to put parenthesis around it, e.g. (a|b|c)&d?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529505850", "createdAt": "2020-11-24T12:24:41Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDQyMjY4", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-537442268", "createdAt": "2020-11-24T12:28:15Z", "commit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjoyODoxNVrOH4-mHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjoyODoxNVrOH4-mHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNzg3MA==", "bodyText": "More of a question: What about empty string, all and _all? should they be handled before reaching to this class?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529507870", "createdAt": "2020-11-24T12:28:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDQ0MDk3", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-537444097", "createdAt": "2020-11-24T12:30:37Z", "commit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozMDozN1rOH4-rlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozMDozN1rOH4-rlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwOTI2OA==", "bodyText": "Nit: Could use a more generic parameter name instead of indices, same goes for the buildAutomataPredicate method.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529509268", "createdAt": "2020-11-24T12:30:37Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);\n+            }\n+            return strings.stream().map(s -> {\n+                if (s.length() > 16) {\n+                    return Strings.cleanTruncate(s, 12) + \"...\";\n+                } else {\n+                    return s;\n+                }\n+            }).collect(Collectors.joining(\"|\"));\n+        }\n+\n+        private static Predicate<String> buildExactMatchPredicate(Set<String> indices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDQ0MzA0", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-537444304", "createdAt": "2020-11-24T12:30:53Z", "commit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozMDo1M1rOH4-sIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjozMDo1M1rOH4-sIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwOTQxMQ==", "bodyText": "Any reason this is not a Set?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529509411", "createdAt": "2020-11-24T12:30:53Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3ODI1MTEz", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-537825113", "createdAt": "2020-11-24T19:10:20Z", "commit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxOToxMDoyMFrOH5RYbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxOTo1Nzo1NVrOH5S_0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgxNTY2Mw==", "bodyText": "Nit: Any concerns here about description compatibility with AutomataPredicate (comma delimited and trancating 80 strings)?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529815663", "createdAt": "2020-11-24T19:10:20Z", "author": {"login": "BigPandaToo"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final List<String> nonExactMatch = new ArrayList<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);\n+            }\n+            return strings.stream().map(s -> {\n+                if (s.length() > 16) {\n+                    return Strings.cleanTruncate(s, 12) + \"...\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgyNjM0NQ==", "bodyText": "How about adding \"?\" for completeness?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529826345", "createdAt": "2020-11-24T19:29:26Z", "author": {"login": "BigPandaToo"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/support/StringMatcherTests.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+public class StringMatcherTests extends ESTestCase {\n+\n+    public void testEmptySet() throws Exception {\n+        final StringMatcher matcher = StringMatcher.of();\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(i, 20));\n+        }\n+    }\n+\n+    public void testSingleWildcard() throws Exception {\n+        final String prefix = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(prefix + \"*\");\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, prefix + randomAlphaOfLengthBetween(i, 20));\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(1, prefix.length() - 1));\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.startsWith(prefix), () -> randomAlphaOfLengthBetween(1, 8)));\n+        }\n+    }\n+\n+    public void testSingleExactMatch() throws Exception {\n+        final String str = randomAlphaOfLengthBetween(3, 12);\n+        final StringMatcher matcher = StringMatcher.of(str);\n+        assertMatch(matcher, str);\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.equals(str), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertNoMatch(matcher, randomAlphaOfLength(1) + str);\n+            assertNoMatch(matcher, str + randomAlphaOfLength(1));\n+        }\n+    }\n+\n+    public void testSingleRegex() throws Exception {\n+        final String notStr = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(\"/~(\" + notStr + \")/\");\n+        assertNoMatch(matcher, notStr);\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, randomValueOtherThanMany(s -> s.equals(notStr), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertMatch(matcher, randomAlphaOfLength(1) + notStr);\n+            assertMatch(matcher, notStr + randomAlphaOfLength(1));\n+        }\n+\n+    }\n+\n+    public void testMultiplePatterns() throws Exception {\n+        final String prefix1 = randomAlphaOfLengthBetween(3, 5);\n+        final String prefix2 = randomAlphaOfLengthBetween(5, 8);\n+        final String prefix3 = randomAlphaOfLengthBetween(10, 12);\n+        final String suffix1 = randomAlphaOfLengthBetween(5, 10);\n+        final String suffix2 = randomAlphaOfLengthBetween(8, 12);\n+        final String exact1 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(5, 9));\n+        final String exact2 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(10, 12));\n+        final String exact3 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(15, 20));\n+\n+        final StringMatcher matcher = StringMatcher.of(List.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgyODQzOQ==", "bodyText": "extra bracket?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529828439", "createdAt": "2020-11-24T19:33:02Z", "author": {"login": "BigPandaToo"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MjEyOQ==", "bodyText": "@ywangd I believe this is Predicate and and or default methods signature we have to use. We can build the description from the Predicate.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r529842129", "createdAt": "2020-11-24T19:57:55Z", "author": {"login": "BigPandaToo"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty))\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUwNTg1MA=="}, "originalCommit": {"oid": "2881817aedee8ae9b84119ef31249265c83945c0"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "219e30e3b168dc503c31fc17dca4d30e949089e0", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/219e30e3b168dc503c31fc17dca4d30e949089e0", "committedDate": "2020-12-15T04:24:28Z", "message": "Merge branch 'master' into feature/patterns-util-class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/5ff5c6dd83c13e2adee39266bfdc952d9dd43da7", "committedDate": "2020-12-15T05:16:01Z", "message": "Address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjQ0Mzk2", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-552244396", "createdAt": "2020-12-15T09:14:35Z", "commit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "677f819709d790ad1004efcff79beea14aae2ea6", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/677f819709d790ad1004efcff79beea14aae2ea6", "committedDate": "2020-12-16T05:39:23Z", "message": "Merge branch 'master' into feature/patterns-util-class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMzY2MDIw", "url": "https://github.com/elastic/elasticsearch/pull/65404#pullrequestreview-553366020", "createdAt": "2020-12-16T05:25:24Z", "commit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNToyNToyNVrOIGxkdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjowODo0NFrOIGzkxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NDUxNw==", "bodyText": "Nit: Unlike the other or and and methods, this one does not have a statement of Objects.requireNonNull(other);. The relevant methods of Java Predicate calls requireNonNull anyway. So it is not really necessary to have the check here. I am happy either way, but some consistency across the methods would be good.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543974517", "createdAt": "2020-12-16T05:25:25Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NzU5MQ==", "bodyText": "Nit: this parameter is redundant since the argument is always the field variable of allText.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543977591", "createdAt": "2020-12-16T05:29:18Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final Set<String> nonExactMatch = new LinkedHashSet<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3OTc0OA==", "bodyText": "Nit: It is technically possible that this single item has a length greater than 250.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543979748", "createdAt": "2020-12-16T05:32:21Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final Set<String> nonExactMatch = new LinkedHashSet<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk4NDk3Nw==", "bodyText": "Nit: If the intention is to keep the length of the final string under 250, this only takes care of the situation when there are fewer items, but has issues when there are many items. For example, if there are 250 items and each of them takes more than 1 char, the end result will be longer than 250 chars.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543984977", "createdAt": "2020-12-16T05:39:04Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));\n+    }\n+\n+    @Override\n+    public StringMatcher and(Predicate<? super String> other) {\n+        return this.and(String.valueOf(other), other);\n+    }\n+\n+    public StringMatcher and(String otherDescription, Predicate<? super String> otherPredicate) {\n+        Objects.requireNonNull(otherPredicate);\n+        return new StringMatcher(this.description + \"&\" + otherDescription, this.predicate.and(otherPredicate));\n+    }\n+\n+    public static class Builder {\n+        private final List<String> allText = new ArrayList<>();\n+        private final Set<String> exactMatch = new HashSet<>();\n+        private final Set<String> nonExactMatch = new LinkedHashSet<>();\n+\n+        public Builder include(String pattern) {\n+            allText.add(pattern);\n+            if (pattern.startsWith(\"/\") || pattern.contains(\"*\") || pattern.contains(\"?\")) {\n+                nonExactMatch.add(pattern);\n+            } else {\n+                exactMatch.add(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(String... patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public Builder includeAll(Iterable<String> patterns) {\n+            for (String pattern : patterns) {\n+                include(pattern);\n+            }\n+            return this;\n+        }\n+\n+        public StringMatcher build() {\n+            if (allText.isEmpty()) {\n+                return MATCH_NOTHING;\n+            }\n+\n+            final String description = describe(allText);\n+            if (exactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildAutomataPredicate(nonExactMatch));\n+            }\n+            if (nonExactMatch.isEmpty()) {\n+                return new StringMatcher(description, buildExactMatchPredicate(exactMatch));\n+            }\n+            final Predicate<String> predicate = buildExactMatchPredicate(exactMatch).or(buildAutomataPredicate(nonExactMatch));\n+            return new StringMatcher(description, predicate);\n+        }\n+\n+        private String describe(List<String> strings) {\n+            if (strings.size() == 1) {\n+                return strings.get(0);\n+            }\n+            final int totalLength = strings.stream().map(String::length).reduce(0, Math::addExact);\n+            if (totalLength < 250) {\n+                return Strings.collectionToDelimitedString(strings, \"|\");\n+            }\n+            final int maxItemLength = Math.max(16, 250 / strings.size());\n+            return strings.stream().map(s -> {\n+                if (s.length() > maxItemLength) {\n+                    return Strings.cleanTruncate(s, maxItemLength - 3) + \"...\";\n+                } else {\n+                    return s;\n+                }\n+            }).collect(Collectors.joining(\"|\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff5c6dd83c13e2adee39266bfdc952d9dd43da7"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk5MzY4Nw==", "bodyText": "Nit: seems to be unfortunate that the description constructed in the or and and methods could be longer than 250 chars after all the effort went into Builder#describe.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r543993687", "createdAt": "2020-12-16T05:51:02Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/StringMatcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.Strings;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class acts as a facade / encapsulation around the expression and testing of string-based patterns within Elasticsearch security.\n+ * Security supports \"wildcards\" in a number of places (e.g. index names within roles). These cases also support\n+ * {@link org.apache.lucene.util.automaton.RegExp Lucene-syntax regular expressions} and are implemented via Lucene\n+ * {@link org.apache.lucene.util.automaton.Automaton} objects.\n+ * However, it can be more efficient to have special handling and avoid {@code Automata} for particular cases such as exact string matches.\n+ * This class handles that logic, an provides a clean interface for\n+ * <em>test whether a provided string matches one of an existing set of patterns</em> that hides the possible implementation options.\n+ */\n+public class StringMatcher implements Predicate<String> {\n+\n+    private static final StringMatcher MATCH_NOTHING = new StringMatcher(\"(empty)\", s -> false);\n+\n+    private final String description;\n+    private final Predicate<String> predicate;\n+    private static final Logger LOGGER = LogManager.getLogger(StringMatcher.class);\n+\n+    private StringMatcher(String description, Predicate<String> predicate) {\n+        this.description = description;\n+        this.predicate = predicate;\n+    }\n+\n+    public static StringMatcher of(Iterable<String> patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static StringMatcher of(String... patterns) {\n+        return StringMatcher.builder().includeAll(patterns).build();\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean test(String s) {\n+        return predicate.test(s);\n+    }\n+\n+    @Override\n+    public StringMatcher or(Predicate<? super String> other) {\n+        Objects.requireNonNull(other);\n+        return new StringMatcher(description + \"|\" + other, this.predicate.or(other));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "677f819709d790ad1004efcff79beea14aae2ea6"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNDE1Nw==", "bodyText": "Nit: why not\nassertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact1, exact2, exact3, prefix1, prefix2, suffix1, suffix2) + randomFrom(nonAlpha));\nAlso, why random from nonAlpha, shouldn't these tests work equally with any printable chars?\nUnless they were supposed to test something that wasn't obvious to me.", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r544004157", "createdAt": "2020-12-16T06:04:33Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/support/StringMatcherTests.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class StringMatcherTests extends ESTestCase {\n+\n+    public void testEmptySet() throws Exception {\n+        final StringMatcher matcher = StringMatcher.of();\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(i, 20));\n+        }\n+    }\n+\n+    public void testSingleWildcard() throws Exception {\n+        final String prefix = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(prefix + \"*\");\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, prefix + randomAlphaOfLengthBetween(i, 20));\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(1, prefix.length() - 1));\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.startsWith(prefix), () -> randomAlphaOfLengthBetween(1, 8)));\n+        }\n+    }\n+\n+    public void testSingleExactMatch() throws Exception {\n+        final String str = randomAlphaOfLengthBetween(3, 12);\n+        final StringMatcher matcher = StringMatcher.of(str);\n+        assertMatch(matcher, str);\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.equals(str), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertNoMatch(matcher, randomAlphaOfLength(1) + str);\n+            assertNoMatch(matcher, str + randomAlphaOfLength(1));\n+        }\n+    }\n+\n+    public void testSingleRegex() throws Exception {\n+        final String notStr = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(\"/~(\" + notStr + \")/\");\n+        assertNoMatch(matcher, notStr);\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, randomValueOtherThanMany(s -> s.equals(notStr), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertMatch(matcher, randomAlphaOfLength(1) + notStr);\n+            assertMatch(matcher, notStr + randomAlphaOfLength(1));\n+        }\n+\n+    }\n+\n+    public void testMultiplePatterns() throws Exception {\n+        final String prefix1 = randomAlphaOfLengthBetween(3, 5);\n+        final String prefix2 = randomAlphaOfLengthBetween(5, 8);\n+        final String prefix3 = randomAlphaOfLengthBetween(10, 12);\n+        final String suffix1 = randomAlphaOfLengthBetween(5, 10);\n+        final String suffix2 = randomAlphaOfLengthBetween(8, 12);\n+        final String exact1 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(5, 9));\n+        final String exact2 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(10, 12));\n+        final String exact3 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(15, 20));\n+\n+        final StringMatcher matcher = StringMatcher.of(List.of(\n+            prefix1 + \"*\", prefix2 + \"?\", \"/\" + prefix3 + \"@/\", \"*\" + suffix1, \"/@\" + suffix2 + \"/\", exact1, exact2, exact3\n+        ));\n+\n+        assertMatch(matcher, exact1);\n+        assertMatch(matcher, exact2);\n+        assertMatch(matcher, exact3);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix1);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix2);\n+        assertMatch(matcher, prefix1 + randomAlphaOfLengthBetween(1, 5));\n+        assertMatch(matcher, prefix2 + randomAlphaOfLength(1));\n+        assertMatch(matcher, prefix3 + randomAlphaOfLengthBetween(1, 5));\n+\n+        assertNoMatch(matcher, prefix2 + randomAlphaOfLength(2));\n+\n+        final char[] nonAlpha = \"@/#$0123456789()[]{}<>;:%&\".toCharArray();\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact1, prefix1, suffix1) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact2, prefix2, suffix2) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact3, prefix3) + randomFrom(nonAlpha));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "677f819709d790ad1004efcff79beea14aae2ea6"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNzM2NA==", "bodyText": "Nit: why not use the equal method of randomUnicodeOfLengthBetween that is available as part of EsTestCase?\nAlso, if we test unicode for description here, should it also be tested for matching?", "url": "https://github.com/elastic/elasticsearch/pull/65404#discussion_r544007364", "createdAt": "2020-12-16T06:08:44Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/support/StringMatcherTests.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.support;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class StringMatcherTests extends ESTestCase {\n+\n+    public void testEmptySet() throws Exception {\n+        final StringMatcher matcher = StringMatcher.of();\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(i, 20));\n+        }\n+    }\n+\n+    public void testSingleWildcard() throws Exception {\n+        final String prefix = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(prefix + \"*\");\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, prefix + randomAlphaOfLengthBetween(i, 20));\n+            assertNoMatch(matcher, randomAlphaOfLengthBetween(1, prefix.length() - 1));\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.startsWith(prefix), () -> randomAlphaOfLengthBetween(1, 8)));\n+        }\n+    }\n+\n+    public void testSingleExactMatch() throws Exception {\n+        final String str = randomAlphaOfLengthBetween(3, 12);\n+        final StringMatcher matcher = StringMatcher.of(str);\n+        assertMatch(matcher, str);\n+        for (int i = 0; i < 10; i++) {\n+            assertNoMatch(matcher, randomValueOtherThanMany(s -> s.equals(str), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertNoMatch(matcher, randomAlphaOfLength(1) + str);\n+            assertNoMatch(matcher, str + randomAlphaOfLength(1));\n+        }\n+    }\n+\n+    public void testSingleRegex() throws Exception {\n+        final String notStr = randomAlphaOfLengthBetween(3, 5);\n+        final StringMatcher matcher = StringMatcher.of(\"/~(\" + notStr + \")/\");\n+        assertNoMatch(matcher, notStr);\n+        for (int i = 0; i < 10; i++) {\n+            assertMatch(matcher, randomValueOtherThanMany(s -> s.equals(notStr), () -> randomAlphaOfLengthBetween(1, 20)));\n+            assertMatch(matcher, randomAlphaOfLength(1) + notStr);\n+            assertMatch(matcher, notStr + randomAlphaOfLength(1));\n+        }\n+\n+    }\n+\n+    public void testMultiplePatterns() throws Exception {\n+        final String prefix1 = randomAlphaOfLengthBetween(3, 5);\n+        final String prefix2 = randomAlphaOfLengthBetween(5, 8);\n+        final String prefix3 = randomAlphaOfLengthBetween(10, 12);\n+        final String suffix1 = randomAlphaOfLengthBetween(5, 10);\n+        final String suffix2 = randomAlphaOfLengthBetween(8, 12);\n+        final String exact1 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(5, 9));\n+        final String exact2 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(10, 12));\n+        final String exact3 = randomValueOtherThanMany(\n+            s -> s.startsWith(prefix1) || s.startsWith(prefix2) || s.startsWith(prefix3) || s.endsWith(suffix1) || s.endsWith(suffix2),\n+            () -> randomAlphaOfLengthBetween(15, 20));\n+\n+        final StringMatcher matcher = StringMatcher.of(List.of(\n+            prefix1 + \"*\", prefix2 + \"?\", \"/\" + prefix3 + \"@/\", \"*\" + suffix1, \"/@\" + suffix2 + \"/\", exact1, exact2, exact3\n+        ));\n+\n+        assertMatch(matcher, exact1);\n+        assertMatch(matcher, exact2);\n+        assertMatch(matcher, exact3);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix1);\n+        assertMatch(matcher, randomAlphaOfLength(3) + suffix2);\n+        assertMatch(matcher, prefix1 + randomAlphaOfLengthBetween(1, 5));\n+        assertMatch(matcher, prefix2 + randomAlphaOfLength(1));\n+        assertMatch(matcher, prefix3 + randomAlphaOfLengthBetween(1, 5));\n+\n+        assertNoMatch(matcher, prefix2 + randomAlphaOfLength(2));\n+\n+        final char[] nonAlpha = \"@/#$0123456789()[]{}<>;:%&\".toCharArray();\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact1, prefix1, suffix1) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact2, prefix2, suffix2) + randomFrom(nonAlpha));\n+        assertNoMatch(matcher, randomFrom(nonAlpha) + randomFrom(exact3, prefix3) + randomFrom(nonAlpha));\n+    }\n+\n+    public void testToString() throws Exception {\n+        // Replace any '/' characters because they're meaningful at the start, and just removing them all is simpler\n+        final String text1 = RandomizedTest.randomUnicodeOfLengthBetween(5, 80).replace('/', '.');\n+        final String text2 = RandomizedTest.randomUnicodeOfLength(20).replace('/', '.');\n+        final String text3 = RandomizedTest.randomUnicodeOfLength(50).replace('/', '.');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "677f819709d790ad1004efcff79beea14aae2ea6"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09038d442b23be7dfba2546ad33e5e1758796ea4", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/09038d442b23be7dfba2546ad33e5e1758796ea4", "committedDate": "2020-12-18T04:25:51Z", "message": "Merge branch 'master' into feature/patterns-util-class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea6288ed505a5604c0d42eebba644cd2c56544d2", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/ea6288ed505a5604c0d42eebba644cd2c56544d2", "committedDate": "2020-12-18T06:49:45Z", "message": "More feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4415, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}