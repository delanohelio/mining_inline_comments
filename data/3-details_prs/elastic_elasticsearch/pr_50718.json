{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMTg5MDE0", "number": 50718, "title": "ILM wait for active shards on rolled index in a separate step", "bodyText": "After we rollover the index we wait for the configured number of shards for the rolled index to become active (based on the index.write.wait_for_active_shards setting which might be present in a template, or otherwise in the default case, for the primaries to become active).\nThis wait might be long due to disk watermarks being tripped, replicas not being able to spring to life due to cluster nodes reconfiguration and others and the RolloverStep might not complete successfully due to this inherent transient situation, albeit the rolled index having been created.\nRelates to #48183 and #44135", "createdAt": "2020-01-07T21:52:34Z", "url": "https://github.com/elastic/elasticsearch/pull/50718", "merged": true, "mergeCommit": {"oid": "457a92fb4c68c55976cc3c3e2f00a053dd2eac70"}, "closed": true, "closedAt": "2020-01-22T09:41:32Z", "author": {"login": "andreidan"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4H5PqgH2gAyMzYwMTg5MDE0OmY2MjkwZTRhODg0YTc5NDYzOWNjNzNhNWIyZTBiYjdlODU4N2Y3ZDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8kDzHgFqTM0NjAzMjQzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f6290e4a884a794639cc73a5b2e0bb7e8587f7d3", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/f6290e4a884a794639cc73a5b2e0bb7e8587f7d3", "committedDate": "2020-01-07T21:46:33Z", "message": "ILM wait for active shards on rolled index in a separate step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fccfee5c9101322f6e93893b7472c3cd4956513a", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/fccfee5c9101322f6e93893b7472c3cd4956513a", "committedDate": "2020-01-07T22:03:21Z", "message": "Add license header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "456ba486c783ec17ec6f673d64d2a5cfcefe96ee", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/456ba486c783ec17ec6f673d64d2a5cfcefe96ee", "committedDate": "2020-01-08T10:52:02Z", "message": "Fix RolloverActionTests to reflect the new step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "292a8e6069e7b88165336640b0b30e53c42a7afb", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/292a8e6069e7b88165336640b0b30e53c42a7afb", "committedDate": "2020-01-15T12:18:47Z", "message": "WaitForActiveShardsStep uses the alias index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2673bd66eed05aeb89a666456b5dad63f7493d8", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2673bd66eed05aeb89a666456b5dad63f7493d8", "committedDate": "2020-01-15T12:18:54Z", "message": "Fix integratino test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77364de507d4b05dca388dbf5231118afbef08a2", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/77364de507d4b05dca388dbf5231118afbef08a2", "committedDate": "2020-01-15T12:26:37Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a98bf0a01f9701a4a27d1fbc130683a068abb50", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/0a98bf0a01f9701a4a27d1fbc130683a068abb50", "committedDate": "2020-01-15T13:17:24Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4842f395b66365ca26b4a4090e99dc7846a98112", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/4842f395b66365ca26b4a4090e99dc7846a98112", "committedDate": "2020-01-15T13:25:18Z", "message": "Don't wait for active shards when rolling over in ILM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/eb8f95f27d87b6a52aa49e627684c101b5dc2a7b", "committedDate": "2020-01-15T17:31:43Z", "message": "Fix TransportPutLifecycleActionTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4615f8e23006c9d3c0416d7e864d26afc64ec7a", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4615f8e23006c9d3c0416d7e864d26afc64ec7a", "committedDate": "2020-01-15T17:46:44Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDAwMzU2", "url": "https://github.com/elastic/elasticsearch/pull/50718#pullrequestreview-343400356", "createdAt": "2020-01-15T17:40:25Z", "commit": {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo0MDoyNlrOFeAvnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjozNjoyNFrOFeIsrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxMzc4OA==", "bodyText": "Can you add a comment above this about why we are setting it to zero (for future code spelunkers)", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367013788", "createdAt": "2020-01-15T17:40:26Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -70,6 +71,7 @@ public void performAction(IndexMetaData indexMetaData, ClusterState currentClust\n \n         // Calling rollover with no conditions will always roll over the index\n         RolloverRequest rolloverRequest = new RolloverRequest(rolloverAlias, null);\n+        rolloverRequest.setWaitForActiveShards(ActiveShardCount.NONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNDYxOA==", "bodyText": "We should check for this to be null here (in the event the index was deleted immediately prior to the invocation), our other ClusterStateWaitSteps have this null check", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367014618", "createdAt": "2020-01-15T17:42:14Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.List;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8f95f27d87b6a52aa49e627684c101b5dc2a7b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NDEwOQ==", "bodyText": "I think we can return a more descriptive information object here, something like \"waiting for 3 shards to become active, currently 2 are active\" or something that includes the amount we're waiting for and the amount currently active.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367144109", "createdAt": "2020-01-15T22:36:24Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.List;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +\n+                \"one index\";\n+            IndexMetaData indexMetaData = indices.get(0);\n+            rolledIndexName = indexMetaData.getIndex().getName();\n+            waitForActiveShardsSettingValue = indexMetaData.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        return new Result(activeShardCount.enoughShardsActive(clusterState, rolledIndexName), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4615f8e23006c9d3c0416d7e864d26afc64ec7a"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "115a1312554445947c073f17fecb93c6663e4f83", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/115a1312554445947c073f17fecb93c6663e4f83", "committedDate": "2020-01-16T12:47:25Z", "message": "Comment to clarify why rollover doens't wait for active shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0924222ed9ac7a98a95c4220ffca25b9003b14e5", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/0924222ed9ac7a98a95c4220ffca25b9003b14e5", "committedDate": "2020-01-16T12:47:25Z", "message": "Guard against the index having been deleted while executing a policy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf09bbc3132713bef72a866faf810238206a5e8c", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/bf09bbc3132713bef72a866faf810238206a5e8c", "committedDate": "2020-01-16T12:47:26Z", "message": "Return a meaningful shards state message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c33a595e0afc994082256c726824c43b15eedd77", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/c33a595e0afc994082256c726824c43b15eedd77", "committedDate": "2020-01-16T12:47:50Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6225c04f81cbe3690686916695a04c7641d1b84c", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/6225c04f81cbe3690686916695a04c7641d1b84c", "committedDate": "2020-01-16T13:54:47Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/a27e1cc370bed4abcb2e3c378b4bc02f45ef2537", "committedDate": "2020-01-16T15:03:31Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MTAzNTIy", "url": "https://github.com/elastic/elasticsearch/pull/50718#pullrequestreview-344103522", "createdAt": "2020-01-16T17:53:39Z", "commit": {"oid": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1MzozOVrOFeiUnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzo1MzozOVrOFeiUnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzkzMw==", "bodyText": "this assertion doesn't stand in a CCR environment", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r367563933", "createdAt": "2020-01-16T17:53:39Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            // if the rollover was not performed on a write index alias, the alias will be moved to the new index and it will be the only\n+            // index this alias points to\n+            List<IndexMetaData> indices = alias.getIndices();\n+            assert indices.size() == 1 : \"when performing rollover on alias with is_write_index = false the alias must point to only \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27e1cc370bed4abcb2e3c378b4bc02f45ef2537"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a838925f90b2b1cda1828c4ca6c2e29d8c8fcaf6", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/a838925f90b2b1cda1828c4ca6c2e29d8c8fcaf6", "committedDate": "2020-01-17T15:47:21Z", "message": "Drop unused getters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f9b842b9313e077a2ae89bed28e334f258c33c8", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/9f9b842b9313e077a2ae89bed28e334f258c33c8", "committedDate": "2020-01-17T15:47:21Z", "message": "Find rolled index by finding the max counter in the name."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3f506e9b5c18d3d1beb2aff9b8e4a15eb2852ea", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3f506e9b5c18d3d1beb2aff9b8e4a15eb2852ea", "committedDate": "2020-01-17T16:05:42Z", "message": "Escape < and > in javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76791435a3f96798f6ac29eba5b03b06db697aa4", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/76791435a3f96798f6ac29eba5b03b06db697aa4", "committedDate": "2020-01-17T17:16:00Z", "message": "Skip WaitForActiveShardsStep when lifecycle complete is set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/3a1cd874b1e1824458af64e8b6544d6bef18d4eb", "committedDate": "2020-01-17T17:16:49Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzI4OTIx", "url": "https://github.com/elastic/elasticsearch/pull/50718#pullrequestreview-344728921", "createdAt": "2020-01-17T17:25:27Z", "commit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzoyNToyOFrOFe__cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDoxN1rOFfAccQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MDAzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String rolledIndexName;\n          \n          \n            \n                    final String rolledIndexName;", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368050035", "createdAt": "2020-01-17T17:25:28Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MDExMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String waitForActiveShardsSettingValue;\n          \n          \n            \n                    final String waitForActiveShardsSettingValue;", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368050113", "createdAt": "2020-01-17T17:25:37Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTM3Mw==", "bodyText": "Can we return the above log message as part of the \"info\" ToXContent object here? Otherwise this could stick in false forever and the user would never know why", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368051373", "createdAt": "2020-01-17T17:28:45Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDMzOQ==", "bodyText": "I think we should remove this assert and throw a regular error", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368054339", "createdAt": "2020-01-17T17:36:25Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NDg4MQ==", "bodyText": "This should catch the NumberFormatException and format it into a nicer, more human readable exception. It's possible to hit this if someone were to take an index foo-000003 and snapshot it, then restore it with a different name (like foo-000003-restored for example), this would flip out but it wouldn't be clear why.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368054881", "createdAt": "2020-01-17T17:37:36Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NjczMQ==", "bodyText": "I believe this PARSER is never actually used?", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368056731", "createdAt": "2020-01-17T17:42:18Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzM5Nw==", "bodyText": "Minor nit, but we should keep these lowercase, and I don't think we need a trailing period (these are more like error messages than sentences)", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368057397", "createdAt": "2020-01-17T17:44:07Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",\n+            a -> new Info((long) a[0], (String) a[1], (boolean) a[2]));\n+\n+        static {\n+            PARSER.declareLong(ConstructingObjectParser.constructorArg(), CURRENT_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareString(ConstructingObjectParser.constructorArg(), TARGET_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENOUGH_SHARDS_ACTIVE);\n+            PARSER.declareString((i, s) -> {\n+            }, MESSAGE);\n+        }\n+\n+        public Info(long currentActiveShardsCount, String targetActiveShardsCount, boolean enoughShardsActive) {\n+            this.currentActiveShardsCount = currentActiveShardsCount;\n+            this.targetActiveShardsCount = targetActiveShardsCount;\n+            this.enoughShardsActive = enoughShardsActive;\n+\n+            if (enoughShardsActive) {\n+                message = \"The target of [\" + targetActiveShardsCount + \"] are active. Don't need to wait anymore.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzQ1Nw==", "bodyText": "Same about lowercasing/trailing-period here.", "url": "https://github.com/elastic/elasticsearch/pull/50718#discussion_r368057457", "createdAt": "2020-01-17T17:44:17Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import com.carrotsearch.hppc.cursors.IntObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex;\n+import org.elasticsearch.cluster.metadata.AliasOrIndex.Alias;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * After we performed the index rollover we wait for the the configured number of shards for the rolled over index (ie. newly created\n+ * index) to become available.\n+ */\n+public class WaitForActiveShardsStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-active-shards\";\n+\n+    private static final Logger logger = LogManager.getLogger(WaitForActiveShardsStep.class);\n+\n+    WaitForActiveShardsStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData originalIndexMeta = clusterState.metaData().index(index);\n+\n+        if (originalIndexMeta == null) {\n+            // Index must have been since deleted\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+\n+        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(originalIndexMeta.getSettings());\n+        if (indexingComplete) {\n+            logger.trace(originalIndexMeta.getIndex() + \" has lifecycle complete set, skipping \" + WaitForActiveShardsStep.NAME);\n+            return new Result(true, null);\n+        }\n+\n+        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+        if (Strings.isNullOrEmpty(rolloverAlias)) {\n+            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+        }\n+\n+        AliasOrIndex aliasOrIndex = clusterState.metaData().getAliasAndIndexLookup().get(rolloverAlias);\n+        assert aliasOrIndex.isAlias() : rolloverAlias + \" must be an alias but it is an index\";\n+\n+        Alias alias = (Alias) aliasOrIndex;\n+        IndexMetaData aliasWriteIndex = alias.getWriteIndex();\n+        String rolledIndexName;\n+        String waitForActiveShardsSettingValue;\n+        if (aliasWriteIndex != null) {\n+            rolledIndexName = aliasWriteIndex.getIndex().getName();\n+            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            List<IndexMetaData> indices = alias.getIndices();\n+            int maxIndexCounter = -1;\n+            IndexMetaData rolledIndexMeta = null;\n+            for (IndexMetaData indexMetaData : indices) {\n+                int indexNameCounter = parseIndexNameCounter(indexMetaData.getIndex().getName());\n+                if (maxIndexCounter < indexNameCounter) {\n+                    maxIndexCounter = indexNameCounter;\n+                    rolledIndexMeta = indexMetaData;\n+                }\n+            }\n+            if (rolledIndexMeta == null) {\n+                // Index must have been since deleted\n+                logger.debug(\"unable to find the index that was rolled over from [{}] as part of lifecycle action [{}]\", index.getName(),\n+                    getKey().getAction());\n+                return new Result(false, null);\n+            }\n+            rolledIndexName = rolledIndexMeta.getIndex().getName();\n+            waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        }\n+\n+        ActiveShardCount activeShardCount = ActiveShardCount.parseString(waitForActiveShardsSettingValue);\n+        boolean enoughShardsActive = activeShardCount.enoughShardsActive(clusterState, rolledIndexName);\n+\n+        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(rolledIndexName);\n+        int currentActiveShards = 0;\n+        for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {\n+            currentActiveShards += shardRouting.value.activeShards().size();\n+        }\n+        return new Result(enoughShardsActive, new Info(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n+    }\n+\n+    /**\n+     * Parses the number from the rolled over index name. It also supports the date-math format (ie. index name is wrapped in &lt; and &gt;)\n+     * <p>\n+     * Eg.\n+     * <p>\n+     * - For \"logs-000002\" it'll return 2\n+     * - For \"&lt;logs-{now/d}-3&gt;\" it'll return 3\n+     */\n+    static int parseIndexNameCounter(String indexName) {\n+        int numberIndex = indexName.lastIndexOf(\"-\");\n+        assert numberIndex != -1 : \"no separator '-' found\";\n+        return Integer.parseInt(indexName.substring(numberIndex + 1, indexName.endsWith(\">\") ? indexName.length() - 1 :\n+            indexName.length()));\n+    }\n+\n+    public static final class Info implements ToXContentObject {\n+\n+        private final long currentActiveShardsCount;\n+        private final String targetActiveShardsCount;\n+        private final boolean enoughShardsActive;\n+        private final String message;\n+\n+        static final ParseField CURRENT_ACTIVE_SHARDS_COUNT = new ParseField(\"current_active_shards_count\");\n+        static final ParseField TARGET_ACTIVE_SHARDS_COUNT = new ParseField(\"target_active_shards_count\");\n+        static final ParseField ENOUGH_SHARDS_ACTIVE = new ParseField(\"enough_shards_active\");\n+        static final ParseField MESSAGE = new ParseField(\"message\");\n+        static final ConstructingObjectParser<Info, Void> PARSER = new ConstructingObjectParser<>(\"wait_for_active_shards_step_info\",\n+            a -> new Info((long) a[0], (String) a[1], (boolean) a[2]));\n+\n+        static {\n+            PARSER.declareLong(ConstructingObjectParser.constructorArg(), CURRENT_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareString(ConstructingObjectParser.constructorArg(), TARGET_ACTIVE_SHARDS_COUNT);\n+            PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENOUGH_SHARDS_ACTIVE);\n+            PARSER.declareString((i, s) -> {\n+            }, MESSAGE);\n+        }\n+\n+        public Info(long currentActiveShardsCount, String targetActiveShardsCount, boolean enoughShardsActive) {\n+            this.currentActiveShardsCount = currentActiveShardsCount;\n+            this.targetActiveShardsCount = targetActiveShardsCount;\n+            this.enoughShardsActive = enoughShardsActive;\n+\n+            if (enoughShardsActive) {\n+                message = \"The target of [\" + targetActiveShardsCount + \"] are active. Don't need to wait anymore.\";\n+            } else {\n+                message = \"Waiting for [\" + targetActiveShardsCount + \"] shards to become active, but only [\" + currentActiveShardsCount +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a1cd874b1e1824458af64e8b6544d6bef18d4eb"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b838f3a6b32b076526ca038310f298f99b8d5626", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/b838f3a6b32b076526ca038310f298f99b8d5626", "committedDate": "2020-01-20T12:20:35Z", "message": "Use lower case and drop . in error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "444985353d95bf9ab1ef0f8f3d5fd5bea9295fb8", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/444985353d95bf9ab1ef0f8f3d5fd5bea9295fb8", "committedDate": "2020-01-20T12:20:35Z", "message": "Mark vars as final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c9f065cfed09c781acf8fb8866515759afe00a", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/64c9f065cfed09c781acf8fb8866515759afe00a", "committedDate": "2020-01-20T12:20:35Z", "message": "Add explicit error handling to parseIndexNameCounter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9322665fd4fb46a2ba927f188f7d9b0f607e90d2", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/9322665fd4fb46a2ba927f188f7d9b0f607e90d2", "committedDate": "2020-01-20T12:20:35Z", "message": "Remove Parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36e07fc60e2e9d1b3ea4bea46a7d32be23f3884c", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/36e07fc60e2e9d1b3ea4bea46a7d32be23f3884c", "committedDate": "2020-01-20T12:20:35Z", "message": "Add Info object to report various step progress messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0ecf31a35f3535602e7bfaabf4285a9c4440dc4", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0ecf31a35f3535602e7bfaabf4285a9c4440dc4", "committedDate": "2020-01-20T12:54:35Z", "message": "Make constructors default visible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4f2c84c5e3c3fb85f0a30463c5ec44675d407b1", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/f4f2c84c5e3c3fb85f0a30463c5ec44675d407b1", "committedDate": "2020-01-20T13:24:46Z", "message": "Merge branch 'master' into ilm-rollover-wait-for-active-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MDMyNDMw", "url": "https://github.com/elastic/elasticsearch/pull/50718#pullrequestreview-346032430", "createdAt": "2020-01-21T16:51:07Z", "commit": {"oid": "f4f2c84c5e3c3fb85f0a30463c5ec44675d407b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3892, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}