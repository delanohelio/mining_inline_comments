{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3MTg2ODgw", "number": 64751, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzozODo1NlrOE7Ku3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzozODo1NlrOE7Ku3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDc3Mjc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/bootstrap/PolicyUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzozODo1NlrOH2qHjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoyMToxMlrOH20W-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NTIxMg==", "bodyText": "Is there a reason we don't just build the map with the canonical class name?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, List<String>> classPermissions = Map.of(\n          \n          \n            \n                        URLPermission.class, ALLOW_ALL_NAMES,\n          \n          \n            \n                        DelegationPermission.class, ALLOW_ALL_NAMES,\n          \n          \n            \n                        ServicePermission.class, ALLOW_ALL_NAMES,\n          \n          \n            \n                        PrivateCredentialPermission.class, ALLOW_ALL_NAMES,\n          \n          \n            \n                        SQLPermission.class, List.of(\"callAbort\", \"setNetworkTimeout\"),\n          \n          \n            \n                        ClassPermission.class, ALLOW_ALL_NAMES\n          \n          \n            \n                    ).entrySet().stream().collect(Collectors.toMap(e -> e.getKey().getCanonicalName(), Map.Entry::getValue));\n          \n          \n            \n                    Map<String, List<String>> classPermissions = Map.of(\n          \n          \n            \n                        URLPermission.class.getCanonicalName(), ALLOW_ALL_NAMES,\n          \n          \n            \n                        DelegationPermission.class.getCanonicalName(), ALLOW_ALL_NAMES,\n          \n          \n            \n                        ServicePermission.class.getCanonicalName(), ALLOW_ALL_NAMES,\n          \n          \n            \n                        PrivateCredentialPermission.class.getCanonicalName(), ALLOW_ALL_NAMES,\n          \n          \n            \n                        SQLPermission.class.getCanonicalName(), List.of(\"callAbort\", \"setNetworkTimeout\"),\n          \n          \n            \n                        ClassPermission.class.getCanonicalName(), ALLOW_ALL_NAMES\n          \n          \n            \n                    );", "url": "https://github.com/elastic/elasticsearch/pull/64751#discussion_r527075212", "createdAt": "2020-11-19T17:38:56Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/bootstrap/PolicyUtil.java", "diffHunk": "@@ -23,31 +23,170 @@\n import org.elasticsearch.common.io.PathUtils;\n import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.plugins.PluginInfo;\n+import org.elasticsearch.script.ClassPermission;\n \n+import javax.security.auth.AuthPermission;\n+import javax.security.auth.PrivateCredentialPermission;\n+import javax.security.auth.kerberos.DelegationPermission;\n+import javax.security.auth.kerberos.ServicePermission;\n+import java.io.FilePermission;\n import java.io.IOException;\n+import java.lang.reflect.ReflectPermission;\n+import java.net.NetPermission;\n+import java.net.SocketPermission;\n import java.net.URISyntaxException;\n import java.net.URL;\n+import java.net.URLPermission;\n import java.nio.file.DirectoryStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.security.CodeSource;\n import java.security.NoSuchAlgorithmException;\n import java.security.Permission;\n import java.security.PermissionCollection;\n+import java.security.Permissions;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n+import java.security.SecurityPermission;\n import java.security.URIParameter;\n+import java.security.UnresolvedPermission;\n import java.security.cert.Certificate;\n+import java.sql.SQLPermission;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n+import java.util.PropertyPermission;\n import java.util.Properties;\n import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n public class PolicyUtil {\n+\n+    // this object is checked by reference, so the value in the list does not matter\n+    static final List<String> ALLOW_ALL_NAMES = List.of(\"ALLOW ALL NAMES SENTINEL\");\n+\n+    static class PermissionMatcher implements Predicate<Permission> {\n+\n+        PermissionCollection namedPermissions;\n+        Map<String, List<String>> classPermissions;\n+\n+        PermissionMatcher(PermissionCollection namedPermissions,\n+                          Map<String, List<String>> classPermissions) {\n+            this.namedPermissions = namedPermissions;\n+            this.classPermissions = classPermissions;\n+        }\n+\n+        @Override\n+        public boolean test(Permission permission) {\n+            if (namedPermissions.implies(permission)) {\n+                return true;\n+            }\n+            String clazz = permission.getClass().getCanonicalName();\n+            String name = permission.getName();\n+            if (permission.getClass().equals(UnresolvedPermission.class)) {\n+                UnresolvedPermission up = (UnresolvedPermission) permission;\n+                clazz = up.getUnresolvedType();\n+                name = up.getUnresolvedName();\n+            }\n+            List<String> allowedNames = classPermissions.get(clazz);\n+            return allowedNames != null && (allowedNames == ALLOW_ALL_NAMES || allowedNames.contains(name));\n+        }\n+    }\n+\n+    private static final PermissionMatcher ALLOWED_PLUGIN_PERMISSIONS;\n+    private static final PermissionMatcher ALLOWED_MODULE_PERMISSIONS;\n+    static {\n+        List<Permission> namedPermissions = List.of(\n+            new ReflectPermission(\"suppressAccessChecks\"),\n+            new RuntimePermission(\"createClassLoader\"),\n+            new RuntimePermission(\"getClassLoader\"),\n+            new RuntimePermission(\"setContextClassLoader\"),\n+            new RuntimePermission(\"setFactory\"),\n+            new RuntimePermission(\"loadLibrary.*\"),\n+            new RuntimePermission(\"accessClassInPackage.*\"),\n+            new RuntimePermission(\"accessDeclaredMembers\"),\n+            new NetPermission(\"requestPasswordAuthentication\"),\n+            new NetPermission(\"getProxySelector\"),\n+            new NetPermission(\"getCookieHandler\"),\n+            new NetPermission(\"getResponseCache\"),\n+            new SocketPermission(\"*\", \"accept,connect,listen,resolve\"),\n+            new SecurityPermission(\"createAccessControlContext\"),\n+            new SecurityPermission(\"insertProvider\"),\n+            new SecurityPermission(\"putProviderProperty.*\"),\n+            // apache abuses the SecurityPermission class for it's own purposes\n+            new SecurityPermission(\"org.apache.*\"),\n+            // write is needed because of HdfsPlugin\n+            new PropertyPermission(\"*\", \"read,write\"),\n+            new AuthPermission(\"doAs\"),\n+            new AuthPermission(\"doAsPrivileged\"),\n+            new AuthPermission(\"getSubject\"),\n+            new AuthPermission(\"getSubjectFromDomainCombiner\"),\n+            new AuthPermission(\"setReadOnly\"),\n+            new AuthPermission(\"modifyPrincipals\"),\n+            new AuthPermission(\"modifyPublicCredentials\"),\n+            new AuthPermission(\"modifyPrivateCredentials\"),\n+            new AuthPermission(\"refreshCredential\"),\n+            new AuthPermission(\"destroyCredential\"),\n+            new AuthPermission(\"createLoginContext.*\"),\n+            new AuthPermission(\"getLoginConfiguration\"),\n+            new AuthPermission(\"setLoginConfiguration\"),\n+            new AuthPermission(\"createLoginConfiguration.*\"),\n+            new AuthPermission(\"refreshLoginConfiguration\")\n+        );\n+        // While it would be ideal to represent all allowed permissions with concrete instances so that we can\n+        // use the builtin implies method to match them against the parsed policy, this does not work in all\n+        // cases for two reasons:\n+        // (1) Some permissions classes do not have a name argument that can represent all possible variants.\n+        //     For example, FilePermission has \"<< ALL FILES >>\" so all paths can be matched, but DelegationPermission\n+        //     does not have anything to represent all principals.\n+        // (2) Some permissions classes are in java modules that are not accessible from the classloader used by\n+        //     the policy parser. This results in those permissions being in UnresolvedPermission instances. Those\n+        //     are normally resolved at runtime when that permission is checked by SecurityManager. But there is\n+        //     no general purpose utility to resolve those permissions, so we must be able to match those\n+        //     unresolved permissions in the policy by class and name values.\n+        // Given the above, the below map is from permission class to the list of allowed name values. A sentinel value\n+        // is used to mean names are accepted. We do not use this model for all permissions because many permission\n+        // classes have their own meaning for some form of wildcard matching of the name, which we want to delegate\n+        // to those permissions if possible.\n+        Map<String, List<String>> classPermissions = Map.of(\n+            URLPermission.class, ALLOW_ALL_NAMES,\n+            DelegationPermission.class, ALLOW_ALL_NAMES,\n+            ServicePermission.class, ALLOW_ALL_NAMES,\n+            PrivateCredentialPermission.class, ALLOW_ALL_NAMES,\n+            SQLPermission.class, List.of(\"callAbort\", \"setNetworkTimeout\"),\n+            ClassPermission.class, ALLOW_ALL_NAMES\n+        ).entrySet().stream().collect(Collectors.toMap(e -> e.getKey().getCanonicalName(), Map.Entry::getValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa7766a7a879e1d367ff867a89988c95258555e1"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MzAwMw==", "bodyText": "Just more cumbersome to add. I found it easier to do the common manipulation at the end on all the entries.", "url": "https://github.com/elastic/elasticsearch/pull/64751#discussion_r527243003", "createdAt": "2020-11-19T22:21:12Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/bootstrap/PolicyUtil.java", "diffHunk": "@@ -23,31 +23,170 @@\n import org.elasticsearch.common.io.PathUtils;\n import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.plugins.PluginInfo;\n+import org.elasticsearch.script.ClassPermission;\n \n+import javax.security.auth.AuthPermission;\n+import javax.security.auth.PrivateCredentialPermission;\n+import javax.security.auth.kerberos.DelegationPermission;\n+import javax.security.auth.kerberos.ServicePermission;\n+import java.io.FilePermission;\n import java.io.IOException;\n+import java.lang.reflect.ReflectPermission;\n+import java.net.NetPermission;\n+import java.net.SocketPermission;\n import java.net.URISyntaxException;\n import java.net.URL;\n+import java.net.URLPermission;\n import java.nio.file.DirectoryStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.security.CodeSource;\n import java.security.NoSuchAlgorithmException;\n import java.security.Permission;\n import java.security.PermissionCollection;\n+import java.security.Permissions;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n+import java.security.SecurityPermission;\n import java.security.URIParameter;\n+import java.security.UnresolvedPermission;\n import java.security.cert.Certificate;\n+import java.sql.SQLPermission;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n+import java.util.PropertyPermission;\n import java.util.Properties;\n import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n public class PolicyUtil {\n+\n+    // this object is checked by reference, so the value in the list does not matter\n+    static final List<String> ALLOW_ALL_NAMES = List.of(\"ALLOW ALL NAMES SENTINEL\");\n+\n+    static class PermissionMatcher implements Predicate<Permission> {\n+\n+        PermissionCollection namedPermissions;\n+        Map<String, List<String>> classPermissions;\n+\n+        PermissionMatcher(PermissionCollection namedPermissions,\n+                          Map<String, List<String>> classPermissions) {\n+            this.namedPermissions = namedPermissions;\n+            this.classPermissions = classPermissions;\n+        }\n+\n+        @Override\n+        public boolean test(Permission permission) {\n+            if (namedPermissions.implies(permission)) {\n+                return true;\n+            }\n+            String clazz = permission.getClass().getCanonicalName();\n+            String name = permission.getName();\n+            if (permission.getClass().equals(UnresolvedPermission.class)) {\n+                UnresolvedPermission up = (UnresolvedPermission) permission;\n+                clazz = up.getUnresolvedType();\n+                name = up.getUnresolvedName();\n+            }\n+            List<String> allowedNames = classPermissions.get(clazz);\n+            return allowedNames != null && (allowedNames == ALLOW_ALL_NAMES || allowedNames.contains(name));\n+        }\n+    }\n+\n+    private static final PermissionMatcher ALLOWED_PLUGIN_PERMISSIONS;\n+    private static final PermissionMatcher ALLOWED_MODULE_PERMISSIONS;\n+    static {\n+        List<Permission> namedPermissions = List.of(\n+            new ReflectPermission(\"suppressAccessChecks\"),\n+            new RuntimePermission(\"createClassLoader\"),\n+            new RuntimePermission(\"getClassLoader\"),\n+            new RuntimePermission(\"setContextClassLoader\"),\n+            new RuntimePermission(\"setFactory\"),\n+            new RuntimePermission(\"loadLibrary.*\"),\n+            new RuntimePermission(\"accessClassInPackage.*\"),\n+            new RuntimePermission(\"accessDeclaredMembers\"),\n+            new NetPermission(\"requestPasswordAuthentication\"),\n+            new NetPermission(\"getProxySelector\"),\n+            new NetPermission(\"getCookieHandler\"),\n+            new NetPermission(\"getResponseCache\"),\n+            new SocketPermission(\"*\", \"accept,connect,listen,resolve\"),\n+            new SecurityPermission(\"createAccessControlContext\"),\n+            new SecurityPermission(\"insertProvider\"),\n+            new SecurityPermission(\"putProviderProperty.*\"),\n+            // apache abuses the SecurityPermission class for it's own purposes\n+            new SecurityPermission(\"org.apache.*\"),\n+            // write is needed because of HdfsPlugin\n+            new PropertyPermission(\"*\", \"read,write\"),\n+            new AuthPermission(\"doAs\"),\n+            new AuthPermission(\"doAsPrivileged\"),\n+            new AuthPermission(\"getSubject\"),\n+            new AuthPermission(\"getSubjectFromDomainCombiner\"),\n+            new AuthPermission(\"setReadOnly\"),\n+            new AuthPermission(\"modifyPrincipals\"),\n+            new AuthPermission(\"modifyPublicCredentials\"),\n+            new AuthPermission(\"modifyPrivateCredentials\"),\n+            new AuthPermission(\"refreshCredential\"),\n+            new AuthPermission(\"destroyCredential\"),\n+            new AuthPermission(\"createLoginContext.*\"),\n+            new AuthPermission(\"getLoginConfiguration\"),\n+            new AuthPermission(\"setLoginConfiguration\"),\n+            new AuthPermission(\"createLoginConfiguration.*\"),\n+            new AuthPermission(\"refreshLoginConfiguration\")\n+        );\n+        // While it would be ideal to represent all allowed permissions with concrete instances so that we can\n+        // use the builtin implies method to match them against the parsed policy, this does not work in all\n+        // cases for two reasons:\n+        // (1) Some permissions classes do not have a name argument that can represent all possible variants.\n+        //     For example, FilePermission has \"<< ALL FILES >>\" so all paths can be matched, but DelegationPermission\n+        //     does not have anything to represent all principals.\n+        // (2) Some permissions classes are in java modules that are not accessible from the classloader used by\n+        //     the policy parser. This results in those permissions being in UnresolvedPermission instances. Those\n+        //     are normally resolved at runtime when that permission is checked by SecurityManager. But there is\n+        //     no general purpose utility to resolve those permissions, so we must be able to match those\n+        //     unresolved permissions in the policy by class and name values.\n+        // Given the above, the below map is from permission class to the list of allowed name values. A sentinel value\n+        // is used to mean names are accepted. We do not use this model for all permissions because many permission\n+        // classes have their own meaning for some form of wildcard matching of the name, which we want to delegate\n+        // to those permissions if possible.\n+        Map<String, List<String>> classPermissions = Map.of(\n+            URLPermission.class, ALLOW_ALL_NAMES,\n+            DelegationPermission.class, ALLOW_ALL_NAMES,\n+            ServicePermission.class, ALLOW_ALL_NAMES,\n+            PrivateCredentialPermission.class, ALLOW_ALL_NAMES,\n+            SQLPermission.class, List.of(\"callAbort\", \"setNetworkTimeout\"),\n+            ClassPermission.class, ALLOW_ALL_NAMES\n+        ).entrySet().stream().collect(Collectors.toMap(e -> e.getKey().getCanonicalName(), Map.Entry::getValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NTIxMg=="}, "originalCommit": {"oid": "aa7766a7a879e1d367ff867a89988c95258555e1"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3128, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}