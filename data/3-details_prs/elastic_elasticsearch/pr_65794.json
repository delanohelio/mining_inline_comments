{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMzYwODI5", "number": 65794, "title": "[DOCS] EQL: Document how sequence queries handle matches", "bodyText": "Documents how a EQL sequence query works internally as a finite state machine. Based on the original Endgame EQL docs.\nCloses #65773\nPreview\nhttps://elasticsearch_65794.docs-preview.app.elstc.co/guide/en/elasticsearch/reference/master/eql-syntax.html#eql-how-sequence-queries-handle-matches", "createdAt": "2020-12-02T23:49:58Z", "url": "https://github.com/elastic/elasticsearch/pull/65794", "merged": true, "mergeCommit": {"oid": "ef6fb59ec355e05aa7b5ebb8fae3fbb075d77a3c"}, "closed": true, "closedAt": "2020-12-04T14:34:39Z", "author": {"login": "jrodewig"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiXe1CgBqjQwNjQ4ODgyOTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdi4m_eAFqTU0NTAwNDk0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a549602af2933b5be8d48d205b728292effc5b8", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/3a549602af2933b5be8d48d205b728292effc5b8", "committedDate": "2020-12-02T23:48:21Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "ed2ee6c60dea7d4d66ca7d4e5466f59a2193624a", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/ed2ee6c60dea7d4d66ca7d4e5466f59a2193624a", "committedDate": "2020-12-02T23:51:59Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed2ee6c60dea7d4d66ca7d4e5466f59a2193624a", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/ed2ee6c60dea7d4d66ca7d4e5466f59a2193624a", "committedDate": "2020-12-02T23:51:59Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "51e310d2f5b983e61c6bb3d17696981253c09db1", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/51e310d2f5b983e61c6bb3d17696981253c09db1", "committedDate": "2020-12-02T23:54:07Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51e310d2f5b983e61c6bb3d17696981253c09db1", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/51e310d2f5b983e61c6bb3d17696981253c09db1", "committedDate": "2020-12-02T23:54:07Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "a4e21d19cee00c10f7d11e30987de9e64db8bed0", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4e21d19cee00c10f7d11e30987de9e64db8bed0", "committedDate": "2020-12-02T23:55:11Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a034afd28471b5098ae8e9d5e65f144b46e8b87", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a034afd28471b5098ae8e9d5e65f144b46e8b87", "committedDate": "2020-12-03T00:12:47Z", "message": "Fix snippet again"}, "afterCommit": {"oid": "45ddbd2a86bf76320bf0a2c2077bb47b6d89c70b", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/45ddbd2a86bf76320bf0a2c2077bb47b6d89c70b", "committedDate": "2020-12-03T03:04:41Z", "message": "Fix snippet again"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45ddbd2a86bf76320bf0a2c2077bb47b6d89c70b", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/45ddbd2a86bf76320bf0a2c2077bb47b6d89c70b", "committedDate": "2020-12-03T03:04:41Z", "message": "Fix snippet again"}, "afterCommit": {"oid": "f2f52f1c69e49d27be82c8c5d4cbe3a112596971", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/f2f52f1c69e49d27be82c8c5d4cbe3a112596971", "committedDate": "2020-12-03T03:05:03Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2f52f1c69e49d27be82c8c5d4cbe3a112596971", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/f2f52f1c69e49d27be82c8c5d4cbe3a112596971", "committedDate": "2020-12-03T03:05:03Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "eaf86cf51ed9244ef12a6f896b3f63a63a239dc9", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/eaf86cf51ed9244ef12a6f896b3f63a63a239dc9", "committedDate": "2020-12-03T03:11:11Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eaf86cf51ed9244ef12a6f896b3f63a63a239dc9", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/eaf86cf51ed9244ef12a6f896b3f63a63a239dc9", "committedDate": "2020-12-03T03:11:11Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "5841410cd07b112ea32b120307e98ac55b0e933b", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/5841410cd07b112ea32b120307e98ac55b0e933b", "committedDate": "2020-12-03T03:12:23Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5841410cd07b112ea32b120307e98ac55b0e933b", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/5841410cd07b112ea32b120307e98ac55b0e933b", "committedDate": "2020-12-03T03:12:23Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "da750cbb20af7268a9a0a19f63059427ff9150be", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/da750cbb20af7268a9a0a19f63059427ff9150be", "committedDate": "2020-12-03T03:12:54Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da750cbb20af7268a9a0a19f63059427ff9150be", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/da750cbb20af7268a9a0a19f63059427ff9150be", "committedDate": "2020-12-03T03:12:54Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "7932ca2ce3ddbd0a04b991654f65f0130805b68e", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/7932ca2ce3ddbd0a04b991654f65f0130805b68e", "committedDate": "2020-12-03T03:19:02Z", "message": "[DOCS] EQL: Document sequence matching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7932ca2ce3ddbd0a04b991654f65f0130805b68e", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/7932ca2ce3ddbd0a04b991654f65f0130805b68e", "committedDate": "2020-12-03T03:19:02Z", "message": "[DOCS] EQL: Document sequence matching"}, "afterCommit": {"oid": "a113a0a54a863cbe86f253c7ade28034a2c8ef73", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/a113a0a54a863cbe86f253c7ade28034a2c8ef73", "committedDate": "2020-12-03T14:35:42Z", "message": "[DOCS] EQL: Document how sequence queries find matches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/bda543777a50649fa014e9d12964b239b7c3da75", "committedDate": "2020-12-03T14:36:52Z", "message": "[DOCS] EQL: Document how sequence queries find matches"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a113a0a54a863cbe86f253c7ade28034a2c8ef73", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/a113a0a54a863cbe86f253c7ade28034a2c8ef73", "committedDate": "2020-12-03T14:35:42Z", "message": "[DOCS] EQL: Document how sequence queries find matches"}, "afterCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/bda543777a50649fa014e9d12964b239b7c3da75", "committedDate": "2020-12-03T14:36:52Z", "message": "[DOCS] EQL: Document how sequence queries find matches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDU2MjAw", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544056200", "createdAt": "2020-12-03T15:14:11Z", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNDoxMlrOH-hSGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNDoxMlrOH-hSGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ==", "bodyText": "is _id sorted by default? i can't remember how it fits into the sequence ordering. i think this is right, just want to double check", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535319065", "createdAt": "2020-12-03T15:14:12Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDYwNzc2", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544060776", "createdAt": "2020-12-03T15:18:17Z", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxODoxN1rOH-he_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxODoxN1rOH-he_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjM2NQ==", "bodyText": "I'm not 100% sure if \"doesn't match state A\" will be immediately clear to users reading the docs.\nI'm wondering if we could say something more like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n          \n          \n            \n            // Nothing happens. The \"elkbee\" user has no pending sequence to move from state A to state B", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535322365", "createdAt": "2020-12-03T15:18:17Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9e14734d0c8dad8be1676591f3594eeb1580bcb", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/d9e14734d0c8dad8be1676591f3594eeb1580bcb", "committedDate": "2020-12-03T15:19:21Z", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-authored-by: Ross Wolf <31489089+rw-access@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDY0ODIz", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544064823", "createdAt": "2020-12-03T15:21:58Z", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMTo1OVrOH-hq9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMTo1OVrOH-hq9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTQzMQ==", "bodyText": "since this is the first state transition, maybe we could be extra clear that we're moving the pending sequence out of state A, and appending a new event as part of the transition.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Sequence [2, 4] moves to state B for \"root\".\n          \n          \n            \n            // Sequence [2] moves out of state A for \"root\". State B for \"root\" now contains [2, 4]\n          \n          \n            \n            \n          \n      \n    \n    \n  \n\nI recently was walking through the algorithm with another engineer and I think these were some of the points of confusion", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535325431", "createdAt": "2020-12-03T15:21:59Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n+\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Sequence [2, 4] moves to state B for \"root\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd5599742a290aac7d8db05413b8240a7af9f2bf", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/cd5599742a290aac7d8db05413b8240a7af9f2bf", "committedDate": "2020-12-03T15:25:35Z", "message": "Update docs/reference/eql/syntax.asciidoc\n\nCo-authored-by: Ross Wolf <31489089+rw-access@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e67a8c48bfe926a664c915a441455688351e8fe9", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/e67a8c48bfe926a664c915a441455688351e8fe9", "committedDate": "2020-12-03T15:26:21Z", "message": "Fix whitespace"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDc1MjUx", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544075251", "createdAt": "2020-12-03T15:27:49Z", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNzo0OVrOH-h-VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNzo0OVrOH-h-VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM4OQ==", "bodyText": "Do you think it could make sense to change the query so the ordering is more obvious?\nLike process.name == \"process1\", process.name == \"process2\", etc. It makes it a little bit more clear what's happening, because it's not totally easy to remember which command matches which state. Unfortunately it does make the dataset more abstract.\nWhat about a middle ground, like...\n\nattrib -> state A\nbash -> state B\ncat  -> state C", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535330389", "createdAt": "2020-12-03T15:27:49Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDc5NzM0", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544079734", "createdAt": "2020-12-03T15:29:43Z", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo0M1rOH-iEiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo0M1rOH-iEiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMTk3Nw==", "bodyText": "I'm also wondering if a visual representation could make it more digestible. Could be in addition to what's already there\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Creates sequence [1] in state A for the \"root\" user.\n          \n          \n            \n            // Creates sequence [1] in state A for the \"root\" user.\n          \n          \n            \n            //\n          \n          \n            \n            // root: A=[1]", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535331977", "createdAt": "2020-12-03T15:29:43Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDgwMzc2", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544080376", "createdAt": "2020-12-03T15:29:59Z", "commit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo1OVrOH-iFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo1OVrOH-iFbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMjIwNg==", "bodyText": "// root: A=[2]\n```", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535332206", "createdAt": "2020-12-03T15:29:59Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d", "author": {"user": {"login": "jrodewig", "name": "James Rodewig"}}, "url": "https://github.com/elastic/elasticsearch/commit/9066d7887b64ef6d21524debeee87580ee2f959d", "committedDate": "2020-12-03T15:43:26Z", "message": "Replace process.name vals. Add state comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODkyMTU4", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-544892158", "createdAt": "2020-12-04T11:51:35Z", "commit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo1MTozNVrOH_Nj-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo1MTozNVrOH_Nj-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw==", "bodyText": "This can be a follow-up ticket; having a visual representation of the events, the potential sequences and the final sequences helps a lot in understanding how this works vs just the test description.\nIt doesn't have to be something fancy, a basic diagram or even ascii art would go a long way.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536044537", "createdAt": "2020-12-04T11:51:35Z", "author": {"login": "costin"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,147 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MDA0OTQ5", "url": "https://github.com/elastic/elasticsearch/pull/65794#pullrequestreview-545004949", "createdAt": "2020-12-04T14:27:56Z", "commit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4142, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}