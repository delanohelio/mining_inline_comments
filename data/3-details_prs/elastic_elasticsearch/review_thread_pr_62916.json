{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNTU5MDk0", "number": 62916, "reviewThreads": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxOTo0NTowMlrOEqHgxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNjoyNzoxMlrOFE0n6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTk4NzI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxOTo0NTowMlrOHcJvXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMTo0MjowM1rOH_1yYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4MTc1OA==", "bodyText": "The origin.type and event.type definitions have been reversed.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499281758", "createdAt": "2020-10-04T19:45:02Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -51,7 +52,7 @@ appender.audit_rolling.layout.pattern = {\\\n # \"user.run_by.realm\" the realm name of the impersonating subject (\"user.run_by.name\")\n # \"user.run_as.realm\" if this \"event.action\" is of a run_as type, this is the realm name the impersonated user is looked up from\n # \"user.roles\" the roles array of the user; these are the roles that are granting privileges\n-# \"origin.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\" and \"ip_filter\"\n+# \"event.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\", \"ip_filter\" and \"security_config_change\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcwMzU4NA==", "bodyText": "Nit: The word originating throws me off a bit because the field is now event.type instead of origin.type. IIUC, even.type says something about \"at which layer the current request is being processed\". This definition works fine for the existing values of rest, transport and ip_filter, but falls short with the new security_config_change value. I don't have a good suggestion, maybe something like \"it is for the broader nature of the current request, the possible values are ...\". Please feel free to come up with your own version.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536703584", "createdAt": "2020-12-05T11:42:03Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -51,7 +52,7 @@ appender.audit_rolling.layout.pattern = {\\\n # \"user.run_by.realm\" the realm name of the impersonating subject (\"user.run_by.name\")\n # \"user.run_as.realm\" if this \"event.action\" is of a run_as type, this is the realm name the impersonated user is looked up from\n # \"user.roles\" the roles array of the user; these are the roles that are granting privileges\n-# \"origin.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\" and \"ip_filter\"\n+# \"event.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\", \"ip_filter\" and \"security_config_change\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4MTc1OA=="}, "originalCommit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAyMjA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDozNjoxMFrOHcKBLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDozNjoxMFrOHcKBLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjMxOA==", "bodyText": "The new field that contains the configuration taking effect, as an un-escaped JSON object, for records with event.type: \"security_config_change\".", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499286318", "createdAt": "2020-10-04T20:36:10Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -37,12 +37,13 @@ appender.audit_rolling.layout.pattern = {\\\n                 %varsNotEmpty{, \"transport.profile\":\"%enc{%map{transport.profile}}{JSON}\"}\\\n                 %varsNotEmpty{, \"rule\":\"%enc{%map{rule}}{JSON}\"}\\\n                 %varsNotEmpty{, \"event.category\":\"%enc{%map{event.category}}{JSON}\"}\\\n+                %varsNotEmpty{, \"config_change\":%map{config_change}}\\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjM4MTQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/user/ChangePasswordRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwMzo1ODo1MlrOHcNC3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDoyOToxOVrOHcW9ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMzNTkwMQ==", "bodyText": "Why do we want to hide refresh policy? I assume it is not because of security, but for verbosity?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499335901", "createdAt": "2020-10-05T03:58:52Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/user/ChangePasswordRequest.java", "diffHunk": "@@ -92,4 +95,21 @@ public void writeTo(StreamOutput out) throws IOException {\n         out.writeBytesReference(new BytesArray(CharArrays.toUtf8Bytes(passwordHash)));\n         refreshPolicy.writeTo(out);\n     }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+                .startObject(\"change_password\")\n+                .field(\"username\", username);\n+        if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+            builder.field(\"password_hash\", passwordHash != null ? String.valueOf(passwordHash) : null);\n+        } else {\n+            builder.field(\"password_hash\", passwordHash != null ? \"<redacted>\" : null);\n+        }\n+        builder.endObject(); // change_password\n+        if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_REFRESH_POLICY, false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ5ODQyNg==", "bodyText": "Yes, verbosity compared to the usefulness of the information.\nBecause the event is recorded before the config change actually takes effect, a refresh policy of immediate only says that the change will take place sooner after the the event is recorded, compared to the other options (i.e. none and wait_until).\nHowever, the refresh value is still optionally included, because the toXContent method is generic and hence should cover all the request fields.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499498426", "createdAt": "2020-10-05T10:29:19Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/user/ChangePasswordRequest.java", "diffHunk": "@@ -92,4 +95,21 @@ public void writeTo(StreamOutput out) throws IOException {\n         out.writeBytesReference(new BytesArray(CharArrays.toUtf8Bytes(passwordHash)));\n         refreshPolicy.writeTo(out);\n     }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+                .startObject(\"change_password\")\n+                .field(\"username\", username);\n+        if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+            builder.field(\"password_hash\", passwordHash != null ? String.valueOf(passwordHash) : null);\n+        } else {\n+            builder.field(\"password_hash\", passwordHash != null ? \"<redacted>\" : null);\n+        }\n+        builder.endObject(); // change_password\n+        if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_REFRESH_POLICY, false)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMzNTkwMQ=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjQyMzEzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNDozNToyM1rOHcNaug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMjo1MDoyNlrOHeIOzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjAxMA==", "bodyText": "I wonder whether we could introduce interfaces dedicated to these, something like the follows:\ninterface SecurityConfigAuditable {\n    String action();\n    String content();  // this method is equivalent to `ToXContent#toXContent`\n}\n\ninterface PutSecurityConfigAuditable() {\n    default String action() {\n        return \"put\";\n    }\n}\n\ninterface DeleteSecurityConfigAuditable() {\n    default String action() {\n        return \"delete\";\n    }\n}\nTo me, it will make the code easier to read and write. I also think it is more preferable to have dedicated interfaces for serialising the request object for auditing purpose instead of the generic ToXContent interface, because 1) the string representation it provides is specific to auditing; 2) security change auditing has pretty good business meaning and we may discover new things later that could add to the interfaces.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499342010", "createdAt": "2020-10-05T04:35:23Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -482,6 +501,41 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                 logger.info(AUDIT_MARKER, logEntry);\n             }\n         }\n+        // \"config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we don't because filtering out security changes by the causing user is trappy.\n+        if (events.contains(SECURITY_CONFIG_CHANGED)) {\n+            String eventAction = null;\n+            if (msg instanceof PutUserRequest ||\n+                    msg instanceof PutRoleMappingRequest ||\n+                    msg instanceof PutRoleRequest ||\n+                    msg instanceof SetEnabledRequest ||\n+                    msg instanceof ChangePasswordRequest ||\n+                    msg instanceof CreateApiKeyRequest ||\n+                    msg instanceof GrantApiKeyRequest ||\n+                    msg instanceof CreateTokenRequest ||\n+                    msg instanceof PutPrivilegesRequest) {\n+                eventAction = \"put\";\n+            } else if (msg instanceof DeleteUserRequest ||\n+                    msg instanceof DeleteRoleMappingRequest ||\n+                    msg instanceof DeleteRoleRequest ||\n+                    msg instanceof InvalidateTokenRequest ||\n+                    msg instanceof InvalidateApiKeyRequest ||\n+                    msg instanceof DeletePrivilegesRequest) {\n+                eventAction = \"delete\";\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2OTkwNA==", "bodyText": "Even though we've discussed this before, I think you're raising a good point.\nI believe the root question is to what extent is the auditing different from generic request serialisation. Given that the present audit approach is not designed around the concept of \"requests\" but rather centred on \"changes\", I think I can see the case for an audit-specific serialisation logic.\nHere's a list for why I think that is the case:\n\nthe refresh policy is not important for auditing\nthe name of the changed object (role, user, etc) should be distinguished as a separate field, not as part of a serialised object\nthe nature of the change (put, enable, clear) should also by distinguished as a separate field", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499569904", "createdAt": "2020-10-05T12:44:46Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -482,6 +501,41 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                 logger.info(AUDIT_MARKER, logEntry);\n             }\n         }\n+        // \"config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we don't because filtering out security changes by the causing user is trappy.\n+        if (events.contains(SECURITY_CONFIG_CHANGED)) {\n+            String eventAction = null;\n+            if (msg instanceof PutUserRequest ||\n+                    msg instanceof PutRoleMappingRequest ||\n+                    msg instanceof PutRoleRequest ||\n+                    msg instanceof SetEnabledRequest ||\n+                    msg instanceof ChangePasswordRequest ||\n+                    msg instanceof CreateApiKeyRequest ||\n+                    msg instanceof GrantApiKeyRequest ||\n+                    msg instanceof CreateTokenRequest ||\n+                    msg instanceof PutPrivilegesRequest) {\n+                eventAction = \"put\";\n+            } else if (msg instanceof DeleteUserRequest ||\n+                    msg instanceof DeleteRoleMappingRequest ||\n+                    msg instanceof DeleteRoleRequest ||\n+                    msg instanceof InvalidateTokenRequest ||\n+                    msg instanceof InvalidateApiKeyRequest ||\n+                    msg instanceof DeletePrivilegesRequest) {\n+                eventAction = \"delete\";\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjAxMA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4MzgzMg==", "bodyText": "@ywangd After mulling over it some more, I've changed back to thinking that the code to print the request bodies should sit in the LoggingAuditTrail class.\nIt's probably easier to show it in code than to talk about, but the reasoning is that the layout of it is particular to the logging audit trail format, and it's not reasonable to expect the reuse of it. It's also easier to ensure and maintain the formatting consistency, if it all sits together rather than be scattered across request methods. A simple example, is the consistency for the username vs user.name fields.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500383832", "createdAt": "2020-10-06T15:21:38Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -482,6 +501,41 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                 logger.info(AUDIT_MARKER, logEntry);\n             }\n         }\n+        // \"config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we don't because filtering out security changes by the causing user is trappy.\n+        if (events.contains(SECURITY_CONFIG_CHANGED)) {\n+            String eventAction = null;\n+            if (msg instanceof PutUserRequest ||\n+                    msg instanceof PutRoleMappingRequest ||\n+                    msg instanceof PutRoleRequest ||\n+                    msg instanceof SetEnabledRequest ||\n+                    msg instanceof ChangePasswordRequest ||\n+                    msg instanceof CreateApiKeyRequest ||\n+                    msg instanceof GrantApiKeyRequest ||\n+                    msg instanceof CreateTokenRequest ||\n+                    msg instanceof PutPrivilegesRequest) {\n+                eventAction = \"put\";\n+            } else if (msg instanceof DeleteUserRequest ||\n+                    msg instanceof DeleteRoleMappingRequest ||\n+                    msg instanceof DeleteRoleRequest ||\n+                    msg instanceof InvalidateTokenRequest ||\n+                    msg instanceof InvalidateApiKeyRequest ||\n+                    msg instanceof DeletePrivilegesRequest) {\n+                eventAction = \"delete\";\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjAxMA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY4MTI3Ng==", "bodyText": "I guess I'll have to see the code to fully understand what you mean by \"the code to print the request bodies\". But I didn't suggest to move the \"print\" part to each individual class. The actual print should always be done in LoggingAuditTrail and I agree with it. I was referring to the \"serialization\" part of the logging message, i.e. the toXContent method, where the message is prepared. Also on the topic of resuing the auditing message, there were talks about auditing into an index (or maybe some other connectors). Would it be a valid possible future reuse?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500681276", "createdAt": "2020-10-07T01:14:23Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -482,6 +501,41 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                 logger.info(AUDIT_MARKER, logEntry);\n             }\n         }\n+        // \"config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we don't because filtering out security changes by the causing user is trappy.\n+        if (events.contains(SECURITY_CONFIG_CHANGED)) {\n+            String eventAction = null;\n+            if (msg instanceof PutUserRequest ||\n+                    msg instanceof PutRoleMappingRequest ||\n+                    msg instanceof PutRoleRequest ||\n+                    msg instanceof SetEnabledRequest ||\n+                    msg instanceof ChangePasswordRequest ||\n+                    msg instanceof CreateApiKeyRequest ||\n+                    msg instanceof GrantApiKeyRequest ||\n+                    msg instanceof CreateTokenRequest ||\n+                    msg instanceof PutPrivilegesRequest) {\n+                eventAction = \"put\";\n+            } else if (msg instanceof DeleteUserRequest ||\n+                    msg instanceof DeleteRoleMappingRequest ||\n+                    msg instanceof DeleteRoleRequest ||\n+                    msg instanceof InvalidateTokenRequest ||\n+                    msg instanceof InvalidateApiKeyRequest ||\n+                    msg instanceof DeletePrivilegesRequest) {\n+                eventAction = \"delete\";\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjAxMA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1NDE4OQ==", "bodyText": "My point is that even the toXContent is not really suitable as a request object method.\nThe JSON object for the config change is part of the JSON object for the whole event so they must use the same  conventions, eg for field names (username vs user.name), or plurals, or tenses (past/present). The objects must also be consistent among themselves. For example, check out the handling of the SetEnabledRequest and GrantApiKeyRequest requests.\nIn general, I've chosen the XContent field names in the context of the audit log that we've got; most commonly field names coincide with the XContent field names, but not always. Same for the nesting patterns.\n\nAlso on the topic of resuing the auditing message, there were talks about auditing into an index (or maybe some other connectors). Would it be a valid possible future reuse?\n\nIf, as initially planned, this feature would've been a particular case of \"request body auditing\" , then yes that would be a valid reuse case. But it's now a different thing. Audit records are a richer translation of requests in a friendlier format in the particular context of security config changes to be applied.\nSlightly off-topic, the index connector is not a suitable connector for audits as the buffering on the local disk is really required (we had something like that and we've deprecated it).", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r501354189", "createdAt": "2020-10-07T22:50:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -482,6 +501,41 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                 logger.info(AUDIT_MARKER, logEntry);\n             }\n         }\n+        // \"config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we don't because filtering out security changes by the causing user is trappy.\n+        if (events.contains(SECURITY_CONFIG_CHANGED)) {\n+            String eventAction = null;\n+            if (msg instanceof PutUserRequest ||\n+                    msg instanceof PutRoleMappingRequest ||\n+                    msg instanceof PutRoleRequest ||\n+                    msg instanceof SetEnabledRequest ||\n+                    msg instanceof ChangePasswordRequest ||\n+                    msg instanceof CreateApiKeyRequest ||\n+                    msg instanceof GrantApiKeyRequest ||\n+                    msg instanceof CreateTokenRequest ||\n+                    msg instanceof PutPrivilegesRequest) {\n+                eventAction = \"put\";\n+            } else if (msg instanceof DeleteUserRequest ||\n+                    msg instanceof DeleteRoleMappingRequest ||\n+                    msg instanceof DeleteRoleRequest ||\n+                    msg instanceof InvalidateTokenRequest ||\n+                    msg instanceof InvalidateApiKeyRequest ||\n+                    msg instanceof DeletePrivilegesRequest) {\n+                eventAction = \"delete\";\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjAxMA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjQ0NDQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNDo1MzowOFrOHcNm_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjo1MzoyNlrOHcPiVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NTE0OA==", "bodyText": "Nit: technically, when the auditing happens, the config has not been \"changed\" yet. So it is probably better just be SECURITY_CONFIG_CHANGE.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499345148", "createdAt": "2020-10-05T04:53:08Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "diffHunk": "@@ -22,6 +21,7 @@\n     CONNECTION_GRANTED,\n     CONNECTION_DENIED,\n     SYSTEM_ACCESS_GRANTED,\n+    SECURITY_CONFIG_CHANGED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NjcyNA==", "bodyText": "Nice, good point!", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499376724", "createdAt": "2020-10-05T06:53:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "diffHunk": "@@ -22,6 +21,7 @@\n     CONNECTION_GRANTED,\n     CONNECTION_DENIED,\n     SYSTEM_ACCESS_GRANTED,\n+    SECURITY_CONFIG_CHANGED,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NTE0OA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjQ1NzYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTowMjo0OVrOHcNudA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTozMjoyN1rOHdNpJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NzA2MA==", "bodyText": "If we are redacting, should we just always show <redacted> regardless of whether the value is null or not? It is better from the information disclosure perspective.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499347060", "createdAt": "2020-10-05T05:02:49Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -86,6 +89,21 @@ public void setPassword(SecureString password) {\n         public void setAccessToken(SecureString accessToken) {\n             this.accessToken = accessToken;\n         }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject()\n+                    .field(\"type\", type)\n+                    .field(\"username\", username);\n+            if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+                builder.field(\"password\", password != null ? password.toString() : null);\n+                builder.field(\"access_token\", accessToken != null ? accessToken.toString() : null);\n+            } else {\n+                builder.field(\"password\", password != null ? \"<redacted>\" : null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNjgwNw==", "bodyText": "It is a good question, but I don't think we have to be that cautious, because the existence of a password doesn't give away much information. I think the audit log overall gives away much more details on the activity on the system.\nIMO, the null vs <redacted> thing is not even something that we should document and test. I'm comfortable with only saying that \"credentials and credential hashes are not printed in the audit log\".", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499506807", "createdAt": "2020-10-05T10:45:39Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -86,6 +89,21 @@ public void setPassword(SecureString password) {\n         public void setAccessToken(SecureString accessToken) {\n             this.accessToken = accessToken;\n         }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject()\n+                    .field(\"type\", type)\n+                    .field(\"username\", username);\n+            if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+                builder.field(\"password\", password != null ? password.toString() : null);\n+                builder.field(\"access_token\", accessToken != null ? accessToken.toString() : null);\n+            } else {\n+                builder.field(\"password\", password != null ? \"<redacted>\" : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NzA2MA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5ODk4MQ==", "bodyText": "I agree that in this case it doesn't make much difference. For instance, the only thing that the existence of the password field ( redacted vs null) \"discloses\" is that the request is using the password grant type, as this is the only case where this is allowed as a parameter.\nIn general, from an audit perspective, as a legitimate administrator, I would like to know as much information as possible so I would prefer to know if a parameter was specified when the call to the API was made* and in that sense I prefer to have \"\" vs null.\n* In the case of an investigation, I might want to know if an attacker had access to a valid password or if they figured out another way to compromise the system/api.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500198981", "createdAt": "2020-10-06T11:25:27Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -86,6 +89,21 @@ public void setPassword(SecureString password) {\n         public void setAccessToken(SecureString accessToken) {\n             this.accessToken = accessToken;\n         }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject()\n+                    .field(\"type\", type)\n+                    .field(\"username\", username);\n+            if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+                builder.field(\"password\", password != null ? password.toString() : null);\n+                builder.field(\"access_token\", accessToken != null ? accessToken.toString() : null);\n+            } else {\n+                builder.field(\"password\", password != null ? \"<redacted>\" : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NzA2MA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5NDI3OA==", "bodyText": "IMO, the null vs  thing is not even something that we should document and test. I'm comfortable with only saying that \"credentials and credential hashes are not printed in the audit log\".\n\nErr, except that the put user action is an example where null vs <redacted> IS significant. if the password_hash field is <redacted> then the put user action updated the password, whereas if it is null then user password remains unchanged.\nTherefore, the password/password_hash field will be null if and only if the field is not present in the request body. Otherwise it will be <redacted>. I'lll make sure to test for it.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500394278", "createdAt": "2020-10-06T15:32:27Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -86,6 +89,21 @@ public void setPassword(SecureString password) {\n         public void setAccessToken(SecureString accessToken) {\n             this.accessToken = accessToken;\n         }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject()\n+                    .field(\"type\", type)\n+                    .field(\"username\", username);\n+            if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+                builder.field(\"password\", password != null ? password.toString() : null);\n+                builder.field(\"access_token\", accessToken != null ? accessToken.toString() : null);\n+            } else {\n+                builder.field(\"password\", password != null ? \"<redacted>\" : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NzA2MA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMjk2MjE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/xcontent/XContentUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTowMDo1N1rOHdL1GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0MDoxM1rOHdOEuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM2NDU2OQ==", "bodyText": "Apologies if we have already discuss this in the past. Does this come from a user request? I can't see the use case for auditing credential values in plaintext and it seems like a dangerous option to include ( even if it defaults to false )", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500364569", "createdAt": "2020-10-06T15:00:57Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/xcontent/XContentUtils.java", "diffHunk": "@@ -14,6 +14,11 @@\n \n public class XContentUtils {\n \n+    public static final class AuditToXContentParams {\n+        public static final String INCLUDE_CREDENTIALS = \"include_credentials\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwMTMzOQ==", "bodyText": "There was no external influence, it was just my \"reflex\" to leave it configurable.\nBut I've gotten the message. No credentials whatsover in the logs, not configurable, at least in this first iteration.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500401339", "createdAt": "2020-10-06T15:40:13Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/xcontent/XContentUtils.java", "diffHunk": "@@ -14,6 +14,11 @@\n \n public class XContentUtils {\n \n+    public static final class AuditToXContentParams {\n+        public static final String INCLUDE_CREDENTIALS = \"include_credentials\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM2NDU2OQ=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjM5ODM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0ODo0N1rOHjmWeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0ODo0N1rOHjmWeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDU1NA==", "bodyText": "The new audit event.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507090554", "createdAt": "2020-10-18T10:48:47Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "diffHunk": "@@ -61,6 +61,9 @@\n                 case \"system_access_granted\":\n                     enumSet.add(SYSTEM_ACCESS_GRANTED);\n                     break;\n+                case \"security_config_change\":\n+                    enumSet.add(SECURITY_CONFIG_CHANGE);\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd44688d2fc7f5ca8af42ed7ca89e2b5e1ce5edf"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjUxNjQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo0NDo1NlrOHjnj9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo0NDo1NlrOHjnj9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExMDM4OA==", "bodyText": "Unlike general request body auditing, security change events are emitted by default.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507110388", "createdAt": "2020-10-18T11:44:56Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -136,7 +169,7 @@\n             Property.NodeScope, Property.Dynamic);\n     private static final List<String> DEFAULT_EVENT_INCLUDES = Arrays.asList(ACCESS_DENIED.toString(), ACCESS_GRANTED.toString(),\n             ANONYMOUS_ACCESS_DENIED.toString(), AUTHENTICATION_FAILED.toString(), CONNECTION_DENIED.toString(), TAMPERED_REQUEST.toString(),\n-            RUN_AS_DENIED.toString(), RUN_AS_GRANTED.toString());\n+            RUN_AS_DENIED.toString(), RUN_AS_GRANTED.toString(), SECURITY_CONFIG_CHANGE.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjUzNjAwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo1MzoyOFrOHjnxTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo1MzoyOFrOHjnxTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExMzgwNA==", "bodyText": "Changes like these are a small refactoring. It allows to build the log entry in a single statement.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507113804", "createdAt": "2020-10-18T11:53:28Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -245,7 +288,7 @@ public void authenticationSuccess(String requestId, Authentication authenticatio\n                         Optional.empty())) == false) {\n             // this is redundant information maintained for bwc purposes\n             final String authnRealm = authentication.getAuthenticatedBy().getName();\n-            final StringMapMessage logEntry = new LogEntryBuilder()\n+            new LogEntryBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjY0NDc5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMjo0NDowNVrOHjo59A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMjo0NDowNVrOHjo59A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzEzMjQwNA==", "bodyText": "api key id not currently audited we need to settle on the best approach, between carrying the id in the request object and intercepting the id from the response (see #63708).", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507132404", "createdAt": "2020-10-18T12:44:05Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -736,7 +802,218 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .array(\"roles\", putUserRequest.roles())\n+                    .field(\"full_name\", putUserRequest.fullName())\n+                    .field(\"email\", putUserRequest.email())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .field(\"has_password\", putUserRequest.passwordHash() != null)\n+                    // TODO metadata can fail because it might contain unknown class types\n+                    // ensure toXContent on such maps is a superset of the metadata maps role mapping can manage\n+                    .field(\"metadata\", putUserRequest.metadata())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(CHANGE_PASSWORD_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    .array(\"cluster_privileges\", putRoleRequest.cluster())\n+                    .array(\"run_as\", putRoleRequest.runAs())\n+                    .array(\"indices_privileges\", (Object[]) putRoleRequest.indices())\n+                    .field(\"application_privileges\", putRoleRequest.applicationPrivileges())\n+                    .field(\"metadata\", putRoleRequest.metadata());\n+            builder.startObject(\"conditional_cluster_privileges\");\n+            for (ConfigurableClusterPrivilege conditionalClusterPrivilege : putRoleRequest.conditionalClusterPrivileges()) {\n+                conditionalClusterPrivilege.toXContent(builder, ToXContent.EMPTY_PARAMS);\n+            }\n+            builder.endObject() // configurable_cluster_privileges\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName())\n+                    .field(\"role_names\", putRoleMappingRequest.getRoles())\n+                    .field(\"role_templates\", putRoleMappingRequest.getRoleTemplates())\n+                    .field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled())\n+                    .field(\"metadata\", putRoleMappingRequest.getMetadata())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "originalPosition": 628}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NzQzNDMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQyMzoxNjozOVrOHjv6uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQyMzoxNjozOVrOHjv6uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI0NzI5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration\n          \n          \n            \n                // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507247291", "createdAt": "2020-10-18T23:16:39Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +164,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NzU0NDAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMDowMToxN1rOHjxFTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMjo0Nzo1M1rOHkMo7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI2NjM4Mw==", "bodyText": "I have a general question: What is our intention for handling errors occur during auditing time? Do we want to propogate the error message back to user in the HTTP response, or do we only need to print it in server log? IIUC, by throwing IllegalStateException, the error will be in the HTTP response?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507266383", "createdAt": "2020-10-19T00:01:17Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +535,60 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {\n+                if (msg instanceof PutUserRequest) {\n+                    assert PutUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutUserRequest) msg).build();\n+                } else if (msg instanceof PutRoleRequest) {\n+                    assert PutRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleRequest) msg).build();\n+                } else if (msg instanceof PutRoleMappingRequest) {\n+                    assert PutRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleMappingRequest) msg).build();\n+                } else if (msg instanceof SetEnabledRequest) {\n+                    assert SetEnabledAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((SetEnabledRequest) msg).build();\n+                } else if (msg instanceof ChangePasswordRequest) {\n+                    assert ChangePasswordAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((ChangePasswordRequest) msg).build();\n+                } else if (msg instanceof CreateApiKeyRequest) {\n+                    assert CreateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((CreateApiKeyRequest) msg).build();\n+                } else if (msg instanceof GrantApiKeyRequest) {\n+                    assert GrantApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((GrantApiKeyRequest) msg).build();\n+                } else if (msg instanceof PutPrivilegesRequest) {\n+                    assert PutPrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutPrivilegesRequest) msg).build();\n+                } else if (msg instanceof DeleteUserRequest) {\n+                    assert DeleteUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteUserRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleRequest) {\n+                    assert DeleteRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleMappingRequest) {\n+                    assert DeleteRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleMappingRequest) msg).build();\n+                } else if (msg instanceof InvalidateApiKeyRequest) {\n+                    assert InvalidateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((InvalidateApiKeyRequest) msg).build();\n+                } else if (msg instanceof DeletePrivilegesRequest) {\n+                    assert DeletePrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeletePrivilegesRequest) msg).build();\n+                } else {\n+                    throw new IllegalStateException(\"Unknown message class type [\" + msg.getClass().getSimpleName() +\n+                            \"] for the \\\"security change\\\" action [\" + action + \"]\");\n+                }\n+            } catch (IOException e) {\n+                // TODO ensure and test that IOExceptions are gracefully handled up the call stack\n+                // TODO Especially check that all valid metadata can be serialized in the audit record\n             }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 399}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MDcyMQ==", "bodyText": "What is our intention for handling errors occur during auditing time?\n\nI think we should handle auditing errors as any other business logic errors, i.e. return the error to the client in the HTTP response, and sometimes also log it.\nWe're not always rigorous about error handling for auditing. I'll try to get some tests for it. This is why I put these TODOs here for.\n\nIIUC, by throwing IllegalStateException, the error will be in the HTTP response?\n\nYeah, because at some upper level in the call stack there will most likely be an ActionListener.wrap that forwards thrown exception when invoking onSuccess to the onFailure handler. This is a good defensive strategy, which worked well, but I'll try to add some explicit tests for the auditing case, because silent failures in this particular area are technically bugs (unlike the other places where's it's a nuisance to the debugging person on the SDH).", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507580721", "createdAt": "2020-10-19T08:53:49Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +535,60 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {\n+                if (msg instanceof PutUserRequest) {\n+                    assert PutUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutUserRequest) msg).build();\n+                } else if (msg instanceof PutRoleRequest) {\n+                    assert PutRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleRequest) msg).build();\n+                } else if (msg instanceof PutRoleMappingRequest) {\n+                    assert PutRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleMappingRequest) msg).build();\n+                } else if (msg instanceof SetEnabledRequest) {\n+                    assert SetEnabledAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((SetEnabledRequest) msg).build();\n+                } else if (msg instanceof ChangePasswordRequest) {\n+                    assert ChangePasswordAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((ChangePasswordRequest) msg).build();\n+                } else if (msg instanceof CreateApiKeyRequest) {\n+                    assert CreateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((CreateApiKeyRequest) msg).build();\n+                } else if (msg instanceof GrantApiKeyRequest) {\n+                    assert GrantApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((GrantApiKeyRequest) msg).build();\n+                } else if (msg instanceof PutPrivilegesRequest) {\n+                    assert PutPrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutPrivilegesRequest) msg).build();\n+                } else if (msg instanceof DeleteUserRequest) {\n+                    assert DeleteUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteUserRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleRequest) {\n+                    assert DeleteRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleMappingRequest) {\n+                    assert DeleteRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleMappingRequest) msg).build();\n+                } else if (msg instanceof InvalidateApiKeyRequest) {\n+                    assert InvalidateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((InvalidateApiKeyRequest) msg).build();\n+                } else if (msg instanceof DeletePrivilegesRequest) {\n+                    assert DeletePrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeletePrivilegesRequest) msg).build();\n+                } else {\n+                    throw new IllegalStateException(\"Unknown message class type [\" + msg.getClass().getSimpleName() +\n+                            \"] for the \\\"security change\\\" action [\" + action + \"]\");\n+                }\n+            } catch (IOException e) {\n+                // TODO ensure and test that IOExceptions are gracefully handled up the call stack\n+                // TODO Especially check that all valid metadata can be serialized in the audit record\n             }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI2NjM4Mw=="}, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 399}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNzg2OQ==", "bodyText": "Thanks for the explanation Albert. If the intention is to report the error back to users, it makes sense to throw exception. My question was mainly about whether it is necessary to alert user with a logging error. Since audit logging is an opt-in feature, I can be convinced that faliure should be more visible. But I wonder how clients should handle this error when it occurs. I assume this will give back a status code 5xx? Since it is not 4xx, clients may decide to retry the request. The API key related requests are not idempotent which could be a bit anonying. Other requests are idempotent, but sometimes have the side effects of clearing relevant caches.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507717869", "createdAt": "2020-10-19T12:47:53Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +535,60 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {\n+                if (msg instanceof PutUserRequest) {\n+                    assert PutUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutUserRequest) msg).build();\n+                } else if (msg instanceof PutRoleRequest) {\n+                    assert PutRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleRequest) msg).build();\n+                } else if (msg instanceof PutRoleMappingRequest) {\n+                    assert PutRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleMappingRequest) msg).build();\n+                } else if (msg instanceof SetEnabledRequest) {\n+                    assert SetEnabledAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((SetEnabledRequest) msg).build();\n+                } else if (msg instanceof ChangePasswordRequest) {\n+                    assert ChangePasswordAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((ChangePasswordRequest) msg).build();\n+                } else if (msg instanceof CreateApiKeyRequest) {\n+                    assert CreateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((CreateApiKeyRequest) msg).build();\n+                } else if (msg instanceof GrantApiKeyRequest) {\n+                    assert GrantApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((GrantApiKeyRequest) msg).build();\n+                } else if (msg instanceof PutPrivilegesRequest) {\n+                    assert PutPrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutPrivilegesRequest) msg).build();\n+                } else if (msg instanceof DeleteUserRequest) {\n+                    assert DeleteUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteUserRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleRequest) {\n+                    assert DeleteRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleMappingRequest) {\n+                    assert DeleteRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleMappingRequest) msg).build();\n+                } else if (msg instanceof InvalidateApiKeyRequest) {\n+                    assert InvalidateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((InvalidateApiKeyRequest) msg).build();\n+                } else if (msg instanceof DeletePrivilegesRequest) {\n+                    assert DeletePrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeletePrivilegesRequest) msg).build();\n+                } else {\n+                    throw new IllegalStateException(\"Unknown message class type [\" + msg.getClass().getSimpleName() +\n+                            \"] for the \\\"security change\\\" action [\" + action + \"]\");\n+                }\n+            } catch (IOException e) {\n+                // TODO ensure and test that IOExceptions are gracefully handled up the call stack\n+                // TODO Especially check that all valid metadata can be serialized in the audit record\n             }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI2NjM4Mw=="}, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 399}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NzYzMDc2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMDozMTozMFrOHjyBAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOToyOTozNFrOHkFq3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI4MTY2NQ==", "bodyText": "The name put looks a bit off in this context. I understand it is a carry over from the Rest action. But put or post is too HTTP specific and do not seem to blend in very well with other verbs like create, enable etc. I'd suggest to use upsert.\nI also wonder whether we could have more consistency and simplicity in the names. The mixed usage of underscore and dot looks a bit standing out. Can we use just either of them, but not both? Some of the fields are named as verb.noun or verb_noun, is it possible to make these field more generic to contain only the verb. The noun part of it will be in the body anyway.\nNames are hard. These are just my 2cents.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507281665", "createdAt": "2020-10-19T00:31:30Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +164,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_PASSWORD_FIELD_NAME = \"change_password\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";\n+    public static final String CREATE_API_KEY_FIELD_NAME = \"create.apikey\";\n+    public static final String INVALIDATE_API_KEYS_FIELD_NAME = \"invalidate_apikeys\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwMzY3Ng==", "bodyText": "The name put looks a bit off in this context. I understand it is a carry over from the Rest action. But put or post is too HTTP specific and do not seem to blend in very well with other verbs like create, enable etc. I'd suggest to use upsert.\n\nIt is not a carry over. I gave it careful thinking. I think put, by it's analogy with the HTTP verb, carries the meaning that this is \"the new configuration taking effect\". No prob to use upsert if you like that more.\n\nI also wonder whether we could have more consistency and simplicity in the names. The mixed usage of underscore and dot looks a bit standing out. Can we use just either of them, but not both? Some of the fields are named as verb.noun or verb_noun, is it possible to make these field more generic to contain only the verb. The noun part of it will be in the body anyway.\n\nI think we have to use both, but I'll take any specific suggestions you've got, we can brainstorm the naming if you're up to. Let me grab an exhaustive list of examples and we can discuss more to the point.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507603676", "createdAt": "2020-10-19T09:29:34Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +164,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_PASSWORD_FIELD_NAME = \"change_password\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";\n+    public static final String CREATE_API_KEY_FIELD_NAME = \"create.apikey\";\n+    public static final String INVALIDATE_API_KEYS_FIELD_NAME = \"invalidate_apikeys\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI4MTY2NQ=="}, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNTg5Nzc3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMzoyMzo1NlrOHn_0QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMToxNzoxN1rOH9uf9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA==", "bodyText": "This approach bothers me.\nPutting this code into the Audit trail rather than in the requests itself increases the risk that we will change the implementation of a request object, but fail to account for that in the audit logs (new fields, etc).\nAt one point we talked about an AuditableRequest interface with a toAuditXContent method. Is there  a reason we moved away from that idea?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r511702080", "createdAt": "2020-10-26T03:23:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNTMwMw==", "bodyText": "At one point we talked about an AuditableRequest interface with a toAuditXContent method. Is there a reason we moved away from that idea?\n\nI started off implementing that but changed course midway. I believe there are good reasons for the change of heart. Let me explain:\nConceptually the request bodies and the audit events both contain fields, and the code in this PR is all about the mapping between the two. The code has dependencies on both the accessor methods of requests (and, optionally, on the toXContent method, which is used when indexing the object) and the \"setter\" methods for the audit event. After some prototyping, I've reached the conclusion that the \"mapping\" code is more dependent on the auditing part than on the request content part. The nestedness and the field names (some of which must be made all the way to the log4j2.properties file) are all examples of it; they are like this because they're crafted to present a consistent interface for all the security changes (eg \"user\":{\"name\" vs \"username\"), which is the being reason for this feature (the \"upgrade\" from the REST request auditing). It is useful to have all the formatting code in a single place. Consequently, the code sits in the LoggingAuditTrail class rather than the individual request classes.\n\nPutting this code into the Audit trail rather than in the requests itself increases the risk that we will change the implementation of a request object, but fail to account for that in the audit logs (new fields, etc).\n\nI acknowledge the worry, but the LoggingAuditTrail is now a consumer of such requests just like the action handlers; if you change the request you can track all the uses of the request class in the IDE and adapt all the consumers as well (not only the conventional consumer which is the action handler). It's not fool proof, but neither is a \"toString\"-like method, which you can miss to adapt when you change the class.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r511805303", "createdAt": "2020-10-26T09:01:39Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA=="}, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzOTY1OA==", "bodyText": "I've reread the comment and I think I came across defensive. I've given this PR a lot of attention and to the best of my judgement this is the best option of the two.\nBut we can change the approach no problem, it will only be a small amount of work.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r511939658", "createdAt": "2020-10-26T12:59:08Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA=="}, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMDU0OQ==", "bodyText": "you can track all the uses of the request class in the IDE and adapt all the consumers as well\n\nI think we need something more reliable than that, but I'm happy to add it in a followup.\nI'm thinking something like a test in the audit package that verifies that the request/request builder matches the format we expect, so that changes in the request, will force a matching change in the audit implementation.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532400549", "createdAt": "2020-11-30T07:51:46Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA=="}, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4NzAyOQ==", "bodyText": "We've discussed this on a different channel.\nWhenever a request body changes, it is expected that audit entries change as well, eg adding a new request field.\nBUT, it's not easy to figure out if the new field should indeed be audited or under what field name. It's not alike request serialization where every field must be serialized. For example, a confidential field might be audited only as present or not, or audited under a slightly different name for uniformity in the audit context.\nTherefore, there's no advantage to placing the auditing code at the request level. We must ensure that changes to request objects of security actions are reflected in all the usage sites of those requests, in this case the auditing code in addition to the action handling code.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r534487029", "createdAt": "2020-12-02T21:17:17Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA=="}, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDAxMDI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/esnative/NativeRealmSettings.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo0MToxM1rOH7u4TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo0MToxM1rOH7u4TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjEwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"default_native\";\n          \n          \n            \n                public static final String DEFAULT_NAME = \"default_native\";", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532396108", "createdAt": "2020-11-30T07:41:13Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/esnative/NativeRealmSettings.java", "diffHunk": "@@ -14,6 +14,7 @@\n \n public final class NativeRealmSettings {\n     public static final String TYPE = \"native\";\n+    public static final String NAME = \"default_native\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDAxNDI3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/file/FileRealmSettings.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo0MjozMlrOH7u6lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDoyODowMFrOH9s2xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjY5Mw==", "bodyText": "As above.\nGiven that an admin can be name these realms whatever they want, I think NAME has the potential to be misleading to future readers.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532396693", "createdAt": "2020-11-30T07:42:32Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/file/FileRealmSettings.java", "diffHunk": "@@ -14,6 +14,7 @@\n \n public final class FileRealmSettings {\n     public static final String TYPE = \"file\";\n+    public static final String NAME = \"default_file\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MDEwMg==", "bodyText": "You're right, it was confusing for me too, I've renamed it to DEFAULT_NAME.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r534460102", "createdAt": "2020-12-02T20:28:00Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/file/FileRealmSettings.java", "diffHunk": "@@ -14,6 +14,7 @@\n \n public final class FileRealmSettings {\n     public static final String TYPE = \"file\";\n+    public static final String NAME = \"default_file\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjY5Mw=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDAzMDE2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo0ODoyMVrOH7vDpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDozNTo0OVrOH9tHQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTAxMg==", "bodyText": "This doesn't seem right.\nAmong other things, the native realm might be named something different, and also the reserved realm might be disabled.\nIf we really need to record a realm name for a user then I think we need to do it correctly.\nDoing it in a possibly-not-correct way isn't helping anyone.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532399012", "createdAt": "2020-11-30T07:48:21Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -191,6 +249,17 @@ public LoggingAuditTrail(Settings settings, ClusterService clusterService, Threa\n         this.events = parse(INCLUDE_EVENT_SETTINGS.get(settings), EXCLUDE_EVENT_SETTINGS.get(settings));\n         this.includeRequestBody = INCLUDE_REQUEST_BODY.get(settings);\n         this.threadContext = threadContext;\n+        this.inferRealmNameFromUsername = (username) -> {\n+            if (username == null) {\n+                return null;\n+            } else if (AnonymousUser.isAnonymousEnabled(settings) && AnonymousUser.isAnonymousUsername(username, settings)) {\n+                return null;\n+            } else if (ClientReservedRealm.isReserved(username, settings)) {\n+                return ReservedRealm.NAME;\n+            } else {\n+                return NativeRealmSettings.NAME;\n+            }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwMDYwMw==", "bodyText": "\ud83e\udd26 It escaped me that you must name the native realm.\nWith the current code base it looks like we'll have to bend over backwards to pull the realm name here. I say it's not worth it.\nI'm going to remove outputing the realm name in the current PR and raise an enhancement request for it; unless you feel otherwise, ofc.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r533700603", "createdAt": "2020-12-01T20:28:15Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -191,6 +249,17 @@ public LoggingAuditTrail(Settings settings, ClusterService clusterService, Threa\n         this.events = parse(INCLUDE_EVENT_SETTINGS.get(settings), EXCLUDE_EVENT_SETTINGS.get(settings));\n         this.includeRequestBody = INCLUDE_REQUEST_BODY.get(settings);\n         this.threadContext = threadContext;\n+        this.inferRealmNameFromUsername = (username) -> {\n+            if (username == null) {\n+                return null;\n+            } else if (AnonymousUser.isAnonymousEnabled(settings) && AnonymousUser.isAnonymousUsername(username, settings)) {\n+                return null;\n+            } else if (ClientReservedRealm.isReserved(username, settings)) {\n+                return ReservedRealm.NAME;\n+            } else {\n+                return NativeRealmSettings.NAME;\n+            }\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTAxMg=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2NDMyMg==", "bodyText": "We've briefly discussed this and concluded it would be difficult to include the realm name in the audited events of APIs that operate on the native and reserved user stores. The user stores are decoupled from the realms and the APIs operate on the stores and are oblivious to the realm setup.\nThe audited event scheme is still of the form {\"user\": {\"name\": .. }} , instead of something like {\"username\":...}, to accommodate outputting the realm name in the future (eg from the response).", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r534464322", "createdAt": "2020-12-02T20:35:49Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -191,6 +249,17 @@ public LoggingAuditTrail(Settings settings, ClusterService clusterService, Threa\n         this.events = parse(INCLUDE_EVENT_SETTINGS.get(settings), EXCLUDE_EVENT_SETTINGS.get(settings));\n         this.includeRequestBody = INCLUDE_REQUEST_BODY.get(settings);\n         this.threadContext = threadContext;\n+        this.inferRealmNameFromUsername = (username) -> {\n+            if (username == null) {\n+                return null;\n+            } else if (AnonymousUser.isAnonymousEnabled(settings) && AnonymousUser.isAnonymousUsername(username, settings)) {\n+                return null;\n+            } else if (ClientReservedRealm.isReserved(username, settings)) {\n+                return ReservedRealm.NAME;\n+            } else {\n+                return NativeRealmSettings.NAME;\n+            }\n+        };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTAxMg=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDA1NDMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo1NjoyM1rOH7vR1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDozMToyMVrOIAphSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA==", "bodyText": "This PR adds 500 lines to a file that is already over 1,000 lines long.\nI really think we need to split it up in some way.\nHappy for it to be a separate PR, but this class is getting way too huge.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532402644", "createdAt": "2020-11-30T07:56:23Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NjQxOA==", "bodyText": "I wholeheartedly agree that we need to invest in restructuring this code. I should've probably seen it coming before this PR. As you say we can tackle in a follow-up.\nThis class took hold of the log line format and settings to alter that format. I tried to splice out the LogEntryBuilder class, and use that on a separate logger, for the new events, but it depends on instance members of the LoggingAuditTrail that deal with the common preamble fields of every log entry (such as the host address and the node id).\nWe need to make this a base class which exposes a log entry builder that implementors can populate with values for their respective event types.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r534496418", "createdAt": "2020-12-02T21:34:58Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyMTg0Ng==", "bodyText": "Can we just pass LoggingAuditTrail.entryCommonFields.commonFields at instantiation time of LogEntryBuilder? It seems only the commonFields and includeRequestBody is from the parent class. So the effort to split the class out is not daunting? Seperate it out could also help tests (which are pretty challenging to read right now), especially around testing the message format, which would not need having to go through instantiating a LoggingAuditTrail. And tests for LoggingAuditTrail itself could mock out the LogEntryBuilder and just assert relevant methods are called.\nI also like the idea of having a base class for it because the \"security_config_change\" auditing has almost no overlap with all other usages, even the common premable needs to be modified for \"security_config_change\".", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536721846", "createdAt": "2020-12-05T12:21:30Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzOTE4Mw==", "bodyText": "Can we just pass LoggingAuditTrail.entryCommonFields.commonFields at instantiation time of LogEntryBuilder?\n\nThe LogEntryBuilder constructor does it already.\n        LogEntryBuilder(boolean showOrigin) {\n            logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n            if (false == showOrigin) {\n                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n            }\n        }\n\n(GH doesn't allow links in PRs, unless you comment at the place).\nDo you mean making the log entry builder class and the common fields protected, and using them outside the LoggingAuditTrail class?\nThe solution is indeed to separate the AuditTrail implementation(s) from a supplier of log entry builders, but the devil is in the details.\nI am happy to prototype your proposal, but I need more information:\nWhere would the log entry builder be called from? How do we instantiate the log entry builder? How would this separate the tests? Maybe we need to discuss this in a conversation.\nI can prototype the separation, on the existing code or the code in this PR, but do you think we can deal with it after this is merged?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537439183", "createdAt": "2020-12-07T11:39:28Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ1OTEwMQ==", "bodyText": "What I mean is to have:\n        LogEntryBuilder(Map<String, String> commonFields, boolean includeRequestBody, boolean showOrigin) {\n            logEntry = new StringMapMessage(commonFields);\n            ...\n        }\nSo the existing call sites will updated to:\nnew LogEntryBuilder(entryCommonFields.commonFields, false, false)\n   ...\nI believe at this point, the class can be extracted into a its own file. The tests can be separated broadly to test just the LogEntryBuilder and the LoggintAuditTrail.\nTests for LogEntryBuilder are mainly for the message format, i.e. tests for the different overloaded versions of the withRequestBody method, which does not require a LoggintAuditTrail.\nTests for LoggintAuditTrail can just ensure relevant methods of the LogEntryBuilder is called without worrying about the format of the final string message. It would be great if we can just mock LogEntryBuilder so its easier to test. An option could be passing a factory to LoggintAuditTrail, e.g.:\npublic LoggintAuditTrail(Factory<LogEntryBuilder> builderFactory, ...) {\n   ...\n}\nAnd uses it like:\nbuilderFactory.get(...,....).with(...).with(...)\nFor tests, we can pass a factory that returns a mock.\nI hope this makes sense. I have no issue to defer these refactoring after this PR is merged.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537459101", "createdAt": "2020-12-07T12:12:21Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU0OTgyOQ==", "bodyText": "Thank you for the suggestion.\nIn principle, I agree we can separate the log building class more. But the constructor that you're proposing takes a map with obscure values that I don't think we should expose publicly. I also don't think testing the StringMapMessage's contents and then testing that the contents map to the actual output logfile improves on the testing we currently have.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537549829", "createdAt": "2020-12-07T14:29:32Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1MTE3Nw==", "bodyText": "Since this is such a debated topic, I'll make sure we'll sit down and discuss it before I start working on the refactoring.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537551177", "createdAt": "2020-12-07T14:31:21Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Nzg4OTk1OnYy", "diffSide": "RIGHT", "path": "distribution/docker/src/docker/config/log4j2.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMToxODo0NlrOH_1Dow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowOTo1MlrOIAogzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjY5MTYxOQ==", "bodyText": "Should we delete this comment about event.category since it is removed from the above configuration?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536691619", "createdAt": "2020-12-05T11:18:46Z", "author": {"login": "ywangd"}, "path": "distribution/docker/src/docker/config/log4j2.properties", "diffHunk": "@@ -114,6 +120,8 @@ appender.audit_rolling.layout.pattern = {\\\n # \"transport.profile\" name of the transport profile in case this is a \"connection_granted\" or \"connection_denied\" event\n # \"rule\" name of the applied rule if the \"origin.type\" is \"ip_filter\"\n # \"event.category\" fixed value \"elasticsearch-audit\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzNDY3MA==", "bodyText": "I don't recall how this disappeared and since no one screamed about it, I think we can proceed with removing the comment as well.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537534670", "createdAt": "2020-12-07T14:09:52Z", "author": {"login": "albertzaharovits"}, "path": "distribution/docker/src/docker/config/log4j2.properties", "diffHunk": "@@ -114,6 +120,8 @@ appender.audit_rolling.layout.pattern = {\\\n # \"transport.profile\" name of the transport profile in case this is a \"connection_granted\" or \"connection_denied\" event\n # \"rule\" name of the applied rule if the \"origin.type\" is \"ip_filter\"\n # \"event.category\" fixed value \"elasticsearch-audit\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjY5MTYxOQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Nzk2Njc2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMTo0MjoyOFrOH_1zAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMTo0MjoyOFrOH_1zAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcwMzc0Ng==", "bodyText": "Same here for remove the comment about event.category.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536703746", "createdAt": "2020-12-05T11:42:28Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -70,6 +76,8 @@ appender.audit_rolling.layout.pattern = {\\\n # \"transport.profile\" name of the transport profile in case this is a \"connection_granted\" or \"connection_denied\" event\n # \"rule\" name of the applied rule if the \"origin.type\" is \"ip_filter\"\n # \"event.category\" fixed value \"elasticsearch-audit\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODEwNDY1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMjoyOToyN1rOH_3GCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoyOTowMFrOIAmwAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTAwMQ==", "bodyText": "Nit: It always gets me when Builder#build() does not return anything but relies on side effect. I'd prefer to have something like ...build().log(logger) or just plain logger.info(...build()). I am aware that we already have this pattern in other places. So I am adding this as a Nit so that no action is needed if you think otherwise.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536725001", "createdAt": "2020-12-05T12:29:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -880,8 +1283,8 @@ LogEntryBuilder with(Map<String, Object> map) {\n             return this;\n         }\n \n-        StringMapMessage build() {\n-            return logEntry;\n+        void build() {\n+            logger.info(AUDIT_MARKER, logEntry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 865}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ1MzIyNA==", "bodyText": "Well, this is part of what we're debating at #62916 (comment) .\nIf we wish to abstract the log entry building we cannot keep exposing the logger, because the logger expects certain fields that the entry builder populates (the logger has a configuration attached from its log4j2.properties file).\nWould renaming build to log satisfy you?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537453224", "createdAt": "2020-12-07T12:02:34Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -880,8 +1283,8 @@ LogEntryBuilder with(Map<String, Object> map) {\n             return this;\n         }\n \n-        StringMapMessage build() {\n-            return logEntry;\n+        void build() {\n+            logger.info(AUDIT_MARKER, logEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTAwMQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 865}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3ODQ5Mg==", "bodyText": "No need to rename because this is just a Nit. But I don't understand what do you mean by \"If we wish to abstract the log entry building we cannot keep exposing the logger\". Could you please elaborate?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537478492", "createdAt": "2020-12-07T12:45:51Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -880,8 +1283,8 @@ LogEntryBuilder with(Map<String, Object> map) {\n             return this;\n         }\n \n-        StringMapMessage build() {\n-            return logEntry;\n+        void build() {\n+            logger.info(AUDIT_MARKER, logEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTAwMQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 865}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUwNTc5NQ==", "bodyText": "I don't understand what do you mean by \"If we wish to abstract the log entry building we cannot keep exposing the logger\". Could you please elaborate?\n\nThe LogEntryBuilder builds a StringMapMessage. The keys in the MapMessage must match the keys in the log4j2.properties layout pattern that is assigned to the logger for the LoggingAuditTrail class.\nSo I don't want to expose (make it non private) the logger because the caller doesn't know how to use it. I prefer we expose the LogEntryBuilder, which encapsulates the logger, because it has methods in its interface. This way, the keys from the log4j pattern stay hidden from the callers.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537505795", "createdAt": "2020-12-07T13:29:00Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -880,8 +1283,8 @@ LogEntryBuilder with(Map<String, Object> map) {\n             return this;\n         }\n \n-        StringMapMessage build() {\n-            return logEntry;\n+        void build() {\n+            logger.info(AUDIT_MARKER, logEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTAwMQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 865}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODExMTA4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMjozMTo1NlrOH_3Jzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzoxMDozOFrOIAmC2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTk2Ng==", "bodyText": "This is a a good change. Not related to your change, but it's interesting that we decided to call this default_file as if there could be other file realms.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536725966", "createdAt": "2020-12-05T12:31:56Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "diffHunk": "@@ -292,15 +292,15 @@ public void usageStats(ActionListener<Map<String, Object>> listener) {\n     private void addNativeRealms(List<Realm> realms) throws Exception {\n         Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE);\n         if (fileRealm != null) {\n-            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, \"default_\" + FileRealmSettings.TYPE);\n+            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, FileRealmSettings.DEFAULT_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0Mzg2OA==", "bodyText": "Given the way realms are configured, you'll have to name the realm if you wish to change any of its settings.\nSo the default_file value is not meant to suggest that other file realms can exist, but that the only file realm can be named differently.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537443868", "createdAt": "2020-12-07T11:47:28Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "diffHunk": "@@ -292,15 +292,15 @@ public void usageStats(ActionListener<Map<String, Object>> listener) {\n     private void addNativeRealms(List<Realm> realms) throws Exception {\n         Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE);\n         if (fileRealm != null) {\n-            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, \"default_\" + FileRealmSettings.TYPE);\n+            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, FileRealmSettings.DEFAULT_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTk2Ng=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ2NDc5NA==", "bodyText": "Again, not related to your PR, but it's an interesting small topic, so forgive me to drag on this a bit more. I should have mentioned that I found the default_xxx names interesting because the reserved realm is just named as reserved, which I personally found more concise and less misleading. If we could choose again now, I wonder whether we should not allow users to configure the name of file and native realms because 1) they don't really do anything; and 2) they create slight confusion; and 3) its a bit awkward when you trying to compare two file realm settings, should they be equal despite having different names?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537464794", "createdAt": "2020-12-07T12:22:43Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "diffHunk": "@@ -292,15 +292,15 @@ public void usageStats(ActionListener<Map<String, Object>> listener) {\n     private void addNativeRealms(List<Realm> realms) throws Exception {\n         Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE);\n         if (fileRealm != null) {\n-            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, \"default_\" + FileRealmSettings.TYPE);\n+            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, FileRealmSettings.DEFAULT_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTk2Ng=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ2NTE2MQ==", "bodyText": "Just want to say this is completely off-topic. So please feel free to ignore it and stay focus on the PR.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537465161", "createdAt": "2020-12-07T12:23:26Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "diffHunk": "@@ -292,15 +292,15 @@ public void usageStats(ActionListener<Map<String, Object>> listener) {\n     private void addNativeRealms(List<Realm> realms) throws Exception {\n         Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE);\n         if (fileRealm != null) {\n-            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, \"default_\" + FileRealmSettings.TYPE);\n+            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, FileRealmSettings.DEFAULT_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTk2Ng=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5NDIzNQ==", "bodyText": "Good topics.\nBut, this is not the PR to work on that, and pinning the names of singleton realms is going to be a breaking change and breaking changes are still a burden on customers and I'm not sure it's worth it in this case.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537494235", "createdAt": "2020-12-07T13:10:38Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "diffHunk": "@@ -292,15 +292,15 @@ public void usageStats(ActionListener<Map<String, Object>> listener) {\n     private void addNativeRealms(List<Realm> realms) throws Exception {\n         Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE);\n         if (fileRealm != null) {\n-            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, \"default_\" + FileRealmSettings.TYPE);\n+            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, FileRealmSettings.DEFAULT_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTk2Ng=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODExMjM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/ReservedRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMjozMjoxM1rOH_3KiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMjozMjoxM1rOH_3KiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNjE1Mw==", "bodyText": "\ud83d\udc4d for clarity", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536726153", "createdAt": "2020-12-05T12:32:13Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/ReservedRealm.java", "diffHunk": "@@ -67,10 +68,10 @@\n \n     public ReservedRealm(Environment env, Settings settings, NativeUsersStore nativeUsersStore, AnonymousUser anonymousUser,\n                          SecurityIndexManager securityIndex, ThreadPool threadPool) {\n-        super(new RealmConfig(new RealmConfig.RealmIdentifier(TYPE, TYPE),\n+        super(new RealmConfig(new RealmConfig.RealmIdentifier(TYPE, NAME),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODM5Mjk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMzo1MDoyN1rOH_59GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzo0Mjo1NlrOICuoKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ==", "bodyText": "Any particular reason to use a largely similar but slightly different representation for a RoleDescriptor? I am worried that we are introducing unnecessary congitive load here for both users and us. For an example, the term privilege here is confusing imo. We already have other usages of privilege. It does not feel right to overload it. Also index vs indices, fields vs field_security, query vs documents.query_string. I am not saying that the existing names are all great and shiny. But they have the practical advantage of being around for a while and familarity. Unless we have a strong reason to do otherwise, I'd prefer to stick with them.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536771865", "createdAt": "2020-12-05T13:50:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4OTE1NA==", "bodyText": "As is the case with auditing all the other requests in this PR, I have chosen the field names under which we audit for consistency in the audit context. You might recall that we had the option to audit low level indexing requests, or high level transport requests. But we've chosen against those because there were cases where those approaches would expose internal fluff.\nAll this long PR is about is mapping fields in request bodies to fields in audit events. That is all, no more, no less.\nIn this particular case, the PutUserRequest and CreateApiKeyRequest both specify some form of role descriptor that must be updated or created. I think the goal of this PR is to make them look similarly when audited.\nIn addition, I don't think we should audit transient metadata. Still, when a request field is null or empty we have the option to skip the field in the audit, and I've done so for example in the FLS/DLS and metadata cases where it would've created noise, IMO.\nThis is my rationale behind these naming decisions.\nIf you have any suggestion, I will gleefully accept it, as I believe there is some point beyond which the utility of a better looking log is not worth the debate it entails.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537489154", "createdAt": "2020-12-07T13:02:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA5ODgzMg==", "bodyText": "I don't think we should audit transient metadata. Still, when a request field is null or empty we have the option to skip the field in the audit\n\nI get it that we strive to be more concise when serialising the RoleDescriptor for auditing. We can do these while keeping the existing field names. I am not suggesting to just reuse the RoleDescriptor#toXContent method, it's just about keeping the same field name when the field needs to be serialised in this place.\n\nI have chosen the field names under which we audit for consistency in the audit context. You might recall that we had the option to audit low level indexing requests, or high level transport requests. But we've chosen against those because there were cases where those approaches would expose internal fluff.\n\nRoleDescriptor is not really that internally. In many cases, users need to specify them in the request body. So I'd expect some familarity from users and using the same field names has the benefit of maintaining that familarity.\nIt's good to have consistency among different requests for auditing, maybe even consistent with ECS to some extend. I don't think it's creating any inconsistency issue by reusing the same field names from RoleDescriptor.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r538098832", "createdAt": "2020-12-08T07:33:55Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwODM3OA==", "bodyText": "I agree with @ywangd here.\nThe get role API returns a structure like:\n{\n  \"role_name\": {\n    \"cluster\": [ \"monitor\" ],\n    \"indices\": [\n      {\n        \"names\": [ \"abc\" ],\n        \"privileges\": [ \"read\" ],\n        \"field_security\": {\n          \"grant\": [  \"*\" ],\n          \"except\": [ \"private.*\" ]\n        },\n        \"query\": \"{ \\\"term\\\": { \\\"public\\\": true}}\",\n        \"allow_restricted_indices\": false\n      }\n    ],\n    \"applications\": [],\n    \"run_as\": [],\n    \"metadata\": {},\n    \"transient_metadata\": {\n      \"enabled\": true\n    }\n  }\n}\n\nBut, if I understand the code correctly, we will audit this as:\n\"role\": {\n  \"name\": \"role_name\",\n  \"privilege\": {\n    \"index\": [\n      {\n        \"names\": [ \"abc\" ],\n        \"privileges\": [ \"read\" ],\n        \"fields\": {\n          \"grant\": [  \"*\" ],\n          \"except\": [ \"private.*\" ]\n        },\n        \"documents\":{ \"query_string\": \"{ \\\"term\\\": { \\\"public\\\": true}}\" }\n      }\n    ],\n    \"cluster\": [ \"monitor\" ],\n    \"run_as\": [],\n    \"application\": [],\n    \"global\": {}\n  }\n}\n\nNot auditing transient_metadata makes sense, but what's the justification for using different field names for \"indices\" vs \"index\", \"field_security\" vs \"fields\" and \"query\" vs \"documents\": { \"query_string\": etc.\n\nI think the goal of this PR is to make them look similarly when audited.\n\nSurely the more important goal is to make them understandable to people reading the audit logs, and using the same terms that we use in the API Keys & Roles APIs does a better job of that.\nWhere API keys and Roles have differences, then we can talk about how to make them consistent in the audit logs, but having the audit logs be arbitrarily different from the existing request/response bodies for both Roles and API keys doesn't seem helpful.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539008378", "createdAt": "2020-12-09T05:04:57Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAxMjMxNQ==", "bodyText": "In terms of specific suggestions, I propose:\n\nIf we want to have a nested object for the role descriptor (what is under the \"privilege\" field in the example above) then we should follow the naming from the Create API Key request, and use some variation on role_descriptors (which can be role_descriptor if it's not going to be an array).\nUse indices, field_security, applications\nAlso use query, without any nested object, and output it as a String, as you already do.\nI'm ambivalent about whether to audit \"allow_restricted_indices\": false. The API always shows it (true or false), but that doesn't mean audit needs to\nProbably skip global if it's empty, as the API does, and continue to skip empty metadata as you do above (but again, I'm mostly ambivalent)\nOrder the fields in the same order that RoleDescriptor does (because consistency is better)", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539012315", "createdAt": "2020-12-09T05:17:01Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxNTk5MA==", "bodyText": "I have pushed f27629e to address all the above suggestions.\nTwo minor mentions related to the suggestions above:\n\nwhen putting a role or creating an API key, index and application (singulars) can also be used (as in the create api key example https://www.elastic.co/guide/en/elasticsearch/reference/7.10/security-api-create-api-key.html), but in responses they are always plural. Given your suggestion they are now audited with plurals only as well.\nI maintain that query_string is a better name to query for the DLS query string. I personally think replicating the structure of the API request or response is the wrong trade-off in this specific case.\n\nOne important note, which is more slightly related to the suggestions above:\nThe audited role descriptors don't show their names in the create api key case. Those names are not important and are not audited in the other cases too, and it helps with the consistency with the other audited events (having a single name field). See for example the role_descriptor: { and role_descriptors: [ in the below samples:\n{\n  \"type\": \"audit\",\n  \"timestamp\": \"2020-12-09T15:29:32,693+0200\",\n  \"node.id\": \"vnYUc3fmSm2QyULf6t9-Sg\",\n  \"event.type\": \"security_config_change\",\n  \"event.action\": \"put_role\",\n  \"request.id\": \"TsYX5M8WQR6hcOC_7yBskQ\",\n  \"put\": {\n    \"role\": {\n      \"name\": \"role_name\",\n      \"role_descriptor\": {\n        \"cluster\": [\n          \"monitor\"\n        ],\n        \"indices\": [\n          {\n            \"names\": [\n              \"abc\"\n            ],\n            \"privileges\": [\n              \"read\"\n            ],\n            \"field_security\": {\n              \"except\": [\n                \"private.*\"\n              ]\n            },\n            \"query\": \"{\\\"match\\\": {\\\"title\\\": \\\"foo\\\"}}\"\n          }\n        ],\n        \"applications\": [\n          {\n            \"application\": \"myapp\",\n            \"privileges\": [\n              \"admin\",\n              \"read\"\n            ],\n            \"resources\": [\n              \"*\"\n            ]\n          }\n        ],\n        \"run_as\": [\n          \"other_user\"\n        ]\n      }\n    }\n  }\n}\n\n{\n  \"type\": \"audit\",\n  \"timestamp\": \"2020-12-09T15:29:57,264+0200\",\n  \"node.id\": \"vnYUc3fmSm2QyULf6t9-Sg\",\n  \"event.type\": \"security_config_change\",\n  \"event.action\": \"create_apikey\",\n  \"request.id\": \"_dwdVsKpRjaCZMyDS86XpQ\",\n  \"create\": {\n    \"apikey\": {\n      \"name\": \"api_key_name\",\n      \"expiration\": \"1d\",\n      \"role_descriptors\": [\n        {\n          \"cluster\": [\n            \"monitor\"\n          ],\n          \"indices\": [\n            {\n              \"names\": [\n                \"abc\"\n              ],\n              \"privileges\": [\n                \"read\"\n              ],\n              \"field_security\": {\n                \"except\": [\n                  \"private.*\"\n                ]\n              },\n              \"query\": \"{\\\"match\\\": {\\\"title\\\": \\\"foo\\\"}}\"\n            }\n          ],\n          \"applications\": [\n            {\n              \"application\": \"myapp\",\n              \"privileges\": [\n                \"admin\",\n                \"read\"\n              ],\n              \"resources\": [\n                \"*\"\n              ]\n            }\n          ],\n          \"run_as\": [\n            \"other_user\"\n          ]\n        }\n      ]\n    }\n  }\n}\n\nIn general, objects in the audit events don't have variables as keys.\nI'm pointing this out because it is different from the responses of the GET APIs that can return multiple values.\nBut our \"set\" APIs, which are the ones that this PR is concerned with, only act on single objects, and\nI think that having a \"name\": \"dummy\", ... field is more straightforward and easier to parse than keying with the value of the name (or equivalent) attribute, eg \"enabled\": {\"user\": {\"name\": \"test\"}} vs \"enabled\": {\"user\": \"test\"}.\nLet me know if we need to discuss this further.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539515990", "createdAt": "2020-12-09T17:45:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMjAxMQ==", "bodyText": "The new structure looks fine to me.\n\nwhen putting a role or creating an API key, index and application (singulars) can also be used\n\nThis is probably a legacy leniency issue and not something to be replicated. +1 to always use the plural format.\n\nThe audited role descriptors don't show their names in the create api key case\n\nI think this is a good change. The name is not an inherent part of RoleDescriptor. For API keys, they are even less relevant. We don't report them in authenticate call anymore. So it makes sense to skip them. In fact, I like how the role_descriptors is an array instead of map in the audit. Honestly I think this should have been the format used by the PutApiKeyRequest. But that's another story.\n\nIn general, objects in the audit events don't have variables as keys.\nI'm pointing this out because it is different from the responses of the GET APIs that can return multiple values.\nBut our \"set\" APIs, which are the ones that this PR is concerned with, only act on single objects, and\nI think that having a \"name\": \"dummy\", ... field is more straightforward and easier to parse than keying with the value of the name (or equivalent) attribute, eg \"enabled\": {\"user\": {\"name\": \"test\"}} vs \"enabled\": {\"user\": \"test\"}.\n\nI think I understand you point here, but the last example does not seem to align with what you described? No keys are variables in both format?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539732011", "createdAt": "2020-12-09T23:42:56Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2ODQwMTgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMzo1MzowM1rOH_6CaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzo1NjoyOFrOICvAMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MzIyNA==", "bodyText": "The null value for different arguments is handled within the constructor of RoleDescriptor. So if we want to ensure null value works the same as empty list/array/map, it seems better to have a separate test for RoleDescriptor elsewhere instead of trying to cover all variations here.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536773224", "createdAt": "2020-12-05T13:53:03Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODkyNA==", "bodyText": "I don't understand what's wrong with asserting the audit format for an empty role.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r537498924", "createdAt": "2020-12-07T13:18:22Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MzIyNA=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA4NzM0Mg==", "bodyText": "First this should have been a Nit. Second I think we talked about different things. It's not about the empty role itself. It is about the randomised arguments used to construct it and I think the randomisation is not necessary if we have a test for RoleDescriptor itself looks like the follows:\nvar name = randomAlphaOfLengthBetween(1, 10);\nvar d1 = new RoleDescriptor(name, null, null, null, null, null, null, null);\nvar d2 = new RoleDescriptor(name, \n    new String[0], \n    new RoleDescriptor.IndicesPrivileges[0], \n    new RoleDescriptor.ApplicationResourcePrivileges[0], \n    new ConfigurableClusterPrivilege[0], \n    new String[0], Map.of(), Map.of());\nassertTrue(d1.equals(d2));\nThe above would ensure that null and empty arrays work identically for RoleDescriptor and how they are managed internally is an implementation detail. Therefore its callers do not have to worry about getting different behaviour whether the passed-in arguments are null or empty array, so that tests don't have to random from them. Otherwise, each place where RoleDescriptor is used, the tests need to random between null and empty array, which are just duplicated code.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r538087342", "createdAt": "2020-12-08T07:10:19Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MzIyNA=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyMjYzMg==", "bodyText": "I have pushed  8b3dcf0 that adds a test as you're describing.\nBut I personally resist assuming that if two object are equals then they must audit to the same thing. I don't see the audit method as a serialization type of method.\nIf you insist, I will remove the randomization.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539522632", "createdAt": "2020-12-09T17:54:56Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MzIyNA=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczODE2MQ==", "bodyText": "It's OK to keep the randomization.\nNo code related actions are required, but I'd like to voice a bit more of my opinion on this topic:\nWe can in general assume if two objects are equal, they should beheave the same regardless of actions (audit included). After all, that's what equals is mostly used for. For an example, when reloading role definitions from a file, our code will cleverly skip the update if the newly parsed RoleDescriptor is equal to the existing one. The message here is that if two objects are equal, they are interchangable in terms of bebaviours and auditing should be no exception. Theequals method is not about just serialization, sure two equal objects should serialise the same as well, but equals should guarantee more than just that. Plus we control the code of RoleDescriptor, so it is reasonable to expect it is well implemented to provide a reliable equals method. Unless what we care about is object identity, but that is not something we are talking about here.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539738161", "createdAt": "2020-12-09T23:56:28Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MzIyNA=="}, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTE5NzU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNjozNVrOICw6Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODoyMDo1OFrOIC8zdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2OTQyMw==", "bodyText": "I'd change this field to be just roles because 1) It is what is used in the request; 2) ECS also has a definition of user.roles.\nI understand the argument that auditing entries do not have to be exactly the same as the request body. And in some cases they cannot be or are preferred not to be. But at the same time, this new auditing is for the request body after all. Therefore, unless there are great reasons, I'd prefer to keep the same field name.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539769423", "createdAt": "2020-12-10T01:16:35Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 561}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2NDI3Ng==", "bodyText": "ECS is a good point.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539964276", "createdAt": "2020-12-10T08:20:58Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2OTQyMw=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 561}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTIyMjIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToyNTo1OFrOICxHtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToyNTo1OFrOICxHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3Mjg1Mw==", "bodyText": "Same here for roles vs role_names.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539772853", "createdAt": "2020-12-10T01:25:58Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 620}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTI1MjE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMTozNjo0MVrOICxXzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODoyMzowOVrOIC84yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3Njk3Mg==", "bodyText": "I am abit torned by this one. I slightly prefer to call it rules, but the serialisation is a singleton map instead of an array, so rule seems to be fine.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539776972", "createdAt": "2020-12-10T01:36:41Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 627}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2NTY0Mw==", "bodyText": "Renamed it to rules.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539965643", "createdAt": "2020-12-10T08:23:09Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3Njk3Mg=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 627}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTI2OTk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMTo0MzoxNVrOICxhqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMDo1ODo0NlrOIDDfgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3OTQ5Nw==", "bodyText": "In my opinion, this nesting of password field can be skipped, i.e.:\n{\"change_password\": { \"user\": {\"name\": \"foo\"} }}", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539779497", "createdAt": "2020-12-10T01:43:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 587}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MzM3OQ==", "bodyText": "It's ultimately printed as ... \"change\":{\"password\":{\"user\":{\"name\":\"foo\"}}} . Removing password makes it more confusing.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539943379", "createdAt": "2020-12-10T07:43:19Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3OTQ5Nw=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 587}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3Mzg1Ng==", "bodyText": "Sorry I mis-interpreted where event.action goes. It is not part of the payload. In this case, I am fine with the current format.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540073856", "createdAt": "2020-12-10T10:58:46Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3OTQ5Nw=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 587}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTI4ODI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMTo1MDowNVrOICxreA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMToxOTo1NVrOIDEUCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4MjAwOA==", "bodyText": "privileges is such an overused term. I personally think the privileges related APIs should have been more explicitly about the fact that they are for \"application privileges\". Given the choice this particular field name is entirely up to auditing (since user visible request does not have anything about it), I wonder whether it could be named as application_privileges for clarity.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539782008", "createdAt": "2020-12-10T01:50:05Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 660}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1MTEwMg==", "bodyText": "Currently, it is audited something like ...,\"event.action\": \"put_privileges\", \"put\": {\"privileges\": []},... . Note the relation between the value of put_privileges and the structure \"put\": {\"privileges\", which is a constant among all these events. Do you wish to propagate the replacement of privileges to the value of event.action?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539951102", "createdAt": "2020-12-10T07:57:49Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4MjAwOA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 660}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4NzMwNA==", "bodyText": "On a second thought, let's keept it as is.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540087304", "createdAt": "2020-12-10T11:19:55Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4MjAwOA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 660}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTY0NjkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoxMTo1NFrOIC0sAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMToxMzowNVrOIDEDSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTI5Ng==", "bodyText": "Should this be grant_api_key and save the nested grant field?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539831296", "createdAt": "2020-12-10T04:11:54Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2ODg2Mg==", "bodyText": "If you ask me, I think it makes sense to have both the ways to create api keys nested under \"create\": {\"apikey\":{... with different internal fields.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539968862", "createdAt": "2020-12-10T08:28:30Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTI5Ng=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4MzAxOA==", "bodyText": "I see you are trying to hold a connection between the value of event.action and the value of the top level payload key. I think this consistency has value, so let's keep it as is.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540083018", "createdAt": "2020-12-10T11:13:05Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTI5Ng=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 677}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTY1MDkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoxMzo1MFrOIC0uSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMTowMDo1NFrOIDDkyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTg4MA==", "bodyText": "Often times (if not all), in serialisation form, it is called api_key.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539831880", "createdAt": "2020-12-10T04:13:50Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 701}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTY5Ng==", "bodyText": "It shows apikey in existing audit logs already. Your call, should the new events use api_key or apikey?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539945696", "createdAt": "2020-12-10T07:47:55Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTg4MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 701}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3NTIxMQ==", "bodyText": "That's unfortunate... Since we already have apikey in the audit log, let's just keep it this way.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540075211", "createdAt": "2020-12-10T11:00:54Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTg4MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 701}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTY3MDEyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoyMjoxM1rOIC04Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoyMjoxM1rOIC04Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNDQ1MA==", "bodyText": "Similarly, I'd prefer api_keys.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539834450", "createdAt": "2020-12-10T04:22:13Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 805}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTY3NDA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoyNDowN1rOIC06oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNDozMDozMFrOIE_bow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA==", "bodyText": "It is possible that one of them could be empty. Do we need to skip the empty value?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539835040", "createdAt": "2020-12-10T04:24:07Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1NDczMQ==", "bodyText": "I don't think so (hence the code). For example, in roles, we don't skip empty fields, we output them as [] instead of null or not showing them at all.\nIn this case, the values of realm and name are important when missing, as they're interpreted as all or *.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539954731", "createdAt": "2020-12-10T08:04:27Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3OTk5Mg==", "bodyText": "With the current form, an empty value, let's say an empty realm value, can be output as null or \"\" or \"   \". I get it that we want to output empty value in this case. But is this inconsitency helpful?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540079992", "createdAt": "2020-12-10T11:08:23Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0OTQxNA==", "bodyText": "In general, the fact that different internal requests amount to the same result is not helpful.\nMore to the point, nulls, empty and whitespace strings are a nuisance, but there are two issues conflated here:\n\nshould we formalize the InvalidateApiKeyRequest object, such that a missing realmName or userName parameter is represented in the same way (equivalently, add methods isRealmNameSet that are then called in the action handler, rather than leave the action handler interpret the parameter)? I think we should.\nshould we audit the value for missing (that we specify in the above)? There are precedents \"for\" (eg cluster/index/app privileges in a role descriptor) as well as \"against\" (eg DLS/FLS permissions on an index privilege). My guiding principle is to audit it, unless it is uncommon and in the process creates noise. If you ask me, in this case I would audit, because null here really means all (it's a special kind of null to the other places).", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540149414", "createdAt": "2020-12-10T13:00:26Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3NTI2Mg==", "bodyText": "I think some of the issue here is the usage of Strings#hasLength, while the Request and Handler code uses Strings#hasText, which eliminates strings of all whitespace. So if you change it to hasText, it will at least get rid of the logging for a string like \"    \".\nI wasn't sure before but now I think I prefer to skip the empty values:\n\nIf null values are really that important here and should be logged, then we should always log them. This means even when both realmName and userName are null, we should log them, because they mean all. But I think this is apparently too much. So the opposite approach, which I prefer, is to not log them on missing values.\nBecause of the internal leniency of the InvalidateApiKeyRequest, empty values can take multiple forms. It is a hassle to consolidate them. And as you said, the right place for the consolidation is in the Request class itself. But I don't think we should drag it into this PR. Therefore, instead of logging different formats of \"null\" value, skipping them at least has the benefit of consistency.\nEven though null has the practical effect of all here, I don't think it really is that special. In my opinion, it is quite obvious because all these variables are search criteria. If not specified, it's obvious that it should take no effect. Also strictly speaking, null does not mean all. It really just means \"missing\" because you will not see it in the final search query at all. The cluster privileges in RoleDescriptor is a different story because it is not a search query, so its meaning could be ambiguous when skipped. If anything, the RoleDescriptor's query field is skipped on missing value because it is also a search criteria.\n\nSo my concrete suggestion would be to use Strings#hasText here and skip empty values.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540175262", "createdAt": "2020-12-10T13:39:11Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4OTcyMg==", "bodyText": "I would support cleaning up the request object so that it didn't support different styles of \"empty\" strings - it may be as simple as changing the setters to have\nif( Strings.hasText(arg) ) {\n   this.field = arg;\n} else \n   this.field = null;\n}\n\nBut, I'm not sure there's a good reason to squeeze that into this PR.\nI think the current logging is the preferred behaviour - or at least we should always print them as a pair, I don't have a string view whether we should output the match-all fields as *, _all or null.\nThe user and realm are a pair. They work as a pair, and they should be printed as a pair.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542089722", "createdAt": "2020-12-14T03:36:44Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEwMjU5MQ==", "bodyText": "I opened #66240 to unify the hasText checks.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542102591", "createdAt": "2020-12-14T04:23:36Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEwMjY2Mg==", "bodyText": "The user and realm are a pair. They work as a pair, and they should be printed as a pair.\n\nThis is a good point. Within the realm system, these two variables are indeed a pair. However, the Invalidate API Key API does not realy treat them as a pair in that 1) you don't need specify both of them; 2) their value absence is handled the same way as for other variables, e.g. API key name, i.e. the value absence just means the search critiera does not include this variable. So there is nothing inherently with this particular API that makes the two feel like a pair. For example, you can invalidate all keys belong to user foo from multiple realms:\nDELETE _security/api_key\n{\"username\":\"foo\"}\nIs this behaviour intended?\nWith above being said, I agree to output username and realm as a pair since this should be the norm. If there needs any fix, I think it is with the InvalidateAPIKey API and its validation logic.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542102662", "createdAt": "2020-12-14T04:23:53Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEwNDQ4Mw==", "bodyText": "Is this behaviour intended?\n\nIt was intentional, though an argument could be made that we should have enforced them being entered as a pair, and explicitly have\nDELETE _security/api_key\n{\n  \"username\":\"foo\",\n  \"realm\":\"*\"\n}\n\nBut it was intentional that you should be able to delete for a username regardless of realm (in case you only have the default realms, and don't know/care what they're called).\nLikewise you can invalidate for a whole realm, e.g. if you had a security compromise and are concerned that all the passwords for an LDAP realm might have been leaked, but we could have made it explicit and required \"username\":\"*\".", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542104483", "createdAt": "2020-12-14T04:30:30Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTY4MTA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoyNzowM1rOIC0-PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoyNzowM1rOIC0-PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTk2NA==", "bodyText": "Similarly, this is probably better to be named application_privileges especially since there is an immediately nested privileges field which does not read well in my opinion.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539835964", "createdAt": "2020-12-10T04:27:03Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 829}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTcyOTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjo0ODozM1rOIDHpMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToxMToxNlrOIFLgPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0MTg3NQ==", "bodyText": "Nit: TransportRequest#validate is called before the requet reaches the auditing logic. For GrantApiKeyRequest, it is not possible to have some of the combinations that could be randomized here, e.g. null grant type. Anyway, I think the randomization can be argued as defensive programming.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540141875", "createdAt": "2020-12-10T12:48:33Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwMjI2OA==", "bodyText": "It was my intention to not rely on request validations on the audit formatting methods.\nIf those validations change, eg. move to the transport handler, the audit methods should not be left to encounter unexpected situations that might throw exceptions.\nThis test here, as well as the other you've pointed out, is testing that desired behaviour, that even invalid requests don't trip the audit.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542302268", "createdAt": "2020-12-14T11:11:16Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0MTg3NQ=="}, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTc1MjIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjo1Mzo1OFrOIDH2Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToxMjo0MVrOIFLjgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0NTIxOA==", "bodyText": "Nit: I don't think we have any role with a null name. So this branch is not necessary.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540145218", "createdAt": "2020-12-10T12:53:58Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));\n+        grantApiKeyRequest.setApiKeyRequest(createApiKeyRequest);\n+        auditTrail.accessGranted(requestId, authentication, GrantApiKeyAction.NAME, grantApiKeyRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedGrantKeyAuditEventString = output.get(1);\n+        StringBuilder grantKeyAuditEventStringBuilder = new StringBuilder();\n+        grantKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        grantKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        grantKeyAuditEventStringBuilder.append(\"},\\\"grant\\\":{\\\"type\\\":\");\n+        if (grantApiKeyRequest.getGrant().getType() != null) {\n+            grantKeyAuditEventStringBuilder.append(\"\\\"\").append(grantApiKeyRequest.getGrant().getType()).append(\"\\\"\");\n+        } else {\n+            grantKeyAuditEventStringBuilder.append(\"null\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getUsername() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"user\\\":{\\\"name\\\":\\\"\").append(grantApiKeyRequest.getGrant().getUsername())\n+                    .append(\"\\\",\\\"has_password\\\":\").append(grantApiKeyRequest.getGrant().getPassword() != null).append(\"}\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getAccessToken() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"has_access_token\\\":\").append(true);\n+        }\n+        grantKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedGrantKeyAuditEventString = grantKeyAuditEventStringBuilder.toString();\n+        assertThat(generatedGrantKeyAuditEventString, containsString(expectedGrantKeyAuditEventString));\n+        generatedGrantKeyAuditEventString = generatedGrantKeyAuditEventString.replace(\", \" + expectedGrantKeyAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedGrantKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        PutRoleRequest putRoleRequest = new PutRoleRequest();\n+        putRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        RoleDescriptor roleDescriptor = randomFrom(allTestRoleDescriptors);\n+        putRoleRequest.name(roleDescriptor.getName());\n+        putRoleRequest.cluster(roleDescriptor.getClusterPrivileges());\n+        putRoleRequest.addIndex(roleDescriptor.getIndicesPrivileges());\n+        putRoleRequest.runAs(roleDescriptor.getRunAs());\n+        putRoleRequest.conditionalCluster(roleDescriptor.getConditionalClusterPrivileges());\n+        putRoleRequest.addApplicationPrivileges(roleDescriptor.getApplicationPrivileges());\n+        putRoleRequest.metadata(roleDescriptor.getMetadata());\n+        auditTrail.accessGranted(requestId, authentication, PutRoleAction.NAME, putRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedPutRoleAuditEventString = output.get(1);\n+        StringBuilder putRoleAuditEventStringBuilder = new StringBuilder();\n+        putRoleAuditEventStringBuilder.append(\"\\\"put\\\":{\\\"role\\\":{\\\"name\\\":\\\"\" + putRoleRequest.name() + \"\\\",\")\n+                .append(\"\\\"role_descriptor\\\":\")\n+                .append(auditedRolesMap.get(putRoleRequest.name()))\n+                .append(\"}}\");\n+        String expectedPutRoleAuditEventString = putRoleAuditEventStringBuilder.toString();\n+        assertThat(generatedPutRoleAuditEventString, containsString(expectedPutRoleAuditEventString));\n+        generatedPutRoleAuditEventString = generatedPutRoleAuditEventString.replace(\", \" + expectedPutRoleAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"put_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedPutRoleAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        DeleteRoleRequest deleteRoleRequest = new DeleteRoleRequest();\n+        deleteRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        deleteRoleRequest.name(putRoleRequest.name());\n+        auditTrail.accessGranted(requestId, authentication, DeleteRoleAction.NAME, deleteRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedDeleteRoleAuditEventString = output.get(1);\n+        StringBuilder deleteRoleStringBuilder = new StringBuilder();\n+        deleteRoleStringBuilder.append(\"\\\"delete\\\":{\\\"role\\\":{\\\"name\\\":\");\n+        if (deleteRoleRequest.name() == null) {\n+            deleteRoleStringBuilder.append(\"null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwMzEwNA==", "bodyText": "Not in the current codebase, but I think we should test the audit methods don't throw even on invalid requests.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542303104", "createdAt": "2020-12-14T11:12:41Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));\n+        grantApiKeyRequest.setApiKeyRequest(createApiKeyRequest);\n+        auditTrail.accessGranted(requestId, authentication, GrantApiKeyAction.NAME, grantApiKeyRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedGrantKeyAuditEventString = output.get(1);\n+        StringBuilder grantKeyAuditEventStringBuilder = new StringBuilder();\n+        grantKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        grantKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        grantKeyAuditEventStringBuilder.append(\"},\\\"grant\\\":{\\\"type\\\":\");\n+        if (grantApiKeyRequest.getGrant().getType() != null) {\n+            grantKeyAuditEventStringBuilder.append(\"\\\"\").append(grantApiKeyRequest.getGrant().getType()).append(\"\\\"\");\n+        } else {\n+            grantKeyAuditEventStringBuilder.append(\"null\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getUsername() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"user\\\":{\\\"name\\\":\\\"\").append(grantApiKeyRequest.getGrant().getUsername())\n+                    .append(\"\\\",\\\"has_password\\\":\").append(grantApiKeyRequest.getGrant().getPassword() != null).append(\"}\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getAccessToken() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"has_access_token\\\":\").append(true);\n+        }\n+        grantKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedGrantKeyAuditEventString = grantKeyAuditEventStringBuilder.toString();\n+        assertThat(generatedGrantKeyAuditEventString, containsString(expectedGrantKeyAuditEventString));\n+        generatedGrantKeyAuditEventString = generatedGrantKeyAuditEventString.replace(\", \" + expectedGrantKeyAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedGrantKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        PutRoleRequest putRoleRequest = new PutRoleRequest();\n+        putRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        RoleDescriptor roleDescriptor = randomFrom(allTestRoleDescriptors);\n+        putRoleRequest.name(roleDescriptor.getName());\n+        putRoleRequest.cluster(roleDescriptor.getClusterPrivileges());\n+        putRoleRequest.addIndex(roleDescriptor.getIndicesPrivileges());\n+        putRoleRequest.runAs(roleDescriptor.getRunAs());\n+        putRoleRequest.conditionalCluster(roleDescriptor.getConditionalClusterPrivileges());\n+        putRoleRequest.addApplicationPrivileges(roleDescriptor.getApplicationPrivileges());\n+        putRoleRequest.metadata(roleDescriptor.getMetadata());\n+        auditTrail.accessGranted(requestId, authentication, PutRoleAction.NAME, putRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedPutRoleAuditEventString = output.get(1);\n+        StringBuilder putRoleAuditEventStringBuilder = new StringBuilder();\n+        putRoleAuditEventStringBuilder.append(\"\\\"put\\\":{\\\"role\\\":{\\\"name\\\":\\\"\" + putRoleRequest.name() + \"\\\",\")\n+                .append(\"\\\"role_descriptor\\\":\")\n+                .append(auditedRolesMap.get(putRoleRequest.name()))\n+                .append(\"}}\");\n+        String expectedPutRoleAuditEventString = putRoleAuditEventStringBuilder.toString();\n+        assertThat(generatedPutRoleAuditEventString, containsString(expectedPutRoleAuditEventString));\n+        generatedPutRoleAuditEventString = generatedPutRoleAuditEventString.replace(\", \" + expectedPutRoleAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"put_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedPutRoleAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        DeleteRoleRequest deleteRoleRequest = new DeleteRoleRequest();\n+        deleteRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        deleteRoleRequest.name(putRoleRequest.name());\n+        auditTrail.accessGranted(requestId, authentication, DeleteRoleAction.NAME, deleteRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedDeleteRoleAuditEventString = output.get(1);\n+        StringBuilder deleteRoleStringBuilder = new StringBuilder();\n+        deleteRoleStringBuilder.append(\"\\\"delete\\\":{\\\"role\\\":{\\\"name\\\":\");\n+        if (deleteRoleRequest.name() == null) {\n+            deleteRoleStringBuilder.append(\"null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0NTIxOA=="}, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 385}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTgwMjg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowNTo0NFrOIDITpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToxOTo1NlrOIFL0zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1Mjc0Mw==", "bodyText": "Similar situation here: I think the issue is we are using Strings#hashLength here. This means a whitespace string, e.g. \"    \" will be output literally here, while it is actually treated as not-specified in the code (tested with Strings#hasText). I'd prefer we log consistently for empty (equivalent to not-specified) values.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540152743", "createdAt": "2020-12-10T13:05:44Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 809}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNzUzNA==", "bodyText": "A moot point by now, but the common case is for the field to be null in which case we don't print it.\nBut, if it is the blank string, it was set explicitly by the user, which might be exploiting some bug.\nIn principle, moving the logic from the transport handler to the audit formatter is brittle.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542307534", "createdAt": "2020-12-14T11:19:56Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1Mjc0Mw=="}, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 809}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTgwOTAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowNzoxMFrOIDIXNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowNzoxMFrOIDIXNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1MzY1NQ==", "bodyText": "Some of the usage of Strings#hasLength needs to be updated if it is changed in the main code.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540153655", "createdAt": "2020-12-10T13:07:10Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));\n+        grantApiKeyRequest.setApiKeyRequest(createApiKeyRequest);\n+        auditTrail.accessGranted(requestId, authentication, GrantApiKeyAction.NAME, grantApiKeyRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedGrantKeyAuditEventString = output.get(1);\n+        StringBuilder grantKeyAuditEventStringBuilder = new StringBuilder();\n+        grantKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        grantKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        grantKeyAuditEventStringBuilder.append(\"},\\\"grant\\\":{\\\"type\\\":\");\n+        if (grantApiKeyRequest.getGrant().getType() != null) {\n+            grantKeyAuditEventStringBuilder.append(\"\\\"\").append(grantApiKeyRequest.getGrant().getType()).append(\"\\\"\");\n+        } else {\n+            grantKeyAuditEventStringBuilder.append(\"null\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getUsername() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"user\\\":{\\\"name\\\":\\\"\").append(grantApiKeyRequest.getGrant().getUsername())\n+                    .append(\"\\\",\\\"has_password\\\":\").append(grantApiKeyRequest.getGrant().getPassword() != null).append(\"}\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getAccessToken() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"has_access_token\\\":\").append(true);\n+        }\n+        grantKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedGrantKeyAuditEventString = grantKeyAuditEventStringBuilder.toString();\n+        assertThat(generatedGrantKeyAuditEventString, containsString(expectedGrantKeyAuditEventString));\n+        generatedGrantKeyAuditEventString = generatedGrantKeyAuditEventString.replace(\", \" + expectedGrantKeyAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedGrantKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        PutRoleRequest putRoleRequest = new PutRoleRequest();\n+        putRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        RoleDescriptor roleDescriptor = randomFrom(allTestRoleDescriptors);\n+        putRoleRequest.name(roleDescriptor.getName());\n+        putRoleRequest.cluster(roleDescriptor.getClusterPrivileges());\n+        putRoleRequest.addIndex(roleDescriptor.getIndicesPrivileges());\n+        putRoleRequest.runAs(roleDescriptor.getRunAs());\n+        putRoleRequest.conditionalCluster(roleDescriptor.getConditionalClusterPrivileges());\n+        putRoleRequest.addApplicationPrivileges(roleDescriptor.getApplicationPrivileges());\n+        putRoleRequest.metadata(roleDescriptor.getMetadata());\n+        auditTrail.accessGranted(requestId, authentication, PutRoleAction.NAME, putRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedPutRoleAuditEventString = output.get(1);\n+        StringBuilder putRoleAuditEventStringBuilder = new StringBuilder();\n+        putRoleAuditEventStringBuilder.append(\"\\\"put\\\":{\\\"role\\\":{\\\"name\\\":\\\"\" + putRoleRequest.name() + \"\\\",\")\n+                .append(\"\\\"role_descriptor\\\":\")\n+                .append(auditedRolesMap.get(putRoleRequest.name()))\n+                .append(\"}}\");\n+        String expectedPutRoleAuditEventString = putRoleAuditEventStringBuilder.toString();\n+        assertThat(generatedPutRoleAuditEventString, containsString(expectedPutRoleAuditEventString));\n+        generatedPutRoleAuditEventString = generatedPutRoleAuditEventString.replace(\", \" + expectedPutRoleAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"put_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedPutRoleAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        DeleteRoleRequest deleteRoleRequest = new DeleteRoleRequest();\n+        deleteRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        deleteRoleRequest.name(putRoleRequest.name());\n+        auditTrail.accessGranted(requestId, authentication, DeleteRoleAction.NAME, deleteRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedDeleteRoleAuditEventString = output.get(1);\n+        StringBuilder deleteRoleStringBuilder = new StringBuilder();\n+        deleteRoleStringBuilder.append(\"\\\"delete\\\":{\\\"role\\\":{\\\"name\\\":\");\n+        if (deleteRoleRequest.name() == null) {\n+            deleteRoleStringBuilder.append(\"null\");\n+        } else {\n+            deleteRoleStringBuilder.append(\"\\\"\").append(deleteRoleRequest.name()).append(\"\\\"\");\n+        }\n+        deleteRoleStringBuilder.append(\"}}\");\n+        String expectedDeleteRoleAuditEventString = deleteRoleStringBuilder.toString();\n+        assertThat(generatedDeleteRoleAuditEventString, containsString(expectedDeleteRoleAuditEventString));\n+        generatedDeleteRoleAuditEventString =\n+                generatedDeleteRoleAuditEventString.replace(\", \" + expectedDeleteRoleAuditEventString,\"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"delete_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedDeleteRoleAuditEventString, checkedFields.immutableMap());\n+    }\n+\n+    public void testSecurityConfigChangeEventFormattingForApiKeyInvalidation() throws IOException {\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        final InvalidateApiKeyRequest invalidateApiKeyRequest;\n+        if (randomBoolean()) {\n+            invalidateApiKeyRequest = new InvalidateApiKeyRequest(randomFrom(randomAlphaOfLength(8), null),\n+                    randomFrom(randomAlphaOfLength(8), null), null, randomFrom(randomAlphaOfLength(8), null), randomBoolean(),\n+                    randomFrom(randomArray(3, String[]::new, () -> randomAlphaOfLength(8)), null));\n+        } else {\n+            invalidateApiKeyRequest = new InvalidateApiKeyRequest(randomFrom(randomAlphaOfLength(8), null),\n+                    randomFrom(randomAlphaOfLength(8), null), randomAlphaOfLength(8), randomFrom(randomAlphaOfLength(8), null),\n+                    randomBoolean());\n+        }\n+        auditTrail.accessGranted(requestId, authentication, InvalidateApiKeyAction.NAME, invalidateApiKeyRequest, authorizationInfo);\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedInvalidateKeyAuditEventString = output.get(1);\n+        StringBuilder invalidateKeyEventStringBuilder = new StringBuilder();\n+        invalidateKeyEventStringBuilder.append(\"\\\"invalidate\\\":{\\\"apikeys\\\":{\");\n+        if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+            invalidateKeyEventStringBuilder.append(\"\\\"ids\\\":[\");\n+            for (String apiKeyId : invalidateApiKeyRequest.getIds()) {\n+                invalidateKeyEventStringBuilder.append(\"\\\"\").append(apiKeyId).append(\"\\\",\");\n+            }\n+            // delete last comma\n+            invalidateKeyEventStringBuilder.deleteCharAt(invalidateKeyEventStringBuilder.length() - 1);\n+            invalidateKeyEventStringBuilder.append(\"],\");\n+        }\n+        if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+            invalidateKeyEventStringBuilder.append(\"\\\"name\\\":\\\"\").append(invalidateApiKeyRequest.getName()).append(\"\\\",\");\n+        }\n+        invalidateKeyEventStringBuilder.append(\"\\\"owned_by_authenticated_user\\\":\")\n+                .append(invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+        if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNTk5NTIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNjoyMjoyMlrOIFBhMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoyMDozOFrOIFQFiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODY3Mg==", "bodyText": "It's a minor thing, but I find it strange that a role with:\n\"field_security\": { \"grant\": [ \"*\" ], \"except\": [ \"secret*\" ] }\n\nwould be audited as\n\"field_security\": { \"except\": [ \"secret*\" ] }\n\nIt's not wrong, but it reads strangely, and my personal view is that it is less clear.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542138672", "createdAt": "2020-12-14T06:22:22Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 747}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1NDQ0Mw==", "bodyText": "Yes, I agree.\nI will make it so that grant is always printed if isUsingFieldLevelSecurity is true.\nThe other checks along the way should prevent inapropriate null or [] values, but there's no biggie if they don't.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542254443", "createdAt": "2020-12-14T09:58:27Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODY3Mg=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 747}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NzM1Mg==", "bodyText": "I have pushed 786518b", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542377352", "createdAt": "2020-12-14T13:20:38Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODY3Mg=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 747}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjAwODEwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNjoyNzoxMlrOIFBn1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoyMDo1M1rOIFQGEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA==", "bodyText": "Sorry, it's late in the review process for this, so don't worry about it too much, but can you explain your choice to make enable & disable top level fields, rather than something like:\n\"change\": {\n  \"enabled\": {\n    \"user\": { \"name\" : \"example\" }, \n    \"enabled\": true | false\n  }\n}", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542140374", "createdAt": "2020-12-14T06:27:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzMTAxOA==", "bodyText": "I wasn't particularly attracted to the output of:\n\"enabled\": {\n  \"user\": { \"name\" : \"example\" },\n  \"enabled\": false\n}\n\nBut I suppose, I can nest the enable/disable structure under the change name if you believe it is more consistent this way.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542231018", "createdAt": "2020-12-14T09:24:55Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzMjA1Ng==", "bodyText": "Ie. like this:\n\"change\": {\n  \"disable\": {\n    \"user\": { \"name\": \"example\"}\n  }\n}", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542232056", "createdAt": "2020-12-14T09:26:27Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0Njk5OQ==", "bodyText": "I do prefer that option - I think having a smaller number of top level fields is to be preferred, but it's just a preference.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542246999", "createdAt": "2020-12-14T09:47:35Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1NTEyOA==", "bodyText": "Indeed \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542255128", "createdAt": "2020-12-14T09:59:20Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NzQ5MQ==", "bodyText": "I have pushed f99e95f", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542377491", "createdAt": "2020-12-14T13:20:53Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA=="}, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3363, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}