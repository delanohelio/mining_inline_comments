{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTk0Mjk4", "number": 58933, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjoxODowOFrOELO3Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjoxODowOFrOELO3Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjEzMzM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/ensemble/Exponent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjoxODowOFrOGsulBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjoxODowOFrOGsulBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU1MzY2OA==", "bodyText": "You've got the math right! \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/58933#discussion_r449553668", "createdAt": "2020-07-03T12:18:08Z", "author": {"login": "valeriy42"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/ensemble/Exponent.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel.ensemble;\n+\n+import org.apache.lucene.util.RamUsageEstimator;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.TargetType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class Exponent implements StrictlyParsedOutputAggregator, LenientlyParsedOutputAggregator {\n+\n+    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Exponent.class);\n+    public static final ParseField NAME = new ParseField(\"exponent\");\n+    public static final ParseField WEIGHTS = new ParseField(\"weights\");\n+\n+    private static final ConstructingObjectParser<Exponent, Void> LENIENT_PARSER = createParser(true);\n+    private static final ConstructingObjectParser<Exponent, Void> STRICT_PARSER = createParser(false);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static ConstructingObjectParser<Exponent, Void> createParser(boolean lenient) {\n+        ConstructingObjectParser<Exponent, Void> parser = new ConstructingObjectParser<>(\n+            NAME.getPreferredName(),\n+            lenient,\n+            a -> new Exponent((List<Double>)a[0]));\n+        parser.declareDoubleArray(ConstructingObjectParser.optionalConstructorArg(), WEIGHTS);\n+        return parser;\n+    }\n+\n+    public static Exponent fromXContentStrict(XContentParser parser) {\n+        return STRICT_PARSER.apply(parser, null);\n+    }\n+\n+    public static Exponent fromXContentLenient(XContentParser parser) {\n+        return LENIENT_PARSER.apply(parser, null);\n+    }\n+\n+    private final double[] weights;\n+\n+    Exponent() {\n+        this((List<Double>) null);\n+    }\n+\n+    private Exponent(List<Double> weights) {\n+        this(weights == null ? null : weights.stream().mapToDouble(Double::valueOf).toArray());\n+    }\n+\n+    public Exponent(double[] weights) {\n+        this.weights = weights;\n+    }\n+\n+    public Exponent(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            this.weights = in.readDoubleArray();\n+        } else {\n+            this.weights = null;\n+        }\n+    }\n+\n+    @Override\n+    public Integer expectedValueSize() {\n+        return this.weights == null ? null : this.weights.length;\n+    }\n+\n+    @Override\n+    public double[] processValues(double[][] values) {\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        if (weights != null && values.length != weights.length) {\n+            throw new IllegalArgumentException(\"values must be the same length as weights.\");\n+        }\n+        assert values[0].length == 1;\n+        double[] processed = new double[values.length];\n+        for (int i = 0; i < values.length; ++i) {\n+            if (weights != null) {\n+                processed[i] = weights[i] * values[i][0];\n+            } else {\n+                processed[i] = values[i][0];\n+            }\n+        }\n+        return processed;\n+    }\n+\n+    @Override\n+    public double aggregate(double[] values) {\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        double sum = 0.0;\n+        for (double val : values) {\n+            if (Double.isFinite(val)) {\n+                sum += val;\n+            }\n+        }\n+        return Math.exp(sum);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84748c3519196f7db3d65dcf37e604ffe49446fc"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2142, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}