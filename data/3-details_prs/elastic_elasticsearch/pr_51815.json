{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwMzU2Mjcx", "number": 51815, "title": "Add REST API for cache directory stats", "bodyText": "Note: this pull request targets the feature/searchable-snapshots branch\nThis pull request adds a REST API that exposes the various CacheDirectory stats added in #51637. It adds the necessary action, transport action and request and response objects as well as a new qa:rest project for REST tests.\nThe REST endpoint is _searchable_snapshots/stats (as a TransportNodesAction it can be filtered by nodes ids) and the response looks like:\n\n{\n           \"_shards\" : {\n             \"total\" : 2,\n             \"successful\" : 1,\n             \"failed\" : 0\n           },\n           \"indices\" : {\n             \"index\" : {\n               \"shards\" : {\n                 \"0\" : [\n                   {\n                     \"snapshot_uuid\" : \"CJ95kbqcSYCu5wBAiUDDNA\",\n                     \"index_uuid\" : \"dllhcZ7kSai9XeBhVjEhIg\",\n                     \"shard\" : {\n                       \"state\" : \"STARTED\",\n                       \"primary\" : true,\n                       \"node\" : \"Zpw8ZgeqT9mCmmfRA1feNw\"\n                     },\n                     \"files\" : [\n                       {\n                         \"name\" : \"_0.cfe\",\n                         \"length\" : 405,\n                         \"open_count\" : 6,\n                         \"inner_count\" : 1,\n                         \"close_count\" : 6,\n                         \"contiguous_bytes_read\" : {\n                           \"count\" : 5,\n                           \"sum\" : 2025,\n                           \"min\" : 405,\n                           \"max\" : 405\n                         },\n                         \"non_contiguous_bytes_read\" : {\n                           \"count\" : 1,\n                           \"sum\" : 16,\n                           \"min\" : 16,\n                           \"max\" : 16\n                         },\n                         \"cached_bytes_read\" : {\n                           \"count\" : 6,\n                           \"sum\" : 2041,\n                           \"min\" : 16,\n                           \"max\" : 405\n                         },\n                         \"cached_bytes_written\" : {\n                           \"count\" : 1,\n                           \"sum\" : 405,\n                           \"min\" : 405,\n                           \"max\" : 405\n                         },\n                         \"direct_bytes_read\" : {\n                           \"count\" : 0,\n                           \"sum\" : 0,\n                           \"min\" : 0,\n                           \"max\" : 0\n                         },\n                         \"forward_seeks\" : {\n                           \"small\" : {\n                             \"count\" : 0,\n                             \"sum\" : 0,\n                             \"min\" : 0,\n                             \"max\" : 0\n                           },\n\t\t\t   \"large\" : {\n                             \"count\" : 0,\n                             \"sum\" : 0,\n                             \"min\" : 0,\n                             \"max\" : 0\n                           }\n                         },\n                         \"backward_seeks\" : {\n                           \"small\" : {\n                             \"count\" : 0,\n                             \"sum\" : 0,\n                             \"min\" : 0,\n                             \"max\" : 0\n                           },\n                           \"large\" : {\n                             \"count\" : 0,\n                             \"sum\" : 0,\n                             \"min\" : 0,\n                             \"max\" : 0\n                           }\n                         }\n                       },\n\n               ...\n}", "createdAt": "2020-02-03T14:46:05Z", "url": "https://github.com/elastic/elasticsearch/pull/51815", "merged": true, "mergeCommit": {"oid": "c73cf6897ac220efb47550e7689da5351a142d86"}, "closed": true, "closedAt": "2020-02-06T13:05:43Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcAt7GnAH2gAyMzcwMzU2MjcxOjY5MGE5YjQ4MWZlOTIwMGEwOGQyODFiODg0ODkxOThiOTI4ZDQ5MmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBqP8XAFqTM1NDQyNTk5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "690a9b481fe9200a08d281b88489198b928d492e", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/690a9b481fe9200a08d281b88489198b928d492e", "committedDate": "2020-02-03T14:36:22Z", "message": "Add REST API for cache directory stats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dfb3fde2f8739f3f06ed7dfc6a7ebe512a086a0", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/2dfb3fde2f8739f3f06ed7dfc6a7ebe512a086a0", "committedDate": "2020-02-03T14:45:34Z", "message": "Fix typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMzY1ODE1", "url": "https://github.com/elastic/elasticsearch/pull/51815#pullrequestreview-352365815", "createdAt": "2020-02-03T16:01:12Z", "commit": {"oid": "2dfb3fde2f8739f3f06ed7dfc6a7ebe512a086a0"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88d5c2e5f19aa11cef774396ad3b543c127f69c1", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/88d5c2e5f19aa11cef774396ad3b543c127f69c1", "committedDate": "2020-02-04T12:33:39Z", "message": "TransportBroadcastByNodeAction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe84072c989e4698ce4a49075d899c3cf3d50463", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe84072c989e4698ce4a49075d899c3cf3d50463", "committedDate": "2020-02-04T15:13:28Z", "message": "Remove unnecessary dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/b934e0e377a4042976eff8db8802d7c9567f0cb0", "committedDate": "2020-02-04T17:35:58Z", "message": "Merge branch 'feature/searchable-snapshots' into add-instrumentation-step-2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNTI3NzQ5", "url": "https://github.com/elastic/elasticsearch/pull/51815#pullrequestreview-353527749", "createdAt": "2020-02-05T08:13:44Z", "commit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODoxMzo0NFrOFlu3aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwODo1MToyMFrOFlv0BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTQ4MA==", "bodyText": "Suggest renaming this to SearchableSnapshotShardStats to clarify that these stats are per-shard.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375109480", "createdAt": "2020-02-05T08:13:44Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEwOTk1NQ==", "bodyText": "Should we use writeVLong? I think all these numbers will be nonnegative (we can assert that).", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375109955", "createdAt": "2020-02-05T08:15:06Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/searchablesnapshots/SearchableSnapshotStats.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.snapshots.SnapshotId;\n+\n+import java.io.IOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+public class SearchableSnapshotStats implements Writeable, ToXContentObject {\n+\n+    private final List<CacheIndexInputStats> inputStats;\n+    private final ShardRouting shardRouting;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+\n+    public SearchableSnapshotStats(ShardRouting shardRouting, SnapshotId snapshotId, IndexId indexId, List<CacheIndexInputStats> stats) {\n+        this.shardRouting = Objects.requireNonNull(shardRouting);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.inputStats = unmodifiableList(Objects.requireNonNull(stats));\n+    }\n+\n+    public SearchableSnapshotStats(StreamInput in) throws IOException {\n+        this.shardRouting = new ShardRouting(in);\n+        this.snapshotId = new SnapshotId(in);\n+        this.indexId = new IndexId(in);\n+        this.inputStats = in.readList(CacheIndexInputStats::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        shardRouting.writeTo(out);\n+        snapshotId.writeTo(out);\n+        indexId.writeTo(out);\n+        out.writeList(inputStats);\n+    }\n+\n+    public ShardRouting getShardRouting() {\n+        return shardRouting;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public List<CacheIndexInputStats> getStats() {\n+        return inputStats;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        {\n+            builder.field(\"snapshot_uuid\", getSnapshotId().getUUID());\n+            builder.field(\"index_uuid\", getIndexId().getId());\n+            builder.startObject(\"shard\");\n+            {\n+                builder.field(\"state\", shardRouting.state());\n+                builder.field(\"primary\", shardRouting.primary());\n+                builder.field(\"node\", shardRouting.currentNodeId());\n+                if (shardRouting.relocatingNodeId() != null) {\n+                    builder.field(\"relocating_node\", shardRouting.relocatingNodeId());\n+                }\n+            }\n+            builder.endObject();\n+            builder.startArray(\"files\");\n+            {\n+                List<CacheIndexInputStats> stats = inputStats.stream()\n+                    .sorted(Comparator.comparing(CacheIndexInputStats::getFileName)).collect(toList());\n+                for (CacheIndexInputStats stat : stats) {\n+                    stat.toXContent(builder, params);\n+                }\n+            }\n+            builder.endArray();\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null || getClass() != other.getClass()) {\n+            return false;\n+        }\n+        SearchableSnapshotStats that = (SearchableSnapshotStats) other;\n+        return Objects.equals(shardRouting, that.shardRouting)\n+            && Objects.equals(snapshotId, that.snapshotId)\n+            && Objects.equals(indexId, that.indexId)\n+            && Objects.equals(inputStats, that.inputStats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(shardRouting, snapshotId, indexId, inputStats);\n+    }\n+\n+\n+    public static class CacheIndexInputStats implements Writeable, ToXContentObject {\n+\n+        private final String fileName;\n+        private final long fileLength;\n+\n+        private final long openCount;\n+        private final long innerCount;\n+        private final long closeCount;\n+\n+        private final Counter forwardSmallSeeks;\n+        private final Counter backwardSmallSeeks;\n+        private final Counter forwardLargeSeeks;\n+        private final Counter backwardLargeSeeks;\n+        private final Counter contiguousReads;\n+        private final Counter nonContiguousReads;\n+        private final Counter cachedBytesRead;\n+        private final Counter cachedBytesWritten;\n+        private final Counter directBytesRead;\n+\n+        public CacheIndexInputStats(String fileName, long fileLength, long openCount, long innerCount, long closeCount,\n+                                    Counter forwardSmallSeeks, Counter backwardSmallSeeks,\n+                                    Counter forwardLargeSeeks, Counter backwardLargeSeeks,\n+                                    Counter contiguousReads, Counter nonContiguousReads,\n+                                    Counter cachedBytesRead, Counter cachedBytesWritten,\n+                                    Counter directBytesRead) {\n+            this.fileName = fileName;\n+            this.fileLength = fileLength;\n+            this.openCount = openCount;\n+            this.innerCount = innerCount;\n+            this.closeCount = closeCount;\n+            this.forwardSmallSeeks = forwardSmallSeeks;\n+            this.backwardSmallSeeks = backwardSmallSeeks;\n+            this.forwardLargeSeeks = forwardLargeSeeks;\n+            this.backwardLargeSeeks = backwardLargeSeeks;\n+            this.contiguousReads = contiguousReads;\n+            this.nonContiguousReads = nonContiguousReads;\n+            this.cachedBytesRead = cachedBytesRead;\n+            this.cachedBytesWritten = cachedBytesWritten;\n+            this.directBytesRead = directBytesRead;\n+        }\n+\n+        CacheIndexInputStats(final StreamInput in) throws IOException {\n+            this.fileName = in.readString();\n+            this.fileLength = in.readVLong();\n+            this.openCount = in.readVLong();\n+            this.innerCount = in.readVLong();\n+            this.closeCount = in.readVLong();\n+            this.forwardSmallSeeks = new Counter(in);\n+            this.backwardSmallSeeks = new Counter(in);\n+            this.forwardLargeSeeks = new Counter(in);\n+            this.backwardLargeSeeks = new Counter(in);\n+            this.contiguousReads = new Counter(in);\n+            this.nonContiguousReads = new Counter(in);\n+            this.cachedBytesRead = new Counter(in);\n+            this.cachedBytesWritten = new Counter(in);\n+            this.directBytesRead = new Counter(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(fileName);\n+            out.writeVLong(fileLength);\n+            out.writeVLong(openCount);\n+            out.writeVLong(innerCount);\n+            out.writeVLong(closeCount);\n+\n+            forwardSmallSeeks.writeTo(out);\n+            backwardSmallSeeks.writeTo(out);\n+            forwardLargeSeeks.writeTo(out);\n+            backwardLargeSeeks.writeTo(out);\n+            contiguousReads.writeTo(out);\n+            nonContiguousReads.writeTo(out);\n+            cachedBytesRead.writeTo(out);\n+            cachedBytesWritten.writeTo(out);\n+            directBytesRead.writeTo(out);\n+        }\n+\n+        public String getFileName() {\n+            return fileName;\n+        }\n+\n+        public long getFileLength() {\n+            return fileLength;\n+        }\n+\n+        public long getOpenCount() {\n+            return openCount;\n+        }\n+\n+        public long getInnerCount() {\n+            return innerCount;\n+        }\n+\n+        public long getCloseCount() {\n+            return closeCount;\n+        }\n+\n+        public Counter getForwardSmallSeeks() {\n+            return forwardSmallSeeks;\n+        }\n+\n+        public Counter getBackwardSmallSeeks() {\n+            return backwardSmallSeeks;\n+        }\n+\n+        public Counter getForwardLargeSeeks() {\n+            return forwardLargeSeeks;\n+        }\n+\n+        public Counter getBackwardLargeSeeks() {\n+            return backwardLargeSeeks;\n+        }\n+\n+        public Counter getContiguousReads() {\n+            return contiguousReads;\n+        }\n+\n+        public Counter getNonContiguousReads() {\n+            return nonContiguousReads;\n+        }\n+\n+        public Counter getCachedBytesRead() {\n+            return cachedBytesRead;\n+        }\n+\n+        public Counter getCachedBytesWritten() {\n+            return cachedBytesWritten;\n+        }\n+\n+        public Counter getDirectBytesRead() {\n+            return directBytesRead;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            {\n+                builder.field(\"name\", getFileName());\n+                builder.field(\"length\", getFileLength());\n+                builder.field(\"open_count\", getOpenCount());\n+                builder.field(\"inner_count\", getInnerCount());\n+                builder.field(\"close_count\", getCloseCount());\n+                builder.field(\"contiguous_bytes_read\", getContiguousReads());\n+                builder.field(\"non_contiguous_bytes_read\", getNonContiguousReads());\n+                builder.field(\"cached_bytes_read\", getCachedBytesRead());\n+                builder.field(\"cached_bytes_written\", getCachedBytesWritten());\n+                builder.field(\"direct_bytes_read\", getDirectBytesRead());\n+                {\n+                    builder.startObject(\"forward_seeks\");\n+                    builder.field(\"small\", getForwardSmallSeeks());\n+                    builder.field(\"large\", getForwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+                {\n+                    builder.startObject(\"backward_seeks\");\n+                    builder.field(\"small\", getBackwardSmallSeeks());\n+                    builder.field(\"large\", getBackwardLargeSeeks());\n+                    builder.endObject();\n+                }\n+            }\n+            return builder.endObject();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (other == null || getClass() != other.getClass()) {\n+                return false;\n+            }\n+            CacheIndexInputStats stats = (CacheIndexInputStats) other;\n+            return fileLength == stats.fileLength\n+                && openCount == stats.openCount\n+                && innerCount == stats.innerCount\n+                && closeCount == stats.closeCount\n+                && Objects.equals(fileName, stats.fileName)\n+                && Objects.equals(forwardSmallSeeks, stats.forwardSmallSeeks)\n+                && Objects.equals(backwardSmallSeeks, stats.backwardSmallSeeks)\n+                && Objects.equals(forwardLargeSeeks, stats.forwardLargeSeeks)\n+                && Objects.equals(backwardLargeSeeks, stats.backwardLargeSeeks)\n+                && Objects.equals(contiguousReads, stats.contiguousReads)\n+                && Objects.equals(nonContiguousReads, stats.nonContiguousReads)\n+                && Objects.equals(cachedBytesRead, stats.cachedBytesRead)\n+                && Objects.equals(cachedBytesWritten, stats.cachedBytesWritten)\n+                && Objects.equals(directBytesRead, stats.directBytesRead);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(fileName, fileLength, openCount, innerCount, closeCount,\n+                forwardSmallSeeks, backwardSmallSeeks,\n+                forwardLargeSeeks, backwardLargeSeeks,\n+                contiguousReads, nonContiguousReads,\n+                cachedBytesRead, cachedBytesWritten,\n+                directBytesRead);\n+        }\n+    }\n+\n+    public static class Counter implements Writeable, ToXContentObject {\n+\n+        private final long count;\n+        private final long total;\n+        private final long min;\n+        private final long max;\n+\n+        public Counter(final long count, final long total, final long min, final long max) {\n+            this.count = count;\n+            this.total = total;\n+            this.min = min;\n+            this.max = max;\n+        }\n+\n+        Counter(final StreamInput in) throws IOException {\n+            this.count = in.readZLong();\n+            this.total = in.readZLong();\n+            this.min = in.readZLong();\n+            this.max = in.readZLong();\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            out.writeZLong(count);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMDk5Nw==", "bodyText": "typo \ud83d\ude01\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    index: \"unkown\"\n          \n          \n            \n                    index: \"unknown\"", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375110997", "createdAt": "2020-02-05T08:17:32Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMjQ4NQ==", "bodyText": "Does this need us to have refreshed and flushed before taking the snapshot? Or is that handled by the framework?", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375112485", "createdAt": "2020-02-05T08:21:11Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMzM5NA==", "bodyText": "I expect this index has replicas; they won't be assigned if the test cluster only has a single data node, but I think this would fail if there were more nodes involved (we don't specify a single node cluster anywhere AFAIK). We should set the number of replicas to make sure this works even in larger clusters.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375113394", "createdAt": "2020-02-05T08:23:28Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/qa/rest/src/test/resources/rest-api-spec/test/stats.yml", "diffHunk": "@@ -0,0 +1,158 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+        index: index\n+        body:\n+          settings:\n+            number_of_shards:   1\n+\n+  - do:\n+      bulk:\n+        body:\n+          - index:\n+              _index: index\n+          - field: foo\n+          - index:\n+              _index: index\n+          - field: bar\n+          - index:\n+              _index: index\n+          - field: baz\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-fs\n+        body:\n+          type: fs\n+          settings:\n+            location: \"repository-fs\"\n+\n+  - do:\n+      snapshot.create:\n+        repository: repository-fs\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - do:\n+      snapshot.delete_repository:\n+        repository: repository-fs\n+\n+  - do:\n+      indices.delete:\n+        index: index\n+\n+---\n+\"Tests searchable snapshots stats\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason:  searchable snapshots introduced in 8.0\n+\n+  - do:\n+      searchable_snapshots.stats: {}\n+\n+  - length: { indices: 0 }\n+\n+  - do:\n+      catch:   missing\n+      searchable_snapshots.stats:\n+        index: \"unkown\"\n+\n+  - do:\n+      snapshot.create_repository:\n+        repository: repository-searchable-snapshots\n+        body:\n+          type: searchable\n+          settings:\n+            delegate_type: fs\n+            location: \"repository-fs\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      snapshot.restore:\n+        repository: repository-searchable-snapshots\n+        snapshot: snapshot\n+        wait_for_completion: true\n+\n+  - match: { snapshot.snapshot: snapshot }\n+  - match: { snapshot.shards.failed: 0 }\n+  - match: { snapshot.shards.successful: 1 }\n+\n+  - do:\n+      search:\n+        rest_total_hits_as_int: true\n+        index: index\n+        body:\n+          query:\n+            match_all: {}\n+\n+  - match: { hits.total: 3 }\n+\n+  - do:\n+      nodes.info: {}\n+  - set:\n+      nodes._arbitrary_key_: node_id\n+\n+  - do:\n+      searchable_snapshots.stats:\n+        index: \"ind*\"\n+\n+  - length:  { indices: 1 }\n+  - length:  { indices.index.shards: 1 }\n+  - length:  { indices.index.shards.0: 1 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNDQzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return stats;\n          \n          \n            \n                    return Collections.unmodifiableMap(stats);", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375114439", "createdAt": "2020-02-05T08:26:15Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheDirectory.java", "diffHunk": "@@ -64,6 +64,22 @@ private CacheKey createCacheKey(String fileName) {\n         return new CacheKey(snapshotId, indexId, shardId, fileName);\n     }\n \n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return stats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExNTIzMA==", "bodyText": "We should at least mark this line as //NORELEASE too, but really I think we should be bolder and say that by the time this is merged we expect this API not to be experimental any more, so there's no need for this.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375115230", "createdAt": "2020-02-05T08:28:13Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/resources/rest-api-spec/api/searchable_snapshots.stats.json", "diffHunk": "@@ -0,0 +1,30 @@\n+{\n+  \"searchable_snapshots.stats\": {\n+    \"documentation\": {\n+      \"url\": \"https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots-get-stats.html //NORELEASE\"\n+    },\n+    \"stability\": \"experimental\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEyNDk5Nw==", "bodyText": "Ideally, we would throw an exception if the user specified an index (or pattern) which didn't match any searchable snapshots, but this would naturally fall to the IndexNameExpressionResolver which doesn't seem to have a suitable extension point for this kind of logic.\nHowever, what do you think about handling at least the case of a user specifying a single index with a typo, matching nothing, with an INFE? I.e. if request.indices() is not empty or [\"*\"] or [\"_all\"] but searchableSnapshotIndices is empty, then that's a bad request.", "url": "https://github.com/elastic/elasticsearch/pull/51815#discussion_r375124997", "createdAt": "2020-02-05T08:51:20Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportSearchableSnapshotsStatsAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.store.FilterDirectory;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.broadcast.node.TransportBroadcastByNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardsIterator;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.CacheIndexInputStats;\n+import org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotStats.Counter;\n+import org.elasticsearch.xpack.searchablesnapshots.InMemoryNoOpCommitDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.CacheDirectory;\n+import org.elasticsearch.xpack.searchablesnapshots.cache.IndexInputStats;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+import static org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY;\n+\n+public class TransportSearchableSnapshotsStatsAction extends TransportBroadcastByNodeAction<SearchableSnapshotsStatsRequest,\n+                                                                                            SearchableSnapshotsStatsResponse,\n+                                                                                            SearchableSnapshotStats> {\n+    private final IndicesService indicesService;\n+\n+    @Inject\n+    public TransportSearchableSnapshotsStatsAction(ClusterService clusterService, TransportService transportService,\n+                                                   IndicesService indicesService, ActionFilters actionFilters,\n+                                                   IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(SearchableSnapshotsStatsAction.NAME, clusterService, transportService, actionFilters, indexNameExpressionResolver,\n+            SearchableSnapshotsStatsRequest::new, ThreadPool.Names.MANAGEMENT);\n+        this.indicesService = indicesService;\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkGlobalBlock(ClusterState state, SearchableSnapshotsStatsRequest request) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkRequestBlock(ClusterState state, SearchableSnapshotsStatsRequest request, String[] indices) {\n+        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indices);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotStats readShardResult(StreamInput in) throws IOException {\n+        return new SearchableSnapshotStats(in);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsResponse newResponse(SearchableSnapshotsStatsRequest request,\n+                                                           int totalShards, int successfulShards, int failedShards,\n+                                                           List<SearchableSnapshotStats> searchableSnapshotStats,\n+                                                           List<DefaultShardOperationFailedException> shardFailures,\n+                                                           ClusterState clusterState) {\n+        return new SearchableSnapshotsStatsResponse(searchableSnapshotStats, totalShards, successfulShards, failedShards, shardFailures);\n+    }\n+\n+    @Override\n+    protected SearchableSnapshotsStatsRequest readRequestFrom(StreamInput in) throws IOException {\n+        return new SearchableSnapshotsStatsRequest(in);\n+    }\n+\n+    @Override\n+    protected ShardsIterator shards(ClusterState state, SearchableSnapshotsStatsRequest request, String[] concreteIndices) {\n+        final List<String> searchableSnapshotIndices = new ArrayList<>();\n+        for (String concreteIndex : concreteIndices) {\n+            IndexMetaData indexMetaData = state.metaData().index(concreteIndex);\n+            if (indexMetaData != null) {\n+                Settings indexSettings = indexMetaData.getSettings();\n+                if (INDEX_STORE_TYPE_SETTING.get(indexSettings).equals(SNAPSHOT_DIRECTORY_FACTORY_KEY)) {\n+                    searchableSnapshotIndices.add(concreteIndex);\n+                }\n+            }\n+        }\n+        return state.routingTable().allShards(searchableSnapshotIndices.toArray(new String[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b934e0e377a4042976eff8db8802d7c9567f0cb0"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1167ff77ef1db7fb89c760de236fda2d2fcae0bf", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/1167ff77ef1db7fb89c760de236fda2d2fcae0bf", "committedDate": "2020-02-05T09:32:08Z", "message": "Renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1d79735f562188b5a0167b7c4400dff0f36c61e", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/b1d79735f562188b5a0167b7c4400dff0f36c61e", "committedDate": "2020-02-05T09:44:08Z", "message": "handle negative longs in tests + random seeking threshold"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4f92bd70270a436a6395001dd4662fdc76efa07", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4f92bd70270a436a6395001dd4662fdc76efa07", "committedDate": "2020-02-05T09:45:46Z", "message": "unknown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2ea47f228c27bead4933eb04cc18ae82ca39601", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/f2ea47f228c27bead4933eb04cc18ae82ca39601", "committedDate": "2020-02-05T10:06:28Z", "message": "replicas to 0 and rename index to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dda6ab7250aee4e614f516f3b718fedd3c6d8538", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/dda6ab7250aee4e614f516f3b718fedd3c6d8538", "committedDate": "2020-02-05T10:09:24Z", "message": "Collections.unmodifiableMap(stats);"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fde0a86e63f0ba22ff6aa1d5d29ddb5b5b1b49ec", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/fde0a86e63f0ba22ff6aa1d5d29ddb5b5b1b49ec", "committedDate": "2020-02-05T10:23:30Z", "message": "Document // NORELEASE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9468d104a8f341b94ba4bbba8373f68f30b508b", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/c9468d104a8f341b94ba4bbba8373f68f30b508b", "committedDate": "2020-02-05T10:58:24Z", "message": "RNFE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1049a35844f78f1faa595e01745efe472b5acbf", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/d1049a35844f78f1faa595e01745efe472b5acbf", "committedDate": "2020-02-06T08:37:20Z", "message": "RNFE bis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c81bcdea24ddc8e98208f9685aff264e34ddfa6f", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/c81bcdea24ddc8e98208f9685aff264e34ddfa6f", "committedDate": "2020-02-06T11:52:34Z", "message": "Merge branch 'feature/searchable-snapshots' into add-instrumentation-step-2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NDI1OTk5", "url": "https://github.com/elastic/elasticsearch/pull/51815#pullrequestreview-354425999", "createdAt": "2020-02-06T12:53:26Z", "commit": {"oid": "c81bcdea24ddc8e98208f9685aff264e34ddfa6f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2972, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}