{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNDE3OTQx", "number": 55011, "title": "[Transform] implement throttling in indexer", "bodyText": "implement throttling in async-indexer used by rollup and transform. The added docs_per_second parameter is used to calculate a delay before the next\nsearch request is send. With re-throttle its possible to change the parameter at\nruntime, at stop its ensured that despite throttling the indexer stops in\nreasonable time\nrelates #54862\nThis PR adds the basics to use throttling, usage/exposure of this feature is planned for separate PR's, that's why I label this as non-issue.", "createdAt": "2020-04-09T13:17:05Z", "url": "https://github.com/elastic/elasticsearch/pull/55011", "merged": true, "mergeCommit": {"oid": "72a43dd538484e889c26dc2e8b7aae72930ed93b"}, "closed": true, "closedAt": "2020-04-30T05:07:14Z", "author": {"login": "hendrikmuhs"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXQNVPgFqTM5MjE5NTE2NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABccasi-gFqTQwMjgxNDQyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMTk1MTY1", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-392195165", "createdAt": "2020-04-13T14:53:25Z", "commit": {"oid": "dc0a4bc9ccb8cb58da69def30129226bf1e285c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1MzoyNlrOGEpBeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1MzoyNlrOGEpBeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTYwOQ==", "bodyText": "Since this is not synchronized, I am not sure if private synchronized void reQueueThrottledSearch() or private synchronized void triggerThrottledSearchNow() actually work :/. The scheduledNextSearch could get set out from under those blocks. Unless we are ONLY worried about reQueueThrottledSearch and triggerThrottledSearchNow conflicting.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r407519609", "createdAt": "2020-04-13T14:53:26Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -410,25 +473,43 @@ private void onSearchResponse(SearchResponse searchResponse) {\n     private void onBulkResponse(BulkResponse response, JobPosition position) {\n         stats.markEndIndexing();\n         try {\n-            ActionListener<SearchResponse> listener = ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n             // TODO probably something more intelligent than every-50 is needed\n             if (stats.getNumPages() > 0 && stats.getNumPages() % 50 == 0) {\n                 doSaveState(IndexerState.INDEXING, position, () -> {\n-                    nextSearch(listener);\n+                    nextSearch();\n                 });\n             } else {\n-                nextSearch(listener);\n+                nextSearch();\n             }\n         } catch (Exception e) {\n             finishWithIndexingFailure(e);\n         }\n     }\n \n-    private void nextSearch(ActionListener<SearchResponse> listener) {\n+    protected void nextSearch() {\n+        if (maximumRequestsPerSecond > 0 && lastDocCount > 0) {\n+            TimeValue executionDelay = calculateThrottlingDelay(maximumRequestsPerSecond, lastDocCount, lastSearchStartTimeNanos,\n+                    getTimeNanos());\n+\n+            if (executionDelay.duration() > 0) {\n+                logger.debug(\"throttling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond,\n+                        lastDocCount);\n+                scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(), executionDelay, executorName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc0a4bc9ccb8cb58da69def30129226bf1e285c0"}, "originalPosition": 194}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5693925e660cca4b6bf2fd660af51db8b7e4da58", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/5693925e660cca4b6bf2fd660af51db8b7e4da58", "committedDate": "2020-04-14T15:02:41Z", "message": "fix corner case issue when stop is called while a next search is scheduled"}, "afterCommit": {"oid": "7c55d357dce778f6aa02b20b01109155eb295662", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/7c55d357dce778f6aa02b20b01109155eb295662", "committedDate": "2020-04-14T15:09:36Z", "message": "fix corner case issue when stop is called while a next search is scheduled"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTU3Nzg2", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-394157786", "createdAt": "2020-04-15T21:45:39Z", "commit": {"oid": "998c4784e7d0a514c03cf9f453b678890ff44f38"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a4c37f9bd05609a45aa755b59079a8e4412049b", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/1a4c37f9bd05609a45aa755b59079a8e4412049b", "committedDate": "2020-04-21T08:59:50Z", "message": "check state more often and do not fire a search request in case of stopping"}, "afterCommit": {"oid": "35a9b748ad78f994697ccbc770208fc19c3844e2", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/35a9b748ad78f994697ccbc770208fc19c3844e2", "committedDate": "2020-04-21T09:39:41Z", "message": "expose wait time so rollup/transform can issue lightweight queries for\nthrottling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDQ1NjU4", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-397445658", "createdAt": "2020-04-21T15:27:37Z", "commit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyNzozN1rOGJL7sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNTozMVrOGJPTbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NTg3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Cancels a scheduled search request and issues the search request immediately\n          \n          \n            \n                 * Cancels a scheduled search request", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412285874", "createdAt": "2020-04-21T15:27:37Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -178,6 +208,35 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Cancels a scheduled search request and issues the search request immediately", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzOTU0Mg==", "bodyText": "From what I understand around cancel, the only times it will return false are:\n\nIf the action has already been completed\nIf the action has already been cancelled.\n\nThis means it will return true if the thread is executing.\nthreadPool.executor(executorName).execute(() -> checkState(getState()));\n\nCould happen in the middle of triggerNextSearch. This MIGHT be ok, but the call to checkState(getState()) might transition from STOPPING -> STOPPED while a search is still in flight. I am not sure this is intended behavior.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412339542", "createdAt": "2020-04-21T17:13:17Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -178,6 +208,35 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Cancels a scheduled search request and issues the search request immediately\n+     */\n+    private synchronized void stopThrottledSearch() {\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTEwMw==", "bodyText": "Similar comment to above, a current search could be inflight. This means that if the next delay is 0L, we could have two searches occurring in parallel.\nAs long as this method is NEVER called out of band, I think this might be ok.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412341103", "createdAt": "2020-04-21T17:15:31Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +562,37 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzE1MDUz", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-399315053", "createdAt": "2020-04-23T17:21:03Z", "commit": {"oid": "9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mzk2MTkz", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-399396193", "createdAt": "2020-04-23T19:08:26Z", "commit": {"oid": "9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOTowODoyNlrOGK3yPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOTowODoyNlrOGK3yPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA1MjkyNw==", "bodyText": "I realized its developer unfriendly to pass maximumRequestsPerSecond as parameter of the constructor.\nIt seems better to have getMaximumRequestsPerSecond() which can be overridden. I still need the rethrottle method, but without a parameter. To avoid that rethrottle kicks in although it hasn't changed, I would still cache the last value for comparison.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414052927", "createdAt": "2020-04-23T19:08:26Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -38,18 +42,69 @@\n public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends IndexerJobStats> {\n     private static final Logger logger = LogManager.getLogger(AsyncTwoPhaseIndexer.class.getName());\n \n+    // max time to wait for throttling\n+    private static final TimeValue MAX_THROTTLE_WAIT_TIME =  TimeValue.timeValueHours(1);\n+    // min time to trigger delayed execution\n+    private static final TimeValue MIN_THROTTLE_WAIT_TIME =  TimeValue.timeValueMillis(10);\n+\n+    private final ActionListener<SearchResponse> searchResponseListener =\n+        ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n+\n     private final JobStats stats;\n \n     private final AtomicReference<IndexerState> state;\n     private final AtomicReference<JobPosition> position;\n-    private final Executor executor;\n+    private final ThreadPool threadPool;\n+    private final String executorName;\n+\n+    // throttling\n+    private volatile float maximumRequestsPerSecond;\n+    private volatile long lastSearchStartTimeNanos = 0;\n+    private volatile long lastDocCount = 0;\n+    private volatile ScheduledRunnable scheduledNextSearch;\n+\n+    class ScheduledRunnable {\n+        private final ThreadPool threadPool;\n+        private final String executorName;\n+        private final Runnable command;\n+        private Scheduler.ScheduledCancellable scheduled;\n+\n+        ScheduledRunnable(ThreadPool threadPool, String executorName, TimeValue delay, Runnable command) {\n+            this.threadPool = threadPool;\n+            this.executorName = executorName;\n+\n+            // with wrapping the command in RunOnce we ensure the command isn't executed twice, e.g. if the\n+            // future is already running and cancel returns true\n+            this.command = new RunOnce(command);\n+            this.scheduled = threadPool.schedule(() -> {command.run();}, delay, executorName);\n+        }\n+\n+        public void reschedule(TimeValue delay) {\n+            // note: cancel return true if the runnable is currently executing\n+            if (scheduled.cancel()) {\n+                if (delay.duration() > 0) {\n+                    scheduled = threadPool.schedule(() -> command.run(), delay, executorName);\n+                } else {\n+                    threadPool.executor(executorName).execute(() -> command.run());\n+                }\n+            }\n+        }\n \n-    protected AsyncTwoPhaseIndexer(Executor executor, AtomicReference<IndexerState> initialState,\n+    }\n+\n+    protected AsyncTwoPhaseIndexer(ThreadPool threadPool, String executorName, AtomicReference<IndexerState> initialState,\n                                    JobPosition initialPosition, JobStats jobStats) {\n-        this.executor = executor;\n+        this(threadPool, executorName, initialState, initialPosition, jobStats, -1);\n+    }\n+\n+    protected AsyncTwoPhaseIndexer(ThreadPool threadPool, String executorName, AtomicReference<IndexerState> initialState,\n+            JobPosition initialPosition, JobStats jobStats, float maximumRequestsPerSecond) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8"}, "originalPosition": 78}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8", "committedDate": "2020-04-22T14:45:37Z", "message": "checkstyle"}, "afterCommit": {"oid": "df0b527d9852ad70288182b93d9edfc33104c191", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/df0b527d9852ad70288182b93d9edfc33104c191", "committedDate": "2020-04-24T06:59:31Z", "message": "formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NzQwMzc0", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-399740374", "createdAt": "2020-04-24T08:24:46Z", "commit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoyNDo0N1rOGLMYlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODozMToyNlrOGLMpPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MDQyMA==", "bodyText": "nit: these two arguments should be camelCase", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414390420", "createdAt": "2020-04-24T08:24:47Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "diffHunk": "@@ -382,22 +457,135 @@ public void testStop_WhileIndexing() throws Exception {\n             assertBusy(() -> assertTrue(isStopped.get()));\n             assertFalse(isFinished.get());\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n \n     public void testFiveRuns() throws Exception {\n+        doTestFiveRuns(-1, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled100() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(100, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsThrottled1000() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(1_000, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 950L));\n+    }\n+\n+    public void testFiveRunsThrottled18000() throws Exception {\n+        // expect throttling to not kick in due to min wait time\n+        doTestFiveRuns(18_000, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled1000000() throws Exception {\n+        // request per seconds is set high, so throttling does not kick in\n+        doTestFiveRuns(1_000_000, Collections.emptyList());\n+    }\n+\n+    public void doTestFiveRuns(float requests_per_second, Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n-        final ExecutorService executor = Executors.newFixedThreadPool(1);\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n         try {\n-            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (executor, state, 2);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                null);\n             indexer.start();\n             assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n             assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n             assertBusy(() -> assertTrue(isFinished.get()));\n             indexer.assertCounters();\n+            threadPool.assertCountersAndDelay(expectedDelays);\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n+\n+    public void testFiveRunsRethrottle0_100() throws Exception {\n+        doTestFiveRunsRethrottle(-1, 100, timeValueCollectionFromMilliseconds(9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_0() throws Exception {\n+        doTestFiveRunsRethrottle(100, 0, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_1000() throws Exception {\n+        doTestFiveRunsRethrottle(100, 1000, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 950L));\n+    }\n+\n+    public void testFiveRunsRethrottle1000_100() throws Exception {\n+        doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n+    }\n+\n+    public void doTestFiveRunsRethrottle(\n+        float requests_per_second,\n+        float requests_per_second_rethrottle,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MTM1NA==", "bodyText": "This comment initially confused me.  It might be clear to say:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // wait until the indexer reached latch await\n          \n          \n            \n                        // wait until the indexer starts waiting on the latch", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414391354", "createdAt": "2020-04-24T08:26:13Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "diffHunk": "@@ -382,22 +457,135 @@ public void testStop_WhileIndexing() throws Exception {\n             assertBusy(() -> assertTrue(isStopped.get()));\n             assertFalse(isFinished.get());\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n \n     public void testFiveRuns() throws Exception {\n+        doTestFiveRuns(-1, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled100() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(100, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsThrottled1000() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(1_000, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 950L));\n+    }\n+\n+    public void testFiveRunsThrottled18000() throws Exception {\n+        // expect throttling to not kick in due to min wait time\n+        doTestFiveRuns(18_000, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled1000000() throws Exception {\n+        // request per seconds is set high, so throttling does not kick in\n+        doTestFiveRuns(1_000_000, Collections.emptyList());\n+    }\n+\n+    public void doTestFiveRuns(float requests_per_second, Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n-        final ExecutorService executor = Executors.newFixedThreadPool(1);\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n         try {\n-            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (executor, state, 2);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                null);\n             indexer.start();\n             assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n             assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n             assertBusy(() -> assertTrue(isFinished.get()));\n             indexer.assertCounters();\n+            threadPool.assertCountersAndDelay(expectedDelays);\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n+\n+    public void testFiveRunsRethrottle0_100() throws Exception {\n+        doTestFiveRunsRethrottle(-1, 100, timeValueCollectionFromMilliseconds(9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_0() throws Exception {\n+        doTestFiveRunsRethrottle(100, 0, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_1000() throws Exception {\n+        doTestFiveRunsRethrottle(100, 1000, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 950L));\n+    }\n+\n+    public void testFiveRunsRethrottle1000_100() throws Exception {\n+        doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n+    }\n+\n+    public void doTestFiveRunsRethrottle(\n+        float requests_per_second,\n+        float requests_per_second_rethrottle,\n+        Collection<TimeValue> expectedDelays\n+    ) throws Exception {\n+        AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n+\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n+        try {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                latch);\n+            indexer.start();\n+            assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n+            assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n+            // wait until the indexer reached latch await", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng==", "bodyText": "This formula implies that requestsPerSecond is really desiredDocsPerSecond.  If that's correct then requestsPerSecond seems like it will cause confusion in the future because I would assume requestsPerSecond referred to the number of searches, each of which could return many documents.\nFor example, if I saw a configuration parameter requests_per_second I might decide to set it to 2 so that I'd get a maximum of 2 search requests per second from this functionality.  But then if one of my searches returns 1000 documents then I get a 500 second wait until the next search.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414394686", "createdAt": "2020-04-24T08:31:26Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +608,43 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        currentMaximumRequestsPerSecond = getMaximumRequestsPerSecond();\n+\n+        if (scheduledNextSearch != null) {\n+            TimeValue executionDelay = calculateThrottlingDelay(\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount,\n+                lastSearchStartTimeNanos,\n+                getTimeNanos()\n+            );\n+\n+            logger.debug(\n+                \"rethrottling job [{}], wait for {} ({} {})\",\n+                getJobId(),\n+                executionDelay,\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount\n+            );\n+            scheduledNextSearch.reschedule(executionDelay);\n+        }\n+    }\n+\n+    static TimeValue calculateThrottlingDelay(float requestsPerSecond, long docCount, long startTimeNanos, long now) {\n+        if (requestsPerSecond <= 0) {\n+            return TimeValue.ZERO;\n+        }\n+        float timeToWaitNanos = (docCount / requestsPerSecond) * TimeUnit.SECONDS.toNanos(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 321}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "committedDate": "2020-04-28T18:43:33Z", "message": "implement throttling in indexer, to be used in transform"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec60e33febcbdba94e0b0d4180456eaaace62ff", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/bec60e33febcbdba94e0b0d4180456eaaace62ff", "committedDate": "2020-04-28T18:43:33Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e09c5b86856a9ac476214ae907abad36c5fc5f3", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/1e09c5b86856a9ac476214ae907abad36c5fc5f3", "committedDate": "2020-04-28T18:43:33Z", "message": "fix corner case issue when stop is called while a next search is scheduled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92293eb42ac9bda85a1d10aab2a4a5acf01d3168", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/92293eb42ac9bda85a1d10aab2a4a5acf01d3168", "committedDate": "2020-04-28T18:43:33Z", "message": "all throttling members should be volatile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cef664e895f2264ed50bb73c5471772badb83422", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/cef664e895f2264ed50bb73c5471772badb83422", "committedDate": "2020-04-28T18:43:33Z", "message": "check state more often and do not fire a search request in case of stopping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f6cfeca3572eb8bd9631d42e1f7648bfc35b07e", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/1f6cfeca3572eb8bd9631d42e1f7648bfc35b07e", "committedDate": "2020-04-28T18:43:33Z", "message": "expose wait time so rollup/transform can issue lightweight queries for\nthrottling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2edb4782e7dfa2d09db245dc1eeee40a5ca0f7a", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/d2edb4782e7dfa2d09db245dc1eeee40a5ca0f7a", "committedDate": "2020-04-28T18:43:33Z", "message": "fix test after stopping earlier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc401f7d14bce16d46eedf1002d46565de86cc9b", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/fc401f7d14bce16d46eedf1002d46565de86cc9b", "committedDate": "2020-04-28T18:43:33Z", "message": "improve code comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "463a597bcfbf14fff759afecd31aeaf4351c8111", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/463a597bcfbf14fff759afecd31aeaf4351c8111", "committedDate": "2020-04-28T18:43:33Z", "message": "relax test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd865be8d5a257b2523b1e298bb409c93a1ea30a", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/fd865be8d5a257b2523b1e298bb409c93a1ea30a", "committedDate": "2020-04-28T18:43:33Z", "message": "use checkState to stop job"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef4f27fcff8ab7c9cbd9b282e553e7f57b643616", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/ef4f27fcff8ab7c9cbd9b282e553e7f57b643616", "committedDate": "2020-04-28T18:43:33Z", "message": "use runOnce to workaround potential duplicate listener calls when re-throttling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54f4874b73131096aad2a3335464605ab7ae9446", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/54f4874b73131096aad2a3335464605ab7ae9446", "committedDate": "2020-04-28T18:43:33Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c1e6835ff3bf7811940de852d1683acdde62caf", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c1e6835ff3bf7811940de852d1683acdde62caf", "committedDate": "2020-04-28T18:43:33Z", "message": "formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70cd6fc0fdd76953133f76176b8136704b0a93b2", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/70cd6fc0fdd76953133f76176b8136704b0a93b2", "committedDate": "2020-04-28T18:43:33Z", "message": "get maximumRequestsPerSecond via a getter instead of requiring a constructor\nargument"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bb62e5ffd0ebcf7495b65b0e884497fd4aa19a1", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/7bb62e5ffd0ebcf7495b65b0e884497fd4aa19a1", "committedDate": "2020-04-28T18:43:33Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/20125a3f3a6ae46edc0434645462920f7e35308b", "committedDate": "2020-04-28T19:19:22Z", "message": "renames requests_per_second to docs_per_second"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b7128824608f203c13b5c65532869c1c34b5dc2d", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/b7128824608f203c13b5c65532869c1c34b5dc2d", "committedDate": "2020-04-24T09:08:31Z", "message": "address review comments"}, "afterCommit": {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/20125a3f3a6ae46edc0434645462920f7e35308b", "committedDate": "2020-04-28T19:19:22Z", "message": "renames requests_per_second to docs_per_second"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNzk5Mjgw", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-402799280", "createdAt": "2020-04-29T15:45:45Z", "commit": {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODE0MjI4", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-402814228", "createdAt": "2020-04-29T16:01:55Z", "commit": {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODE0NDI5", "url": "https://github.com/elastic/elasticsearch/pull/55011#pullrequestreview-402814429", "createdAt": "2020-04-29T16:02:09Z", "commit": {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3648, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}