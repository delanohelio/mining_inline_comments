{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTExMzIw", "number": 51368, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1MToxOFrODaRpnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozODo0MVrODa5lMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODc4NzUxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1MToxOFrOFhI8Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDo1NzoyNlrOFiFmcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mzg0Mg==", "bodyText": "essential change in this file, called on line 176", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r370293842", "createdAt": "2020-01-23T18:51:18Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NzY2NQ==", "bodyText": "\ud83d\udc4d thanks for differentiating the code changes from the formatting changes", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371287665", "createdAt": "2020-01-27T14:57:26Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mzg0Mg=="}, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTMyOTc4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozODo0MVrOFiE6uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNTo0Nzo0MlrOFiHgpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjQ3NQ==", "bodyText": "An empty string would also return -1. Do you mean disallow strings containing a single '.' that is at the beginning? Wouldn't that be an error case anyway?\nI ran a quick check in jshell:\njshell> \"\".lastIndexOf('.')\n$3 ==> -1", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371276475", "createdAt": "2020-01-27T14:38:41Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {\n+        Map<String, String> additionalMappings = new HashMap<>();\n+        fieldMappings.keySet().stream().filter(key -> key.contains(\".\")).forEach(key -> {\n+            int pos;\n+            String objectKey = key;\n+            // lastIndexOf returns -1 on mismatch, but to disallow empty strings check for > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxODk0OQ==", "bodyText": "yes, when I worked on this PR, I discovered that you could create fields with '.' at start or end, which did not work properly (e.g. bulk indexing errors). I fixed it in #51369.\nSo, you are right: this code is \"defense in depth\".", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371318949", "createdAt": "2020-01-27T15:47:42Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {\n+        Map<String, String> additionalMappings = new HashMap<>();\n+        fieldMappings.keySet().stream().filter(key -> key.contains(\".\")).forEach(key -> {\n+            int pos;\n+            String objectKey = key;\n+            // lastIndexOf returns -1 on mismatch, but to disallow empty strings check for > 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjQ3NQ=="}, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 207}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4472, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}