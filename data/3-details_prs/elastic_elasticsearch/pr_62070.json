{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNTY3OTY5", "number": 62070, "title": "Optimize Snapshot Shard Status Update Handling", "bodyText": "Avoiding a number of noop updates that were observed to cause trouble (as in needless noop CS publishing) which can become an issue when working with a large number of concurrent snapshot operations.\nAlso this sets up some simplifications made in the clone snapshot branch.", "createdAt": "2020-09-07T17:35:14Z", "url": "https://github.com/elastic/elasticsearch/pull/62070", "merged": true, "mergeCommit": {"oid": "643925d910fb47cd2cc364400b08ce1d79c74d25"}, "closed": true, "closedAt": "2020-09-10T12:38:17Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdGmfB8AH2gAyNDgxNTY3OTY5OmY4Yzg2NjU2NmU3MDEyZGI1OWUxOGM5Mjk4YzQ2ZWZmZWNhMTNkZTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHf_HVAFqTQ4NTg3ODAwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f8c866566e7012db59e18c9298c46effeca13de6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f8c866566e7012db59e18c9298c46effeca13de6", "committedDate": "2020-09-07T17:31:04Z", "message": "Optimize Snapshot Shard Status Update Handling\n\nAvoiding a number of noop updates that were observed to cause trouble (as in needless CS updates) in production."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c560fff6a67ee5d596566cef0c0816daa000b23", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0c560fff6a67ee5d596566cef0c0816daa000b23", "committedDate": "2020-09-07T17:42:53Z", "message": "faster"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODUyMDU0", "url": "https://github.com/elastic/elasticsearch/pull/62070#pullrequestreview-483852054", "createdAt": "2020-09-08T07:10:47Z", "commit": {"oid": "0c560fff6a67ee5d596566cef0c0816daa000b23"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxMDo0N1rOHOPnhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxMDo0N1rOHOPnhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5Nzk5MA==", "bodyText": "changedCount++;?", "url": "https://github.com/elastic/elasticsearch/pull/62070#discussion_r484697990", "createdAt": "2020-09-08T07:10:47Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1887,55 +1887,67 @@ public boolean assertAllListenersResolved() {\n                         execute(ClusterState currentState, List<UpdateIndexShardSnapshotStatusRequest> tasks) {\n             int changedCount = 0;\n             final List<SnapshotsInProgress.Entry> entries = new ArrayList<>();\n-            final Map<String, Set<ShardId>> reusedShardIdsByRepo = new HashMap<>();\n+            final List<UpdateIndexShardSnapshotStatusRequest> unconsumedTasks = new ArrayList<>(tasks);\n             for (SnapshotsInProgress.Entry entry : currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n-                ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder();\n-                boolean updated = false;\n-\n-                for (UpdateIndexShardSnapshotStatusRequest updateSnapshotState : tasks) {\n+                if (entry.state().completed()) {\n+                    entries.add(entry);\n+                    continue;\n+                }\n+                ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = null;\n+                for (Iterator<UpdateIndexShardSnapshotStatusRequest> iterator = unconsumedTasks.iterator(); iterator.hasNext(); ) {\n+                    final UpdateIndexShardSnapshotStatusRequest updateSnapshotState = iterator.next();\n+                    final Snapshot updatedSnapshot = updateSnapshotState.snapshot();\n+                    final String updatedRepository = updatedSnapshot.getRepository();\n+                    if (entry.repository().equals(updatedRepository) == false) {\n+                        continue;\n+                    }\n                     final ShardId finishedShardId = updateSnapshotState.shardId();\n-                    if (entry.snapshot().equals(updateSnapshotState.snapshot())) {\n-                        logger.trace(\"[{}] Updating shard [{}] with status [{}]\", updateSnapshotState.snapshot(),\n+                    if (entry.snapshot().getSnapshotId().equals(updatedSnapshot.getSnapshotId())) {\n+                        final ShardSnapshotStatus existing = entry.shards().get(finishedShardId);\n+                        if (existing == null) {\n+                            logger.warn(\"Received shard snapshot status update [{}] but this shard is not tracked in [{}]\",\n+                                    updateSnapshotState, entry);\n+                            assert false : \"This should never happen, data nodes should only send updates for expected shards\";\n+                            continue;\n+                        }\n+                        if (existing.state().completed()) {\n+                            // No point in doing noop updates that might happen if data nodes resend shard status after a disconnect\n+                            continue;\n+                        }\n+                        logger.trace(\"[{}] Updating shard [{}] with status [{}]\", updatedSnapshot,\n                                 finishedShardId, updateSnapshotState.status().state());\n-                        if (updated == false) {\n-                            shards.putAll(entry.shards());\n-                            updated = true;\n+                        if (shards == null) {\n+                            shards = ImmutableOpenMap.builder(entry.shards());\n                         }\n                         shards.put(finishedShardId, updateSnapshotState.status());\n                         changedCount++;\n                     } else {\n-                        final String updatedRepository = updateSnapshotState.snapshot().getRepository();\n-                        final Set<ShardId> reusedShardIds = reusedShardIdsByRepo.computeIfAbsent(updatedRepository, k -> new HashSet<>());\n-                        if (entry.state().completed() == false && entry.repository().equals(updatedRepository)\n-                                && reusedShardIds.contains(finishedShardId) == false) {\n-                            final ShardSnapshotStatus existingStatus = entry.shards().get(finishedShardId);\n-                            if (existingStatus == null || existingStatus.state() != ShardState.QUEUED) {\n-                                continue;\n-                            }\n-                            if (updated == false) {\n-                                shards.putAll(entry.shards());\n-                                updated = true;\n-                            }\n-                            final ShardSnapshotStatus finishedStatus = updateSnapshotState.status();\n-                            logger.trace(\"Starting [{}] on [{}] with generation [{}]\", finishedShardId,\n-                                    finishedStatus.nodeId(), finishedStatus.generation());\n-                            shards.put(finishedShardId, new ShardSnapshotStatus(finishedStatus.nodeId(), finishedStatus.generation()));\n-                            reusedShardIds.add(finishedShardId);\n+                        final ShardSnapshotStatus existingStatus = entry.shards().get(finishedShardId);\n+                        if (existingStatus == null || existingStatus.state() != ShardState.QUEUED) {\n+                            continue;\n+                        }\n+                        if (shards == null) {\n+                            shards = ImmutableOpenMap.builder(entry.shards());\n                         }\n+                        final ShardSnapshotStatus finishedStatus = updateSnapshotState.status();\n+                        logger.trace(\"Starting [{}] on [{}] with generation [{}]\", finishedShardId,\n+                                finishedStatus.nodeId(), finishedStatus.generation());\n+                        shards.put(finishedShardId, new ShardSnapshotStatus(finishedStatus.nodeId(), finishedStatus.generation()));\n+                        iterator.remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c560fff6a67ee5d596566cef0c0816daa000b23"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc4239a8b7d51b90bb848ba0ae39f2275a3e2c66", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bc4239a8b7d51b90bb848ba0ae39f2275a3e2c66", "committedDate": "2020-09-08T08:11:12Z", "message": "Merge remote-tracking branch 'elastic/master' into further-optimize-snapshot-shard-update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d4918256ed5132d28f5654ce36fe008e7b00d14", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d4918256ed5132d28f5654ce36fe008e7b00d14", "committedDate": "2020-09-08T09:04:11Z", "message": "Merge remote-tracking branch 'elastic/master' into further-optimize-snapshot-shard-update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c05dc11c8a626f625d7833a58ea5194368aa12b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5c05dc11c8a626f625d7833a58ea5194368aa12b", "committedDate": "2020-09-08T19:01:33Z", "message": "reused state updates counter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb14918fc193edaefb8e302915fdcb6c65fd7bea", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/eb14918fc193edaefb8e302915fdcb6c65fd7bea", "committedDate": "2020-09-08T19:13:09Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdcc74153810282319afa1dde23b8310a63e61c1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/fdcc74153810282319afa1dde23b8310a63e61c1", "committedDate": "2020-09-08T19:37:59Z", "message": "Merge remote-tracking branch 'elastic/master' into further-optimize-snapshot-shard-update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1ODc4MDA0", "url": "https://github.com/elastic/elasticsearch/pull/62070#pullrequestreview-485878004", "createdAt": "2020-09-10T12:30:42Z", "commit": {"oid": "fdcc74153810282319afa1dde23b8310a63e61c1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4733, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}