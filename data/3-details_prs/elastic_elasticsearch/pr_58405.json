{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MzY2MzQ1", "number": 58405, "title": "Remove anonymous PublicationContext implementation", "bodyText": "Today the PublicationContext interface has a single anonymous\nimplementation, and PublicationTransportHandler has various methods\nthat take the variables that this anonymous class captures. This commit\nrefactors this into a proper class with proper fields and moves the\nrelevant methods onto this class.", "createdAt": "2020-06-23T07:08:29Z", "url": "https://github.com/elastic/elasticsearch/pull/58405", "merged": true, "mergeCommit": {"oid": "b8db2da09635df481b3b71f44d5b583db8d5502b"}, "closed": true, "closedAt": "2020-06-23T09:13:28Z", "author": {"login": "DaveCTurner"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuABBhgH2gAyNDM4MzY2MzQ1OjJmMzNhZmJlYmU3YmI3NzRhZmJjYTQwY2M5MTQ4NWQxNWNhOTE5N2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuBI0QAH2gAyNDM4MzY2MzQ1Ojc4N2E1MmRmYTQ0ZDk1MDI4MWIzN2UyZmE4YTE0Y2JmMTMxYzFkYzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2f33afbebe7bb774afbca40cc91485d15ca9197f", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/2f33afbebe7bb774afbca40cc91485d15ca9197f", "committedDate": "2020-06-23T07:07:43Z", "message": "Remove anonymous PublicationContext implementation\n\nToday the `PublicationContext` interface has a single anonymous\nimplementation, and `PublicationTransportHandler` has various methods\nthat take the variables that this anonymous class captures. This commit\nrefactors this into a proper class with proper fields and moves the\nrelevant methods onto this class."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NDk4Nzg1", "url": "https://github.com/elastic/elasticsearch/pull/58405#pullrequestreview-435498785", "createdAt": "2020-06-23T07:09:08Z", "commit": {"oid": "2f33afbebe7bb774afbca40cc91485d15ca9197f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzowOTowOFrOGncDbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzowOTozNVrOGncEPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwNzI3OA==", "bodyText": "Reworded comment", "url": "https://github.com/elastic/elasticsearch/pull/58405#discussion_r444007278", "createdAt": "2020-06-23T07:09:08Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -406,4 +198,216 @@ private PublishWithJoinResponse acceptState(ClusterState incomingState) {\n         }\n         return handlePublishRequest.apply(new PublishRequest(incomingState));\n     }\n+\n+    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+        final PublicationContext publicationContext = new PublicationContext(clusterChangedEvent);\n+\n+        // Build the serializations we expect to need now, early in the process, so that an error during serialization fails the publication\n+        // straight away. This isn't watertight since we send diffs on a best-effort basis and may fall back to sending a full state (and\n+        // therefore serializing it) if the diff-based publication fails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f33afbebe7bb774afbca40cc91485d15ca9197f"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwNzQyOA==", "bodyText": "Added a TRACE log to record the size of the state here.", "url": "https://github.com/elastic/elasticsearch/pull/58405#discussion_r444007428", "createdAt": "2020-06-23T07:09:26Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -406,4 +198,216 @@ private PublishWithJoinResponse acceptState(ClusterState incomingState) {\n         }\n         return handlePublishRequest.apply(new PublishRequest(incomingState));\n     }\n+\n+    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+        final PublicationContext publicationContext = new PublicationContext(clusterChangedEvent);\n+\n+        // Build the serializations we expect to need now, early in the process, so that an error during serialization fails the publication\n+        // straight away. This isn't watertight since we send diffs on a best-effort basis and may fall back to sending a full state (and\n+        // therefore serializing it) if the diff-based publication fails.\n+        publicationContext.buildDiffAndSerializeStates();\n+        return publicationContext;\n+    }\n+\n+    private static BytesReference serializeFullClusterState(ClusterState clusterState, Version nodeVersion) throws IOException {\n+        final BytesStreamOutput bStream = new BytesStreamOutput();\n+        try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {\n+            stream.setVersion(nodeVersion);\n+            stream.writeBoolean(true);\n+            clusterState.writeTo(stream);\n+        }\n+        final BytesReference serializedState = bStream.bytes();\n+        logger.trace(\"serialized full cluster state version [{}] for node version [{}] with size [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f33afbebe7bb774afbca40cc91485d15ca9197f"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwNzQ4NQ==", "bodyText": "Added a TRACE log to record the size of the state here.", "url": "https://github.com/elastic/elasticsearch/pull/58405#discussion_r444007485", "createdAt": "2020-06-23T07:09:35Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -406,4 +198,216 @@ private PublishWithJoinResponse acceptState(ClusterState incomingState) {\n         }\n         return handlePublishRequest.apply(new PublishRequest(incomingState));\n     }\n+\n+    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+        final PublicationContext publicationContext = new PublicationContext(clusterChangedEvent);\n+\n+        // Build the serializations we expect to need now, early in the process, so that an error during serialization fails the publication\n+        // straight away. This isn't watertight since we send diffs on a best-effort basis and may fall back to sending a full state (and\n+        // therefore serializing it) if the diff-based publication fails.\n+        publicationContext.buildDiffAndSerializeStates();\n+        return publicationContext;\n+    }\n+\n+    private static BytesReference serializeFullClusterState(ClusterState clusterState, Version nodeVersion) throws IOException {\n+        final BytesStreamOutput bStream = new BytesStreamOutput();\n+        try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {\n+            stream.setVersion(nodeVersion);\n+            stream.writeBoolean(true);\n+            clusterState.writeTo(stream);\n+        }\n+        final BytesReference serializedState = bStream.bytes();\n+        logger.trace(\"serialized full cluster state version [{}] for node version [{}] with size [{}]\",\n+            clusterState.version(), nodeVersion, serializedState.length());\n+        return serializedState;\n+    }\n+\n+    private static BytesReference serializeDiffClusterState(Diff<ClusterState> diff, Version nodeVersion) throws IOException {\n+        final BytesStreamOutput bStream = new BytesStreamOutput();\n+        try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {\n+            stream.setVersion(nodeVersion);\n+            stream.writeBoolean(false);\n+            diff.writeTo(stream);\n+        }\n+        return bStream.bytes();\n+    }\n+\n+    /**\n+     * Publishing a cluster state typically involves sending the same cluster state (or diff) to every node, so the work of diffing,\n+     * serializing, and compressing the state can be done once and the results shared across publish requests. The\n+     * {@code PublicationContext} implements this sharing.\n+     */\n+    public class PublicationContext {\n+\n+        private final DiscoveryNodes discoveryNodes;\n+        private final ClusterState newState;\n+        private final ClusterState previousState;\n+        private final boolean sendFullVersion;\n+        private final Map<Version, BytesReference> serializedStates = new HashMap<>();\n+        private final Map<Version, BytesReference> serializedDiffs = new HashMap<>();\n+\n+        PublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+            discoveryNodes = clusterChangedEvent.state().nodes();\n+            newState = clusterChangedEvent.state();\n+            previousState = clusterChangedEvent.previousState();\n+            sendFullVersion = previousState.getBlocks().disableStatePersistence();\n+        }\n+\n+        void buildDiffAndSerializeStates() {\n+            Diff<ClusterState> diff = null;\n+            for (DiscoveryNode node : discoveryNodes) {\n+                try {\n+                    if (sendFullVersion || previousState.nodes().nodeExists(node) == false) {\n+                        if (serializedStates.containsKey(node.getVersion()) == false) {\n+                            serializedStates.put(node.getVersion(), serializeFullClusterState(newState, node.getVersion()));\n+                        }\n+                    } else {\n+                        // will send a diff\n+                        if (diff == null) {\n+                            diff = newState.diff(previousState);\n+                        }\n+                        if (serializedDiffs.containsKey(node.getVersion()) == false) {\n+                            final BytesReference serializedDiff = serializeDiffClusterState(diff, node.getVersion());\n+                            serializedDiffs.put(node.getVersion(), serializedDiff);\n+                            logger.trace(\"serialized cluster state diff for version [{}] in for node version [{}] with size [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f33afbebe7bb774afbca40cc91485d15ca9197f"}, "originalPosition": 290}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdf58064dbe9d621af736ac72f08976f7c316319", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/cdf58064dbe9d621af736ac72f08976f7c316319", "committedDate": "2020-06-23T07:39:50Z", "message": "Merge branch 'master' into 2020-06-22-tidy-PublicationTransportHandler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTQ4MjYx", "url": "https://github.com/elastic/elasticsearch/pull/58405#pullrequestreview-435548261", "createdAt": "2020-06-23T08:17:54Z", "commit": {"oid": "cdf58064dbe9d621af736ac72f08976f7c316319"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "787a52dfa44d950281b37e2fa8a14cbf131c1dc0", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/787a52dfa44d950281b37e2fa8a14cbf131c1dc0", "committedDate": "2020-06-23T08:26:08Z", "message": "final"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 332, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}