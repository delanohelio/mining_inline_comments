{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Mjc0NzM5", "number": 60852, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjowMjowN1rOEWAd1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjo1Mzo0OVrOEXTFqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTExNzY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoTileGridAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjowMjowN1rOG9Ft6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjo0NzozMFrOG_AgAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ==", "bodyText": "I think the key might belong in the Factory, at least while we still have them.", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r466709995", "createdAt": "2020-08-06T22:02:07Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoTileGridAggregationBuilder.java", "diffHunk": "@@ -19,24 +19,29 @@\n \n package org.elasticsearch.search.aggregations.bucket.geogrid;\n \n-import java.io.IOException;\n-import java.util.Map;\n-\n import org.elasticsearch.common.geo.GeoBoundingBox;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.xcontent.ObjectParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.metrics.GeoGridAggregatorSupplier;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceRegistry;\n \n+import java.io.IOException;\n+import java.util.Map;\n+\n public class GeoTileGridAggregationBuilder extends GeoGridAggregationBuilder {\n     public static final String NAME = \"geotile_grid\";\n     public static final int DEFAULT_PRECISION = 7;\n     private static final int DEFAULT_MAX_NUM_CELLS = 10000;\n+    public static final ValuesSourceRegistry.RegistryKey<GeoGridAggregatorSupplier> REGISTRY_KEY = new ValuesSourceRegistry.RegistryKey<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5d8046692fc2f63d9f2ecca392fd115841d926"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0MjUyMQ==", "bodyText": "Actually, I was thinking about moving all of registration into the builder...", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468142521", "createdAt": "2020-08-10T19:48:50Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoTileGridAggregationBuilder.java", "diffHunk": "@@ -19,24 +19,29 @@\n \n package org.elasticsearch.search.aggregations.bucket.geogrid;\n \n-import java.io.IOException;\n-import java.util.Map;\n-\n import org.elasticsearch.common.geo.GeoBoundingBox;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.xcontent.ObjectParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.metrics.GeoGridAggregatorSupplier;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceRegistry;\n \n+import java.io.IOException;\n+import java.util.Map;\n+\n public class GeoTileGridAggregationBuilder extends GeoGridAggregationBuilder {\n     public static final String NAME = \"geotile_grid\";\n     public static final int DEFAULT_PRECISION = 7;\n     private static final int DEFAULT_MAX_NUM_CELLS = 10000;\n+    public static final ValuesSourceRegistry.RegistryKey<GeoGridAggregatorSupplier> REGISTRY_KEY = new ValuesSourceRegistry.RegistryKey<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ=="}, "originalCommit": {"oid": "bc5d8046692fc2f63d9f2ecca392fd115841d926"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxODU1MQ==", "bodyText": "I ended up needing access to the registry key in ValuesSourceAggregationBuilder, and had to add an override function to get at it from there.  Given that, I think keeping the key on the builder makes more sense.", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468718551", "createdAt": "2020-08-11T16:42:20Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoTileGridAggregationBuilder.java", "diffHunk": "@@ -19,24 +19,29 @@\n \n package org.elasticsearch.search.aggregations.bucket.geogrid;\n \n-import java.io.IOException;\n-import java.util.Map;\n-\n import org.elasticsearch.common.geo.GeoBoundingBox;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.xcontent.ObjectParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.metrics.GeoGridAggregatorSupplier;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceRegistry;\n \n+import java.io.IOException;\n+import java.util.Map;\n+\n public class GeoTileGridAggregationBuilder extends GeoGridAggregationBuilder {\n     public static final String NAME = \"geotile_grid\";\n     public static final int DEFAULT_PRECISION = 7;\n     private static final int DEFAULT_MAX_NUM_CELLS = 10000;\n+    public static final ValuesSourceRegistry.RegistryKey<GeoGridAggregatorSupplier> REGISTRY_KEY = new ValuesSourceRegistry.RegistryKey<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ=="}, "originalCommit": {"oid": "bc5d8046692fc2f63d9f2ecca392fd115841d926"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyMTY2NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468721665", "createdAt": "2020-08-11T16:47:30Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoTileGridAggregationBuilder.java", "diffHunk": "@@ -19,24 +19,29 @@\n \n package org.elasticsearch.search.aggregations.bucket.geogrid;\n \n-import java.io.IOException;\n-import java.util.Map;\n-\n import org.elasticsearch.common.geo.GeoBoundingBox;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.xcontent.ObjectParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.metrics.GeoGridAggregatorSupplier;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceRegistry;\n \n+import java.io.IOException;\n+import java.util.Map;\n+\n public class GeoTileGridAggregationBuilder extends GeoGridAggregationBuilder {\n     public static final String NAME = \"geotile_grid\";\n     public static final int DEFAULT_PRECISION = 7;\n     private static final int DEFAULT_MAX_NUM_CELLS = 10000;\n+    public static final ValuesSourceRegistry.RegistryKey<GeoGridAggregatorSupplier> REGISTRY_KEY = new ValuesSourceRegistry.RegistryKey<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ=="}, "originalCommit": {"oid": "bc5d8046692fc2f63d9f2ecca392fd115841d926"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNTEyMDQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjowMzozMFrOG9Fvyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjowMzozMFrOG9Fvyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMDQ3NA==", "bodyText": "Do you think we need the marker interface? Like, maybe the <T> below can just be T?", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r466710474", "createdAt": "2020-08-06T22:03:30Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -31,18 +31,34 @@\n import java.util.Objects;\n \n /**\n- * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link AggregatorSupplier}s.  DO NOT directly\n+ * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link ComponentSupplier}s.  DO NOT directly\n  * instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in the case\n  * of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n  *\n  */\n public class ValuesSourceRegistry {\n \n-    public interface CompositeSupplier {\n+    /**\n+     * {@link ComponentSupplier} serves as a marker for what the {@link ValuesSourceRegistry} holds to construct aggregator instances.\n+     * The aggregators for each aggregation should all share a signature, and that signature should be used to create an ComponentSupplier\n+     * for that aggregation.  Alternatively, if an existing supplier has a matching signature, please re-use that.\n+     *\n+     * In many cases, this can be a simple wrapper over the aggregator constructor.  If that is sufficient, please just use a reference to\n+     * the constructor.  Implementing a supplier (typically as a lambda) should only be necessary when factors besides the\n+     * {@link ValuesSourceType} are necessary for selecting the correct aggregator implementation.  This happens in terms for example where\n+     * we make decisions based on the availability of global ordinals.\n+     *\n+     * The suppliers are responsible for any casting of {@link ValuesSource} that needs to happen.  They must accept a base\n+     * {@link ValuesSource} * instance.  The suppliers may perform additional logic to configure the aggregator as needed, such as in\n+     * {@link org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorFactory} deciding the execution mode.\n+     *\n+     * There is ongoing work to  normalize aggregator constructor signatures, and thus reduce the number of ComponentSupplier interfaces.\n+     */\n+    public interface ComponentSupplier {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5d8046692fc2f63d9f2ecca392fd115841d926"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODYyMzI0OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjo0NTozMFrOG_AbIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjo0NTozMFrOG_AbIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyMDQxNw==", "bodyText": "Probably worth a comment about why this is ok.", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468720417", "createdAt": "2020-08-11T16:45:30Z", "author": {"login": "nik9000"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java", "diffHunk": "@@ -79,6 +80,11 @@ public String getType() {\n         return NAME;\n     }\n \n+    @Override\n+    protected ValuesSourceRegistry.RegistryKey<?> getRegistryKey() {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7d77719c0ffdb902c6694804d5cd4d551cc6e29"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODY1NDQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjo1Mzo0OVrOG_AvSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODozNzozNlrOG_EX9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyNTU3Ng==", "bodyText": "I wonder if the factory should be registering the usage. Or if the builder should resolve the registry entry first and pass it down to the factory inside innerBuild.....", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468725576", "createdAt": "2020-08-11T16:53:49Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregationBuilder.java", "diffHunk": "@@ -337,15 +337,21 @@ public ZoneId timeZone() {\n     protected final ValuesSourceAggregatorFactory doBuild(QueryShardContext queryShardContext, AggregatorFactory parent,\n                                                           Builder subFactoriesBuilder) throws IOException {\n         ValuesSourceConfig config = resolveConfig(queryShardContext);\n-        if (queryShardContext.getValuesSourceRegistry().isRegistered(getType())) {\n-            // Only test if the values source type is valid if the aggregation uses the registry\n-            AggregatorSupplier supplier = queryShardContext.getValuesSourceRegistry().getAggregator(config, getType());\n+        if (queryShardContext.getValuesSourceRegistry().isRegistered(getRegistryKey())) {\n+            /*\n+            if the aggregation uses the values source registry, test if the resolved values source type is compatible with this aggregation.\n+            This call will throw if the mapping isn't registered, which is what we want.  Note that we need to throw from here because\n+            AbstractAggregationBuilder#build, which called this, will attempt to register the agg usage next, and if the usage is invalid\n+            that will fail with a weird error.\n+             */\n+            queryShardContext.getValuesSourceRegistry().getAggregator(getRegistryKey(), config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aea16019dcd68a925fbbbe08eec263df3a37b41"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NTE0MA==", "bodyText": "Honestly, I'm not really sure why we don't build the aggregator directly here.  We have all the shard specific information at this point, and we've already parsed everything.  But it would be a huge change to do that, and I'm not ready to take it on today (or any time soon).  But longer term, I think it would make sense for the builder to just create an aggregator directly and not muck about with the factory layer.  In that spirit, I don't want to push more responsibility into the factory.\nAlso, this is a 1000+ line delta, I don't want to touch anything I don't strictly have to.", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468785140", "createdAt": "2020-08-11T18:37:36Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregationBuilder.java", "diffHunk": "@@ -337,15 +337,21 @@ public ZoneId timeZone() {\n     protected final ValuesSourceAggregatorFactory doBuild(QueryShardContext queryShardContext, AggregatorFactory parent,\n                                                           Builder subFactoriesBuilder) throws IOException {\n         ValuesSourceConfig config = resolveConfig(queryShardContext);\n-        if (queryShardContext.getValuesSourceRegistry().isRegistered(getType())) {\n-            // Only test if the values source type is valid if the aggregation uses the registry\n-            AggregatorSupplier supplier = queryShardContext.getValuesSourceRegistry().getAggregator(config, getType());\n+        if (queryShardContext.getValuesSourceRegistry().isRegistered(getRegistryKey())) {\n+            /*\n+            if the aggregation uses the values source registry, test if the resolved values source type is compatible with this aggregation.\n+            This call will throw if the mapping isn't registered, which is what we want.  Note that we need to throw from here because\n+            AbstractAggregationBuilder#build, which called this, will attempt to register the agg usage next, and if the usage is invalid\n+            that will fail with a weird error.\n+             */\n+            queryShardContext.getValuesSourceRegistry().getAggregator(getRegistryKey(), config);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyNTU3Ng=="}, "originalCommit": {"oid": "6aea16019dcd68a925fbbbe08eec263df3a37b41"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2599, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}