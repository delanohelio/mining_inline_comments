{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxMjM1MzI0", "number": 59797, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1MjozN1rOEQtjnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxMToyMFrOERikmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTU5MDcxOnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/SemanticHeaderPhase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1MjozN1rOG1BFwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1MjozN1rOG1BFwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NTU2OA==", "bodyText": "Where did this go?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458245568", "createdAt": "2020-07-21T16:52:37Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/SemanticHeaderPhase.java", "diffHunk": "@@ -1,88 +0,0 @@\n-/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTYwMjc0OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1NTozOFrOG1BNTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzozNzo1OFrOG1CyDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NzUwMw==", "bodyText": "Why the rearrangement?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458247503", "createdAt": "2020-07-21T16:55:38Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java", "diffHunk": "@@ -57,16 +57,16 @@ public Location getLocation() {\n     }\n \n     /**\n-     * Callback to visit a user tree node.\n+     * Create an error with location information pointing to this node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3MzI5Mw==", "bodyText": "Merge issue.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458273293", "createdAt": "2020-07-21T17:37:58Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java", "diffHunk": "@@ -57,16 +57,16 @@ public Location getLocation() {\n     }\n \n     /**\n-     * Callback to visit a user tree node.\n+     * Create an error with location information pointing to this node.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NzUwMw=="}, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTYyNTY0OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzowMToyOFrOG1BbkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDozNToxOFrOG2NfNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI1MTE1Mw==", "bodyText": "Pick a better way to wrap args.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458251153", "createdAt": "2020-07-21T17:01:28Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java", "diffHunk": "@@ -72,108 +73,113 @@ public Operation getOperation() {\n         return userTreeVisitor.visitBinary(this, input);\n     }\n \n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n+    public static void visitDefaultSemanticAnalysis(\n+            DefaultSemanticAnalysisPhase visitor, EBinary userBinaryNode, SemanticScope semanticScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NzI2OA==", "bodyText": "This is no longer relevant.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459497268", "createdAt": "2020-07-23T14:35:18Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java", "diffHunk": "@@ -72,108 +73,113 @@ public Operation getOperation() {\n         return userTreeVisitor.visitBinary(this, input);\n     }\n \n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n+    public static void visitDefaultSemanticAnalysis(\n+            DefaultSemanticAnalysisPhase visitor, EBinary userBinaryNode, SemanticScope semanticScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI1MTE1Mw=="}, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Nzg0MDk5OnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToyMToxMlrOG2PlQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTozNjowNVrOG2QOYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMTU4Ng==", "bodyText": "Are the changes to this file due to intellij?  What happens if you regen?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459531586", "createdAt": "2020-07-23T15:21:12Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java", "diffHunk": "@@ -1,13 +1,17 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.Lexer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0MjExMg==", "bodyText": "Picked up in optimize imports. I'll fix this.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459542112", "createdAt": "2020-07-23T15:36:05Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java", "diffHunk": "@@ -1,13 +1,17 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.Lexer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMTU4Ng=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Nzg0NDYxOnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToyMTo1OFrOG2Pngg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTozNjowN1rOG2QOdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMjE2Mg==", "bodyText": "Similar question about generated vs intellij", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459532162", "createdAt": "2020-07-23T15:21:58Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java", "diffHunk": "@@ -1,13 +1,25 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.atn.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0MjEzNQ==", "bodyText": "Picked up in optimize imports. I'll fix this.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459542135", "createdAt": "2020-07-23T15:36:07Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java", "diffHunk": "@@ -1,13 +1,25 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.atn.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMjE2Mg=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzkyNTUwOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTo0MDoyM1rOG2QZtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo1MTozMlrOG2VSmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTAxNQ==", "bodyText": "Provide a one sentence explanation for each public method.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459545015", "createdAt": "2020-07-23T15:40:23Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyNTExMw==", "bodyText": "Will do. This is going to take a bit of time.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459625113", "createdAt": "2020-07-23T17:51:32Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTAxNQ=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODA3MTcyOnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNTo1MlrOG2R1eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0Nzo0N1rOG2VKYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODUwNA==", "bodyText": "I like the new use of Negate condition in DefaultSemanticAnalysisPhase.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459568504", "createdAt": "2020-07-23T16:15:52Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java", "diffHunk": "@@ -55,48 +50,4 @@ public String getDecimal() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         // terminal node; no children\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        analyze(semanticScope, false);\n-    }\n-\n-    void analyze(SemanticScope semanticScope, boolean negate) {\n-        if (semanticScope.getCondition(this, Write.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMzAwOQ==", "bodyText": ":)", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459623009", "createdAt": "2020-07-23T17:47:47Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java", "diffHunk": "@@ -55,48 +50,4 @@ public String getDecimal() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         // terminal node; no children\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        analyze(semanticScope, false);\n-    }\n-\n-    void analyze(SemanticScope semanticScope, boolean negate) {\n-        if (semanticScope.getCondition(this, Write.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODUwNA=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODA5MDI5OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoyMDo1MFrOG2SBkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo1MDoxNlrOG2VP_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTYwMg==", "bodyText": "Consider moving this definition closer to it's use.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459571602", "createdAt": "2020-07-23T16:20:50Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));\n+        }\n+\n+        for (int i = 0; i < userArgumentsSize; ++i) {\n+            AExpression userArgumentNode = userArgumentNodes.get(i);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(types[i]));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewObjNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitCallLocal(ECallLocal userCallLocalNode, SemanticScope semanticScope) {\n+        String methodName = userCallLocalNode.getMethodName();\n+        List<AExpression> userArgumentNodes = userCallLocalNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userCallLocalNode, Write.class)) {\n+            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to function call [\" + methodName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        FunctionTable.LocalFunction localFunction = null;\n+        PainlessMethod importedMethod = null;\n+        PainlessClassBinding classBinding = null;\n+        int classBindingOffset = 0;\n+        PainlessInstanceBinding instanceBinding = null;\n+\n+        Class<?> valueType;\n+\n+        localFunction = scriptScope.getFunctionTable().getFunction(methodName, userArgumentsSize);\n+\n+        // user cannot call internal functions, reset to null if an internal function is found\n+        if (localFunction != null && localFunction.isInternal()) {\n+            localFunction = null;\n+        }\n+\n+        if (localFunction == null) {\n+            importedMethod = scriptScope.getPainlessLookup().lookupImportedPainlessMethod(methodName, userArgumentsSize);\n+\n+            if (importedMethod == null) {\n+                classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize);\n+\n+                // check to see if this class binding requires an implicit this reference\n+                if (classBinding != null && classBinding.typeParameters.isEmpty() == false &&\n+                        classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                    classBinding = null;\n+                }\n+\n+                if (classBinding == null) {\n+                    // This extra check looks for a possible match where the class binding requires an implicit this\n+                    // reference.  This is a temporary solution to allow the class binding access to data from the\n+                    // base script class without need for a user to add additional arguments.  A long term solution\n+                    // will likely involve adding a class instance binding where any instance can have a class binding\n+                    // as part of its API.  However, the situation at run-time is difficult and will modifications that\n+                    // are a substantial change if even possible to do.\n+                    classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize + 1);\n+\n+                    if (classBinding != null) {\n+                        if (classBinding.typeParameters.isEmpty() == false &&\n+                                classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                            classBindingOffset = 1;\n+                        } else {\n+                            classBinding = null;\n+                        }\n+                    }\n+\n+                    if (classBinding == null) {\n+                        instanceBinding = scriptScope.getPainlessLookup().lookupPainlessInstanceBinding(methodName, userArgumentsSize);\n+\n+                        if (instanceBinding == null) {\n+                            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                                    \"Unknown call [\" + methodName + \"] with [\" + userArgumentNodes + \"] arguments.\"));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        List<Class<?>> typeParameters;\n+\n+        if (localFunction != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardLocalFunction(localFunction));\n+\n+            typeParameters = new ArrayList<>(localFunction.getTypeParameters());\n+            valueType = localFunction.getReturnType();\n+        } else if (importedMethod != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessMethod(importedMethod));\n+\n+            scriptScope.markNonDeterministic(importedMethod.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(importedMethod.typeParameters);\n+            valueType = importedMethod.returnType;\n+        } else if (classBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessClassBinding(classBinding));\n+            semanticScope.putDecoration(userCallLocalNode, new StandardConstant(classBindingOffset));\n+\n+            scriptScope.markNonDeterministic(classBinding.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(classBinding.typeParameters);\n+            valueType = classBinding.returnType;\n+        } else if (instanceBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessInstanceBinding(instanceBinding));\n+\n+            typeParameters = new ArrayList<>(instanceBinding.typeParameters);\n+            valueType = instanceBinding.returnType;\n+        } else {\n+            throw new IllegalStateException(\"Illegal tree structure.\");\n+        }\n+        // if the class binding is using an implicit this reference then the arguments counted must\n+        // be incremented by 1 as the this reference will not be part of the arguments passed into\n+        // the class binding call\n+        for (int argument = 0; argument < userArgumentsSize; ++argument) {\n+            AExpression userArgumentNode = userArgumentNodes.get(argument);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(typeParameters.get(argument + classBindingOffset)));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCallLocalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, SemanticScope semanticScope) {\n+        boolean bool = userBooleanConstantNode.getBool();\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Write.class)) {\n+            throw userBooleanConstantNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to boolean constant [\" + bool + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Read.class) == false) {\n+            throw userBooleanConstantNode.createError(\n+                    new IllegalArgumentException(\"not a statement: boolean constant [\" + bool + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userBooleanConstantNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userBooleanConstantNode, new StandardConstant(bool));\n+    }\n+\n+    @Override\n+    public void visitNumeric(ENumeric userNumericNode, SemanticScope semanticScope) {\n+        String numeric = userNumericNode.getNumeric();\n+\n+        if (semanticScope.getCondition(userNumericNode, Negate.class)) {\n+            numeric = \"-\" + numeric;\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Write.class)) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to numeric constant [\" + numeric + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Read.class) == false) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"not a statement: numeric constant [\" + numeric + \"] not used\"));\n+        }\n+\n+        int radix = userNumericNode.getRadix();\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (numeric.endsWith(\"d\") || numeric.endsWith(\"D\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Double.parseDouble(numeric.substring(0, numeric.length() - 1));\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"f\") || numeric.endsWith(\"F\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Float.parseFloat(numeric.substring(0, numeric.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"l\") || numeric.endsWith(\"L\")) {\n+            try {\n+                constant = Long.parseLong(numeric.substring(0, numeric.length() - 1), radix);\n+                valueType = long.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid long constant [\" + numeric + \"].\"));\n+            }\n+        } else {\n+            try {\n+                TargetType targetType = semanticScope.getDecoration(userNumericNode, TargetType.class);\n+                Class<?> sort = targetType == null ? int.class : targetType.getTargetType();\n+                int integer = Integer.parseInt(numeric, radix);\n+\n+                if (sort == byte.class && integer >= Byte.MIN_VALUE && integer <= Byte.MAX_VALUE) {\n+                    constant = (byte)integer;\n+                    valueType = byte.class;\n+                } else if (sort == char.class && integer >= Character.MIN_VALUE && integer <= Character.MAX_VALUE) {\n+                    constant = (char)integer;\n+                    valueType = char.class;\n+                } else if (sort == short.class && integer >= Short.MIN_VALUE && integer <= Short.MAX_VALUE) {\n+                    constant = (short)integer;\n+                    valueType = short.class;\n+                } else {\n+                    constant = integer;\n+                    valueType = int.class;\n+                }\n+            } catch (NumberFormatException exception) {\n+                try {\n+                    // Check if we can parse as a long. If so then hint that the user might prefer that.\n+                    Long.parseLong(numeric, radix);\n+                    throw userNumericNode.createError(new IllegalArgumentException(\n+                            \"Invalid int constant [\" + numeric + \"]. If you want a long constant then change it to [\" + numeric + \"L].\"));\n+                } catch (NumberFormatException longNoGood) {\n+                    // Ignored\n+                }\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid int constant [\" + numeric + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userNumericNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userNumericNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitDecimal(EDecimal userDecimalNode, SemanticScope semanticScope) {\n+        String decimal = userDecimalNode.getDecimal();\n+\n+        if (semanticScope.getCondition(userDecimalNode, Negate.class)) {\n+            decimal = \"-\" + decimal;\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Write.class)) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to decimal constant [\" + decimal + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Read.class) == false) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\"not a statement: decimal constant [\" + decimal + \"] not used\"));\n+        }\n+\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (decimal.endsWith(\"f\") || decimal.endsWith(\"F\")) {\n+            try {\n+                constant = Float.parseFloat(decimal.substring(0, decimal.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + decimal + \"].\"));\n+            }\n+        } else {\n+            String toParse = decimal;\n+            if (toParse.endsWith(\"d\") || decimal.endsWith(\"D\")) {\n+                toParse = toParse.substring(0, decimal.length() - 1);\n+            }\n+            try {\n+                constant = Double.parseDouble(toParse);\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + decimal + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userDecimalNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userDecimalNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitString(EString userStringNode, SemanticScope semanticScope) {\n+        String string = userStringNode.getString();\n+\n+        if (semanticScope.getCondition(userStringNode, Write.class)) {\n+            throw userStringNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to string constant [\" + string + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userStringNode, Read.class) == false) {\n+            throw userStringNode.createError(new IllegalArgumentException(\"not a statement: string constant [\" + string + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userStringNode, new ValueType(String.class));\n+        semanticScope.putDecoration(userStringNode, new StandardConstant(string));\n+    }\n+\n+    @Override\n+    public void visitNull(ENull userNullNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNullNode, Write.class)) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to null constant\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNullNode, Read.class) == false) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"not a statement: null constant not used\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userNullNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType != null) {\n+            if (targetType.getTargetType().isPrimitive()) {\n+                throw userNullNode.createError(new IllegalArgumentException(\n+                        \"Cannot cast null to a primitive type [\" + targetType.getTargetCanonicalTypeName() + \"].\"));\n+            }\n+\n+            valueType = targetType.getTargetType();\n+        } else {\n+            valueType = Object.class;\n+        }\n+\n+        semanticScope.putDecoration(userNullNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitRegex(ERegex userRegexNode, SemanticScope semanticScope) {\n+        String pattern = userRegexNode.getPattern();\n+        String flags = userRegexNode.getFlags();\n+\n+        if (semanticScope.getCondition(userRegexNode, Write.class)) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to regex constant [\" + pattern + \"] with flags [\" + flags + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userRegexNode, Read.class) == false) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"not a statement: regex constant [\" + pattern + \"] with flags [\" + flags + \"] not used\"));\n+        }\n+\n+        if (semanticScope.getScriptScope().getCompilerSettings().areRegexesEnabled() == false) {\n+            throw userRegexNode.createError(new IllegalStateException(\"Regexes are disabled. Set [script.painless.regex.enabled] to [true] \"\n+                    + \"in elasticsearch.yaml to allow them. Be careful though, regexes break out of Painless's protection against deep \"\n+                    + \"recursion and long loops.\"));\n+        }\n+\n+        Location location = userRegexNode.getLocation();\n+\n+        int constant = 0;\n+\n+        for (int i = 0; i < flags.length(); ++i) {\n+            char flag = flags.charAt(i);\n+\n+            switch (flag) {\n+                case 'c':\n+                    constant |= Pattern.CANON_EQ;\n+                    break;\n+                case 'i':\n+                    constant |= Pattern.CASE_INSENSITIVE;\n+                    break;\n+                case 'l':\n+                    constant |= Pattern.LITERAL;\n+                    break;\n+                case 'm':\n+                    constant |= Pattern.MULTILINE;\n+                    break;\n+                case 's':\n+                    constant |= Pattern.DOTALL;\n+                    break;\n+                case 'U':\n+                    constant |= Pattern.UNICODE_CHARACTER_CLASS;\n+                    break;\n+                case 'u':\n+                    constant |= Pattern.UNICODE_CASE;\n+                    break;\n+                case 'x':\n+                    constant |= Pattern.COMMENTS;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"invalid regular expression: unknown flag [\" + flag + \"]\");\n+            }\n+        }\n+\n+        try {\n+            Pattern.compile(pattern, constant);\n+        } catch (PatternSyntaxException pse) {\n+            throw new Location(location.getSourceName(), location.getOffset() + 1 + pse.getIndex()).createError(\n+                    new IllegalArgumentException(\"invalid regular expression: \" +\n+                            \"could not compile regex constant [\" + pattern + \"] with flags [\" + flags + \"]\", pse));\n+        }\n+\n+        semanticScope.putDecoration(userRegexNode, new ValueType(Pattern.class));\n+        semanticScope.putDecoration(userRegexNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitLambda(ELambda userLambdaNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userLambdaNode, Write.class)) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to a lambda\"));\n+        }\n+\n+        if (semanticScope.getCondition(userLambdaNode, Read.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not a statement: lambda not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userLambdaNode, TargetType.class);\n+        List<String> canonicalTypeNameParameters = userLambdaNode.getCanonicalTypeNameParameters();\n+\n+        Class<?> returnType;\n+        List<Class<?>> typeParameters;\n+        PainlessMethod interfaceMethod;\n+\n+        // inspect the target first, set interface method if we know it.\n+        if (targetType == null) {\n+            // we don't know anything: treat as def\n+            returnType = def.class;\n+            // don't infer any types, replace any null types with def\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (String type : canonicalTypeNameParameters) {\n+                if (type == null) {\n+                    typeParameters.add(def.class);\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(type);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + type + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        } else {\n+            // we know the method statically, infer return type and any unknown/def types\n+            interfaceMethod = scriptScope.getPainlessLookup().lookupFunctionalInterfacePainlessMethod(targetType.getTargetType());\n+            if (interfaceMethod == null) {\n+                throw userLambdaNode.createError(new IllegalArgumentException(\"Cannot pass lambda to \" +\n+                        \"[\" + targetType.getTargetCanonicalTypeName() + \"], not a functional interface\"));\n+            }\n+            // check arity before we manipulate parameters\n+            if (interfaceMethod.typeParameters.size() != canonicalTypeNameParameters.size())\n+                throw new IllegalArgumentException(\"Incorrect number of parameters for [\" + interfaceMethod.javaMethod.getName() +\n+                        \"] in [\" + targetType.getTargetCanonicalTypeName() + \"]\");\n+            // for method invocation, its allowed to ignore the return value\n+            if (interfaceMethod.returnType == void.class) {\n+                returnType = def.class;\n+            } else {\n+                returnType = interfaceMethod.returnType;\n+            }\n+            // replace any null types with the actual type\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (int i = 0; i < canonicalTypeNameParameters.size(); i++) {\n+                String paramType = canonicalTypeNameParameters.get(i);\n+                if (paramType == null) {\n+                    typeParameters.add(interfaceMethod.typeParameters.get(i));\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(paramType);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + paramType + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        }\n+\n+        Location location = userLambdaNode.getLocation();\n+        List<String> parameterNames = userLambdaNode.getParameterNames();\n+        LambdaScope lambdaScope = semanticScope.newLambdaScope(returnType);\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            Class<?> type = typeParameters.get(index);\n+            String parameterName = parameterNames.get(index);\n+            lambdaScope.defineVariable(location, type, parameterName, true);\n+        }\n+\n+        SBlock userBlockNode = userLambdaNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"cannot generate empty lambda\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, lambdaScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, MethodEscape.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not all paths return a value for lambda\"));\n+        }\n+\n+        // prepend capture list to lambda's arguments\n+        List<Variable> capturedVariables = new ArrayList<>(lambdaScope.getCaptures());\n+        List<Class<?>> typeParametersWithCaptures = new ArrayList<>(capturedVariables.size() + typeParameters.size());\n+        List<String> parameterNamesWithCaptures = new ArrayList<>(capturedVariables.size() + parameterNames.size());\n+\n+        for (Variable capturedVariable : capturedVariables) {\n+            typeParametersWithCaptures.add(capturedVariable.getType());\n+            parameterNamesWithCaptures.add(capturedVariable.getName());\n+        }\n+\n+        typeParametersWithCaptures.addAll(typeParameters);\n+        parameterNamesWithCaptures.addAll(parameterNames);\n+\n+        // desugar lambda body into a synthetic method\n+        String name = scriptScope.getNextSyntheticName(\"lambda\");\n+        scriptScope.getFunctionTable().addFunction(name, returnType, typeParametersWithCaptures, true, true);\n+\n+        Class<?> valueType;\n+        // setup method reference to synthetic method\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",\" + capturedVariables.size();\n+            valueType = String.class;\n+            semanticScope.putDecoration(userLambdaNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    location, targetType.getTargetType(), \"this\", name, capturedVariables.size());\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userLambdaNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userLambdaNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userLambdaNode, new MethodNameDecoration(name));\n+        semanticScope.putDecoration(userLambdaNode, new ReturnType(returnType));\n+        semanticScope.putDecoration(userLambdaNode, new TypeParameters(typeParametersWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new ParameterNames(parameterNamesWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new CapturesDecoration(capturedVariables));\n+    }\n+\n+    @Override\n+    public void visitFunctionRef(EFunctionRef userFunctionRefNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        Location location = userFunctionRefNode.getLocation();\n+        String symbol = userFunctionRefNode.getSymbol();\n+        String methodName = userFunctionRefNode.getMethodName();\n+        boolean read = semanticScope.getCondition(userFunctionRefNode, Read.class);\n+\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(symbol);\n+        TargetType targetType = semanticScope.getDecoration(userFunctionRefNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (symbol.equals(\"this\") || type != null)  {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to function reference [\" + symbol + \":\" + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: function reference [\" + symbol + \":\" + methodName + \"] not used\"));\n+            }\n+\n+            if (targetType == null) {\n+                valueType = String.class;\n+                String defReferenceEncoding = \"S\" + symbol + \".\" + methodName + \",0\";\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                        location, targetType.getTargetType(), symbol, methodName, 0);\n+                valueType = targetType.getTargetType();\n+                semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+            }\n+        } else {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to capturing function reference [\" + symbol + \":\"  + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: capturing function reference [\" + symbol + \":\"  + methodName + \"] not used\"));\n+            }\n+\n+            SemanticScope.Variable captured = semanticScope.getVariable(location, symbol);\n+            semanticScope.putDecoration(userFunctionRefNode, new CapturesDecoration(Collections.singletonList(captured)));\n+            if (targetType == null) {\n+                String defReferenceEncoding;\n+                if (captured.getType() == def.class) {\n+                    // dynamic implementation\n+                    defReferenceEncoding = \"D\" + symbol + \".\" + methodName + \",1\";\n+                } else {\n+                    // typed implementation\n+                    defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + methodName + \",1\";\n+                }\n+                valueType = String.class;\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                valueType = targetType.getTargetType();\n+                // static case\n+                if (captured.getType() != def.class) {\n+                    FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(), location,\n+                            targetType.getTargetType(), captured.getCanonicalTypeName(), methodName, 1);\n+                    semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+                }\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArrayFunctionRef(ENewArrayFunctionRef userNewArrayFunctionRefNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userNewArrayFunctionRefNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Write.class)) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"cannot assign a value to new array function reference with target type [ + \" + canonicalTypeName  + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Read.class) == false) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"not a statement: new array function reference with target type [\" + canonicalTypeName + \"] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userNewArrayFunctionRefNode, TargetType.class);\n+\n+        Class<?> valueType;\n+        Class<?> clazz = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReturnType(clazz));\n+\n+        if (clazz == null) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        String name = scriptScope.getNextSyntheticName(\"newarray\");\n+        scriptScope.getFunctionTable().addFunction(name, clazz, Collections.singletonList(int.class), true, true);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new MethodNameDecoration(name));\n+\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",0\";\n+            valueType = String.class;\n+            scriptScope.putDecoration(userNewArrayFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    userNewArrayFunctionRefNode.getLocation(), targetType.getTargetType(), \"this\", name, 0);\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitSymbol(ESymbol userSymbolNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userSymbolNode, Read.class);\n+        boolean write = semanticScope.getCondition(userSymbolNode, Write.class);\n+        String symbol = userSymbolNode.getSymbol();\n+        Class<?> staticType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(symbol);\n+\n+        if (staticType != null)  {\n+            if (write) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"] not used\"));\n+            }\n+\n+            semanticScope.putDecoration(userSymbolNode, new StaticType(staticType));\n+        } else if (semanticScope.isVariableDefined(symbol)) {\n+            if (read == false && write == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: variable [\" + symbol + \"] not used\"));\n+            }\n+\n+            Location location = userSymbolNode.getLocation();\n+            Variable variable = semanticScope.getVariable(location, symbol);\n+\n+            if (write && variable.isFinal()) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n+            }\n+\n+            Class<?> valueType = variable.getType();\n+            semanticScope.putDecoration(userSymbolNode, new ValueType(valueType));\n+        } else {\n+            semanticScope.putDecoration(userSymbolNode, new PartialCanonicalTypeName(symbol));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDot(EDot userDotNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userDotNode, Read.class);\n+        boolean write = semanticScope.getCondition(userDotNode, Write.class);\n+\n+        if (read == false && write == false) {\n+            throw userDotNode.createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String index = userDotNode.getIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 2264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyNDQ0Ng==", "bodyText": "Moved these as far down as possible.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459624446", "createdAt": "2020-07-23T17:50:16Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));\n+        }\n+\n+        for (int i = 0; i < userArgumentsSize; ++i) {\n+            AExpression userArgumentNode = userArgumentNodes.get(i);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(types[i]));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewObjNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitCallLocal(ECallLocal userCallLocalNode, SemanticScope semanticScope) {\n+        String methodName = userCallLocalNode.getMethodName();\n+        List<AExpression> userArgumentNodes = userCallLocalNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userCallLocalNode, Write.class)) {\n+            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to function call [\" + methodName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        FunctionTable.LocalFunction localFunction = null;\n+        PainlessMethod importedMethod = null;\n+        PainlessClassBinding classBinding = null;\n+        int classBindingOffset = 0;\n+        PainlessInstanceBinding instanceBinding = null;\n+\n+        Class<?> valueType;\n+\n+        localFunction = scriptScope.getFunctionTable().getFunction(methodName, userArgumentsSize);\n+\n+        // user cannot call internal functions, reset to null if an internal function is found\n+        if (localFunction != null && localFunction.isInternal()) {\n+            localFunction = null;\n+        }\n+\n+        if (localFunction == null) {\n+            importedMethod = scriptScope.getPainlessLookup().lookupImportedPainlessMethod(methodName, userArgumentsSize);\n+\n+            if (importedMethod == null) {\n+                classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize);\n+\n+                // check to see if this class binding requires an implicit this reference\n+                if (classBinding != null && classBinding.typeParameters.isEmpty() == false &&\n+                        classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                    classBinding = null;\n+                }\n+\n+                if (classBinding == null) {\n+                    // This extra check looks for a possible match where the class binding requires an implicit this\n+                    // reference.  This is a temporary solution to allow the class binding access to data from the\n+                    // base script class without need for a user to add additional arguments.  A long term solution\n+                    // will likely involve adding a class instance binding where any instance can have a class binding\n+                    // as part of its API.  However, the situation at run-time is difficult and will modifications that\n+                    // are a substantial change if even possible to do.\n+                    classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize + 1);\n+\n+                    if (classBinding != null) {\n+                        if (classBinding.typeParameters.isEmpty() == false &&\n+                                classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                            classBindingOffset = 1;\n+                        } else {\n+                            classBinding = null;\n+                        }\n+                    }\n+\n+                    if (classBinding == null) {\n+                        instanceBinding = scriptScope.getPainlessLookup().lookupPainlessInstanceBinding(methodName, userArgumentsSize);\n+\n+                        if (instanceBinding == null) {\n+                            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                                    \"Unknown call [\" + methodName + \"] with [\" + userArgumentNodes + \"] arguments.\"));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        List<Class<?>> typeParameters;\n+\n+        if (localFunction != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardLocalFunction(localFunction));\n+\n+            typeParameters = new ArrayList<>(localFunction.getTypeParameters());\n+            valueType = localFunction.getReturnType();\n+        } else if (importedMethod != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessMethod(importedMethod));\n+\n+            scriptScope.markNonDeterministic(importedMethod.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(importedMethod.typeParameters);\n+            valueType = importedMethod.returnType;\n+        } else if (classBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessClassBinding(classBinding));\n+            semanticScope.putDecoration(userCallLocalNode, new StandardConstant(classBindingOffset));\n+\n+            scriptScope.markNonDeterministic(classBinding.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(classBinding.typeParameters);\n+            valueType = classBinding.returnType;\n+        } else if (instanceBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessInstanceBinding(instanceBinding));\n+\n+            typeParameters = new ArrayList<>(instanceBinding.typeParameters);\n+            valueType = instanceBinding.returnType;\n+        } else {\n+            throw new IllegalStateException(\"Illegal tree structure.\");\n+        }\n+        // if the class binding is using an implicit this reference then the arguments counted must\n+        // be incremented by 1 as the this reference will not be part of the arguments passed into\n+        // the class binding call\n+        for (int argument = 0; argument < userArgumentsSize; ++argument) {\n+            AExpression userArgumentNode = userArgumentNodes.get(argument);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(typeParameters.get(argument + classBindingOffset)));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCallLocalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, SemanticScope semanticScope) {\n+        boolean bool = userBooleanConstantNode.getBool();\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Write.class)) {\n+            throw userBooleanConstantNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to boolean constant [\" + bool + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Read.class) == false) {\n+            throw userBooleanConstantNode.createError(\n+                    new IllegalArgumentException(\"not a statement: boolean constant [\" + bool + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userBooleanConstantNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userBooleanConstantNode, new StandardConstant(bool));\n+    }\n+\n+    @Override\n+    public void visitNumeric(ENumeric userNumericNode, SemanticScope semanticScope) {\n+        String numeric = userNumericNode.getNumeric();\n+\n+        if (semanticScope.getCondition(userNumericNode, Negate.class)) {\n+            numeric = \"-\" + numeric;\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Write.class)) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to numeric constant [\" + numeric + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Read.class) == false) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"not a statement: numeric constant [\" + numeric + \"] not used\"));\n+        }\n+\n+        int radix = userNumericNode.getRadix();\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (numeric.endsWith(\"d\") || numeric.endsWith(\"D\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Double.parseDouble(numeric.substring(0, numeric.length() - 1));\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"f\") || numeric.endsWith(\"F\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Float.parseFloat(numeric.substring(0, numeric.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"l\") || numeric.endsWith(\"L\")) {\n+            try {\n+                constant = Long.parseLong(numeric.substring(0, numeric.length() - 1), radix);\n+                valueType = long.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid long constant [\" + numeric + \"].\"));\n+            }\n+        } else {\n+            try {\n+                TargetType targetType = semanticScope.getDecoration(userNumericNode, TargetType.class);\n+                Class<?> sort = targetType == null ? int.class : targetType.getTargetType();\n+                int integer = Integer.parseInt(numeric, radix);\n+\n+                if (sort == byte.class && integer >= Byte.MIN_VALUE && integer <= Byte.MAX_VALUE) {\n+                    constant = (byte)integer;\n+                    valueType = byte.class;\n+                } else if (sort == char.class && integer >= Character.MIN_VALUE && integer <= Character.MAX_VALUE) {\n+                    constant = (char)integer;\n+                    valueType = char.class;\n+                } else if (sort == short.class && integer >= Short.MIN_VALUE && integer <= Short.MAX_VALUE) {\n+                    constant = (short)integer;\n+                    valueType = short.class;\n+                } else {\n+                    constant = integer;\n+                    valueType = int.class;\n+                }\n+            } catch (NumberFormatException exception) {\n+                try {\n+                    // Check if we can parse as a long. If so then hint that the user might prefer that.\n+                    Long.parseLong(numeric, radix);\n+                    throw userNumericNode.createError(new IllegalArgumentException(\n+                            \"Invalid int constant [\" + numeric + \"]. If you want a long constant then change it to [\" + numeric + \"L].\"));\n+                } catch (NumberFormatException longNoGood) {\n+                    // Ignored\n+                }\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid int constant [\" + numeric + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userNumericNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userNumericNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitDecimal(EDecimal userDecimalNode, SemanticScope semanticScope) {\n+        String decimal = userDecimalNode.getDecimal();\n+\n+        if (semanticScope.getCondition(userDecimalNode, Negate.class)) {\n+            decimal = \"-\" + decimal;\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Write.class)) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to decimal constant [\" + decimal + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Read.class) == false) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\"not a statement: decimal constant [\" + decimal + \"] not used\"));\n+        }\n+\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (decimal.endsWith(\"f\") || decimal.endsWith(\"F\")) {\n+            try {\n+                constant = Float.parseFloat(decimal.substring(0, decimal.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + decimal + \"].\"));\n+            }\n+        } else {\n+            String toParse = decimal;\n+            if (toParse.endsWith(\"d\") || decimal.endsWith(\"D\")) {\n+                toParse = toParse.substring(0, decimal.length() - 1);\n+            }\n+            try {\n+                constant = Double.parseDouble(toParse);\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + decimal + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userDecimalNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userDecimalNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitString(EString userStringNode, SemanticScope semanticScope) {\n+        String string = userStringNode.getString();\n+\n+        if (semanticScope.getCondition(userStringNode, Write.class)) {\n+            throw userStringNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to string constant [\" + string + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userStringNode, Read.class) == false) {\n+            throw userStringNode.createError(new IllegalArgumentException(\"not a statement: string constant [\" + string + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userStringNode, new ValueType(String.class));\n+        semanticScope.putDecoration(userStringNode, new StandardConstant(string));\n+    }\n+\n+    @Override\n+    public void visitNull(ENull userNullNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNullNode, Write.class)) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to null constant\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNullNode, Read.class) == false) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"not a statement: null constant not used\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userNullNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType != null) {\n+            if (targetType.getTargetType().isPrimitive()) {\n+                throw userNullNode.createError(new IllegalArgumentException(\n+                        \"Cannot cast null to a primitive type [\" + targetType.getTargetCanonicalTypeName() + \"].\"));\n+            }\n+\n+            valueType = targetType.getTargetType();\n+        } else {\n+            valueType = Object.class;\n+        }\n+\n+        semanticScope.putDecoration(userNullNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitRegex(ERegex userRegexNode, SemanticScope semanticScope) {\n+        String pattern = userRegexNode.getPattern();\n+        String flags = userRegexNode.getFlags();\n+\n+        if (semanticScope.getCondition(userRegexNode, Write.class)) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to regex constant [\" + pattern + \"] with flags [\" + flags + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userRegexNode, Read.class) == false) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"not a statement: regex constant [\" + pattern + \"] with flags [\" + flags + \"] not used\"));\n+        }\n+\n+        if (semanticScope.getScriptScope().getCompilerSettings().areRegexesEnabled() == false) {\n+            throw userRegexNode.createError(new IllegalStateException(\"Regexes are disabled. Set [script.painless.regex.enabled] to [true] \"\n+                    + \"in elasticsearch.yaml to allow them. Be careful though, regexes break out of Painless's protection against deep \"\n+                    + \"recursion and long loops.\"));\n+        }\n+\n+        Location location = userRegexNode.getLocation();\n+\n+        int constant = 0;\n+\n+        for (int i = 0; i < flags.length(); ++i) {\n+            char flag = flags.charAt(i);\n+\n+            switch (flag) {\n+                case 'c':\n+                    constant |= Pattern.CANON_EQ;\n+                    break;\n+                case 'i':\n+                    constant |= Pattern.CASE_INSENSITIVE;\n+                    break;\n+                case 'l':\n+                    constant |= Pattern.LITERAL;\n+                    break;\n+                case 'm':\n+                    constant |= Pattern.MULTILINE;\n+                    break;\n+                case 's':\n+                    constant |= Pattern.DOTALL;\n+                    break;\n+                case 'U':\n+                    constant |= Pattern.UNICODE_CHARACTER_CLASS;\n+                    break;\n+                case 'u':\n+                    constant |= Pattern.UNICODE_CASE;\n+                    break;\n+                case 'x':\n+                    constant |= Pattern.COMMENTS;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"invalid regular expression: unknown flag [\" + flag + \"]\");\n+            }\n+        }\n+\n+        try {\n+            Pattern.compile(pattern, constant);\n+        } catch (PatternSyntaxException pse) {\n+            throw new Location(location.getSourceName(), location.getOffset() + 1 + pse.getIndex()).createError(\n+                    new IllegalArgumentException(\"invalid regular expression: \" +\n+                            \"could not compile regex constant [\" + pattern + \"] with flags [\" + flags + \"]\", pse));\n+        }\n+\n+        semanticScope.putDecoration(userRegexNode, new ValueType(Pattern.class));\n+        semanticScope.putDecoration(userRegexNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitLambda(ELambda userLambdaNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userLambdaNode, Write.class)) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to a lambda\"));\n+        }\n+\n+        if (semanticScope.getCondition(userLambdaNode, Read.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not a statement: lambda not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userLambdaNode, TargetType.class);\n+        List<String> canonicalTypeNameParameters = userLambdaNode.getCanonicalTypeNameParameters();\n+\n+        Class<?> returnType;\n+        List<Class<?>> typeParameters;\n+        PainlessMethod interfaceMethod;\n+\n+        // inspect the target first, set interface method if we know it.\n+        if (targetType == null) {\n+            // we don't know anything: treat as def\n+            returnType = def.class;\n+            // don't infer any types, replace any null types with def\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (String type : canonicalTypeNameParameters) {\n+                if (type == null) {\n+                    typeParameters.add(def.class);\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(type);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + type + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        } else {\n+            // we know the method statically, infer return type and any unknown/def types\n+            interfaceMethod = scriptScope.getPainlessLookup().lookupFunctionalInterfacePainlessMethod(targetType.getTargetType());\n+            if (interfaceMethod == null) {\n+                throw userLambdaNode.createError(new IllegalArgumentException(\"Cannot pass lambda to \" +\n+                        \"[\" + targetType.getTargetCanonicalTypeName() + \"], not a functional interface\"));\n+            }\n+            // check arity before we manipulate parameters\n+            if (interfaceMethod.typeParameters.size() != canonicalTypeNameParameters.size())\n+                throw new IllegalArgumentException(\"Incorrect number of parameters for [\" + interfaceMethod.javaMethod.getName() +\n+                        \"] in [\" + targetType.getTargetCanonicalTypeName() + \"]\");\n+            // for method invocation, its allowed to ignore the return value\n+            if (interfaceMethod.returnType == void.class) {\n+                returnType = def.class;\n+            } else {\n+                returnType = interfaceMethod.returnType;\n+            }\n+            // replace any null types with the actual type\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (int i = 0; i < canonicalTypeNameParameters.size(); i++) {\n+                String paramType = canonicalTypeNameParameters.get(i);\n+                if (paramType == null) {\n+                    typeParameters.add(interfaceMethod.typeParameters.get(i));\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(paramType);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + paramType + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        }\n+\n+        Location location = userLambdaNode.getLocation();\n+        List<String> parameterNames = userLambdaNode.getParameterNames();\n+        LambdaScope lambdaScope = semanticScope.newLambdaScope(returnType);\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            Class<?> type = typeParameters.get(index);\n+            String parameterName = parameterNames.get(index);\n+            lambdaScope.defineVariable(location, type, parameterName, true);\n+        }\n+\n+        SBlock userBlockNode = userLambdaNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"cannot generate empty lambda\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, lambdaScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, MethodEscape.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not all paths return a value for lambda\"));\n+        }\n+\n+        // prepend capture list to lambda's arguments\n+        List<Variable> capturedVariables = new ArrayList<>(lambdaScope.getCaptures());\n+        List<Class<?>> typeParametersWithCaptures = new ArrayList<>(capturedVariables.size() + typeParameters.size());\n+        List<String> parameterNamesWithCaptures = new ArrayList<>(capturedVariables.size() + parameterNames.size());\n+\n+        for (Variable capturedVariable : capturedVariables) {\n+            typeParametersWithCaptures.add(capturedVariable.getType());\n+            parameterNamesWithCaptures.add(capturedVariable.getName());\n+        }\n+\n+        typeParametersWithCaptures.addAll(typeParameters);\n+        parameterNamesWithCaptures.addAll(parameterNames);\n+\n+        // desugar lambda body into a synthetic method\n+        String name = scriptScope.getNextSyntheticName(\"lambda\");\n+        scriptScope.getFunctionTable().addFunction(name, returnType, typeParametersWithCaptures, true, true);\n+\n+        Class<?> valueType;\n+        // setup method reference to synthetic method\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",\" + capturedVariables.size();\n+            valueType = String.class;\n+            semanticScope.putDecoration(userLambdaNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    location, targetType.getTargetType(), \"this\", name, capturedVariables.size());\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userLambdaNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userLambdaNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userLambdaNode, new MethodNameDecoration(name));\n+        semanticScope.putDecoration(userLambdaNode, new ReturnType(returnType));\n+        semanticScope.putDecoration(userLambdaNode, new TypeParameters(typeParametersWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new ParameterNames(parameterNamesWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new CapturesDecoration(capturedVariables));\n+    }\n+\n+    @Override\n+    public void visitFunctionRef(EFunctionRef userFunctionRefNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        Location location = userFunctionRefNode.getLocation();\n+        String symbol = userFunctionRefNode.getSymbol();\n+        String methodName = userFunctionRefNode.getMethodName();\n+        boolean read = semanticScope.getCondition(userFunctionRefNode, Read.class);\n+\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(symbol);\n+        TargetType targetType = semanticScope.getDecoration(userFunctionRefNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (symbol.equals(\"this\") || type != null)  {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to function reference [\" + symbol + \":\" + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: function reference [\" + symbol + \":\" + methodName + \"] not used\"));\n+            }\n+\n+            if (targetType == null) {\n+                valueType = String.class;\n+                String defReferenceEncoding = \"S\" + symbol + \".\" + methodName + \",0\";\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                        location, targetType.getTargetType(), symbol, methodName, 0);\n+                valueType = targetType.getTargetType();\n+                semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+            }\n+        } else {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to capturing function reference [\" + symbol + \":\"  + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: capturing function reference [\" + symbol + \":\"  + methodName + \"] not used\"));\n+            }\n+\n+            SemanticScope.Variable captured = semanticScope.getVariable(location, symbol);\n+            semanticScope.putDecoration(userFunctionRefNode, new CapturesDecoration(Collections.singletonList(captured)));\n+            if (targetType == null) {\n+                String defReferenceEncoding;\n+                if (captured.getType() == def.class) {\n+                    // dynamic implementation\n+                    defReferenceEncoding = \"D\" + symbol + \".\" + methodName + \",1\";\n+                } else {\n+                    // typed implementation\n+                    defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + methodName + \",1\";\n+                }\n+                valueType = String.class;\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                valueType = targetType.getTargetType();\n+                // static case\n+                if (captured.getType() != def.class) {\n+                    FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(), location,\n+                            targetType.getTargetType(), captured.getCanonicalTypeName(), methodName, 1);\n+                    semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+                }\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArrayFunctionRef(ENewArrayFunctionRef userNewArrayFunctionRefNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userNewArrayFunctionRefNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Write.class)) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"cannot assign a value to new array function reference with target type [ + \" + canonicalTypeName  + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Read.class) == false) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"not a statement: new array function reference with target type [\" + canonicalTypeName + \"] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userNewArrayFunctionRefNode, TargetType.class);\n+\n+        Class<?> valueType;\n+        Class<?> clazz = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReturnType(clazz));\n+\n+        if (clazz == null) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        String name = scriptScope.getNextSyntheticName(\"newarray\");\n+        scriptScope.getFunctionTable().addFunction(name, clazz, Collections.singletonList(int.class), true, true);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new MethodNameDecoration(name));\n+\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",0\";\n+            valueType = String.class;\n+            scriptScope.putDecoration(userNewArrayFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    userNewArrayFunctionRefNode.getLocation(), targetType.getTargetType(), \"this\", name, 0);\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitSymbol(ESymbol userSymbolNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userSymbolNode, Read.class);\n+        boolean write = semanticScope.getCondition(userSymbolNode, Write.class);\n+        String symbol = userSymbolNode.getSymbol();\n+        Class<?> staticType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(symbol);\n+\n+        if (staticType != null)  {\n+            if (write) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"] not used\"));\n+            }\n+\n+            semanticScope.putDecoration(userSymbolNode, new StaticType(staticType));\n+        } else if (semanticScope.isVariableDefined(symbol)) {\n+            if (read == false && write == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: variable [\" + symbol + \"] not used\"));\n+            }\n+\n+            Location location = userSymbolNode.getLocation();\n+            Variable variable = semanticScope.getVariable(location, symbol);\n+\n+            if (write && variable.isFinal()) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n+            }\n+\n+            Class<?> valueType = variable.getType();\n+            semanticScope.putDecoration(userSymbolNode, new ValueType(valueType));\n+        } else {\n+            semanticScope.putDecoration(userSymbolNode, new PartialCanonicalTypeName(symbol));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDot(EDot userDotNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userDotNode, Read.class);\n+        boolean write = semanticScope.getCondition(userDotNode, Write.class);\n+\n+        if (read == false && write == false) {\n+            throw userDotNode.createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String index = userDotNode.getIndex();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTYwMg=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 2264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODIyMTE1OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1NjowNlrOG2TUcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo1MDo1MVrOG2VRMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjgxOA==", "bodyText": "de-indent this line.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459592818", "createdAt": "2020-07-23T16:56:06Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 1575}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyNDc1NQ==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459624755", "createdAt": "2020-07-23T17:50:51Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjgxOA=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 1575}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODIzODc3OnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowMDo0NFrOG2Tfmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0NzozNlrOG2VJ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTY3NA==", "bodyText": "Why is this different in DefaultSemanticAnalysisPhase?  Is it just the changes to use decorations?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459595674", "createdAt": "2020-07-23T17:00:44Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java", "diffHunk": "@@ -68,90 +57,4 @@ public Operation getOperation() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         childNode.visit(userTreeVisitor, scope);\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n-                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        if (semanticScope.getCondition(this, Read.class) == false) {\n-            throw createError(new IllegalArgumentException(\n-                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        Class<?> valueType;\n-        Class<?> promote = null;\n-\n-        if ((operation == Operation.SUB || operation == Operation.ADD) &&\n-                (childNode instanceof ENumeric || childNode instanceof EDecimal)) {\n-            semanticScope.setCondition(childNode, Read.class);\n-            semanticScope.copyDecoration(this, childNode, TargetType.class);\n-            semanticScope.replicateCondition(this, childNode, Explicit.class);\n-            semanticScope.replicateCondition(this, childNode, Internal.class);\n-\n-            if (childNode instanceof ENumeric) {\n-                ENumeric numeric = (ENumeric)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    numeric.analyze(semanticScope, numeric.getNumeric().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else if (childNode instanceof EDecimal) {\n-                EDecimal decimal = (EDecimal)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    decimal.analyze(semanticScope, decimal.getDecimal().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else {\n-                throw createError(new IllegalArgumentException(\"illegal tree structure\"));\n-            }\n-\n-            valueType = semanticScope.getDecoration(childNode, ValueType.class).getValueType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMjkxMQ==", "bodyText": "Yes, this what changed by adding the Negate decoration. Parsing a negative numeric constant (and decimal constant) is a bit odd as the parser gives you the tokens MINUS and NUMERIC, but if they're separated a user cannot enter the negative maximum value as the positive one exceeds the positive max since the negation won't be applied until a parent node. Special care is taken to ensure this doesn't happen that way by collapsing the unary node with the Negate decoration.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459622911", "createdAt": "2020-07-23T17:47:36Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java", "diffHunk": "@@ -68,90 +57,4 @@ public Operation getOperation() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         childNode.visit(userTreeVisitor, scope);\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n-                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        if (semanticScope.getCondition(this, Read.class) == false) {\n-            throw createError(new IllegalArgumentException(\n-                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        Class<?> valueType;\n-        Class<?> promote = null;\n-\n-        if ((operation == Operation.SUB || operation == Operation.ADD) &&\n-                (childNode instanceof ENumeric || childNode instanceof EDecimal)) {\n-            semanticScope.setCondition(childNode, Read.class);\n-            semanticScope.copyDecoration(this, childNode, TargetType.class);\n-            semanticScope.replicateCondition(this, childNode, Explicit.class);\n-            semanticScope.replicateCondition(this, childNode, Internal.class);\n-\n-            if (childNode instanceof ENumeric) {\n-                ENumeric numeric = (ENumeric)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    numeric.analyze(semanticScope, numeric.getNumeric().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else if (childNode instanceof EDecimal) {\n-                EDecimal decimal = (EDecimal)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    decimal.analyze(semanticScope, decimal.getDecimal().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else {\n-                throw createError(new IllegalArgumentException(\"illegal tree structure\"));\n-            }\n-\n-            valueType = semanticScope.getDecoration(childNode, ValueType.class).getValueType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTY3NA=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODI1NzYwOnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNTo1OFrOG2TrcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0Mjo1M1rOG2U_Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODcwNQ==", "bodyText": "Where did this cast move to in DefaultSemanticAnalysisPhase?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459598705", "createdAt": "2020-07-23T17:05:58Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java", "diffHunk": "@@ -57,35 +48,6 @@ public AExpression getExpressionNode() {\n \n     @Override\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n-        expressionNode.visit(userTreeVisitor, scope);\n-    }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        Class<?> rtnType = semanticScope.getReturnType();\n-        boolean isVoid = rtnType == void.class;\n-        boolean lastSource = semanticScope.getCondition(this, LastSource.class);\n-\n-        if (lastSource && !isVoid) {\n-            semanticScope.setCondition(expressionNode, Read.class);\n-        }\n-\n-        AExpression.analyze(expressionNode, semanticScope);\n-        Class<?> expressionValueType = semanticScope.getDecoration(expressionNode, ValueType.class).getValueType();\n-\n-        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n-        semanticScope.putDecoration(expressionNode, new TargetType(rtn ? rtnType : expressionValueType));\n-\n-        if (rtn) {\n-            semanticScope.setCondition(expressionNode, Internal.class);\n-        }\n-\n-        expressionNode.cast(semanticScope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDEyNg==", "bodyText": "Slight logic change:\nIt's now decorateWithCast(userStatementNode, semanticScope); and only applied if this value is returned; otherwise the cast is redundant under the old logic since we set both value type and target type to the same thing.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459620126", "createdAt": "2020-07-23T17:42:53Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java", "diffHunk": "@@ -57,35 +48,6 @@ public AExpression getExpressionNode() {\n \n     @Override\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n-        expressionNode.visit(userTreeVisitor, scope);\n-    }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        Class<?> rtnType = semanticScope.getReturnType();\n-        boolean isVoid = rtnType == void.class;\n-        boolean lastSource = semanticScope.getCondition(this, LastSource.class);\n-\n-        if (lastSource && !isVoid) {\n-            semanticScope.setCondition(expressionNode, Read.class);\n-        }\n-\n-        AExpression.analyze(expressionNode, semanticScope);\n-        Class<?> expressionValueType = semanticScope.getDecoration(expressionNode, ValueType.class).getValueType();\n-\n-        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n-        semanticScope.putDecoration(expressionNode, new TargetType(rtn ? rtnType : expressionValueType));\n-\n-        if (rtn) {\n-            semanticScope.setCondition(expressionNode, Internal.class);\n-        }\n-\n-        expressionNode.cast(semanticScope);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODcwNQ=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODI2NTAzOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowODowNlrOG2TwKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0NDoyMVrOG2VCbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ==", "bodyText": "Line these conditions up.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459599915", "createdAt": "2020-07-23T17:08:06Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMDAzMQ==", "bodyText": "All five of 'em.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459600031", "createdAt": "2020-07-23T17:08:19Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDk3Mg==", "bodyText": "I lined them up. Note that standard style dictates a line continuation is intended twice normally.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459620972", "createdAt": "2020-07-23T17:44:21Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODI3NjcyOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/yamlRestTest/resources/rest-api-spec/test/painless/20_scriptfield.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxMToyMFrOG2T3kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozODozMlrOG2U1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTgxMA==", "bodyText": "Why'd this message change?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459601810", "createdAt": "2020-07-23T17:11:20Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/yamlRestTest/resources/rest-api-spec/test/painless/20_scriptfield.yml", "diffHunk": "@@ -151,6 +151,6 @@ setup:\n     - match: { error.type: \"search_phase_execution_exception\" }\n     - match: { error.reason: \"all shards failed\" }\n     - match: { error.failed_shards.0.reason.caused_by.type: \"illegal_argument_exception\" }\n-    - match: { error.failed_shards.0.reason.caused_by.reason: \"While loop has no escape.\" }\n+    - match: { error.failed_shards.0.reason.caused_by.reason: \"no paths escape from while loop\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzU5Mg==", "bodyText": "Thought this message was clearer and I made it consistent across loops.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459617592", "createdAt": "2020-07-23T17:38:32Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/yamlRestTest/resources/rest-api-spec/test/painless/20_scriptfield.yml", "diffHunk": "@@ -151,6 +151,6 @@ setup:\n     - match: { error.type: \"search_phase_execution_exception\" }\n     - match: { error.reason: \"all shards failed\" }\n     - match: { error.failed_shards.0.reason.caused_by.type: \"illegal_argument_exception\" }\n-    - match: { error.failed_shards.0.reason.caused_by.reason: \"While loop has no escape.\" }\n+    - match: { error.failed_shards.0.reason.caused_by.reason: \"no paths escape from while loop\" }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTgxMA=="}, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2200, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}